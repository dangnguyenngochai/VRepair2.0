static vpx_codec_err_t set_encoder_config ( //<S2SV> VP9_CONFIG * oxcf , //<S2SV> const vpx_codec_enc_cfg_t * cfg , //<S2SV> const struct vp9_extracfg * extra_cfg ) { //<S2SV> oxcf -> profile = cfg -> g_profile ; //<S2SV> oxcf -> width = cfg -> g_w ; //<S2SV> oxcf -> height = cfg -> g_h ; //<S2SV> oxcf -> bit_depth = extra_cfg -> bit_depth ; //<S2SV> oxcf -> framerate = ( double ) cfg -> g_timebase . den / cfg -> g_timebase . num ; //<S2SV> if ( oxcf -> framerate > 180 ) //<S2SV> oxcf -> framerate = 30 ; //<S2SV> switch ( cfg -> g_pass ) { //<S2SV> case VPX_RC_ONE_PASS : //<S2SV> oxcf -> mode = MODE_GOODQUALITY ; //<S2SV> break ; //<S2SV> case VPX_RC_FIRST_PASS : //<S2SV> oxcf -> mode = MODE_FIRSTPASS ; //<S2SV> break ; //<S2SV> case VPX_RC_LAST_PASS : //<S2SV> oxcf -> mode = MODE_SECONDPASS_BEST ; //<S2SV> break ; //<S2SV> } //<S2SV> oxcf -> lag_in_frames = cfg -> g_pass == VPX_RC_FIRST_PASS ? 0 //<S2SV> : cfg -> g_lag_in_frames ; //<S2SV> oxcf -> end_usage = USAGE_LOCAL_FILE_PLAYBACK ; //<S2SV> if ( cfg -> rc_end_usage == VPX_CQ ) //<S2SV> oxcf -> end_usage = USAGE_CONSTRAINED_QUALITY ; //<S2SV> else if ( cfg -> rc_end_usage == VPX_Q ) //<S2SV> oxcf -> end_usage = USAGE_CONSTANT_QUALITY ; //<S2SV> else if ( cfg -> rc_end_usage == VPX_CBR ) //<S2SV> oxcf -> end_usage = USAGE_STREAM_FROM_SERVER ; //<S2SV> oxcf -> target_bandwidth = cfg -> rc_target_bitrate ; //<S2SV> oxcf -> rc_max_intra_bitrate_pct = extra_cfg -> rc_max_intra_bitrate_pct ; //<S2SV> oxcf -> best_allowed_q = q_trans [ cfg -> rc_min_quantizer ] ; //<S2SV> oxcf -> worst_allowed_q = q_trans [ cfg -> rc_max_quantizer ] ; //<S2SV> oxcf -> cq_level = q_trans [ extra_cfg -> cq_level ] ; //<S2SV> oxcf -> fixed_q = - 1 ; //<S2SV> oxcf -> under_shoot_pct = cfg -> rc_undershoot_pct ; //<S2SV> oxcf -> over_shoot_pct = cfg -> rc_overshoot_pct ; //<S2SV> oxcf -> maximum_buffer_size = cfg -> rc_buf_sz ; //<S2SV> oxcf -> starting_buffer_level = cfg -> rc_buf_initial_sz ; //<S2SV> oxcf -> optimal_buffer_level = cfg -> rc_buf_optimal_sz ; //<S2SV> oxcf -> drop_frames_water_mark = cfg -> rc_dropframe_thresh ; //<S2SV> oxcf -> two_pass_vbrbias = cfg -> rc_2pass_vbr_bias_pct ; //<S2SV> oxcf -> two_pass_vbrmin_section = cfg -> rc_2pass_vbr_minsection_pct ; //<S2SV> oxcf -> two_pass_vbrmax_section = cfg -> rc_2pass_vbr_maxsection_pct ; //<S2SV> oxcf -> auto_key = cfg -> kf_mode == VPX_KF_AUTO && //<S2SV> cfg -> kf_min_dist != cfg -> kf_max_dist ; //<S2SV> oxcf -> key_freq = cfg -> kf_max_dist ; //<S2SV> oxcf -> cpu_used = extra_cfg -> cpu_used ; //<S2SV> oxcf -> encode_breakout = extra_cfg -> static_thresh ; //<S2SV> oxcf -> play_alternate = extra_cfg -> enable_auto_alt_ref ; //<S2SV> oxcf -> noise_sensitivity = extra_cfg -> noise_sensitivity ; //<S2SV> oxcf -> sharpness = extra_cfg -> sharpness ; //<S2SV> oxcf -> two_pass_stats_in = cfg -> rc_twopass_stats_in ; //<S2SV> oxcf -> output_pkt_list = extra_cfg -> pkt_list ; //<S2SV> oxcf -> arnr_max_frames = extra_cfg -> arnr_max_frames ; //<S2SV> oxcf -> arnr_strength = extra_cfg -> arnr_strength ; //<S2SV> oxcf -> arnr_type = extra_cfg -> arnr_type ; //<S2SV> oxcf -> tuning = extra_cfg -> tuning ; //<S2SV> oxcf -> tile_columns = extra_cfg -> tile_columns ; //<S2SV> oxcf -> tile_rows = extra_cfg -> tile_rows ; //<S2SV> oxcf -> lossless = extra_cfg -> lossless ; //<S2SV> oxcf -> error_resilient_mode = cfg -> g_error_resilient ; //<S2SV> oxcf -> frame_parallel_decoding_mode = extra_cfg -> frame_parallel_decoding_mode ; //<S2SV> oxcf -> aq_mode = extra_cfg -> aq_mode ; //<S2SV> oxcf -> frame_periodic_boost = extra_cfg -> frame_periodic_boost ; //<S2SV> oxcf -> ss_number_layers = cfg -> ss_number_layers ; //<S2SV> if ( oxcf -> ss_number_layers > 1 ) { //<S2SV> vp9_copy ( oxcf -> ss_target_bitrate , cfg -> ss_target_bitrate ) ; //<S2SV> } else if ( oxcf -> ss_number_layers == 1 ) { //<S2SV> oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; //<S2SV> } //<S2SV> oxcf -> ts_number_layers = cfg -> ts_number_layers ; //<S2SV> if ( oxcf -> ts_number_layers > 1 ) { //<S2SV> vp9_copy ( oxcf -> ts_target_bitrate , cfg -> ts_target_bitrate ) ; //<S2SV> vp9_copy ( oxcf -> ts_rate_decimator , cfg -> ts_rate_decimator ) ; //<S2SV> } else if ( oxcf -> ts_number_layers == 1 ) { //<S2SV> oxcf -> ts_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; //<S2SV> oxcf -> ts_rate_decimator [ 0 ] = 1 ; //<S2SV> } //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 