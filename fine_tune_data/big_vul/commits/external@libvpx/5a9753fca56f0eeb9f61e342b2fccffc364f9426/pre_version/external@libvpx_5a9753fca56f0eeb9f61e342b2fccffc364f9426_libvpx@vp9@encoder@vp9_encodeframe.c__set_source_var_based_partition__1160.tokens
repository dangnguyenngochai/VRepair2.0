static void set_source_var_based_partition ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> MODE_INFO * * mi_8x8 , //<S2SV> int mi_row , int mi_col ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * x = & cpi -> mb ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> int row8x8_remaining = tile -> mi_row_end - mi_row ; //<S2SV> int col8x8_remaining = tile -> mi_col_end - mi_col ; //<S2SV> int r , c ; //<S2SV> MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; //<S2SV> assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; //<S2SV> if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && //<S2SV> ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { //<S2SV> const int src_stride = x -> plane [ 0 ] . src . stride ; //<S2SV> const int pre_stride = cpi -> Last_Source -> y_stride ; //<S2SV> const uint8_t * src = x -> plane [ 0 ] . src . buf ; //<S2SV> const int pre_offset = ( mi_row * MI_SIZE ) * pre_stride + //<S2SV> ( mi_col * MI_SIZE ) ; //<S2SV> const uint8_t * pre_src = cpi -> Last_Source -> y_buffer + pre_offset ; //<S2SV> const int thr_32x32 = cpi -> sf . source_var_thresh ; //<S2SV> const int thr_64x64 = thr_32x32 << 1 ; //<S2SV> int i , j ; //<S2SV> int index ; //<S2SV> diff d32 [ 4 ] ; //<S2SV> int use16x16 = 0 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> diff d16 [ 4 ] ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) { //<S2SV> int b_mi_row = coord_lookup [ i * 4 + j ] . row ; //<S2SV> int b_mi_col = coord_lookup [ i * 4 + j ] . col ; //<S2SV> int b_offset = b_mi_row * MI_SIZE * src_stride + //<S2SV> b_mi_col * MI_SIZE ; //<S2SV> vp9_get_sse_sum_16x16 ( src + b_offset , //<S2SV> src_stride , //<S2SV> pre_src + b_offset , //<S2SV> pre_stride , & d16 [ j ] . sse , & d16 [ j ] . sum ) ; //<S2SV> d16 [ j ] . var = d16 [ j ] . sse - //<S2SV> ( ( ( uint32_t ) d16 [ j ] . sum * d16 [ j ] . sum ) >> 8 ) ; //<S2SV> index = b_mi_row * mis + b_mi_col ; //<S2SV> mi_8x8 [ index ] = mi_upper_left + index ; //<S2SV> mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ; //<S2SV> } //<S2SV> if ( d16 [ 0 ] . var < thr_32x32 && d16 [ 1 ] . var < thr_32x32 && //<S2SV> d16 [ 2 ] . var < thr_32x32 && d16 [ 3 ] . var < thr_32x32 ) { //<S2SV> d32 [ i ] . sse = d16 [ 0 ] . sse ; //<S2SV> d32 [ i ] . sum = d16 [ 0 ] . sum ; //<S2SV> for ( j = 1 ; j < 4 ; j ++ ) { //<S2SV> d32 [ i ] . sse += d16 [ j ] . sse ; //<S2SV> d32 [ i ] . sum += d16 [ j ] . sum ; //<S2SV> } //<S2SV> d32 [ i ] . var = d32 [ i ] . sse - ( ( ( int64_t ) d32 [ i ] . sum * d32 [ i ] . sum ) >> 10 ) ; //<S2SV> index = coord_lookup [ i * 4 ] . row * mis + coord_lookup [ i * 4 ] . col ; //<S2SV> mi_8x8 [ index ] = mi_upper_left + index ; //<S2SV> mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_32X32 ; //<S2SV> if ( ! ( ( cm -> current_video_frame - 1 ) % //<S2SV> cpi -> sf . search_type_check_frequency ) ) //<S2SV> cpi -> use_large_partition_rate += 1 ; //<S2SV> } else { //<S2SV> use16x16 = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! use16x16 ) { //<S2SV> if ( d32 [ 0 ] . var < thr_64x64 && d32 [ 1 ] . var < thr_64x64 && //<S2SV> d32 [ 2 ] . var < thr_64x64 && d32 [ 3 ] . var < thr_64x64 ) { //<S2SV> mi_8x8 [ 0 ] = mi_upper_left ; //<S2SV> mi_8x8 [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> BLOCK_SIZE bsize = BLOCK_16X16 ; //<S2SV> int bh = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> int bw = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> for ( r = 0 ; r < MI_BLOCK_SIZE ; r += bh ) { //<S2SV> for ( c = 0 ; c < MI_BLOCK_SIZE ; c += bw ) { //<S2SV> int index = r * mis + c ; //<S2SV> bsize = find_partition_size ( bsize , //<S2SV> ( row8x8_remaining - r ) , //<S2SV> ( col8x8_remaining - c ) , & bh , & bw ) ; //<S2SV> mi_8x8 [ index ] = mi_upper_left + index ; //<S2SV> mi_8x8 [ index ] -> mbmi . sb_type = bsize ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 