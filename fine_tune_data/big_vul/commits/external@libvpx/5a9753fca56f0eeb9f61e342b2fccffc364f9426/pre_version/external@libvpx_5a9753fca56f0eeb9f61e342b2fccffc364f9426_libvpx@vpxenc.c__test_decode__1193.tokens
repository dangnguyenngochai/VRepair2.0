static void test_decode ( struct stream_state * stream , //<S2SV> enum TestDecodeFatality fatal , //<S2SV> const VpxInterface * codec ) { //<S2SV> vpx_image_t enc_img , dec_img ; //<S2SV> if ( stream -> mismatch_seen ) //<S2SV> return ; //<S2SV> if ( strcmp ( codec -> name , "vp8" ) == 0 ) { //<S2SV> struct vpx_ref_frame ref_enc , ref_dec ; //<S2SV> int width , height ; //<S2SV> width = ( stream -> config . cfg . g_w + 15 ) & ~ 15 ; //<S2SV> height = ( stream -> config . cfg . g_h + 15 ) & ~ 15 ; //<S2SV> vpx_img_alloc ( & ref_enc . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; //<S2SV> enc_img = ref_enc . img ; //<S2SV> vpx_img_alloc ( & ref_dec . img , VPX_IMG_FMT_I420 , width , height , 1 ) ; //<S2SV> dec_img = ref_dec . img ; //<S2SV> ref_enc . frame_type = VP8_LAST_FRAME ; //<S2SV> ref_dec . frame_type = VP8_LAST_FRAME ; //<S2SV> vpx_codec_control ( & stream -> encoder , VP8_COPY_REFERENCE , & ref_enc ) ; //<S2SV> vpx_codec_control ( & stream -> decoder , VP8_COPY_REFERENCE , & ref_dec ) ; //<S2SV> } else { //<S2SV> struct vp9_ref_frame ref ; //<S2SV> ref . idx = 0 ; //<S2SV> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref ) ; //<S2SV> enc_img = ref . img ; //<S2SV> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref ) ; //<S2SV> dec_img = ref . img ; //<S2SV> } //<S2SV> ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>encoder<S2SV_blank>reference<S2SV_blank>frame" ) ; //<S2SV> ctx_exit_on_error ( & stream -> decoder , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>decoder<S2SV_blank>reference<S2SV_blank>frame" ) ; //<S2SV> if ( ! compare_img ( & enc_img , & dec_img ) ) { //<S2SV> int y [ 4 ] , u [ 4 ] , v [ 4 ] ; //<S2SV> find_mismatch ( & enc_img , & dec_img , y , u , v ) ; //<S2SV> stream -> decoder . err = 1 ; //<S2SV> warn_or_exit_on_error ( & stream -> decoder , fatal == TEST_DECODE_FATAL , //<S2SV> "Stream<S2SV_blank>%d:<S2SV_blank>Encode/decode<S2SV_blank>mismatch<S2SV_blank>on<S2SV_blank>frame<S2SV_blank>%d<S2SV_blank>at" //<S2SV> "<S2SV_blank>Y[%d,<S2SV_blank>%d]<S2SV_blank>{%d/%d}," //<S2SV> "<S2SV_blank>U[%d,<S2SV_blank>%d]<S2SV_blank>{%d/%d}," //<S2SV> "<S2SV_blank>V[%d,<S2SV_blank>%d]<S2SV_blank>{%d/%d}" , //<S2SV> stream -> index , stream -> frames_out , //<S2SV> y [ 0 ] , y [ 1 ] , y [ 2 ] , y [ 3 ] , //<S2SV> u [ 0 ] , u [ 1 ] , u [ 2 ] , u [ 3 ] , //<S2SV> v [ 0 ] , v [ 1 ] , v [ 2 ] , v [ 3 ] ) ; //<S2SV> stream -> mismatch_seen = stream -> frames_out ; //<S2SV> } //<S2SV> vpx_img_free ( & enc_img ) ; //<S2SV> vpx_img_free ( & dec_img ) ; //<S2SV> } //<S2SV> 