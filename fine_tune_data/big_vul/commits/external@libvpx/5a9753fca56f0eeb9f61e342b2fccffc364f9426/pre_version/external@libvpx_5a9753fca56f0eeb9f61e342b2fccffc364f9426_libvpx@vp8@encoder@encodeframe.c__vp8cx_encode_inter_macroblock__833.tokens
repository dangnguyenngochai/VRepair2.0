int vp8cx_encode_inter_macroblock //<S2SV> ( //<S2SV> VP8_COMP * cpi , MACROBLOCK * x , TOKENEXTRA * * t , //<S2SV> int recon_yoffset , int recon_uvoffset , //<S2SV> int mb_row , int mb_col //<S2SV> ) //<S2SV> { //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> int intra_error = 0 ; //<S2SV> int rate ; //<S2SV> int distortion ; //<S2SV> x -> skip = 0 ; //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> x -> encode_breakout = cpi -> segment_encode_breakout [ xd -> mode_info_context -> mbmi . segment_id ] ; //<S2SV> else //<S2SV> x -> encode_breakout = cpi -> oxcf . encode_breakout ; //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> x -> best_reference_frame = INTRA_FRAME ; //<S2SV> x -> best_zeromv_reference_frame = INTRA_FRAME ; //<S2SV> x -> best_sse_inter_mode = 0 ; //<S2SV> x -> best_sse_mv . as_int = 0 ; //<S2SV> x -> need_to_clamp_best_mvs = 0 ; //<S2SV> # endif //<S2SV> if ( cpi -> sf . RD ) //<S2SV> { //<S2SV> int zbin_mode_boost_enabled = x -> zbin_mode_boost_enabled ; //<S2SV> if ( cpi -> sf . use_fastquant_for_pick ) //<S2SV> { //<S2SV> x -> quantize_b = vp8_fast_quantize_b ; //<S2SV> x -> quantize_b_pair = vp8_fast_quantize_b_pair ; //<S2SV> x -> zbin_mode_boost_enabled = 0 ; //<S2SV> } //<S2SV> vp8_rd_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , //<S2SV> & distortion , & intra_error ) ; //<S2SV> if ( cpi -> sf . improved_quant ) //<S2SV> { //<S2SV> x -> quantize_b = vp8_regular_quantize_b ; //<S2SV> x -> quantize_b_pair = vp8_regular_quantize_b_pair ; //<S2SV> } //<S2SV> x -> zbin_mode_boost_enabled = zbin_mode_boost_enabled ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_pick_inter_mode ( cpi , x , recon_yoffset , recon_uvoffset , & rate , //<S2SV> & distortion , & intra_error , mb_row , mb_col ) ; //<S2SV> } //<S2SV> x -> prediction_error += distortion ; //<S2SV> x -> intra_error += intra_error ; //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) //<S2SV> { //<S2SV> adjust_act_zbin ( cpi , x ) ; //<S2SV> } //<S2SV> # if 0 //<S2SV> cpi -> frame_distortion += distortion ; //<S2SV> cpi -> last_mb_distortion = distortion ; //<S2SV> # endif //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> if ( cpi -> current_layer == 0 && cpi -> cyclic_refresh_mode_enabled ) //<S2SV> { //<S2SV> if ( ( xd -> mode_info_context -> mbmi . segment_id == 1 ) && //<S2SV> ( ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME ) || ( xd -> mode_info_context -> mbmi . mode != ZEROMV ) ) ) //<S2SV> { //<S2SV> xd -> mode_info_context -> mbmi . segment_id = 0 ; //<S2SV> vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> x -> zbin_mode_boost = 0 ; //<S2SV> if ( x -> zbin_mode_boost_enabled ) //<S2SV> { //<S2SV> if ( xd -> mode_info_context -> mbmi . ref_frame != INTRA_FRAME ) //<S2SV> { //<S2SV> if ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) //<S2SV> { //<S2SV> if ( xd -> mode_info_context -> mbmi . ref_frame != LAST_FRAME && //<S2SV> cpi -> oxcf . number_of_layers == 1 ) //<S2SV> x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; //<S2SV> else //<S2SV> x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; //<S2SV> } //<S2SV> else if ( xd -> mode_info_context -> mbmi . mode == SPLITMV ) //<S2SV> x -> zbin_mode_boost = 0 ; //<S2SV> else //<S2SV> x -> zbin_mode_boost = MV_ZBIN_BOOST ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> sf . improved_quant ) //<S2SV> vp8_update_zbin_extra ( cpi , x ) ; //<S2SV> } //<S2SV> x -> count_mb_ref_frame_usage [ xd -> mode_info_context -> mbmi . ref_frame ] ++ ; //<S2SV> if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) //<S2SV> { //<S2SV> vp8_encode_intra16x16mbuv ( x ) ; //<S2SV> if ( xd -> mode_info_context -> mbmi . mode == B_PRED ) //<S2SV> { //<S2SV> vp8_encode_intra4x4mby ( x ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_encode_intra16x16mby ( x ) ; //<S2SV> } //<S2SV> sum_intra_stats ( cpi , x ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int ref_fb_idx ; //<S2SV> if ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) //<S2SV> ref_fb_idx = cpi -> common . lst_fb_idx ; //<S2SV> else if ( xd -> mode_info_context -> mbmi . ref_frame == GOLDEN_FRAME ) //<S2SV> ref_fb_idx = cpi -> common . gld_fb_idx ; //<S2SV> else //<S2SV> ref_fb_idx = cpi -> common . alt_fb_idx ; //<S2SV> xd -> pre . y_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . y_buffer + recon_yoffset ; //<S2SV> xd -> pre . u_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . u_buffer + recon_uvoffset ; //<S2SV> xd -> pre . v_buffer = cpi -> common . yv12_fb [ ref_fb_idx ] . v_buffer + recon_uvoffset ; //<S2SV> if ( ! x -> skip ) //<S2SV> { //<S2SV> vp8_encode_inter16x16 ( x ) ; //<S2SV> } //<S2SV> else //<S2SV> vp8_build_inter16x16_predictors_mb ( xd , xd -> dst . y_buffer , //<S2SV> xd -> dst . u_buffer , xd -> dst . v_buffer , //<S2SV> xd -> dst . y_stride , xd -> dst . uv_stride ) ; //<S2SV> } //<S2SV> if ( ! x -> skip ) //<S2SV> { //<S2SV> vp8_tokenize_mb ( cpi , x , t ) ; //<S2SV> if ( xd -> mode_info_context -> mbmi . mode != B_PRED ) //<S2SV> vp8_inverse_transform_mby ( xd ) ; //<S2SV> vp8_dequant_idct_add_uv_block //<S2SV> ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , //<S2SV> xd -> dst . u_buffer , xd -> dst . v_buffer , //<S2SV> xd -> dst . uv_stride , xd -> eobs + 16 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> xd -> mode_info_context -> mbmi . mb_skip_coeff = 1 ; //<S2SV> if ( cpi -> common . mb_no_coeff_skip ) //<S2SV> { //<S2SV> x -> skip_true_count ++ ; //<S2SV> vp8_fix_contexts ( xd ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_stuff_mb ( cpi , x , t ) ; //<S2SV> } //<S2SV> } //<S2SV> return rate ; //<S2SV> } //<S2SV> 