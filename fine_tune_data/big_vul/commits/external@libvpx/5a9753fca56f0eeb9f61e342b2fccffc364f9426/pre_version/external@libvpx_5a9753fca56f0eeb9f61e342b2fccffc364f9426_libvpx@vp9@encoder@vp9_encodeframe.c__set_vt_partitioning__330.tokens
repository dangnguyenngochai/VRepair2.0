static int set_vt_partitioning ( VP9_COMP * cpi , //<S2SV> void * data , //<S2SV> const TileInfo * const tile , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int mi_row , //<S2SV> int mi_col , //<S2SV> int mi_size ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> variance_node vt ; //<S2SV> const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> const int64_t threshold_multiplier = 25 ; //<S2SV> int64_t threshold = threshold_multiplier * cpi -> common . base_qindex ; //<S2SV> assert ( block_height == block_width ) ; //<S2SV> tree_to_node ( data , bsize , & vt ) ; //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols && //<S2SV> mi_row + block_height / 2 < cm -> mi_rows && //<S2SV> vt . part_variances -> none . variance < threshold ) { //<S2SV> set_block_size ( cpi , tile , mi_row , mi_col , bsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( mi_row + block_height / 2 < cm -> mi_rows && //<S2SV> vt . part_variances -> vert [ 0 ] . variance < threshold && //<S2SV> vt . part_variances -> vert [ 1 ] . variance < threshold ) { //<S2SV> BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; //<S2SV> set_block_size ( cpi , tile , mi_row , mi_col + block_width / 2 , subsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols && //<S2SV> vt . part_variances -> horz [ 0 ] . variance < threshold && //<S2SV> vt . part_variances -> horz [ 1 ] . variance < threshold ) { //<S2SV> BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> set_block_size ( cpi , tile , mi_row , mi_col , subsize ) ; //<S2SV> set_block_size ( cpi , tile , mi_row + block_height / 2 , mi_col , subsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 