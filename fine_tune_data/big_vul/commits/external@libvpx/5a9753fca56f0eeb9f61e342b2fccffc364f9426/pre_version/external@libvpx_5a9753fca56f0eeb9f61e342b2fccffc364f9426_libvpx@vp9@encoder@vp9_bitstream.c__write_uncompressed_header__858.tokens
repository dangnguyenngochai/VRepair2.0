static void write_uncompressed_header ( VP9_COMP * cpi , //<S2SV> struct vp9_write_bit_buffer * wb ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> vp9_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; //<S2SV> write_profile ( cm -> profile , wb ) ; //<S2SV> vp9_wb_write_bit ( wb , 0 ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> frame_type ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> show_frame ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> error_resilient_mode ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) { //<S2SV> const COLOR_SPACE cs = UNKNOWN ; //<S2SV> write_sync_code ( wb ) ; //<S2SV> if ( cm -> profile > PROFILE_1 ) { //<S2SV> assert ( cm -> bit_depth > BITS_8 ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; //<S2SV> } //<S2SV> vp9_wb_write_literal ( wb , cs , 3 ) ; //<S2SV> if ( cs != SRGB ) { //<S2SV> vp9_wb_write_bit ( wb , 0 ) ; //<S2SV> if ( cm -> profile >= PROFILE_1 ) { //<S2SV> vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; //<S2SV> vp9_wb_write_bit ( wb , 0 ) ; //<S2SV> } //<S2SV> } else { //<S2SV> assert ( cm -> profile == PROFILE_1 ) ; //<S2SV> vp9_wb_write_bit ( wb , 0 ) ; //<S2SV> } //<S2SV> write_frame_size ( cm , wb ) ; //<S2SV> } else { //<S2SV> if ( ! cm -> show_frame ) //<S2SV> vp9_wb_write_bit ( wb , cm -> intra_only ) ; //<S2SV> if ( ! cm -> error_resilient_mode ) //<S2SV> vp9_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; //<S2SV> if ( cm -> intra_only ) { //<S2SV> write_sync_code ( wb ) ; //<S2SV> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; //<S2SV> write_frame_size ( cm , wb ) ; //<S2SV> } else { //<S2SV> MV_REFERENCE_FRAME ref_frame ; //<S2SV> vp9_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> vp9_wb_write_literal ( wb , get_ref_frame_idx ( cpi , ref_frame ) , //<S2SV> REF_FRAMES_LOG2 ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; //<S2SV> } //<S2SV> write_frame_size_with_refs ( cpi , wb ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; //<S2SV> fix_interp_filter ( cm ) ; //<S2SV> write_interp_filter ( cm -> interp_filter , wb ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! cm -> error_resilient_mode ) { //<S2SV> vp9_wb_write_bit ( wb , cm -> refresh_frame_context ) ; //<S2SV> vp9_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; //<S2SV> } //<S2SV> vp9_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; //<S2SV> encode_loopfilter ( & cm -> lf , wb ) ; //<S2SV> encode_quantization ( cm , wb ) ; //<S2SV> encode_segmentation ( cpi , wb ) ; //<S2SV> write_tile_info ( cm , wb ) ; //<S2SV> } //<S2SV> 