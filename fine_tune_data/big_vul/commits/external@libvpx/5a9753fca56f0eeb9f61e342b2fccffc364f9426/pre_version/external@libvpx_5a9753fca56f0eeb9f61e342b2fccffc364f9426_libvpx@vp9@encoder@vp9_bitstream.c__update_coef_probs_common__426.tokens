static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , //<S2SV> TX_SIZE tx_size , //<S2SV> vp9_coeff_stats * frame_branch_ct ) { //<S2SV> vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ; //<S2SV> vp9_coeff_probs_model * old_frame_coef_probs = //<S2SV> cpi -> common . fc . coef_probs [ tx_size ] ; //<S2SV> const vp9_prob upd = DIFF_UPDATE_PROB ; //<S2SV> const int entropy_nodes_update = UNCONSTRAINED_NODES ; //<S2SV> int i , j , k , l , t ; //<S2SV> switch ( cpi -> sf . use_fast_coef_updates ) { //<S2SV> case TWO_LOOP : { //<S2SV> int savings = 0 ; //<S2SV> int update [ 2 ] = { 0 , 0 } ; //<S2SV> for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { //<S2SV> for ( j = 0 ; j < REF_TYPES ; ++ j ) { //<S2SV> for ( k = 0 ; k < COEF_BANDS ; ++ k ) { //<S2SV> for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { //<S2SV> for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { //<S2SV> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; //<S2SV> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; //<S2SV> int s ; //<S2SV> int u = 0 ; //<S2SV> if ( t == PIVOT_NODE ) //<S2SV> s = vp9_prob_diff_update_savings_search_model ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , //<S2SV> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; //<S2SV> else //<S2SV> s = vp9_prob_diff_update_savings_search ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ; //<S2SV> if ( s > 0 && newp != oldp ) //<S2SV> u = 1 ; //<S2SV> if ( u ) //<S2SV> savings += s - ( int ) ( vp9_cost_zero ( upd ) ) ; //<S2SV> else //<S2SV> savings -= ( int ) ( vp9_cost_zero ( upd ) ) ; //<S2SV> update [ u ] ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( update [ 1 ] == 0 || savings < 0 ) { //<S2SV> vp9_write_bit ( bc , 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> vp9_write_bit ( bc , 1 ) ; //<S2SV> for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { //<S2SV> for ( j = 0 ; j < REF_TYPES ; ++ j ) { //<S2SV> for ( k = 0 ; k < COEF_BANDS ; ++ k ) { //<S2SV> for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { //<S2SV> for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { //<S2SV> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; //<S2SV> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; //<S2SV> const vp9_prob upd = DIFF_UPDATE_PROB ; //<S2SV> int s ; //<S2SV> int u = 0 ; //<S2SV> if ( t == PIVOT_NODE ) //<S2SV> s = vp9_prob_diff_update_savings_search_model ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , //<S2SV> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; //<S2SV> else //<S2SV> s = vp9_prob_diff_update_savings_search ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , //<S2SV> * oldp , & newp , upd ) ; //<S2SV> if ( s > 0 && newp != * oldp ) //<S2SV> u = 1 ; //<S2SV> vp9_write ( bc , u , upd ) ; //<S2SV> if ( u ) { //<S2SV> vp9_write_prob_diff_update ( bc , newp , * oldp ) ; //<S2SV> * oldp = newp ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> case ONE_LOOP : //<S2SV> case ONE_LOOP_REDUCED : { //<S2SV> const int prev_coef_contexts_to_update = //<S2SV> cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? //<S2SV> COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ; //<S2SV> const int coef_band_to_update = //<S2SV> cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? //<S2SV> COEF_BANDS >> 1 : COEF_BANDS ; //<S2SV> int updates = 0 ; //<S2SV> int noupdates_before_first = 0 ; //<S2SV> for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { //<S2SV> for ( j = 0 ; j < REF_TYPES ; ++ j ) { //<S2SV> for ( k = 0 ; k < COEF_BANDS ; ++ k ) { //<S2SV> for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { //<S2SV> for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { //<S2SV> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; //<S2SV> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; //<S2SV> int s ; //<S2SV> int u = 0 ; //<S2SV> if ( l >= prev_coef_contexts_to_update || //<S2SV> k >= coef_band_to_update ) { //<S2SV> u = 0 ; //<S2SV> } else { //<S2SV> if ( t == PIVOT_NODE ) //<S2SV> s = vp9_prob_diff_update_savings_search_model ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , //<S2SV> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; //<S2SV> else //<S2SV> s = vp9_prob_diff_update_savings_search ( //<S2SV> frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , //<S2SV> * oldp , & newp , upd ) ; //<S2SV> if ( s > 0 && newp != * oldp ) //<S2SV> u = 1 ; //<S2SV> } //<S2SV> updates += u ; //<S2SV> if ( u == 0 && updates == 0 ) { //<S2SV> noupdates_before_first ++ ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( u == 1 && updates == 1 ) { //<S2SV> int v ; //<S2SV> vp9_write_bit ( bc , 1 ) ; //<S2SV> for ( v = 0 ; v < noupdates_before_first ; ++ v ) //<S2SV> vp9_write ( bc , 0 , upd ) ; //<S2SV> } //<S2SV> vp9_write ( bc , u , upd ) ; //<S2SV> if ( u ) { //<S2SV> vp9_write_prob_diff_update ( bc , newp , * oldp ) ; //<S2SV> * oldp = newp ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( updates == 0 ) { //<S2SV> vp9_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> 