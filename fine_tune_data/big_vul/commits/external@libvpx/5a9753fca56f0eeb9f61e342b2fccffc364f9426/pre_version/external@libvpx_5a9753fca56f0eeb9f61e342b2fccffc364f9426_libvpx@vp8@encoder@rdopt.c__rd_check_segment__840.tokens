static void rd_check_segment ( VP8_COMP * cpi , MACROBLOCK * x , //<S2SV> BEST_SEG_INFO * bsi , unsigned int segmentation ) //<S2SV> { //<S2SV> int i ; //<S2SV> int const * labels ; //<S2SV> int br = 0 ; //<S2SV> int bd = 0 ; //<S2SV> B_PREDICTION_MODE this_mode ; //<S2SV> int label_count ; //<S2SV> int this_segment_rd = 0 ; //<S2SV> int label_mv_thresh ; //<S2SV> int rate = 0 ; //<S2SV> int sbr = 0 ; //<S2SV> int sbd = 0 ; //<S2SV> int segmentyrate = 0 ; //<S2SV> vp8_variance_fn_ptr_t * v_fn_ptr ; //<S2SV> ENTROPY_CONTEXT_PLANES t_above , t_left ; //<S2SV> ENTROPY_CONTEXT * ta ; //<S2SV> ENTROPY_CONTEXT * tl ; //<S2SV> ENTROPY_CONTEXT_PLANES t_above_b , t_left_b ; //<S2SV> ENTROPY_CONTEXT * ta_b ; //<S2SV> ENTROPY_CONTEXT * tl_b ; //<S2SV> vpx_memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> vpx_memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> ta = ( ENTROPY_CONTEXT * ) & t_above ; //<S2SV> tl = ( ENTROPY_CONTEXT * ) & t_left ; //<S2SV> ta_b = ( ENTROPY_CONTEXT * ) & t_above_b ; //<S2SV> tl_b = ( ENTROPY_CONTEXT * ) & t_left_b ; //<S2SV> br = 0 ; //<S2SV> bd = 0 ; //<S2SV> v_fn_ptr = & cpi -> fn_ptr [ segmentation ] ; //<S2SV> labels = vp8_mbsplits [ segmentation ] ; //<S2SV> label_count = vp8_mbsplit_count [ segmentation ] ; //<S2SV> label_mv_thresh = 1 * bsi -> mvthresh / label_count ; //<S2SV> rate = vp8_cost_token ( vp8_mbsplit_tree , vp8_mbsplit_probs , vp8_mbsplit_encodings + segmentation ) ; //<S2SV> rate += vp8_cost_mv_ref ( SPLITMV , bsi -> mdcounts ) ; //<S2SV> this_segment_rd += RDCOST ( x -> rdmult , x -> rddiv , rate , 0 ) ; //<S2SV> br += rate ; //<S2SV> for ( i = 0 ; i < label_count ; i ++ ) //<S2SV> { //<S2SV> int_mv mode_mv [ B_MODE_COUNT ] ; //<S2SV> int best_label_rd = INT_MAX ; //<S2SV> B_PREDICTION_MODE mode_selected = ZERO4X4 ; //<S2SV> int bestlabelyrate = 0 ; //<S2SV> for ( this_mode = LEFT4X4 ; this_mode <= NEW4X4 ; this_mode ++ ) //<S2SV> { //<S2SV> int this_rd ; //<S2SV> int distortion ; //<S2SV> int labelyrate ; //<S2SV> ENTROPY_CONTEXT_PLANES t_above_s , t_left_s ; //<S2SV> ENTROPY_CONTEXT * ta_s ; //<S2SV> ENTROPY_CONTEXT * tl_s ; //<S2SV> vpx_memcpy ( & t_above_s , & t_above , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> vpx_memcpy ( & t_left_s , & t_left , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> ta_s = ( ENTROPY_CONTEXT * ) & t_above_s ; //<S2SV> tl_s = ( ENTROPY_CONTEXT * ) & t_left_s ; //<S2SV> if ( this_mode == NEW4X4 ) //<S2SV> { //<S2SV> int sseshift ; //<S2SV> int num00 ; //<S2SV> int step_param = 0 ; //<S2SV> int further_steps ; //<S2SV> int n ; //<S2SV> int thissme ; //<S2SV> int bestsme = INT_MAX ; //<S2SV> int_mv temp_mv ; //<S2SV> BLOCK * c ; //<S2SV> BLOCKD * e ; //<S2SV> if ( best_label_rd < label_mv_thresh ) //<S2SV> break ; //<S2SV> if ( cpi -> compressor_speed ) //<S2SV> { //<S2SV> if ( segmentation == BLOCK_8X16 || segmentation == BLOCK_16X8 ) //<S2SV> { //<S2SV> bsi -> mvp . as_int = bsi -> sv_mvp [ i ] . as_int ; //<S2SV> if ( i == 1 && segmentation == BLOCK_16X8 ) //<S2SV> bsi -> mvp . as_int = bsi -> sv_mvp [ 2 ] . as_int ; //<S2SV> step_param = bsi -> sv_istep [ i ] ; //<S2SV> } //<S2SV> if ( segmentation == BLOCK_4X4 && i > 0 ) //<S2SV> { //<S2SV> bsi -> mvp . as_int = x -> e_mbd . block [ i - 1 ] . bmi . mv . as_int ; //<S2SV> if ( i == 4 || i == 8 || i == 12 ) //<S2SV> bsi -> mvp . as_int = x -> e_mbd . block [ i - 4 ] . bmi . mv . as_int ; //<S2SV> step_param = 2 ; //<S2SV> } //<S2SV> } //<S2SV> further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; //<S2SV> { //<S2SV> int sadpb = x -> sadperbit4 ; //<S2SV> int_mv mvp_full ; //<S2SV> mvp_full . as_mv . row = bsi -> mvp . as_mv . row >> 3 ; //<S2SV> mvp_full . as_mv . col = bsi -> mvp . as_mv . col >> 3 ; //<S2SV> n = vp8_mbsplit_offset [ segmentation ] [ i ] ; //<S2SV> c = & x -> block [ n ] ; //<S2SV> e = & x -> e_mbd . block [ n ] ; //<S2SV> { //<S2SV> bestsme = cpi -> diamond_search_sad ( x , c , e , & mvp_full , //<S2SV> & mode_mv [ NEW4X4 ] , step_param , //<S2SV> sadpb , & num00 , v_fn_ptr , //<S2SV> x -> mvcost , bsi -> ref_mv ) ; //<S2SV> n = num00 ; //<S2SV> num00 = 0 ; //<S2SV> while ( n < further_steps ) //<S2SV> { //<S2SV> n ++ ; //<S2SV> if ( num00 ) //<S2SV> num00 -- ; //<S2SV> else //<S2SV> { //<S2SV> thissme = cpi -> diamond_search_sad ( x , c , e , //<S2SV> & mvp_full , & temp_mv , //<S2SV> step_param + n , sadpb , //<S2SV> & num00 , v_fn_ptr , //<S2SV> x -> mvcost , bsi -> ref_mv ) ; //<S2SV> if ( thissme < bestsme ) //<S2SV> { //<S2SV> bestsme = thissme ; //<S2SV> mode_mv [ NEW4X4 ] . as_int = temp_mv . as_int ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> sseshift = segmentation_to_sseshift [ segmentation ] ; //<S2SV> if ( ( cpi -> compressor_speed == 0 ) && ( bestsme >> sseshift ) > 4000 ) //<S2SV> { //<S2SV> vp8_clamp_mv ( & mvp_full , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; //<S2SV> thissme = cpi -> full_search_sad ( x , c , e , & mvp_full , //<S2SV> sadpb , 16 , v_fn_ptr , //<S2SV> x -> mvcost , bsi -> ref_mv ) ; //<S2SV> if ( thissme < bestsme ) //<S2SV> { //<S2SV> bestsme = thissme ; //<S2SV> mode_mv [ NEW4X4 ] . as_int = e -> bmi . mv . as_int ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> e -> bmi . mv . as_int = mode_mv [ NEW4X4 ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> { //<S2SV> int disto ; //<S2SV> unsigned int sse ; //<S2SV> cpi -> find_fractional_mv_step ( x , c , e , & mode_mv [ NEW4X4 ] , //<S2SV> bsi -> ref_mv , x -> errorperbit , v_fn_ptr , x -> mvcost , //<S2SV> & disto , & sse ) ; //<S2SV> } //<S2SV> } //<S2SV> rate = labels2mode ( x , labels , i , this_mode , & mode_mv [ this_mode ] , //<S2SV> bsi -> ref_mv , x -> mvcost ) ; //<S2SV> if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || //<S2SV> ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) //<S2SV> { //<S2SV> continue ; //<S2SV> } //<S2SV> distortion = vp8_encode_inter_mb_segment ( x , labels , i ) / 4 ; //<S2SV> labelyrate = rdcost_mbsegment_y ( x , labels , i , ta_s , tl_s ) ; //<S2SV> rate += labelyrate ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; //<S2SV> if ( this_rd < best_label_rd ) //<S2SV> { //<S2SV> sbr = rate ; //<S2SV> sbd = distortion ; //<S2SV> bestlabelyrate = labelyrate ; //<S2SV> mode_selected = this_mode ; //<S2SV> best_label_rd = this_rd ; //<S2SV> vpx_memcpy ( ta_b , ta_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> vpx_memcpy ( tl_b , tl_s , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> } //<S2SV> } //<S2SV> vpx_memcpy ( ta , ta_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> vpx_memcpy ( tl , tl_b , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; //<S2SV> labels2mode ( x , labels , i , mode_selected , & mode_mv [ mode_selected ] , //<S2SV> bsi -> ref_mv , x -> mvcost ) ; //<S2SV> br += sbr ; //<S2SV> bd += sbd ; //<S2SV> segmentyrate += bestlabelyrate ; //<S2SV> this_segment_rd += best_label_rd ; //<S2SV> if ( this_segment_rd >= bsi -> segment_rd ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( this_segment_rd < bsi -> segment_rd ) //<S2SV> { //<S2SV> bsi -> r = br ; //<S2SV> bsi -> d = bd ; //<S2SV> bsi -> segment_yrate = segmentyrate ; //<S2SV> bsi -> segment_rd = this_segment_rd ; //<S2SV> bsi -> segment_num = segmentation ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> bsi -> mvs [ i ] . as_mv = x -> partition_info -> bmi [ i ] . mv . as_mv ; //<S2SV> bsi -> modes [ i ] = x -> partition_info -> bmi [ i ] . mode ; //<S2SV> bsi -> eobs [ i ] = x -> e_mbd . eobs [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 