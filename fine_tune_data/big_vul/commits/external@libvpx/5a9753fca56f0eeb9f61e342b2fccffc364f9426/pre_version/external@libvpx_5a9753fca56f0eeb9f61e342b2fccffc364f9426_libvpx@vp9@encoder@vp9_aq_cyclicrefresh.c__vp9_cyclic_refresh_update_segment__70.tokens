void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , //<S2SV> MB_MODE_INFO * const mbmi , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , int use_rd ) { //<S2SV> const VP9_COMMON * const cm = & cpi -> common ; //<S2SV> CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; //<S2SV> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int bh = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; //<S2SV> const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; //<S2SV> const int block_index = mi_row * cm -> mi_cols + mi_col ; //<S2SV> const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ; //<S2SV> int new_map_value = cr -> map [ block_index ] ; //<S2SV> int x = 0 ; int y = 0 ; //<S2SV> if ( mbmi -> segment_id > 0 && ! refresh_this_block ) //<S2SV> mbmi -> segment_id = 0 ; //<S2SV> if ( mbmi -> segment_id == 1 ) { //<S2SV> new_map_value = - cr -> time_for_refresh ; //<S2SV> } else if ( refresh_this_block ) { //<S2SV> if ( cr -> map [ block_index ] == 1 ) //<S2SV> new_map_value = 0 ; //<S2SV> } else { //<S2SV> new_map_value = 1 ; //<S2SV> } //<S2SV> for ( y = 0 ; y < ymis ; y ++ ) //<S2SV> for ( x = 0 ; x < xmis ; x ++ ) { //<S2SV> cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; //<S2SV> cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = //<S2SV> mbmi -> segment_id ; //<S2SV> } //<S2SV> if ( mbmi -> segment_id ) //<S2SV> cr -> num_seg_blocks += xmis * ymis ; //<S2SV> } //<S2SV> 