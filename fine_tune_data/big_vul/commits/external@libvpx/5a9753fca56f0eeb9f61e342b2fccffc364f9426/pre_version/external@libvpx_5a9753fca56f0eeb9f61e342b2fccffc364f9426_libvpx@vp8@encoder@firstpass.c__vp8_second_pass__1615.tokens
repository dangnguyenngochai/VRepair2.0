void vp8_second_pass ( VP8_COMP * cpi ) //<S2SV> { //<S2SV> int tmp_q ; //<S2SV> int frames_left = ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ; //<S2SV> FIRSTPASS_STATS this_frame = { 0 } ; //<S2SV> FIRSTPASS_STATS this_frame_copy ; //<S2SV> double this_frame_intra_error ; //<S2SV> double this_frame_coded_error ; //<S2SV> int overhead_bits ; //<S2SV> if ( ! cpi -> twopass . stats_in ) //<S2SV> { //<S2SV> return ; //<S2SV> } //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> if ( EOF == input_stats ( cpi , & this_frame ) ) //<S2SV> return ; //<S2SV> this_frame_intra_error = this_frame . intra_error ; //<S2SV> this_frame_coded_error = this_frame . coded_error ; //<S2SV> if ( cpi -> twopass . frames_to_key == 0 ) //<S2SV> { //<S2SV> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; //<S2SV> find_next_key_frame ( cpi , & this_frame_copy ) ; //<S2SV> if ( cpi -> oxcf . error_resilient_mode ) //<S2SV> { //<S2SV> cpi -> twopass . gf_group_bits = cpi -> twopass . kf_group_bits ; //<S2SV> cpi -> twopass . gf_group_error_left = //<S2SV> ( int ) cpi -> twopass . kf_group_error_left ; //<S2SV> cpi -> baseline_gf_interval = cpi -> twopass . frames_to_key ; //<S2SV> cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; //<S2SV> cpi -> source_alt_ref_pending = 0 ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> frames_till_gf_update_due == 0 ) //<S2SV> { //<S2SV> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; //<S2SV> define_gf_group ( cpi , & this_frame_copy ) ; //<S2SV> if ( cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) //<S2SV> { //<S2SV> int bak = cpi -> per_frame_bandwidth ; //<S2SV> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; //<S2SV> assign_std_frame_bits ( cpi , & this_frame_copy ) ; //<S2SV> cpi -> per_frame_bandwidth = bak ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> if ( cpi -> oxcf . error_resilient_mode ) //<S2SV> { //<S2SV> cpi -> frames_till_gf_update_due = cpi -> twopass . frames_to_key ; //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; //<S2SV> assign_std_frame_bits ( cpi , & this_frame_copy ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vpx_memcpy ( & this_frame_copy , & this_frame , sizeof ( this_frame ) ) ; //<S2SV> assign_std_frame_bits ( cpi , & this_frame_copy ) ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> twopass . this_iiratio = ( unsigned int ) ( this_frame_intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( this_frame_coded_error ) ) ; //<S2SV> { //<S2SV> FIRSTPASS_STATS next_frame ; //<S2SV> if ( lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) //<S2SV> { //<S2SV> cpi -> twopass . next_iiratio = ( unsigned int ) ( next_frame . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> target_bandwidth = ( int ) //<S2SV> ( cpi -> per_frame_bandwidth * cpi -> output_framerate ) ; //<S2SV> if ( cpi -> target_bandwidth < 0 ) //<S2SV> cpi -> target_bandwidth = 0 ; //<S2SV> overhead_bits = ( int ) estimate_modemvcost ( //<S2SV> cpi , & cpi -> twopass . total_left_stats ) ; //<S2SV> if ( cpi -> common . current_video_frame == 0 ) //<S2SV> { //<S2SV> cpi -> twopass . est_max_qcorrection_factor = 1.0 ; //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) //<S2SV> { //<S2SV> int est_cq ; //<S2SV> est_cq = //<S2SV> estimate_cq ( cpi , //<S2SV> & cpi -> twopass . total_left_stats , //<S2SV> ( int ) ( cpi -> twopass . bits_left / frames_left ) , //<S2SV> overhead_bits ) ; //<S2SV> cpi -> cq_target_quality = cpi -> oxcf . cq_level ; //<S2SV> if ( est_cq > cpi -> cq_target_quality ) //<S2SV> cpi -> cq_target_quality = est_cq ; //<S2SV> } //<S2SV> cpi -> twopass . maxq_max_limit = cpi -> worst_quality ; //<S2SV> cpi -> twopass . maxq_min_limit = cpi -> best_quality ; //<S2SV> tmp_q = estimate_max_q ( //<S2SV> cpi , //<S2SV> & cpi -> twopass . total_left_stats , //<S2SV> ( int ) ( cpi -> twopass . bits_left / frames_left ) , //<S2SV> overhead_bits ) ; //<S2SV> cpi -> twopass . maxq_max_limit = ( ( tmp_q + 32 ) < cpi -> worst_quality ) //<S2SV> ? ( tmp_q + 32 ) : cpi -> worst_quality ; //<S2SV> cpi -> twopass . maxq_min_limit = ( ( tmp_q - 32 ) > cpi -> best_quality ) //<S2SV> ? ( tmp_q - 32 ) : cpi -> best_quality ; //<S2SV> cpi -> active_worst_quality = tmp_q ; //<S2SV> cpi -> ni_av_qi = tmp_q ; //<S2SV> } //<S2SV> else if ( ( cpi -> common . current_video_frame < //<S2SV> ( ( ( unsigned int ) cpi -> twopass . total_stats . count * 255 ) >> 8 ) ) && //<S2SV> ( ( cpi -> common . current_video_frame + cpi -> baseline_gf_interval ) < //<S2SV> ( unsigned int ) cpi -> twopass . total_stats . count ) ) //<S2SV> { //<S2SV> if ( frames_left < 1 ) //<S2SV> frames_left = 1 ; //<S2SV> tmp_q = estimate_max_q ( //<S2SV> cpi , //<S2SV> & cpi -> twopass . total_left_stats , //<S2SV> ( int ) ( cpi -> twopass . bits_left / frames_left ) , //<S2SV> overhead_bits ) ; //<S2SV> if ( tmp_q > cpi -> active_worst_quality ) //<S2SV> cpi -> active_worst_quality ++ ; //<S2SV> else if ( tmp_q < cpi -> active_worst_quality ) //<S2SV> cpi -> active_worst_quality -- ; //<S2SV> cpi -> active_worst_quality = //<S2SV> ( ( cpi -> active_worst_quality * 3 ) + tmp_q + 2 ) / 4 ; //<S2SV> } //<S2SV> cpi -> twopass . frames_to_key -- ; //<S2SV> subtract_stats ( & cpi -> twopass . total_left_stats , & this_frame ) ; //<S2SV> } //<S2SV> 