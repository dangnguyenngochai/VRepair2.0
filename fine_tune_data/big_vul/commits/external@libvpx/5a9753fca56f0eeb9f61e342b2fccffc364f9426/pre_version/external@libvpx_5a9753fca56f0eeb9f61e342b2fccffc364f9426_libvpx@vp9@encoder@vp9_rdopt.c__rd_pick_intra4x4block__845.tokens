static int64_t rd_pick_intra4x4block ( VP9_COMP * cpi , MACROBLOCK * x , int ib , //<S2SV> MB_PREDICTION_MODE * best_mode , //<S2SV> const int * bmode_costs , //<S2SV> ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , //<S2SV> int * bestrate , int * bestratey , //<S2SV> int64_t * bestdistortion , //<S2SV> BLOCK_SIZE bsize , int64_t rd_thresh ) { //<S2SV> MB_PREDICTION_MODE mode ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> int64_t best_rd = rd_thresh ; //<S2SV> struct macroblock_plane * p = & x -> plane [ 0 ] ; //<S2SV> struct macroblockd_plane * pd = & xd -> plane [ 0 ] ; //<S2SV> const int src_stride = p -> src . stride ; //<S2SV> const int dst_stride = pd -> dst . stride ; //<S2SV> const uint8_t * src_init = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , ib , //<S2SV> src_stride ) ] ; //<S2SV> uint8_t * dst_init = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , ib , //<S2SV> dst_stride ) ] ; //<S2SV> ENTROPY_CONTEXT ta [ 2 ] , tempa [ 2 ] ; //<S2SV> ENTROPY_CONTEXT tl [ 2 ] , templ [ 2 ] ; //<S2SV> const int num_4x4_blocks_wide = num_4x4_blocks_wide_lookup [ bsize ] ; //<S2SV> const int num_4x4_blocks_high = num_4x4_blocks_high_lookup [ bsize ] ; //<S2SV> int idx , idy ; //<S2SV> uint8_t best_dst [ 8 * 8 ] ; //<S2SV> assert ( ib < 4 ) ; //<S2SV> vpx_memcpy ( ta , a , sizeof ( ta ) ) ; //<S2SV> vpx_memcpy ( tl , l , sizeof ( tl ) ) ; //<S2SV> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; //<S2SV> for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { //<S2SV> int64_t this_rd ; //<S2SV> int ratey = 0 ; //<S2SV> int64_t distortion = 0 ; //<S2SV> int rate = bmode_costs [ mode ] ; //<S2SV> if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) //<S2SV> continue ; //<S2SV> if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { //<S2SV> if ( conditional_skipintra ( mode , * best_mode ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> vpx_memcpy ( tempa , ta , sizeof ( ta ) ) ; //<S2SV> vpx_memcpy ( templ , tl , sizeof ( tl ) ) ; //<S2SV> for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { //<S2SV> for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { //<S2SV> const int block = ib + idy * 2 + idx ; //<S2SV> const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; //<S2SV> uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; //<S2SV> int16_t * const src_diff = raster_block_offset_int16 ( BLOCK_8X8 , block , //<S2SV> p -> src_diff ) ; //<S2SV> int16_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; //<S2SV> xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; //<S2SV> vp9_predict_intra_block ( xd , block , 1 , //<S2SV> TX_4X4 , mode , //<S2SV> x -> skip_encode ? src : dst , //<S2SV> x -> skip_encode ? src_stride : dst_stride , //<S2SV> dst , dst_stride , idx , idy , 0 ) ; //<S2SV> vp9_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; //<S2SV> if ( xd -> lossless ) { //<S2SV> const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; //<S2SV> vp9_fwht4x4 ( src_diff , coeff , 8 ) ; //<S2SV> vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; //<S2SV> ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , //<S2SV> so -> scan , so -> neighbors , //<S2SV> cpi -> sf . use_fast_coef_costing ) ; //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) //<S2SV> goto next ; //<S2SV> vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , //<S2SV> p -> eobs [ block ] ) ; //<S2SV> } else { //<S2SV> int64_t unused ; //<S2SV> const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; //<S2SV> const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; //<S2SV> vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; //<S2SV> vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; //<S2SV> ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , //<S2SV> so -> scan , so -> neighbors , //<S2SV> cpi -> sf . use_fast_coef_costing ) ; //<S2SV> distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , //<S2SV> 16 , & unused ) >> 2 ; //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) //<S2SV> goto next ; //<S2SV> vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , //<S2SV> dst , dst_stride , p -> eobs [ block ] ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> rate += ratey ; //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; //<S2SV> if ( this_rd < best_rd ) { //<S2SV> * bestrate = rate ; //<S2SV> * bestratey = ratey ; //<S2SV> * bestdistortion = distortion ; //<S2SV> best_rd = this_rd ; //<S2SV> * best_mode = mode ; //<S2SV> vpx_memcpy ( a , tempa , sizeof ( tempa ) ) ; //<S2SV> vpx_memcpy ( l , templ , sizeof ( templ ) ) ; //<S2SV> for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) //<S2SV> vpx_memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , //<S2SV> num_4x4_blocks_wide * 4 ) ; //<S2SV> } //<S2SV> next : //<S2SV> { } //<S2SV> } //<S2SV> if ( best_rd >= rd_thresh || x -> skip_encode ) //<S2SV> return best_rd ; //<S2SV> for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) //<S2SV> vpx_memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , //<S2SV> num_4x4_blocks_wide * 4 ) ; //<S2SV> return best_rd ; //<S2SV> } //<S2SV> 