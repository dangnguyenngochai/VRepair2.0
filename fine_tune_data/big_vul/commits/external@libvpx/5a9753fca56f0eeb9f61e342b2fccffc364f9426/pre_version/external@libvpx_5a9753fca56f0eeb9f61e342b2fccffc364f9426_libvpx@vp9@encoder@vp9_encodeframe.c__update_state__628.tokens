static void update_state ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize , //<S2SV> int output_enabled ) { //<S2SV> int i , x_idx , y ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> MODE_INFO * mi = & ctx -> mic ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> MODE_INFO * mi_addr = xd -> mi [ 0 ] ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> int max_plane ; //<S2SV> assert ( mi -> mbmi . sb_type == bsize ) ; //<S2SV> * mi_addr = * mi ; //<S2SV> if ( seg -> enabled && output_enabled ) { //<S2SV> if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) { //<S2SV> const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> mi_addr -> mbmi . segment_id = //<S2SV> vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; //<S2SV> } //<S2SV> else if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { //<S2SV> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , //<S2SV> mi_row , mi_col , bsize , 1 ) ; //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> } //<S2SV> } //<S2SV> max_plane = is_inter_block ( mbmi ) ? MAX_MB_PLANE : 1 ; //<S2SV> for ( i = 0 ; i < max_plane ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; //<S2SV> } //<S2SV> for ( i = max_plane ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ; //<S2SV> } //<S2SV> for ( y = 0 ; y < mi_height ; y ++ ) //<S2SV> for ( x_idx = 0 ; x_idx < mi_width ; x_idx ++ ) //<S2SV> if ( ( xd -> mb_to_right_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_width > x_idx //<S2SV> && ( xd -> mb_to_bottom_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_height > y ) { //<S2SV> xd -> mi [ x_idx + y * mis ] = mi_addr ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode ) //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> if ( bsize < BLOCK_32X32 ) { //<S2SV> if ( bsize < BLOCK_16X16 ) //<S2SV> ctx -> tx_rd_diff [ ALLOW_16X16 ] = ctx -> tx_rd_diff [ ALLOW_8X8 ] ; //<S2SV> ctx -> tx_rd_diff [ ALLOW_32X32 ] = ctx -> tx_rd_diff [ ALLOW_16X16 ] ; //<S2SV> } //<S2SV> if ( is_inter_block ( mbmi ) && mbmi -> sb_type < BLOCK_8X8 ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; //<S2SV> mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; //<S2SV> } //<S2SV> x -> skip = ctx -> skip ; //<S2SV> vpx_memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , //<S2SV> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; //<S2SV> if ( ! output_enabled ) //<S2SV> return ; //<S2SV> if ( ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { //<S2SV> for ( i = 0 ; i < TX_MODES ; i ++ ) //<S2SV> cpi -> rd_tx_select_diff [ i ] += ctx -> tx_rd_diff [ i ] ; //<S2SV> } //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> if ( frame_is_intra_only ( cm ) ) { //<S2SV> static const int kf_mode_index [ ] = { //<S2SV> THR_DC , //<S2SV> THR_V_PRED , //<S2SV> THR_H_PRED , //<S2SV> THR_D45_PRED , //<S2SV> THR_D135_PRED , //<S2SV> THR_D117_PRED , //<S2SV> THR_D153_PRED , //<S2SV> THR_D207_PRED , //<S2SV> THR_D63_PRED , //<S2SV> THR_TM , //<S2SV> } ; //<S2SV> ++ cpi -> mode_chosen_counts [ kf_mode_index [ mbmi -> mode ] ] ; //<S2SV> } else { //<S2SV> ++ cpi -> mode_chosen_counts [ ctx -> best_mode_index ] ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> if ( is_inter_block ( mbmi ) ) { //<S2SV> vp9_update_mv_count ( cm , xd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) { //<S2SV> const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; //<S2SV> ++ cm -> counts . switchable_interp [ ctx ] [ mbmi -> interp_filter ] ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> rd_comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ; //<S2SV> cpi -> rd_comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; //<S2SV> cpi -> rd_comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> cpi -> rd_filter_diff [ i ] += ctx -> best_filter_diff [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> 