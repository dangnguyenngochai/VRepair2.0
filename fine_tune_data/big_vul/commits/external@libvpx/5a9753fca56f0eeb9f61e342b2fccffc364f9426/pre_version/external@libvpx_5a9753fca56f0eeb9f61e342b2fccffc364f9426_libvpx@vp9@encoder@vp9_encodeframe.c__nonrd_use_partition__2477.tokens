static void nonrd_use_partition ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> MODE_INFO * * mi_8x8 , //<S2SV> TOKENEXTRA * * tp , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , int output_enabled , //<S2SV> int * totrate , int64_t * totdist ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> PARTITION_TYPE partition ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> int rate = INT_MAX ; //<S2SV> int64_t dist = INT64_MAX ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> subsize = ( bsize >= BLOCK_8X8 ) ? mi_8x8 [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; //<S2SV> partition = partition_lookup [ bsl ] [ subsize ] ; //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( mi_col + hbs < cm -> mi_cols ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col + hbs , //<S2SV> & rate , & dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( rate != INT_MAX && dist != INT64_MAX && //<S2SV> * totrate != INT_MAX && * totdist != INT64_MAX ) { //<S2SV> * totrate += rate ; //<S2SV> * totdist += dist ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row , mi_col , totrate , totdist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> if ( mi_row + hbs < cm -> mi_rows ) { //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile , mi_row + hbs , mi_col , //<S2SV> & rate , & dist , subsize ) ; //<S2SV> get_block_context ( x , subsize ) -> mic . mbmi = mi_8x8 [ 0 ] -> mbmi ; //<S2SV> if ( rate != INT_MAX && dist != INT64_MAX && //<S2SV> * totrate != INT_MAX && * totdist != INT64_MAX ) { //<S2SV> * totrate += rate ; //<S2SV> * totdist += dist ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> * get_sb_index ( x , subsize ) = 0 ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 , tp , mi_row , mi_col , //<S2SV> subsize , output_enabled , totrate , totdist ) ; //<S2SV> * get_sb_index ( x , subsize ) = 1 ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs , tp , //<S2SV> mi_row , mi_col + hbs , subsize , output_enabled , //<S2SV> & rate , & dist ) ; //<S2SV> if ( rate != INT_MAX && dist != INT64_MAX && //<S2SV> * totrate != INT_MAX && * totdist != INT64_MAX ) { //<S2SV> * totrate += rate ; //<S2SV> * totdist += dist ; //<S2SV> } //<S2SV> * get_sb_index ( x , subsize ) = 2 ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis , tp , //<S2SV> mi_row + hbs , mi_col , subsize , output_enabled , //<S2SV> & rate , & dist ) ; //<S2SV> if ( rate != INT_MAX && dist != INT64_MAX && //<S2SV> * totrate != INT_MAX && * totdist != INT64_MAX ) { //<S2SV> * totrate += rate ; //<S2SV> * totdist += dist ; //<S2SV> } //<S2SV> * get_sb_index ( x , subsize ) = 3 ; //<S2SV> nonrd_use_partition ( cpi , tile , mi_8x8 + hbs * mis + hbs , tp , //<S2SV> mi_row + hbs , mi_col + hbs , subsize , output_enabled , //<S2SV> & rate , & dist ) ; //<S2SV> if ( rate != INT_MAX && dist != INT64_MAX && //<S2SV> * totrate != INT_MAX && * totdist != INT64_MAX ) { //<S2SV> * totrate += rate ; //<S2SV> * totdist += dist ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; //<S2SV> } //<S2SV> if ( bsize == BLOCK_64X64 && output_enabled ) { //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) //<S2SV> vp9_cyclic_refresh_set_rate_and_dist_sb ( cpi -> cyclic_refresh , //<S2SV> * totrate , * totdist ) ; //<S2SV> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , 1 , bsize ) ; //<S2SV> } //<S2SV> } //<S2SV> 