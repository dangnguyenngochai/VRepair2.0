static //<S2SV> void encode_mb_row ( VP8_COMP * cpi , //<S2SV> VP8_COMMON * cm , //<S2SV> int mb_row , //<S2SV> MACROBLOCK * x , //<S2SV> MACROBLOCKD * xd , //<S2SV> TOKENEXTRA * * tp , //<S2SV> int * segment_counts , //<S2SV> int * totalrate ) //<S2SV> { //<S2SV> int recon_yoffset , recon_uvoffset ; //<S2SV> int mb_col ; //<S2SV> int ref_fb_idx = cm -> lst_fb_idx ; //<S2SV> int dst_fb_idx = cm -> new_fb_idx ; //<S2SV> int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; //<S2SV> int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; //<S2SV> int map_index = ( mb_row * cpi -> common . mb_cols ) ; //<S2SV> # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) //<S2SV> const int num_part = ( 1 << cm -> multi_token_partition ) ; //<S2SV> TOKENEXTRA * tp_start = cpi -> tok ; //<S2SV> vp8_writer * w ; //<S2SV> # endif //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> const int nsync = cpi -> mt_sync_range ; //<S2SV> const int rightmost_col = cm -> mb_cols + nsync ; //<S2SV> volatile const int * last_row_current_mb_col ; //<S2SV> volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; //<S2SV> if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) //<S2SV> last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; //<S2SV> else //<S2SV> last_row_current_mb_col = & rightmost_col ; //<S2SV> # endif //<S2SV> # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) //<S2SV> if ( num_part > 1 ) //<S2SV> w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; //<S2SV> else //<S2SV> w = & cpi -> bc [ 1 ] ; //<S2SV> # endif //<S2SV> xd -> above_context = cm -> above_context ; //<S2SV> xd -> up_available = ( mb_row != 0 ) ; //<S2SV> recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; //<S2SV> recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; //<S2SV> cpi -> tplist [ mb_row ] . start = * tp ; //<S2SV> xd -> mb_to_top_edge = - ( ( mb_row * 16 ) << 3 ) ; //<S2SV> xd -> mb_to_bottom_edge = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) << 3 ; //<S2SV> x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; //<S2SV> x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) //<S2SV> + ( VP8BORDERINPIXELS - 16 ) ; //<S2SV> x -> mb_activity_ptr = & cpi -> mb_activity_map [ map_index ] ; //<S2SV> for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) //<S2SV> { //<S2SV> # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) //<S2SV> * tp = cpi -> tok ; //<S2SV> # endif //<S2SV> xd -> mb_to_left_edge = - ( ( mb_col * 16 ) << 3 ) ; //<S2SV> xd -> mb_to_right_edge = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) << 3 ; //<S2SV> x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; //<S2SV> x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) //<S2SV> + ( VP8BORDERINPIXELS - 16 ) ; //<S2SV> xd -> dst . y_buffer = cm -> yv12_fb [ dst_fb_idx ] . y_buffer + recon_yoffset ; //<S2SV> xd -> dst . u_buffer = cm -> yv12_fb [ dst_fb_idx ] . u_buffer + recon_uvoffset ; //<S2SV> xd -> dst . v_buffer = cm -> yv12_fb [ dst_fb_idx ] . v_buffer + recon_uvoffset ; //<S2SV> xd -> left_available = ( mb_col != 0 ) ; //<S2SV> x -> rddiv = cpi -> RDDIV ; //<S2SV> x -> rdmult = cpi -> RDMULT ; //<S2SV> vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( cpi -> b_multi_threaded != 0 ) //<S2SV> { //<S2SV> * current_mb_col = mb_col - 1 ; //<S2SV> if ( ( mb_col & ( nsync - 1 ) ) == 0 ) //<S2SV> { //<S2SV> while ( mb_col > ( * last_row_current_mb_col - nsync ) ) //<S2SV> { //<S2SV> x86_pause_hint ( ) ; //<S2SV> thread_sleep ( 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) //<S2SV> vp8_activity_masking ( cpi , x ) ; //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> if ( cpi -> segmentation_map [ map_index + mb_col ] <= 3 ) //<S2SV> xd -> mode_info_context -> mbmi . segment_id = cpi -> segmentation_map [ map_index + mb_col ] ; //<S2SV> else //<S2SV> xd -> mode_info_context -> mbmi . segment_id = 0 ; //<S2SV> vp8cx_mb_init_quantizer ( cpi , x , 1 ) ; //<S2SV> } //<S2SV> else //<S2SV> xd -> mode_info_context -> mbmi . segment_id = 0 ; //<S2SV> x -> active_ptr = cpi -> active_map + map_index + mb_col ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) //<S2SV> { //<S2SV> * totalrate += vp8cx_encode_intra_macroblock ( cpi , x , tp ) ; //<S2SV> # ifdef MODE_STATS //<S2SV> y_modes [ xd -> mbmi . mode ] ++ ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> * totalrate += vp8cx_encode_inter_macroblock ( cpi , x , tp , recon_yoffset , recon_uvoffset , mb_row , mb_col ) ; //<S2SV> # ifdef MODE_STATS //<S2SV> inter_y_modes [ xd -> mbmi . mode ] ++ ; //<S2SV> if ( xd -> mbmi . mode == SPLITMV ) //<S2SV> { //<S2SV> int b ; //<S2SV> for ( b = 0 ; b < xd -> mbmi . partition_count ; b ++ ) //<S2SV> { //<S2SV> inter_b_modes [ x -> partition -> bmi [ b ] . mode ] ++ ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ( cpi -> current_layer == 0 ) && //<S2SV> ( cpi -> cyclic_refresh_mode_enabled && //<S2SV> xd -> segmentation_enabled ) ) //<S2SV> { //<S2SV> cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; //<S2SV> if ( xd -> mode_info_context -> mbmi . segment_id ) //<S2SV> cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; //<S2SV> else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) ) //<S2SV> { //<S2SV> if ( cpi -> cyclic_refresh_map [ map_index + mb_col ] == 1 ) //<S2SV> cpi -> cyclic_refresh_map [ map_index + mb_col ] = 0 ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> cyclic_refresh_map [ map_index + mb_col ] = 1 ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> tplist [ mb_row ] . stop = * tp ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> { //<S2SV> int tok_count = * tp - tp_start ; //<S2SV> pack_tokens ( w , tp_start , tok_count ) ; //<S2SV> } //<S2SV> # endif //<S2SV> x -> gf_active_ptr ++ ; //<S2SV> x -> mb_activity_ptr ++ ; //<S2SV> x -> src . y_buffer += 16 ; //<S2SV> x -> src . u_buffer += 8 ; //<S2SV> x -> src . v_buffer += 8 ; //<S2SV> recon_yoffset += 16 ; //<S2SV> recon_uvoffset += 8 ; //<S2SV> segment_counts [ xd -> mode_info_context -> mbmi . segment_id ] ++ ; //<S2SV> xd -> mode_info_context ++ ; //<S2SV> x -> partition_info ++ ; //<S2SV> xd -> above_context ++ ; //<S2SV> } //<S2SV> vp8_extend_mb_row ( & cm -> yv12_fb [ dst_fb_idx ] , //<S2SV> xd -> dst . y_buffer + 16 , //<S2SV> xd -> dst . u_buffer + 8 , //<S2SV> xd -> dst . v_buffer + 8 ) ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( cpi -> b_multi_threaded != 0 ) //<S2SV> * current_mb_col = rightmost_col ; //<S2SV> # endif //<S2SV> xd -> mode_info_context ++ ; //<S2SV> x -> partition_info ++ ; //<S2SV> } //<S2SV> 