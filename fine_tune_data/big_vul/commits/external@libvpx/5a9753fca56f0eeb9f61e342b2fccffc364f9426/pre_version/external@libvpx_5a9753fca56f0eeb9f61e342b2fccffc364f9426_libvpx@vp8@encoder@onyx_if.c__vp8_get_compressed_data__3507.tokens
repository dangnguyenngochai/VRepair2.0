int vp8_get_compressed_data ( VP8_COMP * cpi , unsigned int * frame_flags , unsigned long * size , unsigned char * dest , unsigned char * dest_end , int64_t * time_stamp , int64_t * time_end , int flush ) //<S2SV> { //<S2SV> # if HAVE_NEON //<S2SV> int64_t store_reg [ 8 ] ; //<S2SV> # endif //<S2SV> VP8_COMMON * cm ; //<S2SV> struct vpx_usec_timer tsctimer ; //<S2SV> struct vpx_usec_timer ticktimer ; //<S2SV> struct vpx_usec_timer cmptimer ; //<S2SV> YV12_BUFFER_CONFIG * force_src_buffer = NULL ; //<S2SV> if ( ! cpi ) //<S2SV> return - 1 ; //<S2SV> cm = & cpi -> common ; //<S2SV> if ( setjmp ( cpi -> common . error . jmp ) ) //<S2SV> { //<S2SV> cpi -> common . error . setjmp = 0 ; //<S2SV> return VPX_CODEC_CORRUPT_FRAME ; //<S2SV> } //<S2SV> cpi -> common . error . setjmp = 1 ; //<S2SV> # if HAVE_NEON //<S2SV> # if CONFIG_RUNTIME_CPU_DETECT //<S2SV> if ( cm -> cpu_caps & HAS_NEON ) //<S2SV> # endif //<S2SV> { //<S2SV> vp8_push_neon ( store_reg ) ; //<S2SV> } //<S2SV> # endif //<S2SV> vpx_usec_timer_start ( & cmptimer ) ; //<S2SV> cpi -> source = NULL ; //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( cpi -> oxcf . error_resilient_mode == 0 && //<S2SV> cpi -> oxcf . play_alternate && //<S2SV> cpi -> source_alt_ref_pending ) //<S2SV> { //<S2SV> if ( ( cpi -> source = vp8_lookahead_peek ( cpi -> lookahead , //<S2SV> cpi -> frames_till_gf_update_due , //<S2SV> PEEK_FORWARD ) ) ) //<S2SV> { //<S2SV> cpi -> alt_ref_source = cpi -> source ; //<S2SV> if ( cpi -> oxcf . arnr_max_frames > 0 ) //<S2SV> { //<S2SV> vp8_temporal_filter_prepare_c ( cpi , //<S2SV> cpi -> frames_till_gf_update_due ) ; //<S2SV> force_src_buffer = & cpi -> alt_ref_buffer ; //<S2SV> } //<S2SV> cpi -> frames_till_alt_ref_frame = cpi -> frames_till_gf_update_due ; //<S2SV> cm -> refresh_alt_ref_frame = 1 ; //<S2SV> cm -> refresh_golden_frame = 0 ; //<S2SV> cm -> refresh_last_frame = 0 ; //<S2SV> cm -> show_frame = 0 ; //<S2SV> cpi -> source_alt_ref_pending = 0 ; //<S2SV> cpi -> is_src_frame_alt_ref = 0 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! cpi -> source ) //<S2SV> { //<S2SV> if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) //<S2SV> { //<S2SV> if ( ( cpi -> last_source = vp8_lookahead_peek ( cpi -> lookahead , 1 , //<S2SV> PEEK_BACKWARD ) ) == NULL ) //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( ( cpi -> source = vp8_lookahead_pop ( cpi -> lookahead , flush ) ) ) //<S2SV> { //<S2SV> cm -> show_frame = 1 ; //<S2SV> cpi -> is_src_frame_alt_ref = cpi -> alt_ref_source //<S2SV> && ( cpi -> source == cpi -> alt_ref_source ) ; //<S2SV> if ( cpi -> is_src_frame_alt_ref ) //<S2SV> cpi -> alt_ref_source = NULL ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> source ) //<S2SV> { //<S2SV> cpi -> Source = force_src_buffer ? force_src_buffer : & cpi -> source -> img ; //<S2SV> cpi -> un_scaled_source = cpi -> Source ; //<S2SV> * time_stamp = cpi -> source -> ts_start ; //<S2SV> * time_end = cpi -> source -> ts_end ; //<S2SV> * frame_flags = cpi -> source -> flags ; //<S2SV> if ( cpi -> pass == 1 && cm -> current_video_frame > 0 ) //<S2SV> { //<S2SV> cpi -> last_frame_unscaled_source = & cpi -> last_source -> img ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> * size = 0 ; //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( flush && cpi -> pass == 1 && ! cpi -> twopass . first_pass_done ) //<S2SV> { //<S2SV> vp8_end_first_pass ( cpi ) ; //<S2SV> cpi -> twopass . first_pass_done = 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> # if HAVE_NEON //<S2SV> # if CONFIG_RUNTIME_CPU_DETECT //<S2SV> if ( cm -> cpu_caps & HAS_NEON ) //<S2SV> # endif //<S2SV> { //<S2SV> vp8_pop_neon ( store_reg ) ; //<S2SV> } //<S2SV> # endif //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( cpi -> source -> ts_start < cpi -> first_time_stamp_ever ) //<S2SV> { //<S2SV> cpi -> first_time_stamp_ever = cpi -> source -> ts_start ; //<S2SV> cpi -> last_end_time_stamp_seen = cpi -> source -> ts_start ; //<S2SV> } //<S2SV> if ( cm -> show_frame ) //<S2SV> { //<S2SV> int64_t this_duration ; //<S2SV> int step = 0 ; //<S2SV> if ( cpi -> source -> ts_start == cpi -> first_time_stamp_ever ) //<S2SV> { //<S2SV> this_duration = cpi -> source -> ts_end - cpi -> source -> ts_start ; //<S2SV> step = 1 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int64_t last_duration ; //<S2SV> this_duration = cpi -> source -> ts_end - cpi -> last_end_time_stamp_seen ; //<S2SV> last_duration = cpi -> last_end_time_stamp_seen //<S2SV> - cpi -> last_time_stamp_seen ; //<S2SV> if ( last_duration ) //<S2SV> step = ( int ) ( ( ( this_duration - last_duration ) * //<S2SV> 10 / last_duration ) ) ; //<S2SV> } //<S2SV> if ( this_duration ) //<S2SV> { //<S2SV> if ( step ) //<S2SV> cpi -> ref_framerate = 10000000.0 / this_duration ; //<S2SV> else //<S2SV> { //<S2SV> double avg_duration , interval ; //<S2SV> interval = ( double ) ( cpi -> source -> ts_end - //<S2SV> cpi -> first_time_stamp_ever ) ; //<S2SV> if ( interval > 10000000.0 ) //<S2SV> interval = 10000000 ; //<S2SV> avg_duration = 10000000.0 / cpi -> ref_framerate ; //<S2SV> avg_duration *= ( interval - avg_duration + this_duration ) ; //<S2SV> avg_duration /= interval ; //<S2SV> cpi -> ref_framerate = 10000000.0 / avg_duration ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> unsigned int i ; //<S2SV> assert ( cpi -> oxcf . number_of_layers <= VPX_TS_MAX_LAYERS ) ; //<S2SV> for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) //<S2SV> { //<S2SV> LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; //<S2SV> lc -> framerate = cpi -> ref_framerate / //<S2SV> cpi -> oxcf . rate_decimator [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> vp8_new_framerate ( cpi , cpi -> ref_framerate ) ; //<S2SV> } //<S2SV> cpi -> last_time_stamp_seen = cpi -> source -> ts_start ; //<S2SV> cpi -> last_end_time_stamp_seen = cpi -> source -> ts_end ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> int layer ; //<S2SV> update_layer_contexts ( cpi ) ; //<S2SV> layer = cpi -> oxcf . layer_id [ //<S2SV> cpi -> temporal_pattern_counter % cpi -> oxcf . periodicity ] ; //<S2SV> restore_layer_context ( cpi , layer ) ; //<S2SV> vp8_new_framerate ( cpi , cpi -> layer_context [ layer ] . framerate ) ; //<S2SV> } //<S2SV> if ( cpi -> compressor_speed == 2 ) //<S2SV> { //<S2SV> vpx_usec_timer_start ( & tsctimer ) ; //<S2SV> vpx_usec_timer_start ( & ticktimer ) ; //<S2SV> } //<S2SV> cpi -> lf_zeromv_pct = ( cpi -> zeromv_count * 100 ) / cm -> MBs ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> { //<S2SV> int i ; //<S2SV> const int num_part = ( 1 << cm -> multi_token_partition ) ; //<S2SV> const unsigned long dest_size = dest_end - dest ; //<S2SV> const int tok_part_buff_size = ( dest_size * 9 ) / ( 10 * num_part ) ; //<S2SV> unsigned char * dp = dest ; //<S2SV> cpi -> partition_d [ 0 ] = dp ; //<S2SV> dp += dest_size / 10 ; //<S2SV> cpi -> partition_d_end [ 0 ] = dp ; //<S2SV> for ( i = 0 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> cpi -> partition_d [ i + 1 ] = dp ; //<S2SV> dp += tok_part_buff_size ; //<S2SV> cpi -> partition_d_end [ i + 1 ] = dp ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> * size = 0 ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> cm -> frame_type = INTER_FRAME ; //<S2SV> cm -> frame_flags = * frame_flags ; //<S2SV> # if 0 //<S2SV> if ( cm -> refresh_alt_ref_frame ) //<S2SV> { //<S2SV> cm -> refresh_golden_frame = 0 ; //<S2SV> cm -> refresh_last_frame = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cm -> refresh_golden_frame = 0 ; //<S2SV> cm -> refresh_last_frame = 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> { //<S2SV> int i = 0 ; //<S2SV> for ( ; i < NUM_YV12_BUFFERS ; i ++ ) //<S2SV> { //<S2SV> if ( ! cm -> yv12_fb [ i ] . flags ) //<S2SV> { //<S2SV> cm -> new_fb_idx = i ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> assert ( i < NUM_YV12_BUFFERS ) ; //<S2SV> } //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( cpi -> pass == 1 ) //<S2SV> { //<S2SV> Pass1Encode ( cpi , size , dest , frame_flags ) ; //<S2SV> } //<S2SV> else if ( cpi -> pass == 2 ) //<S2SV> { //<S2SV> Pass2Encode ( cpi , size , dest , dest_end , frame_flags ) ; //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> encode_frame_to_data_rate ( cpi , size , dest , dest_end , frame_flags ) ; //<S2SV> if ( cpi -> compressor_speed == 2 ) //<S2SV> { //<S2SV> unsigned int duration , duration2 ; //<S2SV> vpx_usec_timer_mark ( & tsctimer ) ; //<S2SV> vpx_usec_timer_mark ( & ticktimer ) ; //<S2SV> duration = ( int ) ( vpx_usec_timer_elapsed ( & ticktimer ) ) ; //<S2SV> duration2 = ( unsigned int ) ( ( double ) duration / 2 ) ; //<S2SV> if ( cm -> frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> if ( cpi -> avg_encode_time == 0 ) //<S2SV> cpi -> avg_encode_time = duration ; //<S2SV> else //<S2SV> cpi -> avg_encode_time = ( 7 * cpi -> avg_encode_time + duration ) >> 3 ; //<S2SV> } //<S2SV> if ( duration2 ) //<S2SV> { //<S2SV> { //<S2SV> if ( cpi -> avg_pick_mode_time == 0 ) //<S2SV> cpi -> avg_pick_mode_time = duration2 ; //<S2SV> else //<S2SV> cpi -> avg_pick_mode_time = ( 7 * cpi -> avg_pick_mode_time + duration2 ) >> 3 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> refresh_entropy_probs == 0 ) //<S2SV> { //<S2SV> vpx_memcpy ( & cm -> fc , & cm -> lfc , sizeof ( cm -> fc ) ) ; //<S2SV> } //<S2SV> if ( cm -> refresh_alt_ref_frame ) //<S2SV> vpx_memcpy ( & cpi -> lfc_a , & cm -> fc , sizeof ( cm -> fc ) ) ; //<S2SV> if ( cm -> refresh_golden_frame ) //<S2SV> vpx_memcpy ( & cpi -> lfc_g , & cm -> fc , sizeof ( cm -> fc ) ) ; //<S2SV> if ( cm -> refresh_last_frame ) //<S2SV> vpx_memcpy ( & cpi -> lfc_n , & cm -> fc , sizeof ( cm -> fc ) ) ; //<S2SV> if ( * size > 0 ) //<S2SV> { //<S2SV> cpi -> droppable = ! frame_is_reference ( cpi ) ; //<S2SV> cm -> refresh_entropy_probs = 1 ; //<S2SV> cm -> refresh_alt_ref_frame = 0 ; //<S2SV> cm -> refresh_golden_frame = 0 ; //<S2SV> cm -> refresh_last_frame = 1 ; //<S2SV> cm -> frame_type = INTER_FRAME ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> save_layer_context ( cpi ) ; //<S2SV> vpx_usec_timer_mark ( & cmptimer ) ; //<S2SV> cpi -> time_compress_data += vpx_usec_timer_elapsed ( & cmptimer ) ; //<S2SV> if ( cpi -> b_calculate_psnr && cpi -> pass != 1 && cm -> show_frame ) //<S2SV> { //<S2SV> generate_psnr_packet ( cpi ) ; //<S2SV> } //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> if ( cpi -> pass != 1 ) //<S2SV> { //<S2SV> cpi -> bytes += * size ; //<S2SV> if ( cm -> show_frame ) //<S2SV> { //<S2SV> cpi -> common . show_frame_mi = cpi -> common . mi ; //<S2SV> cpi -> count ++ ; //<S2SV> if ( cpi -> b_calculate_psnr ) //<S2SV> { //<S2SV> uint64_t ye , ue , ve ; //<S2SV> double frame_psnr ; //<S2SV> YV12_BUFFER_CONFIG * orig = cpi -> Source ; //<S2SV> YV12_BUFFER_CONFIG * recon = cpi -> common . frame_to_show ; //<S2SV> int y_samples = orig -> y_height * orig -> y_width ; //<S2SV> int uv_samples = orig -> uv_height * orig -> uv_width ; //<S2SV> int t_samples = y_samples + 2 * uv_samples ; //<S2SV> double sq_error , sq_error2 ; //<S2SV> ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , //<S2SV> recon -> y_buffer , recon -> y_stride , orig -> y_width , orig -> y_height ) ; //<S2SV> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , //<S2SV> recon -> u_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; //<S2SV> ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , //<S2SV> recon -> v_buffer , recon -> uv_stride , orig -> uv_width , orig -> uv_height ) ; //<S2SV> sq_error = ( double ) ( ye + ue + ve ) ; //<S2SV> frame_psnr = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error ) ; //<S2SV> cpi -> total_y += vpx_sse_to_psnr ( y_samples , 255.0 , ( double ) ye ) ; //<S2SV> cpi -> total_u += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ue ) ; //<S2SV> cpi -> total_v += vpx_sse_to_psnr ( uv_samples , 255.0 , ( double ) ve ) ; //<S2SV> cpi -> total_sq_error += sq_error ; //<S2SV> cpi -> total += frame_psnr ; //<S2SV> # if CONFIG_POSTPROC //<S2SV> { //<S2SV> YV12_BUFFER_CONFIG * pp = & cm -> post_proc_buffer ; //<S2SV> double frame_psnr2 , frame_ssim2 = 0 ; //<S2SV> double weight = 0 ; //<S2SV> vp8_deblock ( cm , cm -> frame_to_show , & cm -> post_proc_buffer , cm -> filter_level * 10 / 6 , 1 , 0 ) ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> ye = calc_plane_error ( orig -> y_buffer , orig -> y_stride , //<S2SV> pp -> y_buffer , pp -> y_stride , orig -> y_width , orig -> y_height ) ; //<S2SV> ue = calc_plane_error ( orig -> u_buffer , orig -> uv_stride , //<S2SV> pp -> u_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; //<S2SV> ve = calc_plane_error ( orig -> v_buffer , orig -> uv_stride , //<S2SV> pp -> v_buffer , pp -> uv_stride , orig -> uv_width , orig -> uv_height ) ; //<S2SV> sq_error2 = ( double ) ( ye + ue + ve ) ; //<S2SV> frame_psnr2 = vpx_sse_to_psnr ( t_samples , 255.0 , sq_error2 ) ; //<S2SV> cpi -> totalp_y += vpx_sse_to_psnr ( y_samples , //<S2SV> 255.0 , ( double ) ye ) ; //<S2SV> cpi -> totalp_u += vpx_sse_to_psnr ( uv_samples , //<S2SV> 255.0 , ( double ) ue ) ; //<S2SV> cpi -> totalp_v += vpx_sse_to_psnr ( uv_samples , //<S2SV> 255.0 , ( double ) ve ) ; //<S2SV> cpi -> total_sq_error2 += sq_error2 ; //<S2SV> cpi -> totalp += frame_psnr2 ; //<S2SV> frame_ssim2 = vp8_calc_ssim ( cpi -> Source , //<S2SV> & cm -> post_proc_buffer , 1 , & weight ) ; //<S2SV> cpi -> summed_quality += frame_ssim2 * weight ; //<S2SV> cpi -> summed_weights += weight ; //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> unsigned int i ; //<S2SV> for ( i = cpi -> current_layer ; //<S2SV> i < cpi -> oxcf . number_of_layers ; i ++ ) //<S2SV> { //<S2SV> cpi -> frames_in_layer [ i ] ++ ; //<S2SV> cpi -> bytes_in_layer [ i ] += * size ; //<S2SV> cpi -> sum_psnr [ i ] += frame_psnr ; //<S2SV> cpi -> sum_psnr_p [ i ] += frame_psnr2 ; //<S2SV> cpi -> total_error2 [ i ] += sq_error ; //<S2SV> cpi -> total_error2_p [ i ] += sq_error2 ; //<S2SV> cpi -> sum_ssim [ i ] += frame_ssim2 * weight ; //<S2SV> cpi -> sum_weights [ i ] += weight ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> if ( cpi -> b_calculate_ssimg ) //<S2SV> { //<S2SV> double y , u , v , frame_all ; //<S2SV> frame_all = vp8_calc_ssimg ( cpi -> Source , cm -> frame_to_show , //<S2SV> & y , & u , & v ) ; //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> unsigned int i ; //<S2SV> for ( i = cpi -> current_layer ; //<S2SV> i < cpi -> oxcf . number_of_layers ; i ++ ) //<S2SV> { //<S2SV> if ( ! cpi -> b_calculate_psnr ) //<S2SV> cpi -> frames_in_layer [ i ] ++ ; //<S2SV> cpi -> total_ssimg_y_in_layer [ i ] += y ; //<S2SV> cpi -> total_ssimg_u_in_layer [ i ] += u ; //<S2SV> cpi -> total_ssimg_v_in_layer [ i ] += v ; //<S2SV> cpi -> total_ssimg_all_in_layer [ i ] += frame_all ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> total_ssimg_y += y ; //<S2SV> cpi -> total_ssimg_u += u ; //<S2SV> cpi -> total_ssimg_v += v ; //<S2SV> cpi -> total_ssimg_all += frame_all ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # if 0 //<S2SV> if ( cpi -> common . frame_type != 0 && cpi -> common . base_qindex == cpi -> oxcf . worst_allowed_q ) //<S2SV> { //<S2SV> skiptruecount += cpi -> skip_true_count ; //<S2SV> skipfalsecount += cpi -> skip_false_count ; //<S2SV> } //<S2SV> # endif //<S2SV> # if 0 //<S2SV> if ( cpi -> pass != 1 ) //<S2SV> { //<S2SV> FILE * f = fopen ( "skip.stt" , "a" ) ; //<S2SV> fprintf ( f , "frame:%4d<S2SV_blank>flags:%4x<S2SV_blank>Q:%4d<S2SV_blank>P:%4d<S2SV_blank>Size:%5d\\n" , cpi -> common . current_video_frame , * frame_flags , cpi -> common . base_qindex , cpi -> prob_skip_false , * size ) ; //<S2SV> if ( cpi -> is_src_frame_alt_ref == 1 ) //<S2SV> fprintf ( f , "skipcount:<S2SV_blank>%4d<S2SV_blank>framesize:<S2SV_blank>%d\\n" , cpi -> skip_true_count , * size ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # endif //<S2SV> # if HAVE_NEON //<S2SV> # if CONFIG_RUNTIME_CPU_DETECT //<S2SV> if ( cm -> cpu_caps & HAS_NEON ) //<S2SV> # endif //<S2SV> { //<S2SV> vp8_pop_neon ( store_reg ) ; //<S2SV> } //<S2SV> # endif //<S2SV> cpi -> common . error . setjmp = 0 ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 