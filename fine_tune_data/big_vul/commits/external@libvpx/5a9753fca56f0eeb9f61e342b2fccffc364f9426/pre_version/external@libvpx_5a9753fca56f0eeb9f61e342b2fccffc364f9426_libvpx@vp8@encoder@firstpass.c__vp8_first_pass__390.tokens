void vp8_first_pass ( VP8_COMP * cpi ) //<S2SV> { //<S2SV> int mb_row , mb_col ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> VP8_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> int recon_yoffset , recon_uvoffset ; //<S2SV> YV12_BUFFER_CONFIG * lst_yv12 = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; //<S2SV> YV12_BUFFER_CONFIG * new_yv12 = & cm -> yv12_fb [ cm -> new_fb_idx ] ; //<S2SV> YV12_BUFFER_CONFIG * gld_yv12 = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; //<S2SV> int recon_y_stride = lst_yv12 -> y_stride ; //<S2SV> int recon_uv_stride = lst_yv12 -> uv_stride ; //<S2SV> int64_t intra_error = 0 ; //<S2SV> int64_t coded_error = 0 ; //<S2SV> int sum_mvr = 0 , sum_mvc = 0 ; //<S2SV> int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; //<S2SV> int sum_mvrs = 0 , sum_mvcs = 0 ; //<S2SV> int mvcount = 0 ; //<S2SV> int intercount = 0 ; //<S2SV> int second_ref_count = 0 ; //<S2SV> int intrapenalty = 256 ; //<S2SV> int neutral_count = 0 ; //<S2SV> int new_mv_count = 0 ; //<S2SV> int sum_in_vectors = 0 ; //<S2SV> uint32_t lastmv_as_int = 0 ; //<S2SV> int_mv zero_ref_mv ; //<S2SV> zero_ref_mv . as_int = 0 ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> x -> src = * cpi -> Source ; //<S2SV> xd -> pre = * lst_yv12 ; //<S2SV> xd -> dst = * new_yv12 ; //<S2SV> x -> partition_info = x -> pi ; //<S2SV> xd -> mode_info_context = cm -> mi ; //<S2SV> if ( ! cm -> use_bilinear_mc_filter ) //<S2SV> { //<S2SV> xd -> subpixel_predict = vp8_sixtap_predict4x4 ; //<S2SV> xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; //<S2SV> xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; //<S2SV> xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> xd -> subpixel_predict = vp8_bilinear_predict4x4 ; //<S2SV> xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; //<S2SV> xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; //<S2SV> xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; //<S2SV> } //<S2SV> vp8_build_block_offsets ( x ) ; //<S2SV> vp8_setup_intra_recon ( new_yv12 ) ; //<S2SV> vp8cx_frame_init_quantizer ( cpi ) ; //<S2SV> { //<S2SV> int flag [ 2 ] = { 1 , 1 } ; //<S2SV> vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; //<S2SV> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; //<S2SV> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; //<S2SV> } //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) //<S2SV> { //<S2SV> int_mv best_ref_mv ; //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> xd -> up_available = ( mb_row != 0 ) ; //<S2SV> recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; //<S2SV> recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; //<S2SV> x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; //<S2SV> x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; //<S2SV> for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) //<S2SV> { //<S2SV> int this_error ; //<S2SV> int gf_motion_error = INT_MAX ; //<S2SV> int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; //<S2SV> xd -> dst . y_buffer = new_yv12 -> y_buffer + recon_yoffset ; //<S2SV> xd -> dst . u_buffer = new_yv12 -> u_buffer + recon_uvoffset ; //<S2SV> xd -> dst . v_buffer = new_yv12 -> v_buffer + recon_uvoffset ; //<S2SV> xd -> left_available = ( mb_col != 0 ) ; //<S2SV> vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; //<S2SV> this_error = vp8_encode_intra ( cpi , x , use_dc_pred ) ; //<S2SV> this_error += intrapenalty ; //<S2SV> intra_error += ( int64_t ) this_error ; //<S2SV> x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; //<S2SV> x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; //<S2SV> if ( cm -> current_video_frame > 0 ) //<S2SV> { //<S2SV> BLOCKD * d = & x -> e_mbd . block [ 0 ] ; //<S2SV> MV tmp_mv = { 0 , 0 } ; //<S2SV> int tmp_err ; //<S2SV> int motion_error = INT_MAX ; //<S2SV> int raw_motion_error = INT_MAX ; //<S2SV> zz_motion_search ( cpi , x , cpi -> last_frame_unscaled_source , //<S2SV> & raw_motion_error , lst_yv12 , & motion_error , //<S2SV> recon_yoffset ) ; //<S2SV> d -> bmi . mv . as_mv . row = 0 ; //<S2SV> d -> bmi . mv . as_mv . col = 0 ; //<S2SV> if ( raw_motion_error < cpi -> oxcf . encode_breakout ) //<S2SV> goto skip_motion_search ; //<S2SV> first_pass_motion_search ( cpi , x , & best_ref_mv , //<S2SV> & d -> bmi . mv . as_mv , lst_yv12 , //<S2SV> & motion_error , recon_yoffset ) ; //<S2SV> if ( best_ref_mv . as_int ) //<S2SV> { //<S2SV> tmp_err = INT_MAX ; //<S2SV> first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , //<S2SV> lst_yv12 , & tmp_err , recon_yoffset ) ; //<S2SV> if ( tmp_err < motion_error ) //<S2SV> { //<S2SV> motion_error = tmp_err ; //<S2SV> d -> bmi . mv . as_mv . row = tmp_mv . row ; //<S2SV> d -> bmi . mv . as_mv . col = tmp_mv . col ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> current_video_frame > 1 ) //<S2SV> { //<S2SV> first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , gld_yv12 , & gf_motion_error , recon_yoffset ) ; //<S2SV> if ( ( gf_motion_error < motion_error ) && ( gf_motion_error < this_error ) ) //<S2SV> { //<S2SV> second_ref_count ++ ; //<S2SV> } //<S2SV> xd -> pre . y_buffer = lst_yv12 -> y_buffer + recon_yoffset ; //<S2SV> xd -> pre . u_buffer = lst_yv12 -> u_buffer + recon_uvoffset ; //<S2SV> xd -> pre . v_buffer = lst_yv12 -> v_buffer + recon_uvoffset ; //<S2SV> } //<S2SV> skip_motion_search : //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> if ( motion_error <= this_error ) //<S2SV> { //<S2SV> if ( ( ( ( this_error - intrapenalty ) * 9 ) <= //<S2SV> ( motion_error * 10 ) ) && //<S2SV> ( this_error < ( 2 * intrapenalty ) ) ) //<S2SV> { //<S2SV> neutral_count ++ ; //<S2SV> } //<S2SV> d -> bmi . mv . as_mv . row *= 8 ; //<S2SV> d -> bmi . mv . as_mv . col *= 8 ; //<S2SV> this_error = motion_error ; //<S2SV> vp8_set_mbmode_and_mvs ( x , NEWMV , & d -> bmi . mv ) ; //<S2SV> vp8_encode_inter16x16y ( x ) ; //<S2SV> sum_mvr += d -> bmi . mv . as_mv . row ; //<S2SV> sum_mvr_abs += abs ( d -> bmi . mv . as_mv . row ) ; //<S2SV> sum_mvc += d -> bmi . mv . as_mv . col ; //<S2SV> sum_mvc_abs += abs ( d -> bmi . mv . as_mv . col ) ; //<S2SV> sum_mvrs += d -> bmi . mv . as_mv . row * d -> bmi . mv . as_mv . row ; //<S2SV> sum_mvcs += d -> bmi . mv . as_mv . col * d -> bmi . mv . as_mv . col ; //<S2SV> intercount ++ ; //<S2SV> best_ref_mv . as_int = d -> bmi . mv . as_int ; //<S2SV> if ( d -> bmi . mv . as_int ) //<S2SV> { //<S2SV> mvcount ++ ; //<S2SV> if ( d -> bmi . mv . as_int != lastmv_as_int ) //<S2SV> new_mv_count ++ ; //<S2SV> lastmv_as_int = d -> bmi . mv . as_int ; //<S2SV> if ( mb_row < cm -> mb_rows / 2 ) //<S2SV> { //<S2SV> if ( d -> bmi . mv . as_mv . row > 0 ) //<S2SV> sum_in_vectors -- ; //<S2SV> else if ( d -> bmi . mv . as_mv . row < 0 ) //<S2SV> sum_in_vectors ++ ; //<S2SV> } //<S2SV> else if ( mb_row > cm -> mb_rows / 2 ) //<S2SV> { //<S2SV> if ( d -> bmi . mv . as_mv . row > 0 ) //<S2SV> sum_in_vectors ++ ; //<S2SV> else if ( d -> bmi . mv . as_mv . row < 0 ) //<S2SV> sum_in_vectors -- ; //<S2SV> } //<S2SV> if ( mb_col < cm -> mb_cols / 2 ) //<S2SV> { //<S2SV> if ( d -> bmi . mv . as_mv . col > 0 ) //<S2SV> sum_in_vectors -- ; //<S2SV> else if ( d -> bmi . mv . as_mv . col < 0 ) //<S2SV> sum_in_vectors ++ ; //<S2SV> } //<S2SV> else if ( mb_col > cm -> mb_cols / 2 ) //<S2SV> { //<S2SV> if ( d -> bmi . mv . as_mv . col > 0 ) //<S2SV> sum_in_vectors ++ ; //<S2SV> else if ( d -> bmi . mv . as_mv . col < 0 ) //<S2SV> sum_in_vectors -- ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> coded_error += ( int64_t ) this_error ; //<S2SV> x -> src . y_buffer += 16 ; //<S2SV> x -> src . u_buffer += 8 ; //<S2SV> x -> src . v_buffer += 8 ; //<S2SV> recon_yoffset += 16 ; //<S2SV> recon_uvoffset += 8 ; //<S2SV> } //<S2SV> x -> src . y_buffer += 16 * x -> src . y_stride - 16 * cm -> mb_cols ; //<S2SV> x -> src . u_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; //<S2SV> x -> src . v_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; //<S2SV> vp8_extend_mb_row ( new_yv12 , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> } //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> { //<S2SV> double weight = 0.0 ; //<S2SV> FIRSTPASS_STATS fps ; //<S2SV> fps . frame = cm -> current_video_frame ; //<S2SV> fps . intra_error = ( double ) ( intra_error >> 8 ) ; //<S2SV> fps . coded_error = ( double ) ( coded_error >> 8 ) ; //<S2SV> weight = simple_weight ( cpi -> Source ) ; //<S2SV> if ( weight < 0.1 ) //<S2SV> weight = 0.1 ; //<S2SV> fps . ssim_weighted_pred_err = fps . coded_error * weight ; //<S2SV> fps . pcnt_inter = 0.0 ; //<S2SV> fps . pcnt_motion = 0.0 ; //<S2SV> fps . MVr = 0.0 ; //<S2SV> fps . mvr_abs = 0.0 ; //<S2SV> fps . MVc = 0.0 ; //<S2SV> fps . mvc_abs = 0.0 ; //<S2SV> fps . MVrv = 0.0 ; //<S2SV> fps . MVcv = 0.0 ; //<S2SV> fps . mv_in_out_count = 0.0 ; //<S2SV> fps . new_mv_count = 0.0 ; //<S2SV> fps . count = 1.0 ; //<S2SV> fps . pcnt_inter = 1.0 * ( double ) intercount / cm -> MBs ; //<S2SV> fps . pcnt_second_ref = 1.0 * ( double ) second_ref_count / cm -> MBs ; //<S2SV> fps . pcnt_neutral = 1.0 * ( double ) neutral_count / cm -> MBs ; //<S2SV> if ( mvcount > 0 ) //<S2SV> { //<S2SV> fps . MVr = ( double ) sum_mvr / ( double ) mvcount ; //<S2SV> fps . mvr_abs = ( double ) sum_mvr_abs / ( double ) mvcount ; //<S2SV> fps . MVc = ( double ) sum_mvc / ( double ) mvcount ; //<S2SV> fps . mvc_abs = ( double ) sum_mvc_abs / ( double ) mvcount ; //<S2SV> fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / ( double ) mvcount ) ) / ( double ) mvcount ; //<S2SV> fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / ( double ) mvcount ) ) / ( double ) mvcount ; //<S2SV> fps . mv_in_out_count = ( double ) sum_in_vectors / ( double ) ( mvcount * 2 ) ; //<S2SV> fps . new_mv_count = new_mv_count ; //<S2SV> fps . pcnt_motion = 1.0 * ( double ) mvcount / cpi -> common . MBs ; //<S2SV> } //<S2SV> fps . duration = ( double ) ( cpi -> source -> ts_end //<S2SV> - cpi -> source -> ts_start ) ; //<S2SV> memcpy ( & cpi -> twopass . this_frame_stats , //<S2SV> & fps , //<S2SV> sizeof ( FIRSTPASS_STATS ) ) ; //<S2SV> output_stats ( cpi , cpi -> output_pkt_list , & cpi -> twopass . this_frame_stats ) ; //<S2SV> accumulate_stats ( & cpi -> twopass . total_stats , & fps ) ; //<S2SV> } //<S2SV> if ( ( cm -> current_video_frame > 0 ) && //<S2SV> ( cpi -> twopass . this_frame_stats . pcnt_inter > 0.20 ) && //<S2SV> ( ( cpi -> twopass . this_frame_stats . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( cpi -> twopass . this_frame_stats . coded_error ) ) > //<S2SV> 2.0 ) ) //<S2SV> { //<S2SV> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; //<S2SV> } //<S2SV> vp8_swap_yv12_buffer ( lst_yv12 , new_yv12 ) ; //<S2SV> vp8_yv12_extend_frame_borders ( lst_yv12 ) ; //<S2SV> if ( cm -> current_video_frame == 0 ) //<S2SV> { //<S2SV> vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; //<S2SV> } //<S2SV> if ( 0 ) //<S2SV> { //<S2SV> char filename [ 512 ] ; //<S2SV> FILE * recon_file ; //<S2SV> sprintf ( filename , "enc%04d.yuv" , ( int ) cm -> current_video_frame ) ; //<S2SV> if ( cm -> current_video_frame == 0 ) //<S2SV> recon_file = fopen ( filename , "wb" ) ; //<S2SV> else //<S2SV> recon_file = fopen ( filename , "ab" ) ; //<S2SV> ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , //<S2SV> recon_file ) ; //<S2SV> fclose ( recon_file ) ; //<S2SV> } //<S2SV> cm -> current_video_frame ++ ; //<S2SV> } //<S2SV> 