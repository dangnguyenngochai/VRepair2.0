static void encode_frame ( struct stream_state * stream , //<S2SV> struct VpxEncoderConfig * global , //<S2SV> struct vpx_image * img , //<S2SV> unsigned int frames_in ) { //<S2SV> vpx_codec_pts_t frame_start , next_frame_start ; //<S2SV> struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; //<S2SV> struct vpx_usec_timer timer ; //<S2SV> frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in - 1 ) //<S2SV> * global -> framerate . den ) //<S2SV> / cfg -> g_timebase . num / global -> framerate . num ; //<S2SV> next_frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in ) //<S2SV> * global -> framerate . den ) //<S2SV> / cfg -> g_timebase . num / global -> framerate . num ; //<S2SV> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { //<S2SV> if ( ! stream -> img ) //<S2SV> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , //<S2SV> cfg -> g_w , cfg -> g_h , 16 ) ; //<S2SV> I420Scale ( img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] , //<S2SV> img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] , //<S2SV> img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] , //<S2SV> img -> d_w , img -> d_h , //<S2SV> stream -> img -> planes [ VPX_PLANE_Y ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_Y ] , //<S2SV> stream -> img -> planes [ VPX_PLANE_U ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_U ] , //<S2SV> stream -> img -> planes [ VPX_PLANE_V ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_V ] , //<S2SV> stream -> img -> d_w , stream -> img -> d_h , //<S2SV> kFilterBox ) ; //<S2SV> img = stream -> img ; //<S2SV> } //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> vpx_codec_encode ( & stream -> encoder , img , frame_start , //<S2SV> ( unsigned long ) ( next_frame_start - frame_start ) , //<S2SV> 0 , global -> deadline ) ; //<S2SV> vpx_usec_timer_mark ( & timer ) ; //<S2SV> stream -> cx_time += vpx_usec_timer_elapsed ( & timer ) ; //<S2SV> ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" , //<S2SV> stream -> index ) ; //<S2SV> } //<S2SV> 