void vp9_init_second_pass ( VP9_COMP * cpi ) { //<S2SV> SVC * const svc = & cpi -> svc ; //<S2SV> FIRSTPASS_STATS this_frame ; //<S2SV> const FIRSTPASS_STATS * start_pos ; //<S2SV> struct twopass_rc * twopass = & cpi -> twopass ; //<S2SV> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; //<S2SV> const int is_spatial_svc = ( svc -> number_spatial_layers > 1 ) && //<S2SV> ( svc -> number_temporal_layers == 1 ) ; //<S2SV> double frame_rate ; //<S2SV> if ( is_spatial_svc ) { //<S2SV> twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; //<S2SV> } //<S2SV> zero_stats ( & twopass -> total_stats ) ; //<S2SV> zero_stats ( & twopass -> total_left_stats ) ; //<S2SV> if ( ! twopass -> stats_in_end ) //<S2SV> return ; //<S2SV> twopass -> total_stats = * twopass -> stats_in_end ; //<S2SV> twopass -> total_left_stats = twopass -> total_stats ; //<S2SV> frame_rate = 10000000.0 * twopass -> total_stats . count / //<S2SV> twopass -> total_stats . duration ; //<S2SV> if ( is_spatial_svc ) { //<S2SV> vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ; //<S2SV> twopass -> bits_left = //<S2SV> ( int64_t ) ( twopass -> total_stats . duration * //<S2SV> svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / //<S2SV> 10000000.0 ) ; //<S2SV> } else { //<S2SV> vp9_new_framerate ( cpi , frame_rate ) ; //<S2SV> twopass -> bits_left = ( int64_t ) ( twopass -> total_stats . duration * //<S2SV> oxcf -> target_bandwidth / 10000000.0 ) ; //<S2SV> } //<S2SV> cpi -> output_framerate = oxcf -> framerate ; //<S2SV> if ( ! is_spatial_svc ) { //<S2SV> twopass -> kf_intra_err_min = KF_MB_INTRA_MIN * cpi -> common . MBs ; //<S2SV> twopass -> gf_intra_err_min = GF_MB_INTRA_MIN * cpi -> common . MBs ; //<S2SV> } //<S2SV> twopass -> sr_update_lag = 1 ; //<S2SV> { //<S2SV> double sum_iiratio = 0.0 ; //<S2SV> start_pos = twopass -> stats_in ; //<S2SV> while ( input_stats ( twopass , & this_frame ) != EOF ) { //<S2SV> const double iiratio = this_frame . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( this_frame . coded_error ) ; //<S2SV> sum_iiratio += fclamp ( iiratio , 1.0 , 20.0 ) ; //<S2SV> } //<S2SV> twopass -> avg_iiratio = sum_iiratio / //<S2SV> DOUBLE_DIVIDE_CHECK ( ( double ) twopass -> total_stats . count ) ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> } //<S2SV> { //<S2SV> double av_error = twopass -> total_stats . ssim_weighted_pred_err / //<S2SV> DOUBLE_DIVIDE_CHECK ( twopass -> total_stats . count ) ; //<S2SV> start_pos = twopass -> stats_in ; //<S2SV> twopass -> modified_error_total = 0.0 ; //<S2SV> twopass -> modified_error_min = //<S2SV> ( av_error * oxcf -> two_pass_vbrmin_section ) / 100 ; //<S2SV> twopass -> modified_error_max = //<S2SV> ( av_error * oxcf -> two_pass_vbrmax_section ) / 100 ; //<S2SV> while ( input_stats ( twopass , & this_frame ) != EOF ) { //<S2SV> twopass -> modified_error_total += //<S2SV> calculate_modified_err ( cpi , & this_frame ) ; //<S2SV> } //<S2SV> twopass -> modified_error_left = twopass -> modified_error_total ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> } //<S2SV> } //<S2SV> 