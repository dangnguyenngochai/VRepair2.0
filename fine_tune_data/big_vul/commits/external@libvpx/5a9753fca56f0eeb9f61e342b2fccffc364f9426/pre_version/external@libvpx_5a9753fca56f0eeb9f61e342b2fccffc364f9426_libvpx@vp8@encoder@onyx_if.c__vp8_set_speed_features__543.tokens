void vp8_set_speed_features ( VP8_COMP * cpi ) //<S2SV> { //<S2SV> SPEED_FEATURES * sf = & cpi -> sf ; //<S2SV> int Mode = cpi -> compressor_speed ; //<S2SV> int Speed = cpi -> Speed ; //<S2SV> int i ; //<S2SV> VP8_COMMON * cm = & cpi -> common ; //<S2SV> int last_improved_quant = sf -> improved_quant ; //<S2SV> int ref_frames ; //<S2SV> for ( i = 0 ; i < MAX_MODES ; i ++ ) //<S2SV> { //<S2SV> cpi -> mode_check_freq [ i ] = 0 ; //<S2SV> } //<S2SV> cpi -> mb . mbs_tested_so_far = 0 ; //<S2SV> sf -> RD = 1 ; //<S2SV> sf -> search_method = NSTEP ; //<S2SV> sf -> improved_quant = 1 ; //<S2SV> sf -> improved_dct = 1 ; //<S2SV> sf -> auto_filter = 1 ; //<S2SV> sf -> recode_loop = 1 ; //<S2SV> sf -> quarter_pixel_search = 1 ; //<S2SV> sf -> half_pixel_search = 1 ; //<S2SV> sf -> iterative_sub_pixel = 1 ; //<S2SV> sf -> optimize_coefficients = 1 ; //<S2SV> sf -> use_fastquant_for_pick = 0 ; //<S2SV> sf -> no_skip_block4x4_search = 1 ; //<S2SV> sf -> first_step = 0 ; //<S2SV> sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; //<S2SV> sf -> improved_mv_pred = 1 ; //<S2SV> for ( i = 0 ; i < MAX_MODES ; i ++ ) //<S2SV> sf -> thresh_mult [ i ] = 0 ; //<S2SV> ref_frames = 1 ; //<S2SV> if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) //<S2SV> ref_frames ++ ; //<S2SV> if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) //<S2SV> ref_frames ++ ; //<S2SV> if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) //<S2SV> ref_frames ++ ; //<S2SV> if ( Mode == 0 ) //<S2SV> Speed = 0 ; //<S2SV> else if ( Mode == 2 ) //<S2SV> Speed = RT ( Speed ) ; //<S2SV> else //<S2SV> { //<S2SV> if ( Speed > 5 ) //<S2SV> Speed = 5 ; //<S2SV> Speed = GOOD ( Speed ) ; //<S2SV> } //<S2SV> sf -> thresh_mult [ THR_ZERO1 ] = //<S2SV> sf -> thresh_mult [ THR_NEAREST1 ] = //<S2SV> sf -> thresh_mult [ THR_NEAR1 ] = //<S2SV> sf -> thresh_mult [ THR_DC ] = 0 ; //<S2SV> sf -> thresh_mult [ THR_ZERO2 ] = //<S2SV> sf -> thresh_mult [ THR_ZERO3 ] = //<S2SV> sf -> thresh_mult [ THR_NEAREST2 ] = //<S2SV> sf -> thresh_mult [ THR_NEAREST3 ] = //<S2SV> sf -> thresh_mult [ THR_NEAR2 ] = //<S2SV> sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; //<S2SV> sf -> thresh_mult [ THR_V_PRED ] = //<S2SV> sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; //<S2SV> sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; //<S2SV> sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; //<S2SV> sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; //<S2SV> sf -> thresh_mult [ THR_NEW2 ] = //<S2SV> sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; //<S2SV> sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; //<S2SV> sf -> thresh_mult [ THR_SPLIT2 ] = //<S2SV> sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ; //<S2SV> cpi -> mode_check_freq [ THR_ZERO1 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEAREST1 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEAR1 ] = //<S2SV> cpi -> mode_check_freq [ THR_TM ] = //<S2SV> cpi -> mode_check_freq [ THR_DC ] = 0 ; //<S2SV> cpi -> mode_check_freq [ THR_ZERO2 ] = //<S2SV> cpi -> mode_check_freq [ THR_ZERO3 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEAREST2 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_zn2 ) ; //<S2SV> cpi -> mode_check_freq [ THR_NEAR2 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_near2 ) ; //<S2SV> cpi -> mode_check_freq [ THR_V_PRED ] = //<S2SV> cpi -> mode_check_freq [ THR_H_PRED ] = //<S2SV> cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_vhbpred ) ; //<S2SV> cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_new1 ) ; //<S2SV> cpi -> mode_check_freq [ THR_NEW2 ] = //<S2SV> cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_new2 ) ; //<S2SV> cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_split1 ) ; //<S2SV> cpi -> mode_check_freq [ THR_SPLIT2 ] = //<S2SV> cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , //<S2SV> mode_check_freq_map_split2 ) ; //<S2SV> Speed = cpi -> Speed ; //<S2SV> switch ( Mode ) //<S2SV> { //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> case 0 : //<S2SV> sf -> first_step = 0 ; //<S2SV> sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; //<S2SV> break ; //<S2SV> case 1 : //<S2SV> case 3 : //<S2SV> if ( Speed > 0 ) //<S2SV> { //<S2SV> sf -> optimize_coefficients = 0 ; //<S2SV> sf -> use_fastquant_for_pick = 1 ; //<S2SV> sf -> no_skip_block4x4_search = 0 ; //<S2SV> sf -> first_step = 1 ; //<S2SV> } //<S2SV> if ( Speed > 2 ) //<S2SV> { //<S2SV> sf -> improved_quant = 0 ; //<S2SV> sf -> improved_dct = 0 ; //<S2SV> sf -> recode_loop = 2 ; //<S2SV> } //<S2SV> if ( Speed > 3 ) //<S2SV> { //<S2SV> sf -> auto_filter = 1 ; //<S2SV> sf -> recode_loop = 0 ; //<S2SV> sf -> RD = 0 ; //<S2SV> } //<S2SV> if ( Speed > 4 ) //<S2SV> { //<S2SV> sf -> auto_filter = 0 ; //<S2SV> } //<S2SV> break ; //<S2SV> # endif //<S2SV> case 2 : //<S2SV> sf -> optimize_coefficients = 0 ; //<S2SV> sf -> recode_loop = 0 ; //<S2SV> sf -> auto_filter = 1 ; //<S2SV> sf -> iterative_sub_pixel = 1 ; //<S2SV> sf -> search_method = NSTEP ; //<S2SV> if ( Speed > 0 ) //<S2SV> { //<S2SV> sf -> improved_quant = 0 ; //<S2SV> sf -> improved_dct = 0 ; //<S2SV> sf -> use_fastquant_for_pick = 1 ; //<S2SV> sf -> no_skip_block4x4_search = 0 ; //<S2SV> sf -> first_step = 1 ; //<S2SV> } //<S2SV> if ( Speed > 2 ) //<S2SV> sf -> auto_filter = 0 ; //<S2SV> if ( Speed > 3 ) //<S2SV> { //<S2SV> sf -> RD = 0 ; //<S2SV> sf -> auto_filter = 1 ; //<S2SV> } //<S2SV> if ( Speed > 4 ) //<S2SV> { //<S2SV> sf -> auto_filter = 0 ; //<S2SV> sf -> search_method = HEX ; //<S2SV> sf -> iterative_sub_pixel = 0 ; //<S2SV> } //<S2SV> if ( Speed > 6 ) //<S2SV> { //<S2SV> unsigned int sum = 0 ; //<S2SV> unsigned int total_mbs = cm -> MBs ; //<S2SV> int thresh ; //<S2SV> unsigned int total_skip ; //<S2SV> int min = 2000 ; //<S2SV> if ( cpi -> oxcf . encode_breakout > 2000 ) //<S2SV> min = cpi -> oxcf . encode_breakout ; //<S2SV> min >>= 7 ; //<S2SV> for ( i = 0 ; i < min ; i ++ ) //<S2SV> { //<S2SV> sum += cpi -> mb . error_bins [ i ] ; //<S2SV> } //<S2SV> total_skip = sum ; //<S2SV> sum = 0 ; //<S2SV> for ( ; i < 1024 ; i ++ ) //<S2SV> { //<S2SV> sum += cpi -> mb . error_bins [ i ] ; //<S2SV> if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) //<S2SV> break ; //<S2SV> } //<S2SV> i -- ; //<S2SV> thresh = ( i << 7 ) ; //<S2SV> if ( thresh < 2000 ) //<S2SV> thresh = 2000 ; //<S2SV> if ( ref_frames > 1 ) //<S2SV> { //<S2SV> sf -> thresh_mult [ THR_NEW1 ] = thresh ; //<S2SV> sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; //<S2SV> sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; //<S2SV> } //<S2SV> if ( ref_frames > 2 ) //<S2SV> { //<S2SV> sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; //<S2SV> sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; //<S2SV> sf -> thresh_mult [ THR_NEAR2 ] = thresh ; //<S2SV> } //<S2SV> if ( ref_frames > 3 ) //<S2SV> { //<S2SV> sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; //<S2SV> sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; //<S2SV> sf -> thresh_mult [ THR_NEAR3 ] = thresh ; //<S2SV> } //<S2SV> sf -> improved_mv_pred = 0 ; //<S2SV> } //<S2SV> if ( Speed > 8 ) //<S2SV> sf -> quarter_pixel_search = 0 ; //<S2SV> if ( cm -> version == 0 ) //<S2SV> { //<S2SV> cm -> filter_type = NORMAL_LOOPFILTER ; //<S2SV> if ( Speed >= 14 ) //<S2SV> cm -> filter_type = SIMPLE_LOOPFILTER ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cm -> filter_type = SIMPLE_LOOPFILTER ; //<S2SV> } //<S2SV> if ( Speed >= 15 ) //<S2SV> sf -> half_pixel_search = 0 ; //<S2SV> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; //<S2SV> } ; //<S2SV> if ( cpi -> pass == 1 ) //<S2SV> { //<S2SV> sf -> improved_quant = 0 ; //<S2SV> sf -> optimize_coefficients = 0 ; //<S2SV> sf -> improved_dct = 0 ; //<S2SV> } //<S2SV> if ( cpi -> sf . search_method == NSTEP ) //<S2SV> { //<S2SV> vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; //<S2SV> } //<S2SV> else if ( cpi -> sf . search_method == DIAMOND ) //<S2SV> { //<S2SV> vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . improved_dct ) //<S2SV> { //<S2SV> cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; //<S2SV> cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; //<S2SV> cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; //<S2SV> } //<S2SV> cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; //<S2SV> if ( cpi -> sf . improved_quant ) //<S2SV> { //<S2SV> cpi -> mb . quantize_b = vp8_regular_quantize_b ; //<S2SV> cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> mb . quantize_b = vp8_fast_quantize_b ; //<S2SV> cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; //<S2SV> } //<S2SV> if ( cpi -> sf . improved_quant != last_improved_quant ) //<S2SV> vp8cx_init_quantizer ( cpi ) ; //<S2SV> if ( cpi -> sf . iterative_sub_pixel == 1 ) //<S2SV> { //<S2SV> cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; //<S2SV> } //<S2SV> else if ( cpi -> sf . quarter_pixel_search ) //<S2SV> { //<S2SV> cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; //<S2SV> } //<S2SV> else if ( cpi -> sf . half_pixel_search ) //<S2SV> { //<S2SV> cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; //<S2SV> } //<S2SV> if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) //<S2SV> cpi -> mb . optimize = 1 ; //<S2SV> else //<S2SV> cpi -> mb . optimize = 0 ; //<S2SV> if ( cpi -> common . full_pixel ) //<S2SV> cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; //<S2SV> # ifdef SPEEDSTATS //<S2SV> frames_at_speed [ cpi -> Speed ] ++ ; //<S2SV> # endif //<S2SV> } //<S2SV> 