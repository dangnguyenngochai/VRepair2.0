static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) //<S2SV> { //<S2SV> FIRSTPASS_STATS next_frame ; //<S2SV> FIRSTPASS_STATS * start_pos ; //<S2SV> int i ; //<S2SV> double r ; //<S2SV> double boost_score = 0.0 ; //<S2SV> double old_boost_score = 0.0 ; //<S2SV> double gf_group_err = 0.0 ; //<S2SV> double gf_first_frame_err = 0.0 ; //<S2SV> double mod_frame_err = 0.0 ; //<S2SV> double mv_ratio_accumulator = 0.0 ; //<S2SV> double decay_accumulator = 1.0 ; //<S2SV> double loop_decay_rate = 1.00 ; //<S2SV> double this_frame_mv_in_out = 0.0 ; //<S2SV> double mv_in_out_accumulator = 0.0 ; //<S2SV> double abs_mv_in_out_accumulator = 0.0 ; //<S2SV> double mod_err_per_mb_accumulator = 0.0 ; //<S2SV> int max_bits = frame_max_bits ( cpi ) ; //<S2SV> unsigned int allow_alt_ref = //<S2SV> cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; //<S2SV> int alt_boost = 0 ; //<S2SV> int f_boost = 0 ; //<S2SV> int b_boost = 0 ; //<S2SV> int flash_detected ; //<S2SV> cpi -> twopass . gf_group_bits = 0 ; //<S2SV> cpi -> twopass . gf_decay_rate = 0 ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> start_pos = cpi -> twopass . stats_in ; //<S2SV> memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_first_frame_err = mod_frame_err ; //<S2SV> if ( cpi -> common . frame_type == KEY_FRAME ) //<S2SV> gf_group_err -= gf_first_frame_err ; //<S2SV> i = 0 ; //<S2SV> while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || //<S2SV> ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && //<S2SV> ( i < cpi -> twopass . frames_to_key ) ) //<S2SV> { //<S2SV> i ++ ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_group_err += mod_frame_err ; //<S2SV> mod_err_per_mb_accumulator += //<S2SV> mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; //<S2SV> if ( EOF == input_stats ( cpi , & next_frame ) ) //<S2SV> break ; //<S2SV> flash_detected = detect_flash ( cpi , 0 ) ; //<S2SV> accumulate_frame_motion_stats ( cpi , & next_frame , //<S2SV> & this_frame_mv_in_out , & mv_in_out_accumulator , //<S2SV> & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; //<S2SV> r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; //<S2SV> if ( ! flash_detected ) //<S2SV> { //<S2SV> loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; //<S2SV> decay_accumulator = decay_accumulator * loop_decay_rate ; //<S2SV> decay_accumulator = //<S2SV> decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; //<S2SV> } //<S2SV> boost_score += ( decay_accumulator * r ) ; //<S2SV> if ( detect_transition_to_still ( cpi , i , 5 , //<S2SV> loop_decay_rate , //<S2SV> decay_accumulator ) ) //<S2SV> { //<S2SV> allow_alt_ref = 0 ; //<S2SV> boost_score = old_boost_score ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( //<S2SV> ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || //<S2SV> ( //<S2SV> ( i > MIN_GF_INTERVAL ) && //<S2SV> ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && //<S2SV> ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && //<S2SV> ( ! flash_detected ) && //<S2SV> ( ( mv_ratio_accumulator > 100.0 ) || //<S2SV> ( abs_mv_in_out_accumulator > 3.0 ) || //<S2SV> ( mv_in_out_accumulator < - 2.0 ) || //<S2SV> ( ( boost_score - old_boost_score ) < 2.0 ) ) //<S2SV> ) ) //<S2SV> { //<S2SV> boost_score = old_boost_score ; //<S2SV> break ; //<S2SV> } //<S2SV> memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; //<S2SV> old_boost_score = boost_score ; //<S2SV> } //<S2SV> cpi -> twopass . gf_decay_rate = //<S2SV> ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> double max_boost ; //<S2SV> if ( cpi -> drop_frames_allowed ) //<S2SV> { //<S2SV> int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * //<S2SV> ( cpi -> oxcf . optimal_buffer_level / 100 ) ; //<S2SV> if ( cpi -> buffer_level > df_buffer_level ) //<S2SV> max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; //<S2SV> else //<S2SV> max_boost = 0.0 ; //<S2SV> } //<S2SV> else if ( cpi -> buffer_level > 0 ) //<S2SV> { //<S2SV> max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> max_boost = 0.0 ; //<S2SV> } //<S2SV> if ( boost_score > max_boost ) //<S2SV> boost_score = max_boost ; //<S2SV> } //<S2SV> if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) //<S2SV> { //<S2SV> while ( i < cpi -> twopass . frames_to_key ) //<S2SV> { //<S2SV> i ++ ; //<S2SV> if ( EOF == input_stats ( cpi , this_frame ) ) //<S2SV> break ; //<S2SV> if ( i < cpi -> twopass . frames_to_key ) //<S2SV> { //<S2SV> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> gf_group_err += mod_frame_err ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; //<S2SV> # if NEW_BOOST //<S2SV> alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; //<S2SV> # endif //<S2SV> if ( allow_alt_ref && //<S2SV> ( i >= MIN_GF_INTERVAL ) && //<S2SV> ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && //<S2SV> # if NEW_BOOST //<S2SV> ( ( next_frame . pcnt_inter > 0.75 ) || //<S2SV> ( next_frame . pcnt_second_ref > 0.5 ) ) && //<S2SV> ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || //<S2SV> ( mv_in_out_accumulator > - 2.0 ) ) && //<S2SV> ( b_boost > 100 ) && //<S2SV> ( f_boost > 100 ) ) //<S2SV> # else //<S2SV> ( next_frame . pcnt_inter > 0.75 ) && //<S2SV> ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || //<S2SV> ( mv_in_out_accumulator > - 2.0 ) ) && //<S2SV> ( cpi -> gfu_boost > 100 ) && //<S2SV> ( cpi -> twopass . gf_decay_rate <= //<S2SV> ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) //<S2SV> # endif //<S2SV> { //<S2SV> int Boost ; //<S2SV> int allocation_chunks ; //<S2SV> int Q = ( cpi -> oxcf . fixed_q < 0 ) //<S2SV> ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; //<S2SV> int tmp_q ; //<S2SV> int arf_frame_bits = 0 ; //<S2SV> int group_bits ; //<S2SV> # if NEW_BOOST //<S2SV> cpi -> gfu_boost = alt_boost ; //<S2SV> # endif //<S2SV> if ( ( cpi -> twopass . kf_group_bits > 0 ) && //<S2SV> ( cpi -> twopass . kf_group_error_left > 0 ) ) //<S2SV> { //<S2SV> group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * //<S2SV> ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; //<S2SV> } //<S2SV> else //<S2SV> group_bits = 0 ; //<S2SV> # if NEW_BOOST //<S2SV> Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; //<S2SV> # else //<S2SV> Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; //<S2SV> # endif //<S2SV> Boost += ( i * 50 ) ; //<S2SV> if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) //<S2SV> Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; //<S2SV> else if ( Boost < 125 ) //<S2SV> Boost = 125 ; //<S2SV> allocation_chunks = ( i * 100 ) + Boost ; //<S2SV> while ( Boost > 1000 ) //<S2SV> { //<S2SV> Boost /= 2 ; //<S2SV> allocation_chunks /= 2 ; //<S2SV> } //<S2SV> arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / //<S2SV> ( double ) allocation_chunks ) ) ; //<S2SV> tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; //<S2SV> if ( tmp_q < cpi -> worst_quality ) //<S2SV> { //<S2SV> int half_gf_int ; //<S2SV> int frames_after_arf ; //<S2SV> int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; //<S2SV> int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; //<S2SV> cpi -> source_alt_ref_pending = 1 ; //<S2SV> cpi -> baseline_gf_interval = i ; //<S2SV> half_gf_int = cpi -> baseline_gf_interval >> 1 ; //<S2SV> frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - //<S2SV> this_frame -> frame - 1 ) ; //<S2SV> switch ( cpi -> oxcf . arnr_type ) //<S2SV> { //<S2SV> case 1 : //<S2SV> frames_fwd = 0 ; //<S2SV> if ( frames_bwd > half_gf_int ) //<S2SV> frames_bwd = half_gf_int ; //<S2SV> break ; //<S2SV> case 2 : //<S2SV> if ( frames_fwd > half_gf_int ) //<S2SV> frames_fwd = half_gf_int ; //<S2SV> if ( frames_fwd > frames_after_arf ) //<S2SV> frames_fwd = frames_after_arf ; //<S2SV> frames_bwd = 0 ; //<S2SV> break ; //<S2SV> case 3 : //<S2SV> default : //<S2SV> frames_fwd >>= 1 ; //<S2SV> if ( frames_fwd > frames_after_arf ) //<S2SV> frames_fwd = frames_after_arf ; //<S2SV> if ( frames_fwd > half_gf_int ) //<S2SV> frames_fwd = half_gf_int ; //<S2SV> frames_bwd = frames_fwd ; //<S2SV> if ( frames_bwd < half_gf_int ) //<S2SV> frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; //<S2SV> break ; //<S2SV> } //<S2SV> cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> source_alt_ref_pending = 0 ; //<S2SV> cpi -> baseline_gf_interval = i ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> cpi -> source_alt_ref_pending = 0 ; //<S2SV> cpi -> baseline_gf_interval = i ; //<S2SV> } //<S2SV> if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - //<S2SV> cpi -> common . current_video_frame ) ) //<S2SV> { //<S2SV> cpi -> twopass . kf_group_bits = //<S2SV> ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; //<S2SV> } //<S2SV> if ( ( cpi -> twopass . kf_group_bits > 0 ) && //<S2SV> ( cpi -> twopass . kf_group_error_left > 0 ) ) //<S2SV> { //<S2SV> cpi -> twopass . gf_group_bits = //<S2SV> ( int64_t ) ( cpi -> twopass . kf_group_bits * //<S2SV> ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> twopass . gf_group_bits = 0 ; //<S2SV> cpi -> twopass . gf_group_bits = //<S2SV> ( cpi -> twopass . gf_group_bits < 0 ) //<S2SV> ? 0 //<S2SV> : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) //<S2SV> ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; //<S2SV> if ( cpi -> twopass . gf_group_bits > //<S2SV> ( int64_t ) max_bits * cpi -> baseline_gf_interval ) //<S2SV> cpi -> twopass . gf_group_bits = //<S2SV> ( int64_t ) max_bits * cpi -> baseline_gf_interval ; //<S2SV> reset_fpf_position ( cpi , start_pos ) ; //<S2SV> cpi -> twopass . modified_error_used += gf_group_err ; //<S2SV> for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { //<S2SV> int Boost ; //<S2SV> int allocation_chunks ; //<S2SV> int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; //<S2SV> int gf_bits ; //<S2SV> if ( cpi -> source_alt_ref_pending && i == 0 ) //<S2SV> { //<S2SV> # if NEW_BOOST //<S2SV> Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; //<S2SV> # else //<S2SV> Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; //<S2SV> # endif //<S2SV> Boost += ( cpi -> baseline_gf_interval * 50 ) ; //<S2SV> if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) //<S2SV> Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; //<S2SV> else if ( Boost < 125 ) //<S2SV> Boost = 125 ; //<S2SV> allocation_chunks = //<S2SV> ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; //<S2SV> if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) //<S2SV> Boost = ( cpi -> baseline_gf_interval * 150 ) ; //<S2SV> else if ( Boost < 125 ) //<S2SV> Boost = 125 ; //<S2SV> allocation_chunks = //<S2SV> ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; //<S2SV> } //<S2SV> while ( Boost > 1000 ) //<S2SV> { //<S2SV> Boost /= 2 ; //<S2SV> allocation_chunks /= 2 ; //<S2SV> } //<S2SV> gf_bits = ( int ) ( ( double ) Boost * //<S2SV> ( cpi -> twopass . gf_group_bits / //<S2SV> ( double ) allocation_chunks ) ) ; //<S2SV> if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) //<S2SV> { //<S2SV> double alt_gf_grp_bits ; //<S2SV> int alt_gf_bits ; //<S2SV> alt_gf_grp_bits = //<S2SV> ( double ) cpi -> twopass . kf_group_bits * //<S2SV> ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / //<S2SV> DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; //<S2SV> alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / //<S2SV> ( double ) allocation_chunks ) ) ; //<S2SV> if ( gf_bits > alt_gf_bits ) //<S2SV> { //<S2SV> gf_bits = alt_gf_bits ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int alt_gf_bits = //<S2SV> ( int ) ( ( double ) cpi -> twopass . kf_group_bits * //<S2SV> mod_frame_err / //<S2SV> DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; //<S2SV> if ( alt_gf_bits > gf_bits ) //<S2SV> { //<S2SV> gf_bits = alt_gf_bits ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) //<S2SV> cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; //<S2SV> } //<S2SV> if ( gf_bits < 0 ) //<S2SV> gf_bits = 0 ; //<S2SV> gf_bits += cpi -> min_frame_bandwidth ; //<S2SV> if ( i == 0 ) //<S2SV> { //<S2SV> cpi -> twopass . gf_bits = gf_bits ; //<S2SV> } //<S2SV> if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) //<S2SV> { //<S2SV> cpi -> per_frame_bandwidth = gf_bits ; //<S2SV> } //<S2SV> } //<S2SV> { //<S2SV> cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; //<S2SV> cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; //<S2SV> if ( cpi -> twopass . kf_group_bits < 0 ) //<S2SV> cpi -> twopass . kf_group_bits = 0 ; //<S2SV> if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) //<S2SV> cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - //<S2SV> gf_first_frame_err ) ; //<S2SV> else //<S2SV> cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; //<S2SV> cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; //<S2SV> if ( cpi -> twopass . gf_group_bits < 0 ) //<S2SV> cpi -> twopass . gf_group_bits = 0 ; //<S2SV> if ( cpi -> baseline_gf_interval >= 3 ) //<S2SV> { //<S2SV> # if NEW_BOOST //<S2SV> int boost = ( cpi -> source_alt_ref_pending ) //<S2SV> ? b_boost : cpi -> gfu_boost ; //<S2SV> # else //<S2SV> int boost = cpi -> gfu_boost ; //<S2SV> # endif //<S2SV> if ( boost >= 150 ) //<S2SV> { //<S2SV> int pct_extra ; //<S2SV> pct_extra = ( boost - 100 ) / 50 ; //<S2SV> pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; //<S2SV> cpi -> twopass . alt_extra_bits = //<S2SV> ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; //<S2SV> cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; //<S2SV> cpi -> twopass . alt_extra_bits /= //<S2SV> ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> twopass . alt_extra_bits = 0 ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> twopass . alt_extra_bits = 0 ; //<S2SV> } //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> FIRSTPASS_STATS sectionstats ; //<S2SV> double Ratio ; //<S2SV> zero_stats ( & sectionstats ) ; //<S2SV> reset_fpf_position ( cpi , start_pos ) ; //<S2SV> for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) //<S2SV> { //<S2SV> input_stats ( cpi , & next_frame ) ; //<S2SV> accumulate_stats ( & sectionstats , & next_frame ) ; //<S2SV> } //<S2SV> avg_stats ( & sectionstats ) ; //<S2SV> cpi -> twopass . section_intra_rating = ( unsigned int ) //<S2SV> ( sectionstats . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; //<S2SV> Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; //<S2SV> cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; //<S2SV> if ( cpi -> twopass . section_max_qfactor < 0.80 ) //<S2SV> cpi -> twopass . section_max_qfactor = 0.80 ; //<S2SV> reset_fpf_position ( cpi , start_pos ) ; //<S2SV> } //<S2SV> } //<S2SV> 