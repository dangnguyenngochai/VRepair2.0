void vp8_remove_compressor ( VP8_COMP * * ptr ) //<S2SV> { //<S2SV> VP8_COMP * cpi = * ptr ; //<S2SV> if ( ! cpi ) //<S2SV> return ; //<S2SV> if ( cpi && ( cpi -> common . current_video_frame > 0 ) ) //<S2SV> { //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( cpi -> pass == 2 ) //<S2SV> { //<S2SV> vp8_end_second_pass ( cpi ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> print_context_counters ( ) ; //<S2SV> print_tree_update_probs ( ) ; //<S2SV> print_mode_context ( ) ; //<S2SV> # endif //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> if ( cpi -> pass != 1 ) //<S2SV> { //<S2SV> FILE * f = fopen ( "opsnr.stt" , "a" ) ; //<S2SV> double time_encoded = ( cpi -> last_end_time_stamp_seen //<S2SV> - cpi -> first_time_stamp_ever ) / 10000000.000 ; //<S2SV> double total_encode_time = ( cpi -> time_receive_data + //<S2SV> cpi -> time_compress_data ) / 1000.000 ; //<S2SV> double dr = ( double ) cpi -> bytes * 8.0 / 1000.0 / time_encoded ; //<S2SV> if ( cpi -> b_calculate_psnr ) //<S2SV> { //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> int i ; //<S2SV> fprintf ( f , "Layer\\tBitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t" //<S2SV> "GLPsnrP\\tVPXSSIM\\t\\n" ) ; //<S2SV> for ( i = 0 ; i < ( int ) cpi -> oxcf . number_of_layers ; i ++ ) //<S2SV> { //<S2SV> double dr = ( double ) cpi -> bytes_in_layer [ i ] * //<S2SV> 8.0 / 1000.0 / time_encoded ; //<S2SV> double samples = 3.0 / 2 * cpi -> frames_in_layer [ i ] * //<S2SV> cpi -> common . Width * cpi -> common . Height ; //<S2SV> double total_psnr = //<S2SV> vpx_sse_to_psnr ( samples , 255.0 , //<S2SV> cpi -> total_error2 [ i ] ) ; //<S2SV> double total_psnr2 = //<S2SV> vpx_sse_to_psnr ( samples , 255.0 , //<S2SV> cpi -> total_error2_p [ i ] ) ; //<S2SV> double total_ssim = 100 * pow ( cpi -> sum_ssim [ i ] / //<S2SV> cpi -> sum_weights [ i ] , 8.0 ) ; //<S2SV> fprintf ( f , "%5d\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t" //<S2SV> "%7.3f\\t%7.3f\\n" , //<S2SV> i , dr , //<S2SV> cpi -> sum_psnr [ i ] / cpi -> frames_in_layer [ i ] , //<S2SV> total_psnr , //<S2SV> cpi -> sum_psnr_p [ i ] / cpi -> frames_in_layer [ i ] , //<S2SV> total_psnr2 , total_ssim ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> double samples = 3.0 / 2 * cpi -> count * //<S2SV> cpi -> common . Width * cpi -> common . Height ; //<S2SV> double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , //<S2SV> cpi -> total_sq_error ) ; //<S2SV> double total_psnr2 = vpx_sse_to_psnr ( samples , 255.0 , //<S2SV> cpi -> total_sq_error2 ) ; //<S2SV> double total_ssim = 100 * pow ( cpi -> summed_quality / //<S2SV> cpi -> summed_weights , 8.0 ) ; //<S2SV> fprintf ( f , "Bitrate\\tAVGPsnr\\tGLBPsnr\\tAVPsnrP\\t" //<S2SV> "GLPsnrP\\tVPXSSIM\\t<S2SV_blank><S2SV_blank>Time(us)\\n" ) ; //<S2SV> fprintf ( f , "%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t%7.3f\\t" //<S2SV> "%7.3f\\t%8.0f\\n" , //<S2SV> dr , cpi -> total / cpi -> count , total_psnr , //<S2SV> cpi -> totalp / cpi -> count , total_psnr2 , //<S2SV> total_ssim , total_encode_time ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> b_calculate_ssimg ) //<S2SV> { //<S2SV> if ( cpi -> oxcf . number_of_layers > 1 ) //<S2SV> { //<S2SV> int i ; //<S2SV> fprintf ( f , "Layer\\tBitRate\\tSSIM_Y\\tSSIM_U\\tSSIM_V\\tSSIM_A\\t" //<S2SV> "Time(us)\\n" ) ; //<S2SV> for ( i = 0 ; i < ( int ) cpi -> oxcf . number_of_layers ; i ++ ) //<S2SV> { //<S2SV> double dr = ( double ) cpi -> bytes_in_layer [ i ] * //<S2SV> 8.0 / 1000.0 / time_encoded ; //<S2SV> fprintf ( f , "%5d\\t%7.3f\\t%6.4f\\t" //<S2SV> "%6.4f\\t%6.4f\\t%6.4f\\t%8.0f\\n" , //<S2SV> i , dr , //<S2SV> cpi -> total_ssimg_y_in_layer [ i ] / //<S2SV> cpi -> frames_in_layer [ i ] , //<S2SV> cpi -> total_ssimg_u_in_layer [ i ] / //<S2SV> cpi -> frames_in_layer [ i ] , //<S2SV> cpi -> total_ssimg_v_in_layer [ i ] / //<S2SV> cpi -> frames_in_layer [ i ] , //<S2SV> cpi -> total_ssimg_all_in_layer [ i ] / //<S2SV> cpi -> frames_in_layer [ i ] , //<S2SV> total_encode_time ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> fprintf ( f , "BitRate\\tSSIM_Y\\tSSIM_U\\tSSIM_V\\tSSIM_A\\t" //<S2SV> "Time(us)\\n" ) ; //<S2SV> fprintf ( f , "%7.3f\\t%6.4f\\t%6.4f\\t%6.4f\\t%6.4f\\t%8.0f\\n" , dr , //<S2SV> cpi -> total_ssimg_y / cpi -> count , //<S2SV> cpi -> total_ssimg_u / cpi -> count , //<S2SV> cpi -> total_ssimg_v / cpi -> count , //<S2SV> cpi -> total_ssimg_all / cpi -> count , total_encode_time ) ; //<S2SV> } //<S2SV> } //<S2SV> fclose ( f ) ; //<S2SV> # if 0 //<S2SV> f = fopen ( "qskip.stt" , "a" ) ; //<S2SV> fprintf ( f , "minq:%d<S2SV_blank>-maxq:%d<S2SV_blank>skiptrue:skipfalse<S2SV_blank>=<S2SV_blank>%d:%d\\n" , cpi -> oxcf . best_allowed_q , cpi -> oxcf . worst_allowed_q , skiptruecount , skipfalsecount ) ; //<S2SV> fclose ( f ) ; //<S2SV> # endif //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef SPEEDSTATS //<S2SV> if ( cpi -> compressor_speed == 2 ) //<S2SV> { //<S2SV> int i ; //<S2SV> FILE * f = fopen ( "cxspeed.stt" , "a" ) ; //<S2SV> cnt_pm /= cpi -> common . MBs ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> fprintf ( f , "%5d" , frames_at_speed [ i ] ) ; //<S2SV> fprintf ( f , "\\n" ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef MODE_STATS //<S2SV> { //<S2SV> extern int count_mb_seg [ 4 ] ; //<S2SV> FILE * f = fopen ( "modes.stt" , "a" ) ; //<S2SV> double dr = ( double ) cpi -> framerate * ( double ) bytes * ( double ) 8 / ( double ) count / ( double ) 1000 ; //<S2SV> fprintf ( f , "intra_mode<S2SV_blank>in<S2SV_blank>Intra<S2SV_blank>Frames:\\n" ) ; //<S2SV> fprintf ( f , "Y:<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , y_modes [ 0 ] , y_modes [ 1 ] , y_modes [ 2 ] , y_modes [ 3 ] , y_modes [ 4 ] ) ; //<S2SV> fprintf ( f , "UV:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , uv_modes [ 0 ] , uv_modes [ 1 ] , uv_modes [ 2 ] , uv_modes [ 3 ] ) ; //<S2SV> fprintf ( f , "B:<S2SV_blank>" ) ; //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 10 ; i ++ ) //<S2SV> fprintf ( f , "%8d,<S2SV_blank>" , b_modes [ i ] ) ; //<S2SV> fprintf ( f , "\\n" ) ; //<S2SV> } //<S2SV> fprintf ( f , "Modes<S2SV_blank>in<S2SV_blank>Inter<S2SV_blank>Frames:\\n" ) ; //<S2SV> fprintf ( f , "Y:<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , //<S2SV> inter_y_modes [ 0 ] , inter_y_modes [ 1 ] , inter_y_modes [ 2 ] , inter_y_modes [ 3 ] , inter_y_modes [ 4 ] , //<S2SV> inter_y_modes [ 5 ] , inter_y_modes [ 6 ] , inter_y_modes [ 7 ] , inter_y_modes [ 8 ] , inter_y_modes [ 9 ] ) ; //<S2SV> fprintf ( f , "UV:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , inter_uv_modes [ 0 ] , inter_uv_modes [ 1 ] , inter_uv_modes [ 2 ] , inter_uv_modes [ 3 ] ) ; //<S2SV> fprintf ( f , "B:<S2SV_blank>" ) ; //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 15 ; i ++ ) //<S2SV> fprintf ( f , "%8d,<S2SV_blank>" , inter_b_modes [ i ] ) ; //<S2SV> fprintf ( f , "\\n" ) ; //<S2SV> } //<S2SV> fprintf ( f , "P:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , count_mb_seg [ 0 ] , count_mb_seg [ 1 ] , count_mb_seg [ 2 ] , count_mb_seg [ 3 ] ) ; //<S2SV> fprintf ( f , "PB:%8d,<S2SV_blank>%8d,<S2SV_blank>%8d,<S2SV_blank>%8d\\n" , inter_b_modes [ LEFT4X4 ] , inter_b_modes [ ABOVE4X4 ] , inter_b_modes [ ZERO4X4 ] , inter_b_modes [ NEW4X4 ] ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> { //<S2SV> int i , j , k ; //<S2SV> FILE * fmode = fopen ( "modecontext.c" , "w" ) ; //<S2SV> fprintf ( fmode , "\\n#include<S2SV_blank>\\"entropymode.h\\"\\n\\n" ) ; //<S2SV> fprintf ( fmode , "const<S2SV_blank>unsigned<S2SV_blank>int<S2SV_blank>vp8_kf_default_bmode_counts<S2SV_blank>" ) ; //<S2SV> fprintf ( fmode , "[VP8_BINTRAMODES]<S2SV_blank>[VP8_BINTRAMODES]<S2SV_blank>[VP8_BINTRAMODES]<S2SV_blank>=\\n{\\n" ) ; //<S2SV> for ( i = 0 ; i < 10 ; i ++ ) //<S2SV> { //<S2SV> fprintf ( fmode , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{<S2SV_blank>/*<S2SV_blank>Above<S2SV_blank>Mode<S2SV_blank>:<S2SV_blank><S2SV_blank>%d<S2SV_blank>*/\\n" , i ) ; //<S2SV> for ( j = 0 ; j < 10 ; j ++ ) //<S2SV> { //<S2SV> fprintf ( fmode , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{" ) ; //<S2SV> for ( k = 0 ; k < 10 ; k ++ ) //<S2SV> { //<S2SV> if ( ! intra_mode_stats [ i ] [ j ] [ k ] ) //<S2SV> fprintf ( fmode , "<S2SV_blank>%5d,<S2SV_blank>" , 1 ) ; //<S2SV> else //<S2SV> fprintf ( fmode , "<S2SV_blank>%5d,<S2SV_blank>" , intra_mode_stats [ i ] [ j ] [ k ] ) ; //<S2SV> } //<S2SV> fprintf ( fmode , "},<S2SV_blank>/*<S2SV_blank>left_mode<S2SV_blank>%d<S2SV_blank>*/\\n" , j ) ; //<S2SV> } //<S2SV> fprintf ( fmode , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>},\\n" ) ; //<S2SV> } //<S2SV> fprintf ( fmode , "};\\n" ) ; //<S2SV> fclose ( fmode ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if defined ( SECTIONBITS_OUTPUT ) //<S2SV> if ( 0 ) //<S2SV> { //<S2SV> int i ; //<S2SV> FILE * f = fopen ( "tokenbits.stt" , "a" ) ; //<S2SV> for ( i = 0 ; i < 28 ; i ++ ) //<S2SV> fprintf ( f , "%8d" , ( int ) ( Sectionbits [ i ] / 256 ) ) ; //<S2SV> fprintf ( f , "\\n" ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if 0 //<S2SV> { //<S2SV> printf ( "\\n_pick_loop_filter_level:%d\\n" , cpi -> time_pick_lpf / 1000 ) ; //<S2SV> printf ( "\\n_frames<S2SV_blank>recive_data<S2SV_blank>encod_mb_row<S2SV_blank>compress_frame<S2SV_blank><S2SV_blank>Total\\n" ) ; //<S2SV> printf ( "%6d<S2SV_blank>%10ld<S2SV_blank>%10ld<S2SV_blank>%10ld<S2SV_blank>%10ld\\n" , cpi -> common . current_video_frame , cpi -> time_receive_data / 1000 , cpi -> time_encode_mb_row / 1000 , cpi -> time_compress_data / 1000 , ( cpi -> time_receive_data + cpi -> time_compress_data ) / 1000 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> vp8cx_remove_encoder_threads ( cpi ) ; //<S2SV> # endif //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> vp8_denoiser_free ( & cpi -> denoiser ) ; //<S2SV> # endif //<S2SV> dealloc_compressor_data ( cpi ) ; //<S2SV> vpx_free ( cpi -> mb . ss ) ; //<S2SV> vpx_free ( cpi -> tok ) ; //<S2SV> vpx_free ( cpi -> cyclic_refresh_map ) ; //<S2SV> vpx_free ( cpi -> consec_zero_last ) ; //<S2SV> vpx_free ( cpi -> consec_zero_last_mvbias ) ; //<S2SV> vp8_remove_common ( & cpi -> common ) ; //<S2SV> vpx_free ( cpi ) ; //<S2SV> * ptr = 0 ; //<S2SV> # ifdef OUTPUT_YUV_SRC //<S2SV> fclose ( yuv_file ) ; //<S2SV> # endif //<S2SV> # ifdef OUTPUT_YUV_DENOISED //<S2SV> fclose ( yuv_denoised_file ) ; //<S2SV> # endif //<S2SV> # if 0 //<S2SV> if ( keyfile ) //<S2SV> fclose ( keyfile ) ; //<S2SV> if ( framepsnr ) //<S2SV> fclose ( framepsnr ) ; //<S2SV> if ( kf_list ) //<S2SV> fclose ( kf_list ) ; //<S2SV> # endif //<S2SV> } //<S2SV> 