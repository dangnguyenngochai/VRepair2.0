int vp9_receive_compressed_data ( VP9Decoder * pbi , //<S2SV> size_t size , const uint8_t * * psource ) { //<S2SV> VP9_COMMON * volatile const cm = & pbi -> common ; //<S2SV> BufferPool * volatile const pool = cm -> buffer_pool ; //<S2SV> RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs ; //<S2SV> const uint8_t * source = * psource ; //<S2SV> int retcode = 0 ; //<S2SV> cm -> error . error_code = VPX_CODEC_OK ; //<S2SV> if ( size == 0 ) { //<S2SV> if ( cm -> frame_refs [ 0 ] . idx > 0 ) { //<S2SV> assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; //<S2SV> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; //<S2SV> } //<S2SV> } //<S2SV> pbi -> ready_for_new_data = 0 ; //<S2SV> if ( ! pbi -> frame_parallel_decode && cm -> new_fb_idx >= 0 //<S2SV> && frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) //<S2SV> pool -> release_fb_cb ( pool -> cb_priv , //<S2SV> & frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ; //<S2SV> cm -> new_fb_idx = get_free_fb ( cm ) ; //<S2SV> if ( cm -> new_fb_idx == INVALID_IDX ) //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; //<S2SV> pbi -> hold_ref_buf = 0 ; //<S2SV> if ( pbi -> frame_parallel_decode ) { //<S2SV> VPxWorker * const worker = pbi -> frame_worker_owner ; //<S2SV> vp9_frameworker_lock_stats ( worker ) ; //<S2SV> frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; //<S2SV> pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; //<S2SV> pbi -> cur_buf -> row = - 1 ; //<S2SV> pbi -> cur_buf -> col = - 1 ; //<S2SV> vp9_frameworker_unlock_stats ( worker ) ; //<S2SV> } else { //<S2SV> pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; //<S2SV> } //<S2SV> if ( setjmp ( cm -> error . jmp ) ) { //<S2SV> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; //<S2SV> int i ; //<S2SV> cm -> error . setjmp = 0 ; //<S2SV> pbi -> ready_for_new_data = 1 ; //<S2SV> winterface -> sync ( & pbi -> lf_worker ) ; //<S2SV> for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { //<S2SV> winterface -> sync ( & pbi -> tile_workers [ i ] ) ; //<S2SV> } //<S2SV> lock_buffer_pool ( pool ) ; //<S2SV> if ( pbi -> hold_ref_buf == 1 ) { //<S2SV> int ref_index = 0 , mask ; //<S2SV> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { //<S2SV> const int old_idx = cm -> ref_frame_map [ ref_index ] ; //<S2SV> decrease_ref_count ( old_idx , frame_bufs , pool ) ; //<S2SV> if ( ( mask & 1 ) && old_idx >= 0 ) { //<S2SV> decrease_ref_count ( old_idx , frame_bufs , pool ) ; //<S2SV> } //<S2SV> ++ ref_index ; //<S2SV> } //<S2SV> for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { //<S2SV> const int old_idx = cm -> ref_frame_map [ ref_index ] ; //<S2SV> decrease_ref_count ( old_idx , frame_bufs , pool ) ; //<S2SV> } //<S2SV> pbi -> hold_ref_buf = 0 ; //<S2SV> } //<S2SV> decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; //<S2SV> unlock_buffer_pool ( pool ) ; //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> cm -> error . setjmp = 1 ; //<S2SV> vp9_decode_frame ( pbi , source , source + size , psource ) ; //<S2SV> swap_frame_buffers ( pbi ) ; //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> if ( ! cm -> show_existing_frame ) { //<S2SV> cm -> last_show_frame = cm -> show_frame ; //<S2SV> cm -> prev_frame = cm -> cur_frame ; //<S2SV> if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) //<S2SV> vp9_swap_current_and_last_seg_map ( cm ) ; //<S2SV> } //<S2SV> if ( pbi -> frame_parallel_decode ) { //<S2SV> VPxWorker * const worker = pbi -> frame_worker_owner ; //<S2SV> FrameWorkerData * const frame_worker_data = worker -> data1 ; //<S2SV> vp9_frameworker_lock_stats ( worker ) ; //<S2SV> if ( cm -> show_frame ) { //<S2SV> cm -> current_video_frame ++ ; //<S2SV> } //<S2SV> frame_worker_data -> frame_decoded = 1 ; //<S2SV> frame_worker_data -> frame_context_ready = 1 ; //<S2SV> vp9_frameworker_signal_stats ( worker ) ; //<S2SV> vp9_frameworker_unlock_stats ( worker ) ; //<S2SV> } else { //<S2SV> cm -> last_width = cm -> width ; //<S2SV> cm -> last_height = cm -> height ; //<S2SV> if ( cm -> show_frame ) { //<S2SV> cm -> current_video_frame ++ ; //<S2SV> } //<S2SV> } //<S2SV> cm -> error . setjmp = 0 ; //<S2SV> return retcode ; //<S2SV> } //<S2SV> 