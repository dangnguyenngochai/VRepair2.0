static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const vpx_image_t * img , //<S2SV> vpx_codec_pts_t pts , //<S2SV> unsigned long duration , //<S2SV> vpx_enc_frame_flags_t flags , //<S2SV> unsigned long deadline ) //<S2SV> { //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> if ( ! ctx -> cfg . rc_target_bitrate ) //<S2SV> return res ; //<S2SV> if ( img ) //<S2SV> res = validate_img ( ctx , img ) ; //<S2SV> if ( ! res ) //<S2SV> res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; //<S2SV> pick_quickcompress_mode ( ctx , duration , deadline ) ; //<S2SV> vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; //<S2SV> if ( ! flags ) { //<S2SV> flags = ctx -> control_frame_flags ; //<S2SV> } //<S2SV> ctx -> control_frame_flags = 0 ; //<S2SV> res = set_reference_and_update ( ctx , flags ) ; //<S2SV> if ( ctx -> cfg . kf_mode == VPX_KF_AUTO //<S2SV> && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) //<S2SV> { //<S2SV> if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) //<S2SV> { //<S2SV> flags |= VPX_EFLAG_FORCE_KF ; //<S2SV> ctx -> fixed_kf_cntr = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! res && ctx -> cpi ) //<S2SV> { //<S2SV> unsigned int lib_flags ; //<S2SV> YV12_BUFFER_CONFIG sd ; //<S2SV> int64_t dst_time_stamp , dst_end_time_stamp ; //<S2SV> unsigned long size , cx_data_sz ; //<S2SV> unsigned char * cx_data ; //<S2SV> unsigned char * cx_data_end ; //<S2SV> int comp_data_state = 0 ; //<S2SV> if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) //<S2SV> ( ( VP8_COMP * ) ctx -> cpi ) -> b_calculate_psnr = 1 ; //<S2SV> if ( ctx -> base . init_flags & VPX_CODEC_USE_OUTPUT_PARTITION ) //<S2SV> ( ( VP8_COMP * ) ctx -> cpi ) -> output_partition = 1 ; //<S2SV> lib_flags = ( flags & VPX_EFLAG_FORCE_KF ) ? FRAMEFLAGS_KEY : 0 ; //<S2SV> dst_time_stamp = pts * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; //<S2SV> dst_end_time_stamp = ( pts + duration ) * 10000000 * ctx -> cfg . g_timebase . num / ctx -> cfg . g_timebase . den ; //<S2SV> if ( img != NULL ) //<S2SV> { //<S2SV> res = image2yuvconfig ( img , & sd ) ; //<S2SV> if ( vp8_receive_raw_frame ( ctx -> cpi , ctx -> next_frame_flag | lib_flags , //<S2SV> & sd , dst_time_stamp , dst_end_time_stamp ) ) //<S2SV> { //<S2SV> VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; //<S2SV> res = update_error_state ( ctx , & cpi -> common . error ) ; //<S2SV> } //<S2SV> ctx -> next_frame_flag = 0 ; //<S2SV> } //<S2SV> cx_data = ctx -> cx_data ; //<S2SV> cx_data_sz = ctx -> cx_data_sz ; //<S2SV> cx_data_end = ctx -> cx_data + cx_data_sz ; //<S2SV> lib_flags = 0 ; //<S2SV> while ( cx_data_sz >= ctx -> cx_data_sz / 2 ) //<S2SV> { //<S2SV> comp_data_state = vp8_get_compressed_data ( ctx -> cpi , //<S2SV> & lib_flags , //<S2SV> & size , //<S2SV> cx_data , //<S2SV> cx_data_end , //<S2SV> & dst_time_stamp , //<S2SV> & dst_end_time_stamp , //<S2SV> ! img ) ; //<S2SV> if ( comp_data_state == VPX_CODEC_CORRUPT_FRAME ) //<S2SV> return VPX_CODEC_CORRUPT_FRAME ; //<S2SV> else if ( comp_data_state == - 1 ) //<S2SV> break ; //<S2SV> if ( size ) //<S2SV> { //<S2SV> vpx_codec_pts_t round , delta ; //<S2SV> vpx_codec_cx_pkt_t pkt ; //<S2SV> VP8_COMP * cpi = ( VP8_COMP * ) ctx -> cpi ; //<S2SV> round = ( vpx_codec_pts_t ) 10000000 //<S2SV> * ctx -> cfg . g_timebase . num / 2 - 1 ; //<S2SV> delta = ( dst_end_time_stamp - dst_time_stamp ) ; //<S2SV> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; //<S2SV> pkt . data . frame . pts = //<S2SV> ( dst_time_stamp * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ; //<S2SV> pkt . data . frame . duration = ( unsigned long ) //<S2SV> ( ( delta * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ) ; //<S2SV> pkt . data . frame . flags = lib_flags << 16 ; //<S2SV> if ( lib_flags & FRAMEFLAGS_KEY ) //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_KEY ; //<S2SV> if ( ! cpi -> common . show_frame ) //<S2SV> { //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_INVISIBLE ; //<S2SV> pkt . data . frame . pts = ( ( cpi -> last_time_stamp_seen //<S2SV> * ctx -> cfg . g_timebase . den + round ) //<S2SV> / ctx -> cfg . g_timebase . num / 10000000 ) + 1 ; //<S2SV> pkt . data . frame . duration = 0 ; //<S2SV> } //<S2SV> if ( cpi -> droppable ) //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_DROPPABLE ; //<S2SV> if ( cpi -> output_partition ) //<S2SV> { //<S2SV> int i ; //<S2SV> const int num_partitions = //<S2SV> ( 1 << cpi -> common . multi_token_partition ) + 1 ; //<S2SV> pkt . data . frame . flags |= VPX_FRAME_IS_FRAGMENT ; //<S2SV> for ( i = 0 ; i < num_partitions ; ++ i ) //<S2SV> { //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> pkt . data . frame . buf = cpi -> partition_d [ i ] ; //<S2SV> # else //<S2SV> pkt . data . frame . buf = cx_data ; //<S2SV> cx_data += cpi -> partition_sz [ i ] ; //<S2SV> cx_data_sz -= cpi -> partition_sz [ i ] ; //<S2SV> # endif //<S2SV> pkt . data . frame . sz = cpi -> partition_sz [ i ] ; //<S2SV> pkt . data . frame . partition_id = i ; //<S2SV> if ( i == ( num_partitions - 1 ) ) //<S2SV> pkt . data . frame . flags &= ~ VPX_FRAME_IS_FRAGMENT ; //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; //<S2SV> } //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> cx_data_sz -= ctx -> cx_data_sz / 2 ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pkt . data . frame . buf = cx_data ; //<S2SV> pkt . data . frame . sz = size ; //<S2SV> pkt . data . frame . partition_id = - 1 ; //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; //<S2SV> cx_data += size ; //<S2SV> cx_data_sz -= size ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 