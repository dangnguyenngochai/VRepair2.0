void vp9_setup_past_independence ( VP9_COMMON * cm ) { //<S2SV> struct loopfilter * const lf = & cm -> lf ; //<S2SV> int i ; //<S2SV> vp9_clearall_segfeatures ( & cm -> seg ) ; //<S2SV> cm -> seg . abs_delta = SEGMENT_DELTADATA ; //<S2SV> if ( cm -> last_frame_seg_map && ! cm -> frame_parallel_decode ) //<S2SV> memset ( cm -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; //<S2SV> if ( cm -> current_frame_seg_map ) //<S2SV> memset ( cm -> current_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; //<S2SV> vp9_zero ( lf -> last_ref_deltas ) ; //<S2SV> vp9_zero ( lf -> last_mode_deltas ) ; //<S2SV> set_default_lf_deltas ( lf ) ; //<S2SV> lf -> last_sharpness_level = - 1 ; //<S2SV> vp9_default_coef_probs ( cm ) ; //<S2SV> init_mode_probs ( cm -> fc ) ; //<S2SV> vp9_init_mv_probs ( cm ) ; //<S2SV> cm -> fc -> initialized = 1 ; //<S2SV> if ( cm -> frame_type == KEY_FRAME || //<S2SV> cm -> error_resilient_mode || cm -> reset_frame_context == 3 ) { //<S2SV> for ( i = 0 ; i < FRAME_CONTEXTS ; ++ i ) //<S2SV> cm -> frame_contexts [ i ] = * cm -> fc ; //<S2SV> } else if ( cm -> reset_frame_context == 2 ) { //<S2SV> cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; //<S2SV> } //<S2SV> if ( frame_is_intra_only ( cm ) && cm -> prev_mip && ! cm -> frame_parallel_decode ) //<S2SV> memset ( cm -> prev_mip , 0 , //<S2SV> cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> prev_mip ) ) ; //<S2SV> vp9_zero ( cm -> ref_frame_sign_bias ) ; //<S2SV> cm -> frame_context_idx = 0 ; //<S2SV> } //<S2SV> 