void vp9_init_second_pass ( VP9_COMP * cpi ) { //<S2SV> SVC * const svc = & cpi -> svc ; //<S2SV> const VP9EncoderConfig * const oxcf = & cpi -> oxcf ; //<S2SV> const int is_two_pass_svc = ( svc -> number_spatial_layers > 1 ) || //<S2SV> ( svc -> number_temporal_layers > 1 ) ; //<S2SV> TWO_PASS * const twopass = is_two_pass_svc ? //<S2SV> & svc -> layer_context [ svc -> spatial_layer_id ] . twopass : & cpi -> twopass ; //<S2SV> double frame_rate ; //<S2SV> FIRSTPASS_STATS * stats ; //<S2SV> zero_stats ( & twopass -> total_stats ) ; //<S2SV> zero_stats ( & twopass -> total_left_stats ) ; //<S2SV> if ( ! twopass -> stats_in_end ) //<S2SV> return ; //<S2SV> stats = & twopass -> total_stats ; //<S2SV> * stats = * twopass -> stats_in_end ; //<S2SV> twopass -> total_left_stats = * stats ; //<S2SV> frame_rate = 10000000.0 * stats -> count / stats -> duration ; //<S2SV> if ( is_two_pass_svc ) { //<S2SV> vp9_update_spatial_layer_framerate ( cpi , frame_rate ) ; //<S2SV> twopass -> bits_left = ( int64_t ) ( stats -> duration * //<S2SV> svc -> layer_context [ svc -> spatial_layer_id ] . target_bandwidth / //<S2SV> 10000000.0 ) ; //<S2SV> } else { //<S2SV> vp9_new_framerate ( cpi , frame_rate ) ; //<S2SV> twopass -> bits_left = ( int64_t ) ( stats -> duration * oxcf -> target_bandwidth / //<S2SV> 10000000.0 ) ; //<S2SV> } //<S2SV> twopass -> sr_update_lag = 1 ; //<S2SV> { //<S2SV> const double avg_error = stats -> coded_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( stats -> count ) ; //<S2SV> const FIRSTPASS_STATS * s = twopass -> stats_in ; //<S2SV> double modified_error_total = 0.0 ; //<S2SV> twopass -> modified_error_min = ( avg_error * //<S2SV> oxcf -> two_pass_vbrmin_section ) / 100 ; //<S2SV> twopass -> modified_error_max = ( avg_error * //<S2SV> oxcf -> two_pass_vbrmax_section ) / 100 ; //<S2SV> while ( s < twopass -> stats_in_end ) { //<S2SV> modified_error_total += calculate_modified_err ( cpi , twopass , oxcf , s ) ; //<S2SV> ++ s ; //<S2SV> } //<S2SV> twopass -> modified_error_left = modified_error_total ; //<S2SV> } //<S2SV> cpi -> rc . vbr_bits_off_target = 0 ; //<S2SV> cpi -> rc . vbr_bits_off_target_fast = 0 ; //<S2SV> cpi -> rc . rate_error_estimate = 0 ; //<S2SV> twopass -> kf_zeromotion_pct = 100 ; //<S2SV> twopass -> last_kfgroup_zeromotion_pct = 100 ; //<S2SV> if ( oxcf -> resize_mode != RESIZE_NONE ) { //<S2SV> vp9_init_subsampling ( cpi ) ; //<S2SV> } //<S2SV> } //<S2SV> 