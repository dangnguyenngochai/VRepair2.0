struct lookahead_ctx * vp9_lookahead_init ( unsigned int width , //<S2SV> unsigned int height , //<S2SV> unsigned int subsampling_x , //<S2SV> unsigned int subsampling_y , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> int use_highbitdepth , //<S2SV> # endif //<S2SV> unsigned int depth ) { //<S2SV> struct lookahead_ctx * ctx = NULL ; //<S2SV> depth = clamp ( depth , 1 , MAX_LAG_BUFFERS ) ; //<S2SV> depth += MAX_PRE_FRAMES ; //<S2SV> ctx = calloc ( 1 , sizeof ( * ctx ) ) ; //<S2SV> if ( ctx ) { //<S2SV> const int legacy_byte_alignment = 0 ; //<S2SV> unsigned int i ; //<S2SV> ctx -> max_sz = depth ; //<S2SV> ctx -> buf = calloc ( depth , sizeof ( * ctx -> buf ) ) ; //<S2SV> if ( ! ctx -> buf ) //<S2SV> goto bail ; //<S2SV> for ( i = 0 ; i < depth ; i ++ ) //<S2SV> if ( vpx_alloc_frame_buffer ( & ctx -> buf [ i ] . img , //<S2SV> width , height , subsampling_x , subsampling_y , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> use_highbitdepth , //<S2SV> # endif //<S2SV> VP9_ENC_BORDER_IN_PIXELS , //<S2SV> legacy_byte_alignment ) ) //<S2SV> goto bail ; //<S2SV> } //<S2SV> return ctx ; //<S2SV> bail : //<S2SV> vp9_lookahead_destroy ( ctx ) ; //<S2SV> return NULL ; //<S2SV> } //<S2SV> 