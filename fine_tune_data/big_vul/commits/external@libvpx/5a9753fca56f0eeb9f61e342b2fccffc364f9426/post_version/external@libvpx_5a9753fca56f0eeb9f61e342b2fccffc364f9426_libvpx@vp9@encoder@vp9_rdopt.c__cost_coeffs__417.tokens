static int cost_coeffs ( MACROBLOCK * x , //<S2SV> int plane , int block , //<S2SV> ENTROPY_CONTEXT * A , ENTROPY_CONTEXT * L , //<S2SV> TX_SIZE tx_size , //<S2SV> const int16_t * scan , const int16_t * nb , //<S2SV> int use_fast_coef_costing ) { //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const struct macroblock_plane * p = & x -> plane [ plane ] ; //<S2SV> const struct macroblockd_plane * pd = & xd -> plane [ plane ] ; //<S2SV> const PLANE_TYPE type = pd -> plane_type ; //<S2SV> const int16_t * band_count = & band_counts [ tx_size ] [ 1 ] ; //<S2SV> const int eob = p -> eobs [ block ] ; //<S2SV> const tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; //<S2SV> unsigned int ( * token_costs ) [ 2 ] [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = //<S2SV> x -> token_costs [ tx_size ] [ type ] [ is_inter_block ( mbmi ) ] ; //<S2SV> uint8_t token_cache [ 32 * 32 ] ; //<S2SV> int pt = combine_entropy_contexts ( * A , * L ) ; //<S2SV> int c , cost ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; //<S2SV> # else //<S2SV> const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; //<S2SV> # endif //<S2SV> assert ( type == PLANE_TYPE_Y ? mbmi -> tx_size == tx_size //<S2SV> : get_uv_tx_size ( mbmi , pd ) == tx_size ) ; //<S2SV> if ( eob == 0 ) { //<S2SV> cost = token_costs [ 0 ] [ 0 ] [ pt ] [ EOB_TOKEN ] ; //<S2SV> c = 0 ; //<S2SV> } else { //<S2SV> int band_left = * band_count ++ ; //<S2SV> int v = qcoeff [ 0 ] ; //<S2SV> int16_t prev_t ; //<S2SV> EXTRABIT e ; //<S2SV> vp9_get_token_extra ( v , & prev_t , & e ) ; //<S2SV> cost = ( * token_costs ) [ 0 ] [ pt ] [ prev_t ] + //<S2SV> vp9_get_cost ( prev_t , e , cat6_high_cost ) ; //<S2SV> token_cache [ 0 ] = vp9_pt_energy_class [ prev_t ] ; //<S2SV> ++ token_costs ; //<S2SV> for ( c = 1 ; c < eob ; c ++ ) { //<S2SV> const int rc = scan [ c ] ; //<S2SV> int16_t t ; //<S2SV> v = qcoeff [ rc ] ; //<S2SV> vp9_get_token_extra ( v , & t , & e ) ; //<S2SV> if ( use_fast_coef_costing ) { //<S2SV> cost += ( * token_costs ) [ ! prev_t ] [ ! prev_t ] [ t ] + //<S2SV> vp9_get_cost ( t , e , cat6_high_cost ) ; //<S2SV> } else { //<S2SV> pt = get_coef_context ( nb , token_cache , c ) ; //<S2SV> cost += ( * token_costs ) [ ! prev_t ] [ pt ] [ t ] + //<S2SV> vp9_get_cost ( t , e , cat6_high_cost ) ; //<S2SV> token_cache [ rc ] = vp9_pt_energy_class [ t ] ; //<S2SV> } //<S2SV> prev_t = t ; //<S2SV> if ( ! -- band_left ) { //<S2SV> band_left = * band_count ++ ; //<S2SV> ++ token_costs ; //<S2SV> } //<S2SV> } //<S2SV> if ( band_left ) { //<S2SV> if ( use_fast_coef_costing ) { //<S2SV> cost += ( * token_costs ) [ 0 ] [ ! prev_t ] [ EOB_TOKEN ] ; //<S2SV> } else { //<S2SV> pt = get_coef_context ( nb , token_cache , c ) ; //<S2SV> cost += ( * token_costs ) [ 0 ] [ pt ] [ EOB_TOKEN ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * A = * L = ( c > 0 ) ; //<S2SV> return cost ; //<S2SV> } //<S2SV> 