static size_t read_uncompressed_header ( VP9Decoder * pbi , //<S2SV> struct vpx_read_bit_buffer * rb ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> BufferPool * const pool = cm -> buffer_pool ; //<S2SV> RefCntBuffer * const frame_bufs = pool -> frame_bufs ; //<S2SV> int i , mask , ref_index = 0 ; //<S2SV> size_t sz ; //<S2SV> cm -> last_frame_type = cm -> frame_type ; //<S2SV> cm -> last_intra_only = cm -> intra_only ; //<S2SV> if ( vpx_rb_read_literal ( rb , 2 ) != VP9_FRAME_MARKER ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>marker" ) ; //<S2SV> cm -> profile = vp9_read_profile ( rb ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> profile >= MAX_PROFILES ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; //<S2SV> # else //<S2SV> if ( cm -> profile >= PROFILE_2 ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; //<S2SV> # endif //<S2SV> cm -> show_existing_frame = vpx_rb_read_bit ( rb ) ; //<S2SV> if ( cm -> show_existing_frame ) { //<S2SV> const int frame_to_show = cm -> ref_frame_map [ vpx_rb_read_literal ( rb , 3 ) ] ; //<S2SV> lock_buffer_pool ( pool ) ; //<S2SV> if ( frame_to_show < 0 || frame_bufs [ frame_to_show ] . ref_count < 1 ) { //<S2SV> unlock_buffer_pool ( pool ) ; //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Buffer<S2SV_blank>%d<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>a<S2SV_blank>decoded<S2SV_blank>frame" , //<S2SV> frame_to_show ) ; //<S2SV> } //<S2SV> ref_cnt_fb ( frame_bufs , & cm -> new_fb_idx , frame_to_show ) ; //<S2SV> unlock_buffer_pool ( pool ) ; //<S2SV> pbi -> refresh_frame_flags = 0 ; //<S2SV> cm -> lf . filter_level = 0 ; //<S2SV> cm -> show_frame = 1 ; //<S2SV> if ( pbi -> frame_parallel_decode ) { //<S2SV> for ( i = 0 ; i < REF_FRAMES ; ++ i ) //<S2SV> cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> cm -> frame_type = ( FRAME_TYPE ) vpx_rb_read_bit ( rb ) ; //<S2SV> cm -> show_frame = vpx_rb_read_bit ( rb ) ; //<S2SV> cm -> error_resilient_mode = vpx_rb_read_bit ( rb ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) { //<S2SV> if ( ! vp9_read_sync_code ( rb ) ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; //<S2SV> read_bitdepth_colorspace_sampling ( cm , rb ) ; //<S2SV> pbi -> refresh_frame_flags = ( 1 << REF_FRAMES ) - 1 ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> cm -> frame_refs [ i ] . idx = INVALID_IDX ; //<S2SV> cm -> frame_refs [ i ] . buf = NULL ; //<S2SV> } //<S2SV> setup_frame_size ( cm , rb ) ; //<S2SV> if ( pbi -> need_resync ) { //<S2SV> memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; //<S2SV> pbi -> need_resync = 0 ; //<S2SV> } //<S2SV> } else { //<S2SV> cm -> intra_only = cm -> show_frame ? 0 : vpx_rb_read_bit ( rb ) ; //<S2SV> cm -> reset_frame_context = cm -> error_resilient_mode ? //<S2SV> 0 : vpx_rb_read_literal ( rb , 2 ) ; //<S2SV> if ( cm -> intra_only ) { //<S2SV> if ( ! vp9_read_sync_code ( rb ) ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , //<S2SV> "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; //<S2SV> if ( cm -> profile > PROFILE_0 ) { //<S2SV> read_bitdepth_colorspace_sampling ( cm , rb ) ; //<S2SV> } else { //<S2SV> cm -> color_space = VPX_CS_BT_601 ; //<S2SV> cm -> subsampling_y = cm -> subsampling_x = 1 ; //<S2SV> cm -> bit_depth = VPX_BITS_8 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> cm -> use_highbitdepth = 0 ; //<S2SV> # endif //<S2SV> } //<S2SV> pbi -> refresh_frame_flags = vpx_rb_read_literal ( rb , REF_FRAMES ) ; //<S2SV> setup_frame_size ( cm , rb ) ; //<S2SV> if ( pbi -> need_resync ) { //<S2SV> memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; //<S2SV> pbi -> need_resync = 0 ; //<S2SV> } //<S2SV> } else if ( pbi -> need_resync != 1 ) { //<S2SV> pbi -> refresh_frame_flags = vpx_rb_read_literal ( rb , REF_FRAMES ) ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> const int ref = vpx_rb_read_literal ( rb , REF_FRAMES_LOG2 ) ; //<S2SV> const int idx = cm -> ref_frame_map [ ref ] ; //<S2SV> RefBuffer * const ref_frame = & cm -> frame_refs [ i ] ; //<S2SV> ref_frame -> idx = idx ; //<S2SV> ref_frame -> buf = & frame_bufs [ idx ] . buf ; //<S2SV> cm -> ref_frame_sign_bias [ LAST_FRAME + i ] = vpx_rb_read_bit ( rb ) ; //<S2SV> } //<S2SV> setup_frame_size_with_refs ( cm , rb ) ; //<S2SV> cm -> allow_high_precision_mv = vpx_rb_read_bit ( rb ) ; //<S2SV> cm -> interp_filter = read_interp_filter ( rb ) ; //<S2SV> for ( i = 0 ; i < REFS_PER_FRAME ; ++ i ) { //<S2SV> RefBuffer * const ref_buf = & cm -> frame_refs [ i ] ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , //<S2SV> ref_buf -> buf -> y_crop_width , //<S2SV> ref_buf -> buf -> y_crop_height , //<S2SV> cm -> width , cm -> height , //<S2SV> cm -> use_highbitdepth ) ; //<S2SV> # else //<S2SV> vp9_setup_scale_factors_for_frame ( & ref_buf -> sf , //<S2SV> ref_buf -> buf -> y_crop_width , //<S2SV> ref_buf -> buf -> y_crop_height , //<S2SV> cm -> width , cm -> height ) ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; //<S2SV> # endif //<S2SV> get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; //<S2SV> if ( pbi -> need_resync ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder" //<S2SV> "<S2SV_blank>state" ) ; //<S2SV> } //<S2SV> if ( ! cm -> error_resilient_mode ) { //<S2SV> cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; //<S2SV> cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; //<S2SV> } else { //<S2SV> cm -> refresh_frame_context = 0 ; //<S2SV> cm -> frame_parallel_decoding_mode = 1 ; //<S2SV> } //<S2SV> cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; //<S2SV> lock_buffer_pool ( pool ) ; //<S2SV> for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { //<S2SV> if ( mask & 1 ) { //<S2SV> cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; //<S2SV> ++ frame_bufs [ cm -> new_fb_idx ] . ref_count ; //<S2SV> } else { //<S2SV> cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; //<S2SV> } //<S2SV> if ( cm -> ref_frame_map [ ref_index ] >= 0 ) //<S2SV> ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; //<S2SV> ++ ref_index ; //<S2SV> } //<S2SV> for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { //<S2SV> cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; //<S2SV> if ( cm -> ref_frame_map [ ref_index ] >= 0 ) //<S2SV> ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; //<S2SV> } //<S2SV> unlock_buffer_pool ( pool ) ; //<S2SV> pbi -> hold_ref_buf = 1 ; //<S2SV> if ( frame_is_intra_only ( cm ) || cm -> error_resilient_mode ) //<S2SV> vp9_setup_past_independence ( cm ) ; //<S2SV> setup_loopfilter ( & cm -> lf , rb ) ; //<S2SV> setup_quantization ( cm , & pbi -> mb , rb ) ; //<S2SV> setup_segmentation ( & cm -> seg , rb ) ; //<S2SV> setup_segmentation_dequant ( cm ) ; //<S2SV> setup_tile_info ( cm , rb ) ; //<S2SV> sz = vpx_rb_read_literal ( rb , 16 ) ; //<S2SV> if ( sz == 0 ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; //<S2SV> return sz ; //<S2SV> } //<S2SV> 