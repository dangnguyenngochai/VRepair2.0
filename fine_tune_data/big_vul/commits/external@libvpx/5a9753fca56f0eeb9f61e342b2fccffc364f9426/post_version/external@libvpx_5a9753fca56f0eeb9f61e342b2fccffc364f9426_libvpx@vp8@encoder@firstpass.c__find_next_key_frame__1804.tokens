static void find_next_key_frame ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) //<S2SV> { //<S2SV> int i , j ; //<S2SV> FIRSTPASS_STATS last_frame ; //<S2SV> FIRSTPASS_STATS first_frame ; //<S2SV> FIRSTPASS_STATS next_frame ; //<S2SV> FIRSTPASS_STATS * start_position ; //<S2SV> double decay_accumulator = 1.0 ; //<S2SV> double boost_score = 0 ; //<S2SV> double old_boost_score = 0.0 ; //<S2SV> double loop_decay_rate ; //<S2SV> double kf_mod_err = 0.0 ; //<S2SV> double kf_group_err = 0.0 ; //<S2SV> double kf_group_intra_err = 0.0 ; //<S2SV> double kf_group_coded_err = 0.0 ; //<S2SV> double recent_loop_decay [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ; //<S2SV> memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> start_position = cpi -> twopass . stats_in ; //<S2SV> cpi -> common . frame_type = KEY_FRAME ; //<S2SV> cpi -> this_key_frame_forced = cpi -> next_key_frame_forced ; //<S2SV> cpi -> source_alt_ref_active = 0 ; //<S2SV> cpi -> frames_till_gf_update_due = 0 ; //<S2SV> cpi -> twopass . frames_to_key = 1 ; //<S2SV> memcpy ( & first_frame , this_frame , sizeof ( * this_frame ) ) ; //<S2SV> cpi -> twopass . kf_group_bits = 0 ; //<S2SV> cpi -> twopass . kf_group_error_left = 0 ; //<S2SV> kf_mod_err = calculate_modified_err ( cpi , this_frame ) ; //<S2SV> i = 0 ; //<S2SV> while ( cpi -> twopass . stats_in < cpi -> twopass . stats_in_end ) //<S2SV> { //<S2SV> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; //<S2SV> kf_group_intra_err += this_frame -> intra_error ; //<S2SV> kf_group_coded_err += this_frame -> coded_error ; //<S2SV> memcpy ( & last_frame , this_frame , sizeof ( * this_frame ) ) ; //<S2SV> input_stats ( cpi , this_frame ) ; //<S2SV> if ( cpi -> oxcf . auto_key //<S2SV> && lookup_next_frame_stats ( cpi , & next_frame ) != EOF ) //<S2SV> { //<S2SV> if ( ( i >= MIN_GF_INTERVAL ) && //<S2SV> test_candidate_kf ( cpi , & last_frame , this_frame , & next_frame ) ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; //<S2SV> recent_loop_decay [ i % 8 ] = loop_decay_rate ; //<S2SV> decay_accumulator = 1.0 ; //<S2SV> for ( j = 0 ; j < 8 ; j ++ ) //<S2SV> { //<S2SV> decay_accumulator = decay_accumulator * recent_loop_decay [ j ] ; //<S2SV> } //<S2SV> if ( detect_transition_to_still ( cpi , i , //<S2SV> ( cpi -> key_frame_frequency - i ) , //<S2SV> loop_decay_rate , //<S2SV> decay_accumulator ) ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> cpi -> twopass . frames_to_key ++ ; //<S2SV> if ( cpi -> twopass . frames_to_key >= 2 * ( int ) cpi -> key_frame_frequency ) //<S2SV> break ; //<S2SV> } else //<S2SV> cpi -> twopass . frames_to_key ++ ; //<S2SV> i ++ ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . auto_key //<S2SV> && cpi -> twopass . frames_to_key > ( int ) cpi -> key_frame_frequency ) //<S2SV> { //<S2SV> FIRSTPASS_STATS * current_pos = cpi -> twopass . stats_in ; //<S2SV> FIRSTPASS_STATS tmp_frame ; //<S2SV> cpi -> twopass . frames_to_key /= 2 ; //<S2SV> memcpy ( & tmp_frame , & first_frame , sizeof ( first_frame ) ) ; //<S2SV> reset_fpf_position ( cpi , start_position ) ; //<S2SV> kf_group_err = 0 ; //<S2SV> kf_group_intra_err = 0 ; //<S2SV> kf_group_coded_err = 0 ; //<S2SV> for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) //<S2SV> { //<S2SV> kf_group_err += calculate_modified_err ( cpi , & tmp_frame ) ; //<S2SV> kf_group_intra_err += tmp_frame . intra_error ; //<S2SV> kf_group_coded_err += tmp_frame . coded_error ; //<S2SV> input_stats ( cpi , & tmp_frame ) ; //<S2SV> } //<S2SV> reset_fpf_position ( cpi , current_pos ) ; //<S2SV> cpi -> next_key_frame_forced = 1 ; //<S2SV> } //<S2SV> else //<S2SV> cpi -> next_key_frame_forced = 0 ; //<S2SV> if ( cpi -> twopass . stats_in >= cpi -> twopass . stats_in_end ) //<S2SV> { //<S2SV> kf_group_err += calculate_modified_err ( cpi , this_frame ) ; //<S2SV> kf_group_intra_err += this_frame -> intra_error ; //<S2SV> kf_group_coded_err += this_frame -> coded_error ; //<S2SV> } //<S2SV> if ( ( cpi -> twopass . bits_left > 0 ) && ( cpi -> twopass . modified_error_left > 0.0 ) ) //<S2SV> { //<S2SV> int max_bits = frame_max_bits ( cpi ) ; //<S2SV> int64_t max_grp_bits ; //<S2SV> cpi -> twopass . kf_group_bits = ( int64_t ) ( cpi -> twopass . bits_left * //<S2SV> ( kf_group_err / //<S2SV> cpi -> twopass . modified_error_left ) ) ; //<S2SV> max_grp_bits = ( int64_t ) max_bits * ( int64_t ) cpi -> twopass . frames_to_key ; //<S2SV> if ( cpi -> twopass . kf_group_bits > max_grp_bits ) //<S2SV> cpi -> twopass . kf_group_bits = max_grp_bits ; //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> int64_t opt_buffer_lvl = cpi -> oxcf . optimal_buffer_level ; //<S2SV> int64_t buffer_lvl = cpi -> buffer_level ; //<S2SV> if ( buffer_lvl >= opt_buffer_lvl ) //<S2SV> { //<S2SV> int64_t high_water_mark = ( opt_buffer_lvl + //<S2SV> cpi -> oxcf . maximum_buffer_size ) >> 1 ; //<S2SV> int64_t av_group_bits ; //<S2SV> av_group_bits = ( int64_t ) cpi -> av_per_frame_bandwidth * //<S2SV> ( int64_t ) cpi -> twopass . frames_to_key ; //<S2SV> if ( cpi -> buffer_level >= high_water_mark ) //<S2SV> { //<S2SV> int64_t min_group_bits ; //<S2SV> min_group_bits = av_group_bits + //<S2SV> ( int64_t ) ( buffer_lvl - //<S2SV> high_water_mark ) ; //<S2SV> if ( cpi -> twopass . kf_group_bits < min_group_bits ) //<S2SV> cpi -> twopass . kf_group_bits = min_group_bits ; //<S2SV> } //<S2SV> else if ( cpi -> twopass . kf_group_bits < av_group_bits ) //<S2SV> { //<S2SV> int64_t bits_below_av = av_group_bits - //<S2SV> cpi -> twopass . kf_group_bits ; //<S2SV> cpi -> twopass . kf_group_bits += //<S2SV> ( int64_t ) ( ( double ) bits_below_av * //<S2SV> ( double ) ( buffer_lvl - opt_buffer_lvl ) / //<S2SV> ( double ) ( high_water_mark - opt_buffer_lvl ) ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> cpi -> twopass . kf_group_bits = 0 ; //<S2SV> reset_fpf_position ( cpi , start_position ) ; //<S2SV> decay_accumulator = 1.0 ; //<S2SV> boost_score = 0.0 ; //<S2SV> for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) //<S2SV> { //<S2SV> double r ; //<S2SV> if ( EOF == input_stats ( cpi , & next_frame ) ) //<S2SV> break ; //<S2SV> if ( next_frame . intra_error > cpi -> twopass . kf_intra_err_min ) //<S2SV> r = ( IIKFACTOR2 * next_frame . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; //<S2SV> else //<S2SV> r = ( IIKFACTOR2 * cpi -> twopass . kf_intra_err_min / //<S2SV> DOUBLE_DIVIDE_CHECK ( next_frame . coded_error ) ) ; //<S2SV> if ( r > RMAX ) //<S2SV> r = RMAX ; //<S2SV> loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; //<S2SV> decay_accumulator = decay_accumulator * loop_decay_rate ; //<S2SV> decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; //<S2SV> boost_score += ( decay_accumulator * r ) ; //<S2SV> if ( ( i > MIN_GF_INTERVAL ) && //<S2SV> ( ( boost_score - old_boost_score ) < 1.0 ) ) //<S2SV> { //<S2SV> break ; //<S2SV> } //<S2SV> old_boost_score = boost_score ; //<S2SV> } //<S2SV> if ( 1 ) //<S2SV> { //<S2SV> FIRSTPASS_STATS sectionstats ; //<S2SV> double Ratio ; //<S2SV> zero_stats ( & sectionstats ) ; //<S2SV> reset_fpf_position ( cpi , start_position ) ; //<S2SV> for ( i = 0 ; i < cpi -> twopass . frames_to_key ; i ++ ) //<S2SV> { //<S2SV> input_stats ( cpi , & next_frame ) ; //<S2SV> accumulate_stats ( & sectionstats , & next_frame ) ; //<S2SV> } //<S2SV> avg_stats ( & sectionstats ) ; //<S2SV> cpi -> twopass . section_intra_rating = ( unsigned int ) //<S2SV> ( sectionstats . intra_error //<S2SV> / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; //<S2SV> Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; //<S2SV> cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; //<S2SV> if ( cpi -> twopass . section_max_qfactor < 0.80 ) //<S2SV> cpi -> twopass . section_max_qfactor = 0.80 ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> double max_boost ; //<S2SV> if ( cpi -> drop_frames_allowed ) //<S2SV> { //<S2SV> int df_buffer_level = ( int ) ( cpi -> oxcf . drop_frames_water_mark //<S2SV> * ( cpi -> oxcf . optimal_buffer_level / 100 ) ) ; //<S2SV> if ( cpi -> buffer_level > df_buffer_level ) //<S2SV> max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; //<S2SV> else //<S2SV> max_boost = 0.0 ; //<S2SV> } //<S2SV> else if ( cpi -> buffer_level > 0 ) //<S2SV> { //<S2SV> max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> max_boost = 0.0 ; //<S2SV> } //<S2SV> if ( boost_score > max_boost ) //<S2SV> boost_score = max_boost ; //<S2SV> } //<S2SV> reset_fpf_position ( cpi , start_position ) ; //<S2SV> if ( 1 ) //<S2SV> { //<S2SV> int kf_boost = ( int ) boost_score ; //<S2SV> int allocation_chunks ; //<S2SV> int Counter = cpi -> twopass . frames_to_key ; //<S2SV> int alt_kf_bits ; //<S2SV> YV12_BUFFER_CONFIG * lst_yv12 = & cpi -> common . yv12_fb [ cpi -> common . lst_fb_idx ] ; //<S2SV> # if 0 //<S2SV> while ( ( kf_boost < 48 ) && ( Counter > 0 ) ) //<S2SV> { //<S2SV> Counter -= 2 ; //<S2SV> kf_boost ++ ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( kf_boost < 48 ) //<S2SV> { //<S2SV> kf_boost += ( ( Counter + 1 ) >> 1 ) ; //<S2SV> if ( kf_boost > 48 ) kf_boost = 48 ; //<S2SV> } //<S2SV> if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) > ( 320 * 240 ) ) //<S2SV> kf_boost += 2 * ( lst_yv12 -> y_width * lst_yv12 -> y_height ) / ( 320 * 240 ) ; //<S2SV> else if ( ( lst_yv12 -> y_width * lst_yv12 -> y_height ) < ( 320 * 240 ) ) //<S2SV> kf_boost -= 4 * ( 320 * 240 ) / ( lst_yv12 -> y_width * lst_yv12 -> y_height ) ; //<S2SV> kf_boost = ( int ) ( ( double ) kf_boost * 100.0 ) >> 4 ; //<S2SV> if ( kf_boost < 250 ) //<S2SV> kf_boost = 250 ; //<S2SV> if ( decay_accumulator >= 0.99 ) //<S2SV> { //<S2SV> allocation_chunks = //<S2SV> ( ( cpi -> twopass . frames_to_key - 1 ) * 10 ) + kf_boost ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> allocation_chunks = //<S2SV> ( ( cpi -> twopass . frames_to_key - 1 ) * 100 ) + kf_boost ; //<S2SV> } //<S2SV> while ( kf_boost > 1000 ) //<S2SV> { //<S2SV> kf_boost /= 2 ; //<S2SV> allocation_chunks /= 2 ; //<S2SV> } //<S2SV> cpi -> twopass . kf_group_bits = ( cpi -> twopass . kf_group_bits < 0 ) ? 0 : cpi -> twopass . kf_group_bits ; //<S2SV> cpi -> twopass . kf_bits = ( int ) ( ( double ) kf_boost * ( ( double ) cpi -> twopass . kf_group_bits / ( double ) allocation_chunks ) ) ; //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> if ( cpi -> twopass . kf_bits > ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ) //<S2SV> cpi -> twopass . kf_bits = ( int ) ( ( 3 * cpi -> buffer_level ) >> 2 ) ; //<S2SV> } //<S2SV> if ( kf_mod_err < kf_group_err / cpi -> twopass . frames_to_key ) //<S2SV> { //<S2SV> double alt_kf_grp_bits = //<S2SV> ( ( double ) cpi -> twopass . bits_left * //<S2SV> ( kf_mod_err * ( double ) cpi -> twopass . frames_to_key ) / //<S2SV> DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ; //<S2SV> alt_kf_bits = ( int ) ( ( double ) kf_boost * //<S2SV> ( alt_kf_grp_bits / ( double ) allocation_chunks ) ) ; //<S2SV> if ( cpi -> twopass . kf_bits > alt_kf_bits ) //<S2SV> { //<S2SV> cpi -> twopass . kf_bits = alt_kf_bits ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> alt_kf_bits = //<S2SV> ( int ) ( ( double ) cpi -> twopass . bits_left * //<S2SV> ( kf_mod_err / //<S2SV> DOUBLE_DIVIDE_CHECK ( cpi -> twopass . modified_error_left ) ) ) ; //<S2SV> if ( alt_kf_bits > cpi -> twopass . kf_bits ) //<S2SV> { //<S2SV> cpi -> twopass . kf_bits = alt_kf_bits ; //<S2SV> } //<S2SV> } //<S2SV> cpi -> twopass . kf_group_bits -= cpi -> twopass . kf_bits ; //<S2SV> cpi -> twopass . kf_bits += cpi -> min_frame_bandwidth ; //<S2SV> cpi -> per_frame_bandwidth = cpi -> twopass . kf_bits ; //<S2SV> cpi -> target_bandwidth = ( int ) ( cpi -> twopass . kf_bits * //<S2SV> cpi -> output_framerate ) ; //<S2SV> } //<S2SV> cpi -> twopass . kf_group_error_left = ( int ) ( kf_group_err - kf_mod_err ) ; //<S2SV> cpi -> twopass . modified_error_left -= kf_group_err ; //<S2SV> if ( cpi -> oxcf . allow_spatial_resampling ) //<S2SV> { //<S2SV> int resample_trigger = 0 ; //<S2SV> int last_kf_resampled = 0 ; //<S2SV> int kf_q ; //<S2SV> int scale_val = 0 ; //<S2SV> int hr , hs , vr , vs ; //<S2SV> int new_width = cpi -> oxcf . Width ; //<S2SV> int new_height = cpi -> oxcf . Height ; //<S2SV> int projected_buffer_level ; //<S2SV> int tmp_q ; //<S2SV> double projected_bits_perframe ; //<S2SV> double group_iiratio = ( kf_group_intra_err - first_frame . intra_error ) / ( kf_group_coded_err - first_frame . coded_error ) ; //<S2SV> double err_per_frame = kf_group_err / cpi -> twopass . frames_to_key ; //<S2SV> double bits_per_frame ; //<S2SV> double av_bits_per_frame ; //<S2SV> double effective_size_ratio ; //<S2SV> if ( ( cpi -> common . Width != cpi -> oxcf . Width ) || ( cpi -> common . Height != cpi -> oxcf . Height ) ) //<S2SV> last_kf_resampled = 1 ; //<S2SV> cpi -> common . horiz_scale = NORMAL ; //<S2SV> cpi -> common . vert_scale = NORMAL ; //<S2SV> av_bits_per_frame = cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ; //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> bits_per_frame = av_bits_per_frame ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> bits_per_frame = ( double ) //<S2SV> ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) ; //<S2SV> if ( bits_per_frame < av_bits_per_frame ) //<S2SV> bits_per_frame = av_bits_per_frame ; //<S2SV> } //<S2SV> if ( bits_per_frame < ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ) //<S2SV> bits_per_frame = ( cpi -> oxcf . target_bandwidth * cpi -> oxcf . two_pass_vbrmin_section / 100 ) ; //<S2SV> kf_q = estimate_kf_group_q ( cpi , err_per_frame , //<S2SV> ( int ) bits_per_frame , group_iiratio ) ; //<S2SV> projected_bits_perframe = bits_per_frame ; //<S2SV> tmp_q = kf_q ; //<S2SV> while ( tmp_q > cpi -> worst_quality ) //<S2SV> { //<S2SV> projected_bits_perframe *= 1.04 ; //<S2SV> tmp_q -- ; //<S2SV> } //<S2SV> projected_buffer_level = ( int ) //<S2SV> ( cpi -> buffer_level - ( int ) //<S2SV> ( ( projected_bits_perframe - av_bits_per_frame ) * //<S2SV> cpi -> twopass . frames_to_key ) ) ; //<S2SV> if ( 0 ) //<S2SV> { //<S2SV> FILE * f = fopen ( "Subsamle.stt" , "a" ) ; //<S2SV> fprintf ( f , "<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%12.0f<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n" , cpi -> common . current_video_frame , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) //<S2SV> { //<S2SV> if ( ( projected_buffer_level < ( cpi -> oxcf . resample_down_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) || //<S2SV> ( last_kf_resampled && ( projected_buffer_level < ( cpi -> oxcf . resample_up_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ) ) ) //<S2SV> resample_trigger = 1 ; //<S2SV> else //<S2SV> resample_trigger = 0 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int64_t clip_bits = ( int64_t ) ( cpi -> twopass . total_stats . count * cpi -> oxcf . target_bandwidth / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> framerate ) ) ; //<S2SV> int64_t over_spend = cpi -> oxcf . starting_buffer_level - cpi -> buffer_level ; //<S2SV> if ( ( last_kf_resampled && ( kf_q > cpi -> worst_quality ) ) || //<S2SV> ( ( kf_q > cpi -> worst_quality ) && //<S2SV> ( over_spend > clip_bits / 20 ) ) ) //<S2SV> resample_trigger = 1 ; //<S2SV> else //<S2SV> resample_trigger = 0 ; //<S2SV> } //<S2SV> if ( resample_trigger ) //<S2SV> { //<S2SV> while ( ( kf_q >= cpi -> worst_quality ) && ( scale_val < 6 ) ) //<S2SV> { //<S2SV> scale_val ++ ; //<S2SV> cpi -> common . vert_scale = vscale_lookup [ scale_val ] ; //<S2SV> cpi -> common . horiz_scale = hscale_lookup [ scale_val ] ; //<S2SV> Scale2Ratio ( cpi -> common . horiz_scale , & hr , & hs ) ; //<S2SV> Scale2Ratio ( cpi -> common . vert_scale , & vr , & vs ) ; //<S2SV> new_width = ( ( hs - 1 ) + ( cpi -> oxcf . Width * hr ) ) / hs ; //<S2SV> new_height = ( ( vs - 1 ) + ( cpi -> oxcf . Height * vr ) ) / vs ; //<S2SV> effective_size_ratio = ( double ) ( new_width * new_height ) / ( double ) ( cpi -> oxcf . Width * cpi -> oxcf . Height ) ; //<S2SV> effective_size_ratio = ( 1.0 + ( 3.0 * effective_size_ratio ) ) / 4.0 ; //<S2SV> kf_q = estimate_kf_group_q ( cpi , //<S2SV> err_per_frame * effective_size_ratio , //<S2SV> ( int ) bits_per_frame , group_iiratio ) ; //<S2SV> if ( 0 ) //<S2SV> { //<S2SV> FILE * f = fopen ( "Subsamle.stt" , "a" ) ; //<S2SV> fprintf ( f , "********<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%12.0f<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n" , kf_q , cpi -> common . horiz_scale , cpi -> common . vert_scale , kf_group_err / cpi -> twopass . frames_to_key , ( int ) ( cpi -> twopass . kf_group_bits / cpi -> twopass . frames_to_key ) , new_height , new_width ) ; //<S2SV> fclose ( f ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( cpi -> common . Width != new_width ) || ( cpi -> common . Height != new_height ) ) //<S2SV> { //<S2SV> cpi -> common . Width = new_width ; //<S2SV> cpi -> common . Height = new_height ; //<S2SV> vp8_alloc_compressor_data ( cpi ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 