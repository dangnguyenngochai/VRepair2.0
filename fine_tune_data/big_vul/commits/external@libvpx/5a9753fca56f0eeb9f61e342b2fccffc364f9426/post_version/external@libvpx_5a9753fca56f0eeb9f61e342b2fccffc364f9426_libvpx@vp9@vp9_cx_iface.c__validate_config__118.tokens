static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , //<S2SV> const vpx_codec_enc_cfg_t * cfg , //<S2SV> const struct vp9_extracfg * extra_cfg ) { //<S2SV> RANGE_CHECK ( cfg , g_w , 1 , 65535 ) ; //<S2SV> RANGE_CHECK ( cfg , g_h , 1 , 65535 ) ; //<S2SV> RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; //<S2SV> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; //<S2SV> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; //<S2SV> RANGE_CHECK_BOOL ( extra_cfg , lossless ) ; //<S2SV> RANGE_CHECK ( extra_cfg , aq_mode , 0 , AQ_MODE_COUNT - 1 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , frame_periodic_boost , 0 , 1 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , g_lag_in_frames , MAX_LAG_BUFFERS ) ; //<S2SV> RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; //<S2SV> RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; //<S2SV> RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; //<S2SV> RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; //<S2SV> RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; //<S2SV> RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; //<S2SV> if ( extra_cfg -> max_gf_interval > 0 ) { //<S2SV> RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; //<S2SV> } //<S2SV> if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { //<S2SV> RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , //<S2SV> ( MAX_LAG_BUFFERS - 1 ) ) ; //<S2SV> } //<S2SV> if ( cfg -> rc_resize_allowed == 1 ) { //<S2SV> RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; //<S2SV> RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; //<S2SV> } //<S2SV> RANGE_CHECK ( cfg , ss_number_layers , 1 , VPX_SS_MAX_LAYERS ) ; //<S2SV> RANGE_CHECK ( cfg , ts_number_layers , 1 , VPX_TS_MAX_LAYERS ) ; //<S2SV> if ( cfg -> ss_number_layers * cfg -> ts_number_layers > VPX_MAX_LAYERS ) //<S2SV> ERROR ( "ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; //<S2SV> if ( cfg -> ts_number_layers > 1 ) { //<S2SV> unsigned int sl , tl ; //<S2SV> for ( sl = 1 ; sl < cfg -> ss_number_layers ; ++ sl ) { //<S2SV> for ( tl = 1 ; tl < cfg -> ts_number_layers ; ++ tl ) { //<S2SV> const int layer = //<S2SV> LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; //<S2SV> if ( cfg -> layer_target_bitrate [ layer ] < //<S2SV> cfg -> layer_target_bitrate [ layer - 1 ] ) //<S2SV> ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>increasing" ) ; //<S2SV> } //<S2SV> } //<S2SV> RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; //<S2SV> for ( tl = cfg -> ts_number_layers - 2 ; tl > 0 ; -- tl ) //<S2SV> if ( cfg -> ts_rate_decimator [ tl - 1 ] != 2 * cfg -> ts_rate_decimator [ tl ] ) //<S2SV> ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; //<S2SV> } //<S2SV> # if CONFIG_SPATIAL_SVC //<S2SV> if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && //<S2SV> cfg -> g_pass == VPX_RC_LAST_PASS ) { //<S2SV> unsigned int i , alt_ref_sum = 0 ; //<S2SV> for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { //<S2SV> if ( cfg -> ss_enable_auto_alt_ref [ i ] ) //<S2SV> ++ alt_ref_sum ; //<S2SV> } //<S2SV> if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) //<S2SV> ERROR ( "Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames" ) ; //<S2SV> if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && //<S2SV> cfg -> g_error_resilient == 0 ) //<S2SV> ERROR ( "Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( cfg -> kf_mode != VPX_KF_DISABLED && //<S2SV> cfg -> kf_min_dist != cfg -> kf_max_dist && //<S2SV> cfg -> kf_min_dist > 0 ) //<S2SV> ERROR ( "kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>" //<S2SV> "or<S2SV_blank>kf_max_dist<S2SV_blank>instead." ) ; //<S2SV> RANGE_CHECK ( extra_cfg , enable_auto_alt_ref , 0 , 2 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , cpu_used , - 8 , 8 ) ; //<S2SV> RANGE_CHECK_HI ( extra_cfg , noise_sensitivity , 6 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , tile_columns , 0 , 6 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , tile_rows , 0 , 2 ) ; //<S2SV> RANGE_CHECK_HI ( extra_cfg , sharpness , 7 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , arnr_max_frames , 0 , 15 ) ; //<S2SV> RANGE_CHECK_HI ( extra_cfg , arnr_strength , 6 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , cq_level , 0 , 63 ) ; //<S2SV> RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; //<S2SV> RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; //<S2SV> RANGE_CHECK ( extra_cfg , content , //<S2SV> VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 ) ; //<S2SV> if ( extra_cfg -> tuning == VP8_TUNE_SSIM ) //<S2SV> ERROR ( "Option<S2SV_blank>--tune=ssim<S2SV_blank>is<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>VP9." ) ; //<S2SV> if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { //<S2SV> const size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; //<S2SV> const int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; //<S2SV> const FIRSTPASS_STATS * stats ; //<S2SV> if ( cfg -> rc_twopass_stats_in . buf == NULL ) //<S2SV> ERROR ( "rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set." ) ; //<S2SV> if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) //<S2SV> ERROR ( "rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet." ) ; //<S2SV> if ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) { //<S2SV> int i ; //<S2SV> unsigned int n_packets_per_layer [ VPX_SS_MAX_LAYERS ] = { 0 } ; //<S2SV> stats = cfg -> rc_twopass_stats_in . buf ; //<S2SV> for ( i = 0 ; i < n_packets ; ++ i ) { //<S2SV> const int layer_id = ( int ) stats [ i ] . spatial_layer_id ; //<S2SV> if ( layer_id >= 0 && layer_id < ( int ) cfg -> ss_number_layers ) { //<S2SV> ++ n_packets_per_layer [ layer_id ] ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < ( int ) cfg -> ss_number_layers ; ++ i ) { //<S2SV> unsigned int layer_id ; //<S2SV> if ( n_packets_per_layer [ i ] < 2 ) { //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets<S2SV_blank>for<S2SV_blank>each<S2SV_blank>" //<S2SV> "layer." ) ; //<S2SV> } //<S2SV> stats = ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + //<S2SV> n_packets - cfg -> ss_number_layers + i ; //<S2SV> layer_id = ( int ) stats -> spatial_layer_id ; //<S2SV> if ( layer_id >= cfg -> ss_number_layers //<S2SV> || ( unsigned int ) ( stats -> count + 0.5 ) != //<S2SV> n_packets_per_layer [ layer_id ] - 1 ) //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets." ) ; //<S2SV> stats = //<S2SV> ( const FIRSTPASS_STATS * ) cfg -> rc_twopass_stats_in . buf + n_packets - 1 ; //<S2SV> if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; //<S2SV> } //<S2SV> } //<S2SV> # if ! CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { //<S2SV> ERROR ( "Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && //<S2SV> cfg -> g_bit_depth > VPX_BITS_8 ) { //<S2SV> ERROR ( "Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; //<S2SV> } //<S2SV> if ( cfg -> g_profile <= ( unsigned int ) PROFILE_1 && //<S2SV> cfg -> g_input_bit_depth > 8 ) { //<S2SV> ERROR ( "Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; //<S2SV> } //<S2SV> if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && //<S2SV> cfg -> g_bit_depth == VPX_BITS_8 ) { //<S2SV> ERROR ( "Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1" ) ; //<S2SV> } //<S2SV> RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB ) ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 