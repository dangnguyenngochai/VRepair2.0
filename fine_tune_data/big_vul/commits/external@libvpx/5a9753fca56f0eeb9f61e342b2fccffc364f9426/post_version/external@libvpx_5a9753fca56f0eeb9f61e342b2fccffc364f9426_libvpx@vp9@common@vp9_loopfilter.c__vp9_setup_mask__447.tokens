void vp9_setup_mask ( VP9_COMMON * const cm , const int mi_row , const int mi_col , //<S2SV> MODE_INFO * * mi , const int mode_info_stride , //<S2SV> LOOP_FILTER_MASK * lfm ) { //<S2SV> int idx_32 , idx_16 , idx_8 ; //<S2SV> const loop_filter_info_n * const lfi_n = & cm -> lf_info ; //<S2SV> MODE_INFO * * mip = mi ; //<S2SV> MODE_INFO * * mip2 = mi ; //<S2SV> const int offset_32 [ ] = { 4 , ( mode_info_stride << 2 ) - 4 , 4 , //<S2SV> - ( mode_info_stride << 2 ) - 4 } ; //<S2SV> const int offset_16 [ ] = { 2 , ( mode_info_stride << 1 ) - 2 , 2 , //<S2SV> - ( mode_info_stride << 1 ) - 2 } ; //<S2SV> const int offset [ ] = { 1 , mode_info_stride - 1 , 1 , - mode_info_stride - 1 } ; //<S2SV> const int shift_32_y [ ] = { 0 , 4 , 32 , 36 } ; //<S2SV> const int shift_16_y [ ] = { 0 , 2 , 16 , 18 } ; //<S2SV> const int shift_8_y [ ] = { 0 , 1 , 8 , 9 } ; //<S2SV> const int shift_32_uv [ ] = { 0 , 2 , 8 , 10 } ; //<S2SV> const int shift_16_uv [ ] = { 0 , 1 , 4 , 5 } ; //<S2SV> int i ; //<S2SV> const int max_rows = ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ? //<S2SV> cm -> mi_rows - mi_row : MI_BLOCK_SIZE ) ; //<S2SV> const int max_cols = ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ? //<S2SV> cm -> mi_cols - mi_col : MI_BLOCK_SIZE ) ; //<S2SV> vp9_zero ( * lfm ) ; //<S2SV> assert ( mip [ 0 ] != NULL ) ; //<S2SV> switch ( mip [ 0 ] -> mbmi . sb_type ) { //<S2SV> case BLOCK_64X64 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_64X32 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; //<S2SV> mip2 = mip + mode_info_stride * 4 ; //<S2SV> if ( 4 >= max_rows ) //<S2SV> break ; //<S2SV> build_masks ( lfi_n , mip2 [ 0 ] , 32 , 8 , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_32X64 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; //<S2SV> mip2 = mip + 4 ; //<S2SV> if ( 4 >= max_cols ) //<S2SV> break ; //<S2SV> build_masks ( lfi_n , mip2 [ 0 ] , 4 , 2 , lfm ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> for ( idx_32 = 0 ; idx_32 < 4 ; mip += offset_32 [ idx_32 ] , ++ idx_32 ) { //<S2SV> const int shift_y = shift_32_y [ idx_32 ] ; //<S2SV> const int shift_uv = shift_32_uv [ idx_32 ] ; //<S2SV> const int mi_32_col_offset = ( ( idx_32 & 1 ) << 2 ) ; //<S2SV> const int mi_32_row_offset = ( ( idx_32 >> 1 ) << 2 ) ; //<S2SV> if ( mi_32_col_offset >= max_cols || mi_32_row_offset >= max_rows ) //<S2SV> continue ; //<S2SV> switch ( mip [ 0 ] -> mbmi . sb_type ) { //<S2SV> case BLOCK_32X32 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_32X16 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> if ( mi_32_row_offset + 2 >= max_rows ) //<S2SV> continue ; //<S2SV> mip2 = mip + mode_info_stride * 2 ; //<S2SV> build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 16 , shift_uv + 4 , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_16X32 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> if ( mi_32_col_offset + 2 >= max_cols ) //<S2SV> continue ; //<S2SV> mip2 = mip + 2 ; //<S2SV> build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 2 , shift_uv + 1 , lfm ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> for ( idx_16 = 0 ; idx_16 < 4 ; mip += offset_16 [ idx_16 ] , ++ idx_16 ) { //<S2SV> const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] ; //<S2SV> const int shift_uv = shift_32_uv [ idx_32 ] + shift_16_uv [ idx_16 ] ; //<S2SV> const int mi_16_col_offset = mi_32_col_offset + //<S2SV> ( ( idx_16 & 1 ) << 1 ) ; //<S2SV> const int mi_16_row_offset = mi_32_row_offset + //<S2SV> ( ( idx_16 >> 1 ) << 1 ) ; //<S2SV> if ( mi_16_col_offset >= max_cols || mi_16_row_offset >= max_rows ) //<S2SV> continue ; //<S2SV> switch ( mip [ 0 ] -> mbmi . sb_type ) { //<S2SV> case BLOCK_16X16 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_16X8 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> if ( mi_16_row_offset + 1 >= max_rows ) //<S2SV> continue ; //<S2SV> mip2 = mip + mode_info_stride ; //<S2SV> build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 8 , lfm ) ; //<S2SV> break ; //<S2SV> case BLOCK_8X16 : //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> if ( mi_16_col_offset + 1 >= max_cols ) //<S2SV> continue ; //<S2SV> mip2 = mip + 1 ; //<S2SV> build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 1 , lfm ) ; //<S2SV> break ; //<S2SV> default : { //<S2SV> const int shift_y = shift_32_y [ idx_32 ] + //<S2SV> shift_16_y [ idx_16 ] + //<S2SV> shift_8_y [ 0 ] ; //<S2SV> build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; //<S2SV> mip += offset [ 0 ] ; //<S2SV> for ( idx_8 = 1 ; idx_8 < 4 ; mip += offset [ idx_8 ] , ++ idx_8 ) { //<S2SV> const int shift_y = shift_32_y [ idx_32 ] + //<S2SV> shift_16_y [ idx_16 ] + //<S2SV> shift_8_y [ idx_8 ] ; //<S2SV> const int mi_8_col_offset = mi_16_col_offset + //<S2SV> ( ( idx_8 & 1 ) ) ; //<S2SV> const int mi_8_row_offset = mi_16_row_offset + //<S2SV> ( ( idx_8 >> 1 ) ) ; //<S2SV> if ( mi_8_col_offset >= max_cols || //<S2SV> mi_8_row_offset >= max_rows ) //<S2SV> continue ; //<S2SV> build_y_mask ( lfi_n , mip [ 0 ] , shift_y , lfm ) ; //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> } //<S2SV> lfm -> left_y [ TX_16X16 ] |= lfm -> left_y [ TX_32X32 ] ; //<S2SV> lfm -> above_y [ TX_16X16 ] |= lfm -> above_y [ TX_32X32 ] ; //<S2SV> lfm -> left_uv [ TX_16X16 ] |= lfm -> left_uv [ TX_32X32 ] ; //<S2SV> lfm -> above_uv [ TX_16X16 ] |= lfm -> above_uv [ TX_32X32 ] ; //<S2SV> lfm -> left_y [ TX_8X8 ] |= lfm -> left_y [ TX_4X4 ] & left_border ; //<S2SV> lfm -> left_y [ TX_4X4 ] &= ~ left_border ; //<S2SV> lfm -> above_y [ TX_8X8 ] |= lfm -> above_y [ TX_4X4 ] & above_border ; //<S2SV> lfm -> above_y [ TX_4X4 ] &= ~ above_border ; //<S2SV> lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_4X4 ] & left_border_uv ; //<S2SV> lfm -> left_uv [ TX_4X4 ] &= ~ left_border_uv ; //<S2SV> lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_4X4 ] & above_border_uv ; //<S2SV> lfm -> above_uv [ TX_4X4 ] &= ~ above_border_uv ; //<S2SV> if ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ) { //<S2SV> const uint64_t rows = cm -> mi_rows - mi_row ; //<S2SV> const uint64_t mask_y = ( ( ( uint64_t ) 1 << ( rows << 3 ) ) - 1 ) ; //<S2SV> const uint16_t mask_uv = ( ( ( uint16_t ) 1 << ( ( ( rows + 1 ) >> 1 ) << 2 ) ) - 1 ) ; //<S2SV> for ( i = 0 ; i < TX_32X32 ; i ++ ) { //<S2SV> lfm -> left_y [ i ] &= mask_y ; //<S2SV> lfm -> above_y [ i ] &= mask_y ; //<S2SV> lfm -> left_uv [ i ] &= mask_uv ; //<S2SV> lfm -> above_uv [ i ] &= mask_uv ; //<S2SV> } //<S2SV> lfm -> int_4x4_y &= mask_y ; //<S2SV> lfm -> int_4x4_uv &= mask_uv ; //<S2SV> if ( rows == 1 ) { //<S2SV> lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] ; //<S2SV> lfm -> above_uv [ TX_16X16 ] = 0 ; //<S2SV> } //<S2SV> if ( rows == 5 ) { //<S2SV> lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] & 0xff00 ; //<S2SV> lfm -> above_uv [ TX_16X16 ] &= ~ ( lfm -> above_uv [ TX_16X16 ] & 0xff00 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ) { //<S2SV> const uint64_t columns = cm -> mi_cols - mi_col ; //<S2SV> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101ULL ; //<S2SV> const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ; //<S2SV> const uint16_t mask_uv_int = ( ( 1 << ( columns >> 1 ) ) - 1 ) * 0x1111 ; //<S2SV> for ( i = 0 ; i < TX_32X32 ; i ++ ) { //<S2SV> lfm -> left_y [ i ] &= mask_y ; //<S2SV> lfm -> above_y [ i ] &= mask_y ; //<S2SV> lfm -> left_uv [ i ] &= mask_uv ; //<S2SV> lfm -> above_uv [ i ] &= mask_uv ; //<S2SV> } //<S2SV> lfm -> int_4x4_y &= mask_y ; //<S2SV> lfm -> int_4x4_uv &= mask_uv_int ; //<S2SV> if ( columns == 1 ) { //<S2SV> lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_16X16 ] ; //<S2SV> lfm -> left_uv [ TX_16X16 ] = 0 ; //<S2SV> } //<S2SV> if ( columns == 5 ) { //<S2SV> lfm -> left_uv [ TX_8X8 ] |= ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; //<S2SV> lfm -> left_uv [ TX_16X16 ] &= ~ ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mi_col == 0 ) { //<S2SV> for ( i = 0 ; i < TX_32X32 ; i ++ ) { //<S2SV> lfm -> left_y [ i ] &= 0xfefefefefefefefeULL ; //<S2SV> lfm -> left_uv [ i ] &= 0xeeee ; //<S2SV> } //<S2SV> } //<S2SV> assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_8X8 ] ) ) ; //<S2SV> assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> left_y [ TX_8X8 ] & lfm -> left_y [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> int_4x4_y & lfm -> left_y [ TX_16X16 ] ) ) ; //<S2SV> assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_8X8 ] ) ) ; //<S2SV> assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> left_uv [ TX_8X8 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> int_4x4_uv & lfm -> left_uv [ TX_16X16 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_8X8 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_y [ TX_8X8 ] & lfm -> above_y [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> int_4x4_y & lfm -> above_y [ TX_16X16 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_8X8 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> above_uv [ TX_8X8 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; //<S2SV> assert ( ! ( lfm -> int_4x4_uv & lfm -> above_uv [ TX_16X16 ] ) ) ; //<S2SV> } //<S2SV> 