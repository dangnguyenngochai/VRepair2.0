void vp9_choose_segmap_coding_method ( VP9_COMMON * cm , MACROBLOCKD * xd ) { //<S2SV> struct segmentation * seg = & cm -> seg ; //<S2SV> int no_pred_cost ; //<S2SV> int t_pred_cost = INT_MAX ; //<S2SV> int i , tile_col , mi_row , mi_col ; //<S2SV> int temporal_predictor_count [ PREDICTION_PROBS ] [ 2 ] = { { 0 } } ; //<S2SV> int no_pred_segcounts [ MAX_SEGMENTS ] = { 0 } ; //<S2SV> int t_unpred_seg_counts [ MAX_SEGMENTS ] = { 0 } ; //<S2SV> vpx_prob no_pred_tree [ SEG_TREE_PROBS ] ; //<S2SV> vpx_prob t_pred_tree [ SEG_TREE_PROBS ] ; //<S2SV> vpx_prob t_nopred_prob [ PREDICTION_PROBS ] ; //<S2SV> memset ( seg -> tree_probs , 255 , sizeof ( seg -> tree_probs ) ) ; //<S2SV> memset ( seg -> pred_probs , 255 , sizeof ( seg -> pred_probs ) ) ; //<S2SV> for ( tile_col = 0 ; tile_col < 1 << cm -> log2_tile_cols ; tile_col ++ ) { //<S2SV> TileInfo tile ; //<S2SV> MODE_INFO * * mi_ptr ; //<S2SV> vp9_tile_init ( & tile , cm , 0 , tile_col ) ; //<S2SV> mi_ptr = cm -> mi_grid_visible + tile . mi_col_start ; //<S2SV> for ( mi_row = 0 ; mi_row < cm -> mi_rows ; //<S2SV> mi_row += 8 , mi_ptr += 8 * cm -> mi_stride ) { //<S2SV> MODE_INFO * * mi = mi_ptr ; //<S2SV> for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; //<S2SV> mi_col += 8 , mi += 8 ) //<S2SV> count_segs_sb ( cm , xd , & tile , mi , no_pred_segcounts , //<S2SV> temporal_predictor_count , t_unpred_seg_counts , //<S2SV> mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> } //<S2SV> } //<S2SV> calc_segtree_probs ( no_pred_segcounts , no_pred_tree ) ; //<S2SV> no_pred_cost = cost_segmap ( no_pred_segcounts , no_pred_tree ) ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> calc_segtree_probs ( t_unpred_seg_counts , t_pred_tree ) ; //<S2SV> t_pred_cost = cost_segmap ( t_unpred_seg_counts , t_pred_tree ) ; //<S2SV> for ( i = 0 ; i < PREDICTION_PROBS ; i ++ ) { //<S2SV> const int count0 = temporal_predictor_count [ i ] [ 0 ] ; //<S2SV> const int count1 = temporal_predictor_count [ i ] [ 1 ] ; //<S2SV> t_nopred_prob [ i ] = get_binary_prob ( count0 , count1 ) ; //<S2SV> t_pred_cost += count0 * vp9_cost_zero ( t_nopred_prob [ i ] ) + //<S2SV> count1 * vp9_cost_one ( t_nopred_prob [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( t_pred_cost < no_pred_cost ) { //<S2SV> seg -> temporal_update = 1 ; //<S2SV> memcpy ( seg -> tree_probs , t_pred_tree , sizeof ( t_pred_tree ) ) ; //<S2SV> memcpy ( seg -> pred_probs , t_nopred_prob , sizeof ( t_nopred_prob ) ) ; //<S2SV> } else { //<S2SV> seg -> temporal_update = 0 ; //<S2SV> memcpy ( seg -> tree_probs , no_pred_tree , sizeof ( no_pred_tree ) ) ; //<S2SV> } //<S2SV> } //<S2SV> 