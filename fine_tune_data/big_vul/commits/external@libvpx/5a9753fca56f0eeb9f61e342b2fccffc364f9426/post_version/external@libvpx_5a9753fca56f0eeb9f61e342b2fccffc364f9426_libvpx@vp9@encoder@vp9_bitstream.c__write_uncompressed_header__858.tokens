static void write_uncompressed_header ( VP9_COMP * cpi , //<S2SV> struct vpx_write_bit_buffer * wb ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; //<S2SV> vpx_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; //<S2SV> write_profile ( cm -> profile , wb ) ; //<S2SV> vpx_wb_write_bit ( wb , 0 ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> frame_type ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> show_frame ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> error_resilient_mode ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) { //<S2SV> write_sync_code ( wb ) ; //<S2SV> write_bitdepth_colorspace_sampling ( cm , wb ) ; //<S2SV> write_frame_size ( cm , wb ) ; //<S2SV> } else { //<S2SV> if ( ! cm -> show_frame ) //<S2SV> vpx_wb_write_bit ( wb , cm -> intra_only ) ; //<S2SV> if ( ! cm -> error_resilient_mode ) //<S2SV> vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; //<S2SV> if ( cm -> intra_only ) { //<S2SV> write_sync_code ( wb ) ; //<S2SV> if ( cm -> profile > PROFILE_0 ) { //<S2SV> write_bitdepth_colorspace_sampling ( cm , wb ) ; //<S2SV> } //<S2SV> vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; //<S2SV> write_frame_size ( cm , wb ) ; //<S2SV> } else { //<S2SV> MV_REFERENCE_FRAME ref_frame ; //<S2SV> vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; //<S2SV> vpx_wb_write_literal ( wb , get_ref_frame_map_idx ( cpi , ref_frame ) , //<S2SV> REF_FRAMES_LOG2 ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> ref_frame_sign_bias [ ref_frame ] ) ; //<S2SV> } //<S2SV> write_frame_size_with_refs ( cpi , wb ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> allow_high_precision_mv ) ; //<S2SV> fix_interp_filter ( cm , cpi -> td . counts ) ; //<S2SV> write_interp_filter ( cm -> interp_filter , wb ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! cm -> error_resilient_mode ) { //<S2SV> vpx_wb_write_bit ( wb , cm -> refresh_frame_context ) ; //<S2SV> vpx_wb_write_bit ( wb , cm -> frame_parallel_decoding_mode ) ; //<S2SV> } //<S2SV> vpx_wb_write_literal ( wb , cm -> frame_context_idx , FRAME_CONTEXTS_LOG2 ) ; //<S2SV> encode_loopfilter ( & cm -> lf , wb ) ; //<S2SV> encode_quantization ( cm , wb ) ; //<S2SV> encode_segmentation ( cm , xd , wb ) ; //<S2SV> write_tile_info ( cm , wb ) ; //<S2SV> } //<S2SV> 