void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , //<S2SV> int recon_uvoffset , int * returnrate , //<S2SV> int * returndistortion , int * returnintra , //<S2SV> int mb_row , int mb_col ) //<S2SV> { //<S2SV> BLOCK * b = & x -> block [ 0 ] ; //<S2SV> BLOCKD * d = & x -> e_mbd . block [ 0 ] ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> int_mv best_ref_mv_sb [ 2 ] ; //<S2SV> int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; //<S2SV> int_mv best_ref_mv ; //<S2SV> int_mv * mode_mv ; //<S2SV> MB_PREDICTION_MODE this_mode ; //<S2SV> int num00 ; //<S2SV> int best_mode_index = 0 ; //<S2SV> BEST_MODE best_mode ; //<S2SV> int i ; //<S2SV> int mode_index ; //<S2SV> int mdcounts [ 4 ] ; //<S2SV> int rate ; //<S2SV> RATE_DISTORTION rd ; //<S2SV> int uv_intra_rate , uv_intra_distortion , uv_intra_rate_tokenonly ; //<S2SV> int uv_intra_tteob = 0 ; //<S2SV> int uv_intra_done = 0 ; //<S2SV> MB_PREDICTION_MODE uv_intra_mode = 0 ; //<S2SV> int_mv mvp ; //<S2SV> int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; //<S2SV> int saddone = 0 ; //<S2SV> int sr = 0 ; //<S2SV> unsigned char * plane [ 4 ] [ 3 ] ; //<S2SV> int ref_frame_map [ 4 ] ; //<S2SV> int sign_bias = 0 ; //<S2SV> int intra_rd_penalty = 10 * vp8_dc_quant ( cpi -> common . base_qindex , //<S2SV> cpi -> common . y1dc_delta_q ) ; //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> unsigned int zero_mv_sse = UINT_MAX , best_sse = UINT_MAX , //<S2SV> best_rd_sse = UINT_MAX ; //<S2SV> # endif //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = 0 ; //<S2SV> best_mode . rd = INT_MAX ; //<S2SV> best_mode . yrd = INT_MAX ; //<S2SV> best_mode . intra_rd = INT_MAX ; //<S2SV> memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; //<S2SV> memset ( & best_mode . mbmode , 0 , sizeof ( best_mode . mbmode ) ) ; //<S2SV> memset ( & best_mode . bmodes , 0 , sizeof ( best_mode . bmodes ) ) ; //<S2SV> get_reference_search_order ( cpi , ref_frame_map ) ; //<S2SV> if ( ref_frame_map [ 1 ] > 0 ) //<S2SV> { //<S2SV> sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , //<S2SV> x -> e_mbd . mode_info_context , //<S2SV> mode_mv_sb , //<S2SV> best_ref_mv_sb , //<S2SV> mdcounts , //<S2SV> ref_frame_map [ 1 ] , //<S2SV> cpi -> common . ref_frame_sign_bias ) ; //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; //<S2SV> } //<S2SV> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; //<S2SV> * returnintra = INT_MAX ; //<S2SV> x -> mbs_tested_so_far ++ ; //<S2SV> x -> skip = 0 ; //<S2SV> for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) //<S2SV> { //<S2SV> int this_rd = INT_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int other_cost = 0 ; //<S2SV> int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; //<S2SV> if ( best_mode . rd <= x -> rd_threshes [ mode_index ] ) //<S2SV> continue ; //<S2SV> if ( this_ref_frame < 0 ) //<S2SV> continue ; //<S2SV> rd . rate2 = 0 ; //<S2SV> rd . distortion2 = 0 ; //<S2SV> this_mode = vp8_mode_order [ mode_index ] ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; //<S2SV> if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) //<S2SV> { //<S2SV> if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) //<S2SV> { //<S2SV> x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; //<S2SV> x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; //<S2SV> x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; //<S2SV> if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) //<S2SV> { //<S2SV> sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; //<S2SV> mode_mv = mode_mv_sb [ sign_bias ] ; //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) //<S2SV> { //<S2SV> if ( x -> mbs_tested_so_far <= cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) //<S2SV> { //<S2SV> x -> rd_thresh_mult [ mode_index ] += 4 ; //<S2SV> if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) //<S2SV> x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; //<S2SV> x -> rd_threshes [ mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ mode_index ] ; //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> x -> mode_test_hit_counts [ mode_index ] ++ ; //<S2SV> if ( x -> zbin_mode_boost_enabled ) //<S2SV> { //<S2SV> if ( this_ref_frame == INTRA_FRAME ) //<S2SV> x -> zbin_mode_boost = 0 ; //<S2SV> else //<S2SV> { //<S2SV> if ( vp8_mode_order [ mode_index ] == ZEROMV ) //<S2SV> { //<S2SV> if ( this_ref_frame != LAST_FRAME ) //<S2SV> x -> zbin_mode_boost = GF_ZEROMV_ZBIN_BOOST ; //<S2SV> else //<S2SV> x -> zbin_mode_boost = LF_ZEROMV_ZBIN_BOOST ; //<S2SV> } //<S2SV> else if ( vp8_mode_order [ mode_index ] == SPLITMV ) //<S2SV> x -> zbin_mode_boost = 0 ; //<S2SV> else //<S2SV> x -> zbin_mode_boost = MV_ZBIN_BOOST ; //<S2SV> } //<S2SV> vp8_update_zbin_extra ( cpi , x ) ; //<S2SV> } //<S2SV> if ( ! uv_intra_done && this_ref_frame == INTRA_FRAME ) //<S2SV> { //<S2SV> rd_pick_intra_mbuv_mode ( x , & uv_intra_rate , //<S2SV> & uv_intra_rate_tokenonly , //<S2SV> & uv_intra_distortion ) ; //<S2SV> uv_intra_mode = x -> e_mbd . mode_info_context -> mbmi . uv_mode ; //<S2SV> for ( i = 16 ; i < 24 ; i ++ ) //<S2SV> uv_intra_tteob += x -> e_mbd . eobs [ i ] ; //<S2SV> uv_intra_done = 1 ; //<S2SV> } //<S2SV> switch ( this_mode ) //<S2SV> { //<S2SV> case B_PRED : //<S2SV> { //<S2SV> int tmp_rd ; //<S2SV> int distortion ; //<S2SV> tmp_rd = rd_pick_intra4x4mby_modes ( x , & rate , & rd . rate_y , & distortion , best_mode . yrd ) ; //<S2SV> rd . rate2 += rate ; //<S2SV> rd . distortion2 += distortion ; //<S2SV> if ( tmp_rd < best_mode . yrd ) //<S2SV> { //<S2SV> rd . rate2 += uv_intra_rate ; //<S2SV> rd . rate_uv = uv_intra_rate_tokenonly ; //<S2SV> rd . distortion2 += uv_intra_distortion ; //<S2SV> rd . distortion_uv = uv_intra_distortion ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> this_rd = INT_MAX ; //<S2SV> disable_skip = 1 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case SPLITMV : //<S2SV> { //<S2SV> int tmp_rd ; //<S2SV> int this_rd_thresh ; //<S2SV> int distortion ; //<S2SV> this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 1 ) ? //<S2SV> x -> rd_threshes [ THR_NEW1 ] : x -> rd_threshes [ THR_NEW3 ] ; //<S2SV> this_rd_thresh = ( vp8_ref_frame_order [ mode_index ] == 2 ) ? //<S2SV> x -> rd_threshes [ THR_NEW2 ] : this_rd_thresh ; //<S2SV> tmp_rd = vp8_rd_pick_best_mbsegmentation ( cpi , x , & best_ref_mv , //<S2SV> best_mode . yrd , mdcounts , //<S2SV> & rate , & rd . rate_y , & distortion , this_rd_thresh ) ; //<S2SV> rd . rate2 += rate ; //<S2SV> rd . distortion2 += distortion ; //<S2SV> if ( tmp_rd < best_mode . yrd ) //<S2SV> { //<S2SV> rd_inter4x4_uv ( cpi , x , & rd . rate_uv , & rd . distortion_uv , cpi -> common . full_pixel ) ; //<S2SV> rd . rate2 += rd . rate_uv ; //<S2SV> rd . distortion2 += rd . distortion_uv ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> this_rd = INT_MAX ; //<S2SV> disable_skip = 1 ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case DC_PRED : //<S2SV> case V_PRED : //<S2SV> case H_PRED : //<S2SV> case TM_PRED : //<S2SV> { //<S2SV> int distortion ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; //<S2SV> vp8_build_intra_predictors_mby_s ( xd , //<S2SV> xd -> dst . y_buffer - xd -> dst . y_stride , //<S2SV> xd -> dst . y_buffer - 1 , //<S2SV> xd -> dst . y_stride , //<S2SV> xd -> predictor , //<S2SV> 16 ) ; //<S2SV> macro_block_yrd ( x , & rd . rate_y , & distortion ) ; //<S2SV> rd . rate2 += rd . rate_y ; //<S2SV> rd . distortion2 += distortion ; //<S2SV> rd . rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; //<S2SV> rd . rate2 += uv_intra_rate ; //<S2SV> rd . rate_uv = uv_intra_rate_tokenonly ; //<S2SV> rd . distortion2 += uv_intra_distortion ; //<S2SV> rd . distortion_uv = uv_intra_distortion ; //<S2SV> } //<S2SV> break ; //<S2SV> case NEWMV : //<S2SV> { //<S2SV> int thissme ; //<S2SV> int bestsme = INT_MAX ; //<S2SV> int step_param = cpi -> sf . first_step ; //<S2SV> int further_steps ; //<S2SV> int n ; //<S2SV> int do_refine = 1 ; //<S2SV> int sadpb = x -> sadperbit16 ; //<S2SV> int_mv mvp_full ; //<S2SV> int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; //<S2SV> int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; //<S2SV> int tmp_col_min = x -> mv_col_min ; //<S2SV> int tmp_col_max = x -> mv_col_max ; //<S2SV> int tmp_row_min = x -> mv_row_min ; //<S2SV> int tmp_row_max = x -> mv_row_max ; //<S2SV> if ( ! saddone ) //<S2SV> { //<S2SV> vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; //<S2SV> saddone = 1 ; //<S2SV> } //<S2SV> vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ; //<S2SV> mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; //<S2SV> mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; //<S2SV> if ( x -> mv_col_min < col_min ) //<S2SV> x -> mv_col_min = col_min ; //<S2SV> if ( x -> mv_col_max > col_max ) //<S2SV> x -> mv_col_max = col_max ; //<S2SV> if ( x -> mv_row_min < row_min ) //<S2SV> x -> mv_row_min = row_min ; //<S2SV> if ( x -> mv_row_max > row_max ) //<S2SV> x -> mv_row_max = row_max ; //<S2SV> if ( sr > step_param ) //<S2SV> step_param = sr ; //<S2SV> { //<S2SV> bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , //<S2SV> step_param , sadpb , & num00 , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvcost , & best_ref_mv ) ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; //<S2SV> n = num00 ; //<S2SV> num00 = 0 ; //<S2SV> if ( n > further_steps ) //<S2SV> do_refine = 0 ; //<S2SV> while ( n < further_steps ) //<S2SV> { //<S2SV> n ++ ; //<S2SV> if ( num00 ) //<S2SV> num00 -- ; //<S2SV> else //<S2SV> { //<S2SV> thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , //<S2SV> & d -> bmi . mv , step_param + n , sadpb , & num00 , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , //<S2SV> & best_ref_mv ) ; //<S2SV> if ( num00 > ( further_steps - n ) ) //<S2SV> do_refine = 0 ; //<S2SV> if ( thissme < bestsme ) //<S2SV> { //<S2SV> bestsme = thissme ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( do_refine == 1 ) //<S2SV> { //<S2SV> int search_range ; //<S2SV> search_range = 8 ; //<S2SV> thissme = cpi -> refining_search_sad ( x , b , d , & d -> bmi . mv , sadpb , //<S2SV> search_range , & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvcost , & best_ref_mv ) ; //<S2SV> if ( thissme < bestsme ) //<S2SV> { //<S2SV> bestsme = thissme ; //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> x -> mv_col_min = tmp_col_min ; //<S2SV> x -> mv_col_max = tmp_col_max ; //<S2SV> x -> mv_row_min = tmp_row_min ; //<S2SV> x -> mv_row_max = tmp_row_max ; //<S2SV> if ( bestsme < INT_MAX ) //<S2SV> { //<S2SV> int dis ; //<S2SV> unsigned int sse ; //<S2SV> cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , //<S2SV> x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ BLOCK_16X16 ] , //<S2SV> x -> mvcost , & dis , & sse ) ; //<S2SV> } //<S2SV> mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; //<S2SV> rd . rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , x -> mvcost , 96 ) ; //<S2SV> } //<S2SV> case NEARESTMV : //<S2SV> case NEARMV : //<S2SV> vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; //<S2SV> if ( ( ( this_mode == NEARMV ) || ( this_mode == NEARESTMV ) ) && ( mode_mv [ this_mode ] . as_int == 0 ) ) //<S2SV> continue ; //<S2SV> case ZEROMV : //<S2SV> if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || //<S2SV> ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) //<S2SV> continue ; //<S2SV> vp8_set_mbmode_and_mvs ( x , this_mode , & mode_mv [ this_mode ] ) ; //<S2SV> this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , //<S2SV> & disable_skip , cpi , x ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , //<S2SV> disable_skip , uv_intra_tteob , //<S2SV> intra_rd_penalty , cpi , x ) ; //<S2SV> if ( ( x -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) && //<S2SV> ( this_rd < best_mode . intra_rd ) ) //<S2SV> { //<S2SV> best_mode . intra_rd = this_rd ; //<S2SV> * returnintra = rd . distortion2 ; //<S2SV> } //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity ) //<S2SV> { //<S2SV> unsigned int sse ; //<S2SV> vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & sse , //<S2SV> mode_mv [ this_mode ] ) ; //<S2SV> if ( sse < best_rd_sse ) //<S2SV> best_rd_sse = sse ; //<S2SV> if ( this_mode == ZEROMV && sse < zero_mv_sse ) //<S2SV> { //<S2SV> zero_mv_sse = sse ; //<S2SV> x -> best_zeromv_reference_frame = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame ; //<S2SV> } //<S2SV> if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && //<S2SV> sse < best_sse ) //<S2SV> { //<S2SV> best_sse = sse ; //<S2SV> vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , & best_sse , //<S2SV> mode_mv [ this_mode ] ) ; //<S2SV> x -> best_sse_inter_mode = NEWMV ; //<S2SV> x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; //<S2SV> x -> need_to_clamp_best_mvs = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; //<S2SV> x -> best_reference_frame = //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( this_rd < best_mode . rd || x -> skip ) //<S2SV> { //<S2SV> best_mode_index = mode_index ; //<S2SV> * returnrate = rd . rate2 ; //<S2SV> * returndistortion = rd . distortion2 ; //<S2SV> if ( this_mode <= B_PRED ) //<S2SV> { //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = uv_intra_mode ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; //<S2SV> } //<S2SV> update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; //<S2SV> x -> rd_thresh_mult [ mode_index ] = //<S2SV> ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? //<S2SV> x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> x -> rd_thresh_mult [ mode_index ] += 4 ; //<S2SV> if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) //<S2SV> x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; //<S2SV> } //<S2SV> x -> rd_threshes [ mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ mode_index ] ; //<S2SV> if ( x -> skip ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) //<S2SV> { //<S2SV> int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 2 ) ; //<S2SV> x -> rd_thresh_mult [ best_mode_index ] = //<S2SV> ( x -> rd_thresh_mult [ best_mode_index ] >= //<S2SV> ( MIN_THRESHMULT + best_adjustment ) ) ? //<S2SV> x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : //<S2SV> MIN_THRESHMULT ; //<S2SV> x -> rd_threshes [ best_mode_index ] = //<S2SV> ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * //<S2SV> x -> rd_thresh_mult [ best_mode_index ] ; //<S2SV> } //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity ) //<S2SV> { //<S2SV> int block_index = mb_row * cpi -> common . mb_cols + mb_col ; //<S2SV> if ( x -> best_sse_inter_mode == DC_PRED ) //<S2SV> { //<S2SV> x -> best_sse_inter_mode = best_mode . mbmode . mode ; //<S2SV> x -> best_sse_mv = best_mode . mbmode . mv ; //<S2SV> x -> need_to_clamp_best_mvs = best_mode . mbmode . need_to_clamp_mvs ; //<S2SV> x -> best_reference_frame = best_mode . mbmode . ref_frame ; //<S2SV> best_sse = best_rd_sse ; //<S2SV> } //<S2SV> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , //<S2SV> recon_yoffset , recon_uvoffset , //<S2SV> & cpi -> common . lf_info , mb_row , mb_col , //<S2SV> block_index ) ; //<S2SV> if ( best_mode . mbmode . ref_frame == INTRA_FRAME && //<S2SV> x -> best_zeromv_reference_frame != INTRA_FRAME ) //<S2SV> { //<S2SV> int this_rd = INT_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int other_cost = 0 ; //<S2SV> int this_ref_frame = x -> best_zeromv_reference_frame ; //<S2SV> rd . rate2 = x -> ref_frame_cost [ this_ref_frame ] + //<S2SV> vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; //<S2SV> rd . distortion2 = 0 ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; //<S2SV> x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; //<S2SV> x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; //<S2SV> x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; //<S2SV> this_rd = evaluate_inter_mode_rd ( mdcounts , & rd , & disable_skip , cpi , x ) ; //<S2SV> this_rd = calculate_final_rd_costs ( this_rd , & rd , & other_cost , //<S2SV> disable_skip , uv_intra_tteob , //<S2SV> intra_rd_penalty , cpi , x ) ; //<S2SV> if ( this_rd < best_mode . rd || x -> skip ) //<S2SV> { //<S2SV> * returnrate = rd . rate2 ; //<S2SV> * returndistortion = rd . distortion2 ; //<S2SV> update_best_mode ( & best_mode , this_rd , & rd , other_cost , x ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( cpi -> is_src_frame_alt_ref && //<S2SV> ( best_mode . mbmode . mode != ZEROMV || best_mode . mbmode . ref_frame != ALTREF_FRAME ) ) //<S2SV> { //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = //<S2SV> ( cpi -> common . mb_no_coeff_skip ) ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mode . mbmode , sizeof ( MB_MODE_INFO ) ) ; //<S2SV> if ( best_mode . mbmode . mode == B_PRED ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> xd -> mode_info_context -> bmi [ i ] . as_mode = best_mode . bmodes [ i ] . as_mode ; //<S2SV> } //<S2SV> if ( best_mode . mbmode . mode == SPLITMV ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> xd -> mode_info_context -> bmi [ i ] . mv . as_int = best_mode . bmodes [ i ] . mv . as_int ; //<S2SV> memcpy ( x -> partition_info , & best_mode . partition , sizeof ( PARTITION_INFO ) ) ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . mv . as_int = //<S2SV> x -> partition_info -> bmi [ 15 ] . mv . as_int ; //<S2SV> } //<S2SV> if ( sign_bias //<S2SV> != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) //<S2SV> best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; //<S2SV> rd_update_mvcount ( x , & best_ref_mv ) ; //<S2SV> } //<S2SV> 