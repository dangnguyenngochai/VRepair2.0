void vp8_alloc_compressor_data ( VP8_COMP * cpi ) //<S2SV> { //<S2SV> VP8_COMMON * cm = & cpi -> common ; //<S2SV> int width = cm -> Width ; //<S2SV> int height = cm -> Height ; //<S2SV> if ( vp8_alloc_frame_buffers ( cm , width , height ) ) //<S2SV> vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame<S2SV_blank>buffers" ) ; //<S2SV> if ( vp8_alloc_partition_data ( cpi ) ) //<S2SV> vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>partition<S2SV_blank>data" ) ; //<S2SV> if ( ( width & 0xf ) != 0 ) //<S2SV> width += 16 - ( width & 0xf ) ; //<S2SV> if ( ( height & 0xf ) != 0 ) //<S2SV> height += 16 - ( height & 0xf ) ; //<S2SV> if ( vp8_yv12_alloc_frame_buffer ( & cpi -> pick_lf_lvl_frame , //<S2SV> width , height , VP8BORDERINPIXELS ) ) //<S2SV> vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>last<S2SV_blank>frame<S2SV_blank>buffer" ) ; //<S2SV> if ( vp8_yv12_alloc_frame_buffer ( & cpi -> scaled_source , //<S2SV> width , height , VP8BORDERINPIXELS ) ) //<S2SV> vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>scaled<S2SV_blank>source<S2SV_blank>buffer" ) ; //<S2SV> vpx_free ( cpi -> tok ) ; //<S2SV> { //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> unsigned int tokens = 8 * 24 * 16 ; //<S2SV> # else //<S2SV> unsigned int tokens = cm -> mb_rows * cm -> mb_cols * 24 * 16 ; //<S2SV> # endif //<S2SV> CHECK_MEM_ERROR ( cpi -> tok , vpx_calloc ( tokens , sizeof ( * cpi -> tok ) ) ) ; //<S2SV> } //<S2SV> cpi -> zeromv_count = 0 ; //<S2SV> vpx_free ( cpi -> gf_active_flags ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> gf_active_flags , //<S2SV> vpx_calloc ( sizeof ( * cpi -> gf_active_flags ) , //<S2SV> cm -> mb_rows * cm -> mb_cols ) ) ; //<S2SV> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; //<S2SV> vpx_free ( cpi -> mb_activity_map ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> mb_activity_map , //<S2SV> vpx_calloc ( sizeof ( * cpi -> mb_activity_map ) , //<S2SV> cm -> mb_rows * cm -> mb_cols ) ) ; //<S2SV> vpx_free ( cpi -> lfmv ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> lfmv , vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , //<S2SV> sizeof ( * cpi -> lfmv ) ) ) ; //<S2SV> vpx_free ( cpi -> lf_ref_frame_sign_bias ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> lf_ref_frame_sign_bias , //<S2SV> vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , //<S2SV> sizeof ( * cpi -> lf_ref_frame_sign_bias ) ) ) ; //<S2SV> vpx_free ( cpi -> lf_ref_frame ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> lf_ref_frame , //<S2SV> vpx_calloc ( ( cm -> mb_rows + 2 ) * ( cm -> mb_cols + 2 ) , //<S2SV> sizeof ( * cpi -> lf_ref_frame ) ) ) ; //<S2SV> vpx_free ( cpi -> segmentation_map ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> segmentation_map , //<S2SV> vpx_calloc ( cm -> mb_rows * cm -> mb_cols , //<S2SV> sizeof ( * cpi -> segmentation_map ) ) ) ; //<S2SV> cpi -> cyclic_refresh_mode_index = 0 ; //<S2SV> vpx_free ( cpi -> active_map ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> active_map , //<S2SV> vpx_calloc ( cm -> mb_rows * cm -> mb_cols , //<S2SV> sizeof ( * cpi -> active_map ) ) ) ; //<S2SV> memset ( cpi -> active_map , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( width < 640 ) //<S2SV> cpi -> mt_sync_range = 1 ; //<S2SV> else if ( width <= 1280 ) //<S2SV> cpi -> mt_sync_range = 4 ; //<S2SV> else if ( width <= 2560 ) //<S2SV> cpi -> mt_sync_range = 8 ; //<S2SV> else //<S2SV> cpi -> mt_sync_range = 16 ; //<S2SV> if ( cpi -> oxcf . multi_threaded > 1 ) //<S2SV> { //<S2SV> vpx_free ( cpi -> mt_current_mb_col ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> mt_current_mb_col , //<S2SV> vpx_malloc ( sizeof ( * cpi -> mt_current_mb_col ) * cm -> mb_rows ) ) ; //<S2SV> } //<S2SV> # endif //<S2SV> vpx_free ( cpi -> tplist ) ; //<S2SV> CHECK_MEM_ERROR ( cpi -> tplist , vpx_malloc ( sizeof ( TOKENLIST ) * cm -> mb_rows ) ) ; //<S2SV> # if CONFIG_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity > 0 ) { //<S2SV> vp8_denoiser_free ( & cpi -> denoiser ) ; //<S2SV> vp8_denoiser_allocate ( & cpi -> denoiser , width , height , //<S2SV> cm -> mb_rows , cm -> mb_cols , //<S2SV> cpi -> oxcf . noise_sensitivity ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> 