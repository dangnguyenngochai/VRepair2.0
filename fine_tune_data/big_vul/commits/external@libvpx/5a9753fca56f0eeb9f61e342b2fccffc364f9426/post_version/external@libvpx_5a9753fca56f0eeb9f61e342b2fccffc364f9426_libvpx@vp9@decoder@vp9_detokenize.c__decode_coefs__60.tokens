static int decode_coefs ( const MACROBLOCKD * xd , //<S2SV> PLANE_TYPE type , //<S2SV> tran_low_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , //<S2SV> int ctx , const int16_t * scan , const int16_t * nb , //<S2SV> vpx_reader * r ) { //<S2SV> FRAME_COUNTS * counts = xd -> counts ; //<S2SV> const int max_eob = 16 << ( tx_size << 1 ) ; //<S2SV> const FRAME_CONTEXT * const fc = xd -> fc ; //<S2SV> const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; //<S2SV> int band , c = 0 ; //<S2SV> const vpx_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = //<S2SV> fc -> coef_probs [ tx_size ] [ type ] [ ref ] ; //<S2SV> const vpx_prob * prob ; //<S2SV> unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] ; //<S2SV> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; //<S2SV> uint8_t token_cache [ 32 * 32 ] ; //<S2SV> const uint8_t * band_translate = get_band_translate ( tx_size ) ; //<S2SV> const int dq_shift = ( tx_size == TX_32X32 ) ; //<S2SV> int v , token ; //<S2SV> int16_t dqv = dq [ 0 ] ; //<S2SV> const uint8_t * cat1_prob ; //<S2SV> const uint8_t * cat2_prob ; //<S2SV> const uint8_t * cat3_prob ; //<S2SV> const uint8_t * cat4_prob ; //<S2SV> const uint8_t * cat5_prob ; //<S2SV> const uint8_t * cat6_prob ; //<S2SV> if ( counts ) { //<S2SV> coef_counts = counts -> coef [ tx_size ] [ type ] [ ref ] ; //<S2SV> eob_branch_count = counts -> eob_branch [ tx_size ] [ type ] [ ref ] ; //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> bd > VPX_BITS_8 ) { //<S2SV> if ( xd -> bd == VPX_BITS_10 ) { //<S2SV> cat1_prob = vp9_cat1_prob_high10 ; //<S2SV> cat2_prob = vp9_cat2_prob_high10 ; //<S2SV> cat3_prob = vp9_cat3_prob_high10 ; //<S2SV> cat4_prob = vp9_cat4_prob_high10 ; //<S2SV> cat5_prob = vp9_cat5_prob_high10 ; //<S2SV> cat6_prob = vp9_cat6_prob_high10 ; //<S2SV> } else { //<S2SV> cat1_prob = vp9_cat1_prob_high12 ; //<S2SV> cat2_prob = vp9_cat2_prob_high12 ; //<S2SV> cat3_prob = vp9_cat3_prob_high12 ; //<S2SV> cat4_prob = vp9_cat4_prob_high12 ; //<S2SV> cat5_prob = vp9_cat5_prob_high12 ; //<S2SV> cat6_prob = vp9_cat6_prob_high12 ; //<S2SV> } //<S2SV> } else { //<S2SV> cat1_prob = vp9_cat1_prob ; //<S2SV> cat2_prob = vp9_cat2_prob ; //<S2SV> cat3_prob = vp9_cat3_prob ; //<S2SV> cat4_prob = vp9_cat4_prob ; //<S2SV> cat5_prob = vp9_cat5_prob ; //<S2SV> cat6_prob = vp9_cat6_prob ; //<S2SV> } //<S2SV> # else //<S2SV> cat1_prob = vp9_cat1_prob ; //<S2SV> cat2_prob = vp9_cat2_prob ; //<S2SV> cat3_prob = vp9_cat3_prob ; //<S2SV> cat4_prob = vp9_cat4_prob ; //<S2SV> cat5_prob = vp9_cat5_prob ; //<S2SV> cat6_prob = vp9_cat6_prob ; //<S2SV> # endif //<S2SV> while ( c < max_eob ) { //<S2SV> int val = - 1 ; //<S2SV> band = * band_translate ++ ; //<S2SV> prob = coef_probs [ band ] [ ctx ] ; //<S2SV> if ( counts ) //<S2SV> ++ eob_branch_count [ band ] [ ctx ] ; //<S2SV> if ( ! vpx_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ; //<S2SV> break ; //<S2SV> } //<S2SV> while ( ! vpx_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( ZERO_TOKEN ) ; //<S2SV> dqv = dq [ 1 ] ; //<S2SV> token_cache [ scan [ c ] ] = 0 ; //<S2SV> ++ c ; //<S2SV> if ( c >= max_eob ) //<S2SV> return c ; //<S2SV> ctx = get_coef_context ( nb , token_cache , c ) ; //<S2SV> band = * band_translate ++ ; //<S2SV> prob = coef_probs [ band ] [ ctx ] ; //<S2SV> } //<S2SV> if ( ! vpx_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) { //<S2SV> INCREMENT_COUNT ( ONE_TOKEN ) ; //<S2SV> token = ONE_TOKEN ; //<S2SV> val = 1 ; //<S2SV> } else { //<S2SV> INCREMENT_COUNT ( TWO_TOKEN ) ; //<S2SV> token = vpx_read_tree ( r , vp9_coef_con_tree , //<S2SV> vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ) ; //<S2SV> switch ( token ) { //<S2SV> case TWO_TOKEN : //<S2SV> case THREE_TOKEN : //<S2SV> case FOUR_TOKEN : //<S2SV> val = token ; //<S2SV> break ; //<S2SV> case CATEGORY1_TOKEN : //<S2SV> val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; //<S2SV> break ; //<S2SV> case CATEGORY2_TOKEN : //<S2SV> val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; //<S2SV> break ; //<S2SV> case CATEGORY3_TOKEN : //<S2SV> val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; //<S2SV> break ; //<S2SV> case CATEGORY4_TOKEN : //<S2SV> val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; //<S2SV> break ; //<S2SV> case CATEGORY5_TOKEN : //<S2SV> val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; //<S2SV> break ; //<S2SV> case CATEGORY6_TOKEN : //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> switch ( xd -> bd ) { //<S2SV> case VPX_BITS_8 : //<S2SV> val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; //<S2SV> break ; //<S2SV> case VPX_BITS_10 : //<S2SV> val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; //<S2SV> break ; //<S2SV> case VPX_BITS_12 : //<S2SV> val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> # else //<S2SV> val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; //<S2SV> # endif //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> v = ( val * dqv ) >> dq_shift ; //<S2SV> # if CONFIG_COEFFICIENT_RANGE_CHECKING //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , //<S2SV> xd -> bd ) ; //<S2SV> # else //<S2SV> dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; //<S2SV> # endif //<S2SV> # else //<S2SV> dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; //<S2SV> # endif //<S2SV> token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; //<S2SV> ++ c ; //<S2SV> ctx = get_coef_context ( nb , token_cache , c ) ; //<S2SV> dqv = dq [ 1 ] ; //<S2SV> } //<S2SV> return c ; //<S2SV> } //<S2SV> 