static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , //<S2SV> const vpx_codec_enc_cfg_t * cfg , //<S2SV> const struct vp8_extracfg * vp8_cfg , //<S2SV> int finalize ) //<S2SV> { //<S2SV> RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; //<S2SV> RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; //<S2SV> RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; //<S2SV> RANGE_CHECK ( cfg , g_timebase . num , 1 , 1000000000 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; //<S2SV> RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; //<S2SV> # if CONFIG_REALTIME_ONLY //<S2SV> RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; //<S2SV> # elif CONFIG_MULTI_RES_ENCODING //<S2SV> if ( ctx -> base . enc . total_encoders > 1 ) //<S2SV> RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; //<S2SV> # else //<S2SV> RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; //<S2SV> # endif //<S2SV> RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; //<S2SV> RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; //<S2SV> # if CONFIG_MULTI_RES_ENCODING //<S2SV> if ( ctx -> base . enc . total_encoders > 1 ) //<S2SV> RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; //<S2SV> # else //<S2SV> RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; //<S2SV> # endif //<S2SV> RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; //<S2SV> RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; //<S2SV> # if CONFIG_REALTIME_ONLY //<S2SV> RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; //<S2SV> # elif CONFIG_MULTI_RES_ENCODING //<S2SV> if ( ctx -> base . enc . total_encoders > 1 ) //<S2SV> RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; //<S2SV> # else //<S2SV> RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; //<S2SV> # endif //<S2SV> if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist //<S2SV> && cfg -> kf_min_dist > 0 ) //<S2SV> ERROR ( "kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>" //<S2SV> "or<S2SV_blank>kf_max_dist<S2SV_blank>instead." ) ; //<S2SV> RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; //<S2SV> RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; //<S2SV> # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING //<S2SV> RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; //<S2SV> # else //<S2SV> RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; //<S2SV> # endif //<S2SV> RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , //<S2SV> VP8_EIGHT_TOKENPARTITION ) ; //<S2SV> RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; //<S2SV> RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; //<S2SV> RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; //<S2SV> RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ; //<S2SV> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; //<S2SV> RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 ) ; //<S2SV> if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) //<S2SV> RANGE_CHECK ( vp8_cfg , cq_level , //<S2SV> cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; //<S2SV> # if ! ( CONFIG_REALTIME_ONLY ) //<S2SV> if ( cfg -> g_pass == VPX_RC_LAST_PASS ) //<S2SV> { //<S2SV> size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; //<S2SV> int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / //<S2SV> packet_sz ) ; //<S2SV> FIRSTPASS_STATS * stats ; //<S2SV> if ( ! cfg -> rc_twopass_stats_in . buf ) //<S2SV> ERROR ( "rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set." ) ; //<S2SV> if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) //<S2SV> ERROR ( "rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet." ) ; //<S2SV> if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets." ) ; //<S2SV> stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf //<S2SV> + ( n_packets - 1 ) * packet_sz ) ; //<S2SV> if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) //<S2SV> ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; //<S2SV> } //<S2SV> # endif //<S2SV> RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; //<S2SV> if ( cfg -> ts_number_layers > 1 ) //<S2SV> { //<S2SV> unsigned int i ; //<S2SV> RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; //<S2SV> for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) //<S2SV> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] && //<S2SV> cfg -> rc_target_bitrate > 0 ) //<S2SV> ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing" ) ; //<S2SV> RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; //<S2SV> for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) //<S2SV> if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) //<S2SV> ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; //<S2SV> RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; //<S2SV> } //<S2SV> # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) //<S2SV> if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) //<S2SV> ERROR ( "g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions" ) ; //<S2SV> # endif //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 