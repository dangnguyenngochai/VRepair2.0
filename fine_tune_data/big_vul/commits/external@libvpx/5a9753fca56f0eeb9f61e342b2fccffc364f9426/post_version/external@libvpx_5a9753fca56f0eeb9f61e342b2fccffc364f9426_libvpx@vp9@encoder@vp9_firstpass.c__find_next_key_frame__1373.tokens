static void find_next_key_frame ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { //<S2SV> int i , j ; //<S2SV> RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> TWO_PASS * const twopass = & cpi -> twopass ; //<S2SV> GF_GROUP * const gf_group = & twopass -> gf_group ; //<S2SV> const VP9EncoderConfig * const oxcf = & cpi -> oxcf ; //<S2SV> const FIRSTPASS_STATS first_frame = * this_frame ; //<S2SV> const FIRSTPASS_STATS * const start_position = twopass -> stats_in ; //<S2SV> FIRSTPASS_STATS next_frame ; //<S2SV> FIRSTPASS_STATS last_frame ; //<S2SV> int kf_bits = 0 ; //<S2SV> int loop_decay_counter = 0 ; //<S2SV> double decay_accumulator = 1.0 ; //<S2SV> double av_decay_accumulator = 0.0 ; //<S2SV> double zero_motion_accumulator = 1.0 ; //<S2SV> double boost_score = 0.0 ; //<S2SV> double kf_mod_err = 0.0 ; //<S2SV> double kf_group_err = 0.0 ; //<S2SV> double recent_loop_decay [ 8 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ; //<S2SV> vp9_zero ( next_frame ) ; //<S2SV> cpi -> common . frame_type = KEY_FRAME ; //<S2SV> vp9_zero ( * gf_group ) ; //<S2SV> rc -> this_key_frame_forced = rc -> next_key_frame_forced ; //<S2SV> rc -> source_alt_ref_active = 0 ; //<S2SV> cpi -> multi_arf_last_grp_enabled = 0 ; //<S2SV> rc -> frames_till_gf_update_due = 0 ; //<S2SV> rc -> frames_to_key = 1 ; //<S2SV> twopass -> kf_group_bits = 0 ; //<S2SV> twopass -> kf_group_error_left = 0 ; //<S2SV> kf_mod_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> i = 0 ; //<S2SV> while ( twopass -> stats_in < twopass -> stats_in_end && //<S2SV> rc -> frames_to_key < cpi -> oxcf . key_freq ) { //<S2SV> kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> last_frame = * this_frame ; //<S2SV> input_stats ( twopass , this_frame ) ; //<S2SV> if ( cpi -> oxcf . auto_key && twopass -> stats_in < twopass -> stats_in_end ) { //<S2SV> double loop_decay_rate ; //<S2SV> if ( test_candidate_kf ( twopass , & last_frame , this_frame , //<S2SV> twopass -> stats_in ) ) //<S2SV> break ; //<S2SV> loop_decay_rate = get_prediction_decay_rate ( cpi , twopass -> stats_in ) ; //<S2SV> recent_loop_decay [ i % 8 ] = loop_decay_rate ; //<S2SV> decay_accumulator = 1.0 ; //<S2SV> for ( j = 0 ; j < 8 ; ++ j ) //<S2SV> decay_accumulator *= recent_loop_decay [ j ] ; //<S2SV> if ( detect_transition_to_still ( cpi , i , cpi -> oxcf . key_freq - i , //<S2SV> loop_decay_rate , decay_accumulator ) ) //<S2SV> break ; //<S2SV> ++ rc -> frames_to_key ; //<S2SV> if ( rc -> frames_to_key >= 2 * cpi -> oxcf . key_freq ) //<S2SV> break ; //<S2SV> } else { //<S2SV> ++ rc -> frames_to_key ; //<S2SV> } //<S2SV> ++ i ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . auto_key && //<S2SV> rc -> frames_to_key > cpi -> oxcf . key_freq ) { //<S2SV> FIRSTPASS_STATS tmp_frame = first_frame ; //<S2SV> rc -> frames_to_key /= 2 ; //<S2SV> reset_fpf_position ( twopass , start_position ) ; //<S2SV> kf_group_err = 0.0 ; //<S2SV> for ( i = 0 ; i < rc -> frames_to_key ; ++ i ) { //<S2SV> kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , & tmp_frame ) ; //<S2SV> input_stats ( twopass , & tmp_frame ) ; //<S2SV> } //<S2SV> rc -> next_key_frame_forced = 1 ; //<S2SV> } else if ( twopass -> stats_in == twopass -> stats_in_end || //<S2SV> rc -> frames_to_key >= cpi -> oxcf . key_freq ) { //<S2SV> rc -> next_key_frame_forced = 1 ; //<S2SV> } else { //<S2SV> rc -> next_key_frame_forced = 0 ; //<S2SV> } //<S2SV> if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { //<S2SV> int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; //<S2SV> int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ; //<S2SV> int j ; //<S2SV> for ( j = 0 ; j < new_frame_to_key - rc -> frames_to_key ; ++ j ) { //<S2SV> if ( EOF == input_stats ( twopass , this_frame ) ) //<S2SV> break ; //<S2SV> kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> } //<S2SV> rc -> frames_to_key = new_frame_to_key ; //<S2SV> } //<S2SV> if ( twopass -> stats_in >= twopass -> stats_in_end ) { //<S2SV> kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> } //<S2SV> if ( twopass -> bits_left > 0 && twopass -> modified_error_left > 0.0 ) { //<S2SV> const int max_bits = frame_max_bits ( rc , & cpi -> oxcf ) ; //<S2SV> int64_t max_grp_bits ; //<S2SV> twopass -> kf_group_bits = ( int64_t ) ( twopass -> bits_left * //<S2SV> ( kf_group_err / twopass -> modified_error_left ) ) ; //<S2SV> max_grp_bits = ( int64_t ) max_bits * ( int64_t ) rc -> frames_to_key ; //<S2SV> if ( twopass -> kf_group_bits > max_grp_bits ) //<S2SV> twopass -> kf_group_bits = max_grp_bits ; //<S2SV> } else { //<S2SV> twopass -> kf_group_bits = 0 ; //<S2SV> } //<S2SV> twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; //<S2SV> reset_fpf_position ( twopass , start_position ) ; //<S2SV> decay_accumulator = 1.0 ; //<S2SV> boost_score = 0.0 ; //<S2SV> for ( i = 0 ; i < ( rc -> frames_to_key - 1 ) ; ++ i ) { //<S2SV> if ( EOF == input_stats ( twopass , & next_frame ) ) //<S2SV> break ; //<S2SV> zero_motion_accumulator = //<S2SV> MIN ( zero_motion_accumulator , //<S2SV> get_zero_motion_factor ( cpi , & next_frame ) ) ; //<S2SV> if ( ( i <= rc -> max_gf_interval ) || //<S2SV> ( ( i <= ( rc -> max_gf_interval * 4 ) ) && ( decay_accumulator > 0.5 ) ) ) { //<S2SV> const double frame_boost = //<S2SV> calc_frame_boost ( cpi , this_frame , 0 , KF_MAX_BOOST ) ; //<S2SV> if ( ! detect_flash ( twopass , 0 ) ) { //<S2SV> const double loop_decay_rate = //<S2SV> get_prediction_decay_rate ( cpi , & next_frame ) ; //<S2SV> decay_accumulator *= loop_decay_rate ; //<S2SV> decay_accumulator = MAX ( decay_accumulator , MIN_DECAY_FACTOR ) ; //<S2SV> av_decay_accumulator += decay_accumulator ; //<S2SV> ++ loop_decay_counter ; //<S2SV> } //<S2SV> boost_score += ( decay_accumulator * frame_boost ) ; //<S2SV> } //<S2SV> } //<S2SV> av_decay_accumulator /= ( double ) loop_decay_counter ; //<S2SV> reset_fpf_position ( twopass , start_position ) ; //<S2SV> twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 ) ; //<S2SV> twopass -> section_intra_rating = //<S2SV> calculate_section_intra_ratio ( start_position , twopass -> stats_in_end , //<S2SV> rc -> frames_to_key ) ; //<S2SV> rc -> kf_boost = ( int ) ( av_decay_accumulator * boost_score ) ; //<S2SV> rc -> kf_boost = MAX ( rc -> kf_boost , ( rc -> frames_to_key * 3 ) ) ; //<S2SV> rc -> kf_boost = MAX ( rc -> kf_boost , MIN_KF_BOOST ) ; //<S2SV> kf_bits = calculate_boost_bits ( ( rc -> frames_to_key - 1 ) , //<S2SV> rc -> kf_boost , twopass -> kf_group_bits ) ; //<S2SV> if ( twopass -> kf_group_bits ) { //<S2SV> twopass -> kfgroup_inter_fraction = //<S2SV> ( double ) ( twopass -> kf_group_bits - kf_bits ) / //<S2SV> ( double ) twopass -> kf_group_bits ; //<S2SV> } else { //<S2SV> twopass -> kfgroup_inter_fraction = 1.0 ; //<S2SV> } //<S2SV> twopass -> kf_group_bits -= kf_bits ; //<S2SV> gf_group -> bit_allocation [ 0 ] = kf_bits ; //<S2SV> gf_group -> update_type [ 0 ] = KF_UPDATE ; //<S2SV> gf_group -> rf_level [ 0 ] = KF_STD ; //<S2SV> twopass -> kf_group_error_left = ( int ) ( kf_group_err - kf_mod_err ) ; //<S2SV> twopass -> modified_error_left -= kf_group_err ; //<S2SV> if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { //<S2SV> cpi -> rc . next_frame_size_selector = UNSCALED ; //<S2SV> } //<S2SV> } //<S2SV> 