static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> MACROBLOCKD * const xd , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE * min_block_size , //<S2SV> BLOCK_SIZE * max_block_size ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MODE_INFO * * mi = xd -> mi ; //<S2SV> const int left_in_image = xd -> left_available && mi [ - 1 ] ; //<S2SV> const int above_in_image = xd -> up_available && mi [ - xd -> mi_stride ] ; //<S2SV> const int row8x8_remaining = tile -> mi_row_end - mi_row ; //<S2SV> const int col8x8_remaining = tile -> mi_col_end - mi_col ; //<S2SV> int bh , bw ; //<S2SV> BLOCK_SIZE min_size = BLOCK_4X4 ; //<S2SV> BLOCK_SIZE max_size = BLOCK_64X64 ; //<S2SV> int bs_hist [ BLOCK_SIZES ] = { 0 } ; //<S2SV> if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) { //<S2SV> min_size = BLOCK_64X64 ; //<S2SV> max_size = BLOCK_4X4 ; //<S2SV> if ( cm -> frame_type != KEY_FRAME ) { //<S2SV> MODE_INFO * * prev_mi = //<S2SV> & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ; //<S2SV> get_sb_partition_size_range ( xd , prev_mi , & min_size , & max_size , bs_hist ) ; //<S2SV> } //<S2SV> if ( left_in_image ) { //<S2SV> MODE_INFO * * left_sb64_mi = & mi [ - MI_BLOCK_SIZE ] ; //<S2SV> get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , //<S2SV> bs_hist ) ; //<S2SV> } //<S2SV> if ( above_in_image ) { //<S2SV> MODE_INFO * * above_sb64_mi = & mi [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; //<S2SV> get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , //<S2SV> bs_hist ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . auto_min_max_partition_size == RELAXED_NEIGHBORING_MIN_MAX ) { //<S2SV> min_size = min_partition_size [ min_size ] ; //<S2SV> max_size = max_partition_size [ max_size ] ; //<S2SV> } //<S2SV> } //<S2SV> max_size = find_partition_size ( max_size , //<S2SV> row8x8_remaining , col8x8_remaining , //<S2SV> & bh , & bw ) ; //<S2SV> if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { //<S2SV> min_size = BLOCK_4X4 ; //<S2SV> } else { //<S2SV> min_size = MIN ( cpi -> sf . rd_auto_partition_min_limit , //<S2SV> MIN ( min_size , max_size ) ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . use_square_partition_only && //<S2SV> next_square_size [ max_size ] < min_size ) { //<S2SV> min_size = next_square_size [ max_size ] ; //<S2SV> } //<S2SV> * min_block_size = min_size ; //<S2SV> * max_block_size = max_size ; //<S2SV> } //<S2SV> 