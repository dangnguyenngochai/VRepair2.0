void vp9_update_layer_context_change_config ( VP9_COMP * const cpi , //<S2SV> const int target_bandwidth ) { //<S2SV> SVC * const svc = & cpi -> svc ; //<S2SV> const VP9EncoderConfig * const oxcf = & cpi -> oxcf ; //<S2SV> const RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> int sl , tl , layer = 0 , spatial_layer_target ; //<S2SV> float bitrate_alloc = 1.0 ; //<S2SV> if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { //<S2SV> for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { //<S2SV> spatial_layer_target = 0 ; //<S2SV> for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { //<S2SV> layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; //<S2SV> svc -> layer_context [ layer ] . target_bandwidth = //<S2SV> oxcf -> layer_target_bitrate [ layer ] ; //<S2SV> } //<S2SV> layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? //<S2SV> 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; //<S2SV> spatial_layer_target = //<S2SV> svc -> layer_context [ layer ] . target_bandwidth = //<S2SV> oxcf -> layer_target_bitrate [ layer ] ; //<S2SV> for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { //<S2SV> LAYER_CONTEXT * const lc = //<S2SV> & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; //<S2SV> RATE_CONTROL * const lrc = & lc -> rc ; //<S2SV> lc -> spatial_layer_target_bandwidth = spatial_layer_target ; //<S2SV> bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; //<S2SV> lrc -> starting_buffer_level = //<S2SV> ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; //<S2SV> lrc -> optimal_buffer_level = //<S2SV> ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; //<S2SV> lrc -> maximum_buffer_size = //<S2SV> ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; //<S2SV> lrc -> bits_off_target = //<S2SV> MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; //<S2SV> lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; //<S2SV> lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; //<S2SV> lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; //<S2SV> lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; //<S2SV> lrc -> worst_quality = rc -> worst_quality ; //<S2SV> lrc -> best_quality = rc -> best_quality ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> int layer_end ; //<S2SV> if ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) { //<S2SV> layer_end = svc -> number_temporal_layers ; //<S2SV> } else { //<S2SV> layer_end = svc -> number_spatial_layers ; //<S2SV> } //<S2SV> for ( layer = 0 ; layer < layer_end ; ++ layer ) { //<S2SV> LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; //<S2SV> RATE_CONTROL * const lrc = & lc -> rc ; //<S2SV> lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; //<S2SV> bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; //<S2SV> lrc -> starting_buffer_level = //<S2SV> ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; //<S2SV> lrc -> optimal_buffer_level = //<S2SV> ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; //<S2SV> lrc -> maximum_buffer_size = //<S2SV> ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; //<S2SV> lrc -> bits_off_target = MIN ( lrc -> bits_off_target , //<S2SV> lrc -> maximum_buffer_size ) ; //<S2SV> lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; //<S2SV> if ( svc -> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) { //<S2SV> lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ layer ] ; //<S2SV> } else { //<S2SV> lc -> framerate = cpi -> framerate ; //<S2SV> } //<S2SV> lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; //<S2SV> lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; //<S2SV> lrc -> worst_quality = rc -> worst_quality ; //<S2SV> lrc -> best_quality = rc -> best_quality ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 