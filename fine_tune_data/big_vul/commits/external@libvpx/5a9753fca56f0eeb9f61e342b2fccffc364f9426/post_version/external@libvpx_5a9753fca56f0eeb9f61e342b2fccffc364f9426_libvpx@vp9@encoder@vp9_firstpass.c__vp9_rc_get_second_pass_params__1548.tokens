void vp9_rc_get_second_pass_params ( VP9_COMP * cpi ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> TWO_PASS * const twopass = & cpi -> twopass ; //<S2SV> GF_GROUP * const gf_group = & twopass -> gf_group ; //<S2SV> int frames_left ; //<S2SV> FIRSTPASS_STATS this_frame ; //<S2SV> int target_rate ; //<S2SV> LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? //<S2SV> & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; //<S2SV> if ( lc != NULL ) { //<S2SV> frames_left = ( int ) ( twopass -> total_stats . count - //<S2SV> lc -> current_video_frame_in_layer ) ; //<S2SV> } else { //<S2SV> frames_left = ( int ) ( twopass -> total_stats . count - //<S2SV> cm -> current_video_frame ) ; //<S2SV> } //<S2SV> if ( ! twopass -> stats_in ) //<S2SV> return ; //<S2SV> if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { //<S2SV> int target_rate ; //<S2SV> configure_buffer_updates ( cpi ) ; //<S2SV> target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; //<S2SV> target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; //<S2SV> rc -> base_frame_target = target_rate ; //<S2SV> cm -> frame_type = INTER_FRAME ; //<S2SV> if ( lc != NULL ) { //<S2SV> if ( cpi -> svc . spatial_layer_id == 0 ) { //<S2SV> lc -> is_key_frame = 0 ; //<S2SV> } else { //<S2SV> lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; //<S2SV> if ( lc -> is_key_frame ) //<S2SV> cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> sf . allow_partition_search_skip && //<S2SV> cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { //<S2SV> cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> if ( cpi -> oxcf . rc_mode == VPX_Q ) { //<S2SV> twopass -> active_worst_quality = cpi -> oxcf . cq_level ; //<S2SV> } else if ( cm -> current_video_frame == 0 || //<S2SV> ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { //<S2SV> const int section_target_bandwidth = ( int ) ( twopass -> bits_left / //<S2SV> frames_left ) ; //<S2SV> const double section_length = twopass -> total_left_stats . count ; //<S2SV> const double section_error = //<S2SV> twopass -> total_left_stats . coded_error / section_length ; //<S2SV> const double section_intra_skip = //<S2SV> twopass -> total_left_stats . intra_skip_pct / section_length ; //<S2SV> const double section_inactive_zone = //<S2SV> ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / //<S2SV> ( ( double ) cm -> mb_rows * section_length ) ; //<S2SV> const int tmp_q = //<S2SV> get_twopass_worst_quality ( cpi , section_error , //<S2SV> section_intra_skip + section_inactive_zone , //<S2SV> section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; //<S2SV> twopass -> active_worst_quality = tmp_q ; //<S2SV> twopass -> baseline_active_worst_quality = tmp_q ; //<S2SV> rc -> ni_av_qi = tmp_q ; //<S2SV> rc -> last_q [ INTER_FRAME ] = tmp_q ; //<S2SV> rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; //<S2SV> rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; //<S2SV> rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; //<S2SV> rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; //<S2SV> } //<S2SV> vp9_zero ( this_frame ) ; //<S2SV> if ( EOF == input_stats ( twopass , & this_frame ) ) //<S2SV> return ; //<S2SV> if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) //<S2SV> twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; //<S2SV> else //<S2SV> twopass -> fr_content_type = FC_NORMAL ; //<S2SV> if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { //<S2SV> FIRSTPASS_STATS this_frame_copy ; //<S2SV> this_frame_copy = this_frame ; //<S2SV> find_next_key_frame ( cpi , & this_frame ) ; //<S2SV> this_frame = this_frame_copy ; //<S2SV> } else { //<S2SV> cm -> frame_type = INTER_FRAME ; //<S2SV> } //<S2SV> if ( lc != NULL ) { //<S2SV> if ( cpi -> svc . spatial_layer_id == 0 ) { //<S2SV> lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; //<S2SV> if ( lc -> is_key_frame ) { //<S2SV> cpi -> ref_frame_flags &= //<S2SV> ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; //<S2SV> lc -> frames_from_key_frame = 0 ; //<S2SV> cpi -> svc . encode_intra_empty_frame = 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> cm -> frame_type = INTER_FRAME ; //<S2SV> lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; //<S2SV> if ( lc -> is_key_frame ) { //<S2SV> cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; //<S2SV> lc -> frames_from_key_frame = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( rc -> frames_till_gf_update_due == 0 ) { //<S2SV> define_gf_group ( cpi , & this_frame ) ; //<S2SV> rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; //<S2SV> if ( lc != NULL ) //<S2SV> cpi -> refresh_golden_frame = 1 ; //<S2SV> # if ARF_STATS_OUTPUT //<S2SV> { //<S2SV> FILE * fpfile ; //<S2SV> fpfile = fopen ( "arf.stt" , "a" ) ; //<S2SV> ++ arf_count ; //<S2SV> fprintf ( fpfile , "%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n" , //<S2SV> cm -> current_video_frame , rc -> frames_till_gf_update_due , //<S2SV> rc -> kf_boost , arf_count , rc -> gfu_boost ) ; //<S2SV> fclose ( fpfile ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> configure_buffer_updates ( cpi ) ; //<S2SV> if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && //<S2SV> ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { //<S2SV> cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; //<S2SV> } //<S2SV> target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; //<S2SV> if ( cpi -> common . frame_type == KEY_FRAME ) //<S2SV> target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) ; //<S2SV> else //<S2SV> target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; //<S2SV> rc -> base_frame_target = target_rate ; //<S2SV> { //<S2SV> const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) //<S2SV> ? cpi -> initial_mbs : cpi -> common . MBs ; //<S2SV> twopass -> mb_av_energy = //<S2SV> log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; //<S2SV> } //<S2SV> subtract_stats ( & twopass -> total_left_stats , & this_frame ) ; //<S2SV> } //<S2SV> 