static void update_state ( VP9_COMP * cpi , ThreadData * td , //<S2SV> PICK_MODE_CONTEXT * ctx , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize , //<S2SV> int output_enabled ) { //<S2SV> int i , x_idx , y ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> RD_COUNTS * const rdc = & td -> rd_counts ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> MODE_INFO * mi = & ctx -> mic ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> MODE_INFO * mi_addr = xd -> mi [ 0 ] ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; //<S2SV> const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; //<S2SV> const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; //<S2SV> const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; //<S2SV> MV_REF * const frame_mvs = //<S2SV> cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; //<S2SV> int w , h ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> int max_plane ; //<S2SV> assert ( mi -> mbmi . sb_type == bsize ) ; //<S2SV> * mi_addr = * mi ; //<S2SV> * x -> mbmi_ext = ctx -> mbmi_ext ; //<S2SV> if ( seg -> enabled ) { //<S2SV> if ( cpi -> oxcf . aq_mode == COMPLEXITY_AQ ) { //<S2SV> const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> mi_addr -> mbmi . segment_id = //<S2SV> get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) { //<S2SV> vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , //<S2SV> mi_col , bsize , ctx -> rate , ctx -> dist , //<S2SV> x -> skip ) ; //<S2SV> } //<S2SV> } //<S2SV> max_plane = is_inter_block ( mbmi ) ? MAX_MB_PLANE : 1 ; //<S2SV> for ( i = 0 ; i < max_plane ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; //<S2SV> } //<S2SV> for ( i = max_plane ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 2 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 2 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 2 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 2 ] ; //<S2SV> } //<S2SV> for ( y = 0 ; y < mi_height ; y ++ ) //<S2SV> for ( x_idx = 0 ; x_idx < mi_width ; x_idx ++ ) //<S2SV> if ( ( xd -> mb_to_right_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_width > x_idx //<S2SV> && ( xd -> mb_to_bottom_edge >> ( 3 + MI_SIZE_LOG2 ) ) + mi_height > y ) { //<S2SV> xd -> mi [ x_idx + y * mis ] = mi_addr ; //<S2SV> } //<S2SV> if ( cpi -> oxcf . aq_mode ) //<S2SV> vp9_init_plane_quantizers ( cpi , x ) ; //<S2SV> if ( is_inter_block ( mbmi ) && mbmi -> sb_type < BLOCK_8X8 ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; //<S2SV> mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; //<S2SV> } //<S2SV> x -> skip = ctx -> skip ; //<S2SV> memcpy ( x -> zcoeff_blk [ mbmi -> tx_size ] , ctx -> zcoeff_blk , //<S2SV> sizeof ( ctx -> zcoeff_blk [ 0 ] ) * ctx -> num_4x4_blk ) ; //<S2SV> if ( ! output_enabled ) //<S2SV> return ; //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> if ( frame_is_intra_only ( cm ) ) { //<S2SV> static const int kf_mode_index [ ] = { //<S2SV> THR_DC , //<S2SV> THR_V_PRED , //<S2SV> THR_H_PRED , //<S2SV> THR_D45_PRED , //<S2SV> THR_D135_PRED , //<S2SV> THR_D117_PRED , //<S2SV> THR_D153_PRED , //<S2SV> THR_D207_PRED , //<S2SV> THR_D63_PRED , //<S2SV> THR_TM , //<S2SV> } ; //<S2SV> ++ cpi -> mode_chosen_counts [ kf_mode_index [ mbmi -> mode ] ] ; //<S2SV> } else { //<S2SV> ++ cpi -> mode_chosen_counts [ ctx -> best_mode_index ] ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> if ( is_inter_block ( mbmi ) ) { //<S2SV> vp9_update_mv_count ( td ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) { //<S2SV> const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; //<S2SV> ++ td -> counts -> switchable_interp [ ctx ] [ mbmi -> interp_filter ] ; //<S2SV> } //<S2SV> } //<S2SV> rdc -> comp_pred_diff [ SINGLE_REFERENCE ] += ctx -> single_pred_diff ; //<S2SV> rdc -> comp_pred_diff [ COMPOUND_REFERENCE ] += ctx -> comp_pred_diff ; //<S2SV> rdc -> comp_pred_diff [ REFERENCE_MODE_SELECT ] += ctx -> hybrid_pred_diff ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> rdc -> filter_diff [ i ] += ctx -> best_filter_diff [ i ] ; //<S2SV> } //<S2SV> for ( h = 0 ; h < y_mis ; ++ h ) { //<S2SV> MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; //<S2SV> for ( w = 0 ; w < x_mis ; ++ w ) { //<S2SV> MV_REF * const mv = frame_mv + w ; //<S2SV> mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; //<S2SV> mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; //<S2SV> mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; //<S2SV> mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 