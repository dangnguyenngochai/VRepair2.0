static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int mi_row , int mi_col , //<S2SV> int_mv * tmp_mv , int * rate_mv ) { //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> const VP9_COMMON * cm = & cpi -> common ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 , 0 } } ; //<S2SV> int bestsme = INT_MAX ; //<S2SV> int step_param ; //<S2SV> int sadpb = x -> sadperbit16 ; //<S2SV> MV mvp_full ; //<S2SV> int ref = mbmi -> ref_frame [ 0 ] ; //<S2SV> MV ref_mv = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ; //<S2SV> int tmp_col_min = x -> mv_col_min ; //<S2SV> int tmp_col_max = x -> mv_col_max ; //<S2SV> int tmp_row_min = x -> mv_row_min ; //<S2SV> int tmp_row_max = x -> mv_row_max ; //<S2SV> int cost_list [ 5 ] ; //<S2SV> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , //<S2SV> ref ) ; //<S2SV> MV pred_mv [ 3 ] ; //<S2SV> pred_mv [ 0 ] = x -> mbmi_ext -> ref_mvs [ ref ] [ 0 ] . as_mv ; //<S2SV> pred_mv [ 1 ] = x -> mbmi_ext -> ref_mvs [ ref ] [ 1 ] . as_mv ; //<S2SV> pred_mv [ 2 ] = x -> pred_mv [ ref ] ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; //<S2SV> vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; //<S2SV> } //<S2SV> vp9_set_mv_search_range ( x , & ref_mv ) ; //<S2SV> if ( cpi -> sf . mv . auto_mv_step_size && cm -> show_frame ) { //<S2SV> step_param = ( vp9_init_search_range ( x -> max_mv_context [ ref ] ) + //<S2SV> cpi -> mv_step_param ) / 2 ; //<S2SV> } else { //<S2SV> step_param = cpi -> mv_step_param ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 ) { //<S2SV> int boffset = 2 * ( b_width_log2_lookup [ BLOCK_64X64 ] - //<S2SV> MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] ) ) ; //<S2SV> step_param = MAX ( step_param , boffset ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search ) { //<S2SV> int bwl = b_width_log2_lookup [ bsize ] ; //<S2SV> int bhl = b_height_log2_lookup [ bsize ] ; //<S2SV> int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; //<S2SV> if ( tlevel < 5 ) //<S2SV> step_param += 2 ; //<S2SV> if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { //<S2SV> int i ; //<S2SV> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cm -> show_frame ; ++ i ) { //<S2SV> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { //<S2SV> x -> pred_mv [ ref ] . row = 0 ; //<S2SV> x -> pred_mv [ ref ] . col = 0 ; //<S2SV> tmp_mv -> as_int = INVALID_MV ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) //<S2SV> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; //<S2SV> } //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; //<S2SV> mvp_full . col >>= 3 ; //<S2SV> mvp_full . row >>= 3 ; //<S2SV> bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , //<S2SV> cond_cost_list ( cpi , cost_list ) , //<S2SV> & ref_mv , & tmp_mv -> as_mv , INT_MAX , 1 ) ; //<S2SV> x -> mv_col_min = tmp_col_min ; //<S2SV> x -> mv_col_max = tmp_col_max ; //<S2SV> x -> mv_row_min = tmp_row_min ; //<S2SV> x -> mv_row_max = tmp_row_max ; //<S2SV> if ( bestsme < INT_MAX ) { //<S2SV> int dis ; //<S2SV> cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , //<S2SV> cm -> allow_high_precision_mv , //<S2SV> x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ bsize ] , //<S2SV> cpi -> sf . mv . subpel_force_stop , //<S2SV> cpi -> sf . mv . subpel_iters_per_step , //<S2SV> cond_cost_list ( cpi , cost_list ) , //<S2SV> x -> nmvjointcost , x -> mvcost , //<S2SV> & dis , & x -> pred_sse [ ref ] , NULL , 0 , 0 ) ; //<S2SV> } //<S2SV> * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , //<S2SV> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> x -> pred_mv [ ref ] = tmp_mv -> as_mv ; //<S2SV> if ( scaled_ref_frame ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> 