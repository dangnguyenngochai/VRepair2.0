void vp9_first_pass ( VP9_COMP * cpi , const struct lookahead_entry * source ) { //<S2SV> int mb_row , mb_col ; //<S2SV> MACROBLOCK * const x = & cpi -> td . mb ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> TileInfo tile ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> const PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ; //<S2SV> int i ; //<S2SV> int recon_yoffset , recon_uvoffset ; //<S2SV> int64_t intra_error = 0 ; //<S2SV> int64_t coded_error = 0 ; //<S2SV> int64_t sr_coded_error = 0 ; //<S2SV> int sum_mvr = 0 , sum_mvc = 0 ; //<S2SV> int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; //<S2SV> int64_t sum_mvrs = 0 , sum_mvcs = 0 ; //<S2SV> int mvcount = 0 ; //<S2SV> int intercount = 0 ; //<S2SV> int second_ref_count = 0 ; //<S2SV> const int intrapenalty = INTRA_MODE_PENALTY ; //<S2SV> double neutral_count ; //<S2SV> int intra_skip_count = 0 ; //<S2SV> int image_data_start_row = INVALID_ROW ; //<S2SV> int new_mv_count = 0 ; //<S2SV> int sum_in_vectors = 0 ; //<S2SV> MV lastmv = { 0 , 0 } ; //<S2SV> TWO_PASS * twopass = & cpi -> twopass ; //<S2SV> const MV zero_mv = { 0 , 0 } ; //<S2SV> int recon_y_stride , recon_uv_stride , uv_mb_height ; //<S2SV> YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; //<S2SV> YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; //<S2SV> YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; //<S2SV> const YV12_BUFFER_CONFIG * first_ref_buf = lst_yv12 ; //<S2SV> LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? //<S2SV> & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; //<S2SV> double intra_factor ; //<S2SV> double brightness_factor ; //<S2SV> BufferPool * const pool = cm -> buffer_pool ; //<S2SV> assert ( new_yv12 != NULL ) ; //<S2SV> assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; //<S2SV> } //<S2SV> # endif //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> intra_factor = 0.0 ; //<S2SV> brightness_factor = 0.0 ; //<S2SV> neutral_count = 0.0 ; //<S2SV> set_first_pass_params ( cpi ) ; //<S2SV> vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; //<S2SV> if ( lc != NULL ) { //<S2SV> twopass = & lc -> twopass ; //<S2SV> cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; //<S2SV> cpi -> ref_frame_flags = VP9_LAST_FLAG ; //<S2SV> if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < //<S2SV> REF_FRAMES ) { //<S2SV> cpi -> gld_fb_idx = //<S2SV> cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; //<S2SV> cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; //<S2SV> cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; //<S2SV> } else { //<S2SV> cpi -> refresh_golden_frame = 0 ; //<S2SV> } //<S2SV> if ( lc -> current_video_frame_in_layer == 0 ) //<S2SV> cpi -> ref_frame_flags = 0 ; //<S2SV> vp9_scale_references ( cpi ) ; //<S2SV> if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) { //<S2SV> first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; //<S2SV> if ( first_ref_buf == NULL ) //<S2SV> first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; //<S2SV> } //<S2SV> if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { //<S2SV> gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; //<S2SV> if ( gld_yv12 == NULL ) { //<S2SV> gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; //<S2SV> } //<S2SV> } else { //<S2SV> gld_yv12 = NULL ; //<S2SV> } //<S2SV> set_ref_ptrs ( cm , xd , //<S2SV> ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , //<S2SV> ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; //<S2SV> cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , //<S2SV> & cpi -> scaled_source ) ; //<S2SV> } //<S2SV> vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; //<S2SV> vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; //<S2SV> vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; //<S2SV> } //<S2SV> xd -> mi = cm -> mi_grid_visible ; //<S2SV> xd -> mi [ 0 ] = cm -> mi ; //<S2SV> vp9_frame_init_quantizer ( cpi ) ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 1 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 1 ] ; //<S2SV> } //<S2SV> x -> skip_recode = 0 ; //<S2SV> vp9_init_mv_probs ( cm ) ; //<S2SV> vp9_initialize_rd_consts ( cpi ) ; //<S2SV> vp9_tile_init ( & tile , cm , 0 , 0 ) ; //<S2SV> recon_y_stride = new_yv12 -> y_stride ; //<S2SV> recon_uv_stride = new_yv12 -> uv_stride ; //<S2SV> uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; ++ mb_row ) { //<S2SV> MV best_ref_mv = { 0 , 0 } ; //<S2SV> xd -> up_available = ( mb_row != 0 ) ; //<S2SV> recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; //<S2SV> recon_uvoffset = ( mb_row * recon_uv_stride * uv_mb_height ) ; //<S2SV> x -> mv_row_min = - ( ( mb_row * 16 ) + BORDER_MV_PIXELS_B16 ) ; //<S2SV> x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) //<S2SV> + BORDER_MV_PIXELS_B16 ; //<S2SV> for ( mb_col = 0 ; mb_col < cm -> mb_cols ; ++ mb_col ) { //<S2SV> int this_error ; //<S2SV> const int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; //<S2SV> const BLOCK_SIZE bsize = get_bsize ( cm , mb_row , mb_col ) ; //<S2SV> double log_intra ; //<S2SV> int level_sample ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> const int mb_index = mb_row * cm -> mb_cols + mb_col ; //<S2SV> # endif //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> xd -> plane [ 0 ] . dst . buf = new_yv12 -> y_buffer + recon_yoffset ; //<S2SV> xd -> plane [ 1 ] . dst . buf = new_yv12 -> u_buffer + recon_uvoffset ; //<S2SV> xd -> plane [ 2 ] . dst . buf = new_yv12 -> v_buffer + recon_uvoffset ; //<S2SV> xd -> left_available = ( mb_col != 0 ) ; //<S2SV> xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = INTRA_FRAME ; //<S2SV> set_mi_row_col ( xd , & tile , //<S2SV> mb_row << 1 , num_8x8_blocks_high_lookup [ bsize ] , //<S2SV> mb_col << 1 , num_8x8_blocks_wide_lookup [ bsize ] , //<S2SV> cm -> mi_rows , cm -> mi_cols ) ; //<S2SV> x -> skip_encode = 0 ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; //<S2SV> xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? //<S2SV> ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; //<S2SV> vp9_encode_intra_block_plane ( x , bsize , 0 ) ; //<S2SV> this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; //<S2SV> if ( this_error < UL_INTRA_THRESH ) { //<S2SV> ++ intra_skip_count ; //<S2SV> } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { //<S2SV> image_data_start_row = mb_row ; //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) { //<S2SV> switch ( cm -> bit_depth ) { //<S2SV> case VPX_BITS_8 : //<S2SV> break ; //<S2SV> case VPX_BITS_10 : //<S2SV> this_error >>= 4 ; //<S2SV> break ; //<S2SV> case VPX_BITS_12 : //<S2SV> this_error >>= 8 ; //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 && "cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>" //<S2SV> "VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; //<S2SV> return ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> log_intra = log ( this_error + 1.0 ) ; //<S2SV> if ( log_intra < 10.0 ) //<S2SV> intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; //<S2SV> else //<S2SV> intra_factor += 1.0 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) //<S2SV> level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; //<S2SV> else //<S2SV> level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; //<S2SV> # else //<S2SV> level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; //<S2SV> # endif //<S2SV> if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) //<S2SV> brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; //<S2SV> else //<S2SV> brightness_factor += 1.0 ; //<S2SV> this_error += intrapenalty ; //<S2SV> intra_error += ( int64_t ) this_error ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; //<S2SV> } //<S2SV> # endif //<S2SV> x -> mv_col_min = - ( ( mb_col * 16 ) + BORDER_MV_PIXELS_B16 ) ; //<S2SV> x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + BORDER_MV_PIXELS_B16 ; //<S2SV> if ( ( lc == NULL && cm -> current_video_frame > 0 ) || //<S2SV> ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) { //<S2SV> int tmp_err , motion_error , raw_motion_error ; //<S2SV> MV mv = { 0 , 0 } , tmp_mv = { 0 , 0 } ; //<S2SV> struct buf_2d unscaled_last_source_buf_2d ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> motion_error = highbd_get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; //<S2SV> } else { //<S2SV> motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; //<S2SV> } //<S2SV> # else //<S2SV> motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; //<S2SV> # endif //<S2SV> unscaled_last_source_buf_2d . buf = //<S2SV> cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; //<S2SV> unscaled_last_source_buf_2d . stride = //<S2SV> cpi -> unscaled_last_source -> y_stride ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> raw_motion_error = highbd_get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; //<S2SV> } else { //<S2SV> raw_motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; //<S2SV> } //<S2SV> # else //<S2SV> raw_motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; //<S2SV> # endif //<S2SV> if ( raw_motion_error > 25 || lc != NULL ) { //<S2SV> first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; //<S2SV> if ( ! is_zero_mv ( & best_ref_mv ) ) { //<S2SV> tmp_err = INT_MAX ; //<S2SV> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; //<S2SV> if ( tmp_err < motion_error ) { //<S2SV> motion_error = tmp_err ; //<S2SV> mv = tmp_mv ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ( lc == NULL && cm -> current_video_frame > 1 ) || //<S2SV> ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) //<S2SV> && gld_yv12 != NULL ) { //<S2SV> int gf_motion_error ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = gld_yv12 -> y_buffer + recon_yoffset ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> gf_motion_error = highbd_get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; //<S2SV> } else { //<S2SV> gf_motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; //<S2SV> } //<S2SV> # else //<S2SV> gf_motion_error = get_prediction_error ( //<S2SV> bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; //<S2SV> # endif //<S2SV> first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , //<S2SV> & gf_motion_error ) ; //<S2SV> if ( gf_motion_error < motion_error && gf_motion_error < this_error ) //<S2SV> ++ second_ref_count ; //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf = first_ref_buf -> y_buffer + recon_yoffset ; //<S2SV> xd -> plane [ 1 ] . pre [ 0 ] . buf = first_ref_buf -> u_buffer + recon_uvoffset ; //<S2SV> xd -> plane [ 2 ] . pre [ 0 ] . buf = first_ref_buf -> v_buffer + recon_uvoffset ; //<S2SV> if ( gf_motion_error < this_error ) //<S2SV> sr_coded_error += gf_motion_error ; //<S2SV> else //<S2SV> sr_coded_error += this_error ; //<S2SV> } else { //<S2SV> sr_coded_error += motion_error ; //<S2SV> } //<S2SV> } else { //<S2SV> sr_coded_error += motion_error ; //<S2SV> } //<S2SV> best_ref_mv . row = 0 ; //<S2SV> best_ref_mv . col = 0 ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; //<S2SV> if ( this_error > FPMB_ERROR_LARGE_TH ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; //<S2SV> } else if ( this_error < FPMB_ERROR_SMALL_TH ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( motion_error <= this_error ) { //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> if ( ( ( this_error - intrapenalty ) * 9 <= motion_error * 10 ) && //<S2SV> ( this_error < ( 2 * intrapenalty ) ) ) { //<S2SV> neutral_count += 1.0 ; //<S2SV> } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && //<S2SV> ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { //<S2SV> neutral_count += ( double ) motion_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; //<S2SV> } //<S2SV> mv . row *= 8 ; //<S2SV> mv . col *= 8 ; //<S2SV> this_error = motion_error ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; //<S2SV> xd -> mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv = mv ; //<S2SV> xd -> mi [ 0 ] -> mbmi . tx_size = TX_4X4 ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; //<S2SV> xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mb_row << 1 , mb_col << 1 , bsize ) ; //<S2SV> vp9_encode_sby_pass1 ( x , bsize ) ; //<S2SV> sum_mvr += mv . row ; //<S2SV> sum_mvr_abs += abs ( mv . row ) ; //<S2SV> sum_mvc += mv . col ; //<S2SV> sum_mvc_abs += abs ( mv . col ) ; //<S2SV> sum_mvrs += mv . row * mv . row ; //<S2SV> sum_mvcs += mv . col * mv . col ; //<S2SV> ++ intercount ; //<S2SV> best_ref_mv = mv ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; //<S2SV> if ( this_error > FPMB_ERROR_LARGE_TH ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_ERROR_LARGE_MASK ; //<S2SV> } else if ( this_error < FPMB_ERROR_SMALL_TH ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_ERROR_SMALL_MASK ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! is_zero_mv ( & mv ) ) { //<S2SV> ++ mvcount ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= //<S2SV> ~ FPMB_MOTION_ZERO_MASK ; //<S2SV> if ( mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_MOTION_RIGHT_MASK ; //<S2SV> } else if ( mv . as_mv . row < 0 && //<S2SV> abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_MOTION_UP_MASK ; //<S2SV> } else if ( mv . as_mv . col < 0 && //<S2SV> abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_MOTION_LEFT_MASK ; //<S2SV> } else { //<S2SV> cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= //<S2SV> FPMB_MOTION_DOWN_MASK ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! is_equal_mv ( & mv , & lastmv ) ) //<S2SV> ++ new_mv_count ; //<S2SV> lastmv = mv ; //<S2SV> if ( mb_row < cm -> mb_rows / 2 ) { //<S2SV> if ( mv . row > 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> else if ( mv . row < 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> } else if ( mb_row > cm -> mb_rows / 2 ) { //<S2SV> if ( mv . row > 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> else if ( mv . row < 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> } //<S2SV> if ( mb_col < cm -> mb_cols / 2 ) { //<S2SV> if ( mv . col > 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> else if ( mv . col < 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> } else if ( mb_col > cm -> mb_cols / 2 ) { //<S2SV> if ( mv . col > 0 ) //<S2SV> ++ sum_in_vectors ; //<S2SV> else if ( mv . col < 0 ) //<S2SV> -- sum_in_vectors ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> sr_coded_error += ( int64_t ) this_error ; //<S2SV> } //<S2SV> coded_error += ( int64_t ) this_error ; //<S2SV> x -> plane [ 0 ] . src . buf += 16 ; //<S2SV> x -> plane [ 1 ] . src . buf += uv_mb_height ; //<S2SV> x -> plane [ 2 ] . src . buf += uv_mb_height ; //<S2SV> recon_yoffset += 16 ; //<S2SV> recon_uvoffset += uv_mb_height ; //<S2SV> } //<S2SV> x -> plane [ 0 ] . src . buf += 16 * x -> plane [ 0 ] . src . stride - 16 * cm -> mb_cols ; //<S2SV> x -> plane [ 1 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - //<S2SV> uv_mb_height * cm -> mb_cols ; //<S2SV> x -> plane [ 2 ] . src . buf += uv_mb_height * x -> plane [ 1 ] . src . stride - //<S2SV> uv_mb_height * cm -> mb_cols ; //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> } //<S2SV> if ( ( image_data_start_row > cm -> mb_rows / 2 ) || //<S2SV> ( image_data_start_row == INVALID_ROW ) ) { //<S2SV> image_data_start_row = cm -> mb_rows / 2 ; //<S2SV> } //<S2SV> if ( image_data_start_row > 0 ) { //<S2SV> intra_skip_count = //<S2SV> MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; //<S2SV> } //<S2SV> { //<S2SV> FIRSTPASS_STATS fps ; //<S2SV> const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) //<S2SV> ? cpi -> initial_mbs : cpi -> common . MBs ; //<S2SV> const double min_err = 200 * sqrt ( num_mbs ) ; //<S2SV> intra_factor = intra_factor / ( double ) num_mbs ; //<S2SV> brightness_factor = brightness_factor / ( double ) num_mbs ; //<S2SV> fps . weight = intra_factor * brightness_factor ; //<S2SV> fps . frame = cm -> current_video_frame ; //<S2SV> fps . spatial_layer_id = cpi -> svc . spatial_layer_id ; //<S2SV> fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; //<S2SV> fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err ; //<S2SV> fps . intra_error = ( double ) ( intra_error >> 8 ) + min_err ; //<S2SV> fps . count = 1.0 ; //<S2SV> fps . pcnt_inter = ( double ) intercount / num_mbs ; //<S2SV> fps . pcnt_second_ref = ( double ) second_ref_count / num_mbs ; //<S2SV> fps . pcnt_neutral = ( double ) neutral_count / num_mbs ; //<S2SV> fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; //<S2SV> fps . inactive_zone_rows = ( double ) image_data_start_row ; //<S2SV> fps . inactive_zone_cols = ( double ) 0 ; //<S2SV> if ( mvcount > 0 ) { //<S2SV> fps . MVr = ( double ) sum_mvr / mvcount ; //<S2SV> fps . mvr_abs = ( double ) sum_mvr_abs / mvcount ; //<S2SV> fps . MVc = ( double ) sum_mvc / mvcount ; //<S2SV> fps . mvc_abs = ( double ) sum_mvc_abs / mvcount ; //<S2SV> fps . MVrv = ( ( double ) sum_mvrs - //<S2SV> ( ( double ) sum_mvr * sum_mvr / mvcount ) ) / mvcount ; //<S2SV> fps . MVcv = ( ( double ) sum_mvcs - //<S2SV> ( ( double ) sum_mvc * sum_mvc / mvcount ) ) / mvcount ; //<S2SV> fps . mv_in_out_count = ( double ) sum_in_vectors / ( mvcount * 2 ) ; //<S2SV> fps . new_mv_count = new_mv_count ; //<S2SV> fps . pcnt_motion = ( double ) mvcount / num_mbs ; //<S2SV> } else { //<S2SV> fps . MVr = 0.0 ; //<S2SV> fps . mvr_abs = 0.0 ; //<S2SV> fps . MVc = 0.0 ; //<S2SV> fps . mvc_abs = 0.0 ; //<S2SV> fps . MVrv = 0.0 ; //<S2SV> fps . MVcv = 0.0 ; //<S2SV> fps . mv_in_out_count = 0.0 ; //<S2SV> fps . new_mv_count = 0.0 ; //<S2SV> fps . pcnt_motion = 0.0 ; //<S2SV> } //<S2SV> fps . duration = ( double ) ( source -> ts_end - source -> ts_start ) ; //<S2SV> twopass -> this_frame_stats = fps ; //<S2SV> output_stats ( & twopass -> this_frame_stats , cpi -> output_pkt_list ) ; //<S2SV> accumulate_stats ( & twopass -> total_stats , & fps ) ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> if ( ( twopass -> sr_update_lag > 3 ) || //<S2SV> ( ( cm -> current_video_frame > 0 ) && //<S2SV> ( twopass -> this_frame_stats . pcnt_inter > 0.20 ) && //<S2SV> ( ( twopass -> this_frame_stats . intra_error / //<S2SV> DOUBLE_DIVIDE_CHECK ( twopass -> this_frame_stats . coded_error ) ) > 2.0 ) ) ) { //<S2SV> if ( gld_yv12 != NULL ) { //<S2SV> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , //<S2SV> cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ; //<S2SV> } //<S2SV> twopass -> sr_update_lag = 1 ; //<S2SV> } else { //<S2SV> ++ twopass -> sr_update_lag ; //<S2SV> } //<S2SV> vpx_extend_frame_borders ( new_yv12 ) ; //<S2SV> if ( lc != NULL ) { //<S2SV> vp9_update_reference_frames ( cpi ) ; //<S2SV> } else { //<S2SV> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , //<S2SV> cm -> new_fb_idx ) ; //<S2SV> } //<S2SV> if ( cm -> current_video_frame == 0 && cpi -> gld_fb_idx != INVALID_IDX && //<S2SV> lc == NULL ) { //<S2SV> ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , //<S2SV> cm -> ref_frame_map [ cpi -> lst_fb_idx ] ) ; //<S2SV> } //<S2SV> if ( 0 ) { //<S2SV> char filename [ 512 ] ; //<S2SV> FILE * recon_file ; //<S2SV> snprintf ( filename , sizeof ( filename ) , "enc%04d.yuv" , //<S2SV> ( int ) cm -> current_video_frame ) ; //<S2SV> if ( cm -> current_video_frame == 0 ) //<S2SV> recon_file = fopen ( filename , "wb" ) ; //<S2SV> else //<S2SV> recon_file = fopen ( filename , "ab" ) ; //<S2SV> ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; //<S2SV> fclose ( recon_file ) ; //<S2SV> } //<S2SV> ++ cm -> current_video_frame ; //<S2SV> if ( cpi -> use_svc ) //<S2SV> vp9_inc_frame_in_layer ( cpi ) ; //<S2SV> } //<S2SV> 