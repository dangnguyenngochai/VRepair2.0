static size_t encode_tiles ( VP9_COMP * cpi , uint8_t * data_ptr ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> vpx_writer residual_bc ; //<S2SV> int tile_row , tile_col ; //<S2SV> TOKENEXTRA * tok_end ; //<S2SV> size_t total_size = 0 ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> memset ( cm -> above_seg_context , 0 , //<S2SV> sizeof ( * cm -> above_seg_context ) * mi_cols_aligned_to_sb ( cm -> mi_cols ) ) ; //<S2SV> for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { //<S2SV> for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { //<S2SV> int tile_idx = tile_row * tile_cols + tile_col ; //<S2SV> TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] ; //<S2SV> tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] + //<S2SV> cpi -> tok_count [ tile_row ] [ tile_col ] ; //<S2SV> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) //<S2SV> vpx_start_encode ( & residual_bc , data_ptr + total_size + 4 ) ; //<S2SV> else //<S2SV> vpx_start_encode ( & residual_bc , data_ptr + total_size ) ; //<S2SV> write_modes ( cpi , & cpi -> tile_data [ tile_idx ] . tile_info , //<S2SV> & residual_bc , & tok , tok_end ) ; //<S2SV> assert ( tok == tok_end ) ; //<S2SV> vpx_stop_encode ( & residual_bc ) ; //<S2SV> if ( tile_col < tile_cols - 1 || tile_row < tile_rows - 1 ) { //<S2SV> mem_put_be32 ( data_ptr + total_size , residual_bc . pos ) ; //<S2SV> total_size += 4 ; //<S2SV> } //<S2SV> total_size += residual_bc . pos ; //<S2SV> } //<S2SV> } //<S2SV> return total_size ; //<S2SV> } //<S2SV> 