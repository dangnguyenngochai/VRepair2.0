static struct VP8D_COMP * create_decompressor ( VP8D_CONFIG * oxcf ) //<S2SV> { //<S2SV> VP8D_COMP * pbi = vpx_memalign ( 32 , sizeof ( VP8D_COMP ) ) ; //<S2SV> if ( ! pbi ) //<S2SV> return NULL ; //<S2SV> memset ( pbi , 0 , sizeof ( VP8D_COMP ) ) ; //<S2SV> if ( setjmp ( pbi -> common . error . jmp ) ) //<S2SV> { //<S2SV> pbi -> common . error . setjmp = 0 ; //<S2SV> remove_decompressor ( pbi ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> pbi -> common . error . setjmp = 1 ; //<S2SV> vp8_create_common ( & pbi -> common ) ; //<S2SV> pbi -> common . current_video_frame = 0 ; //<S2SV> pbi -> ready_for_new_data = 1 ; //<S2SV> vp8cx_init_de_quantizer ( pbi ) ; //<S2SV> vp8_loop_filter_init ( & pbi -> common ) ; //<S2SV> pbi -> common . error . setjmp = 0 ; //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> pbi -> ec_enabled = oxcf -> error_concealment ; //<S2SV> pbi -> overlaps = NULL ; //<S2SV> # else //<S2SV> ( void ) oxcf ; //<S2SV> pbi -> ec_enabled = 0 ; //<S2SV> # endif //<S2SV> pbi -> ec_active = 0 ; //<S2SV> pbi -> decoded_key_frame = 0 ; //<S2SV> pbi -> independent_partitions = 0 ; //<S2SV> vp8_setup_block_dptrs ( & pbi -> mb ) ; //<S2SV> return pbi ; //<S2SV> } //<S2SV> 