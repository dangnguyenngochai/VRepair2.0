static void get_cx_data ( struct stream_state * stream , //<S2SV> struct VpxEncoderConfig * global , //<S2SV> int * got_data ) { //<S2SV> const vpx_codec_cx_pkt_t * pkt ; //<S2SV> const struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; //<S2SV> vpx_codec_iter_t iter = NULL ; //<S2SV> * got_data = 0 ; //<S2SV> while ( ( pkt = vpx_codec_get_cx_data ( & stream -> encoder , & iter ) ) ) { //<S2SV> static size_t fsize = 0 ; //<S2SV> static int64_t ivf_header_pos = 0 ; //<S2SV> switch ( pkt -> kind ) { //<S2SV> case VPX_CODEC_CX_FRAME_PKT : //<S2SV> if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { //<S2SV> stream -> frames_out ++ ; //<S2SV> } //<S2SV> if ( ! global -> quiet ) //<S2SV> fprintf ( stderr , "<S2SV_blank>%6luF" , ( unsigned long ) pkt -> data . frame . sz ) ; //<S2SV> update_rate_histogram ( stream -> rate_hist , cfg , pkt ) ; //<S2SV> # if CONFIG_WEBM_IO //<S2SV> if ( stream -> config . write_webm ) { //<S2SV> write_webm_block ( & stream -> ebml , cfg , pkt ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( ! stream -> config . write_webm ) { //<S2SV> if ( pkt -> data . frame . partition_id <= 0 ) { //<S2SV> ivf_header_pos = ftello ( stream -> file ) ; //<S2SV> fsize = pkt -> data . frame . sz ; //<S2SV> ivf_write_frame_header ( stream -> file , pkt -> data . frame . pts , fsize ) ; //<S2SV> } else { //<S2SV> fsize += pkt -> data . frame . sz ; //<S2SV> if ( ! ( pkt -> data . frame . flags & VPX_FRAME_IS_FRAGMENT ) ) { //<S2SV> const int64_t currpos = ftello ( stream -> file ) ; //<S2SV> fseeko ( stream -> file , ivf_header_pos , SEEK_SET ) ; //<S2SV> ivf_write_frame_size ( stream -> file , fsize ) ; //<S2SV> fseeko ( stream -> file , currpos , SEEK_SET ) ; //<S2SV> } //<S2SV> } //<S2SV> ( void ) fwrite ( pkt -> data . frame . buf , 1 , pkt -> data . frame . sz , //<S2SV> stream -> file ) ; //<S2SV> } //<S2SV> stream -> nbytes += pkt -> data . raw . sz ; //<S2SV> * got_data = 1 ; //<S2SV> # if CONFIG_DECODERS //<S2SV> if ( global -> test_decode != TEST_DECODE_OFF && ! stream -> mismatch_seen ) { //<S2SV> vpx_codec_decode ( & stream -> decoder , pkt -> data . frame . buf , //<S2SV> ( unsigned int ) pkt -> data . frame . sz , NULL , 0 ) ; //<S2SV> if ( stream -> decoder . err ) { //<S2SV> warn_or_exit_on_error ( & stream -> decoder , //<S2SV> global -> test_decode == TEST_DECODE_FATAL , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>stream<S2SV_blank>%d" , //<S2SV> stream -> frames_out + 1 , stream -> index ) ; //<S2SV> stream -> mismatch_seen = stream -> frames_out + 1 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> break ; //<S2SV> case VPX_CODEC_STATS_PKT : //<S2SV> stream -> frames_out ++ ; //<S2SV> stats_write ( & stream -> stats , //<S2SV> pkt -> data . twopass_stats . buf , //<S2SV> pkt -> data . twopass_stats . sz ) ; //<S2SV> stream -> nbytes += pkt -> data . raw . sz ; //<S2SV> break ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> case VPX_CODEC_FPMB_STATS_PKT : //<S2SV> stats_write ( & stream -> fpmb_stats , //<S2SV> pkt -> data . firstpass_mb_stats . buf , //<S2SV> pkt -> data . firstpass_mb_stats . sz ) ; //<S2SV> stream -> nbytes += pkt -> data . raw . sz ; //<S2SV> break ; //<S2SV> # endif //<S2SV> case VPX_CODEC_PSNR_PKT : //<S2SV> if ( global -> show_psnr ) { //<S2SV> int i ; //<S2SV> stream -> psnr_sse_total += pkt -> data . psnr . sse [ 0 ] ; //<S2SV> stream -> psnr_samples_total += pkt -> data . psnr . samples [ 0 ] ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> if ( ! global -> quiet ) //<S2SV> fprintf ( stderr , "%.3f<S2SV_blank>" , pkt -> data . psnr . psnr [ i ] ) ; //<S2SV> stream -> psnr_totals [ i ] += pkt -> data . psnr . psnr [ i ] ; //<S2SV> } //<S2SV> stream -> psnr_count ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 