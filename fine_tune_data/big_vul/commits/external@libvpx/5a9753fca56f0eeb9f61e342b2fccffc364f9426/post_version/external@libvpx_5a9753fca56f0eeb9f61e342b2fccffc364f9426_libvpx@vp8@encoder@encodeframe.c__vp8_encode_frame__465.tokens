void vp8_encode_frame ( VP8_COMP * cpi ) //<S2SV> { //<S2SV> int mb_row ; //<S2SV> MACROBLOCK * const x = & cpi -> mb ; //<S2SV> VP8_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> TOKENEXTRA * tp = cpi -> tok ; //<S2SV> int segment_counts [ MAX_MB_SEGMENTS ] ; //<S2SV> int totalrate ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> BOOL_CODER * bc = & cpi -> bc [ 1 ] ; //<S2SV> const int num_part = ( 1 << cm -> multi_token_partition ) ; //<S2SV> # endif //<S2SV> memset ( segment_counts , 0 , sizeof ( segment_counts ) ) ; //<S2SV> totalrate = 0 ; //<S2SV> if ( cpi -> compressor_speed == 2 ) //<S2SV> { //<S2SV> if ( cpi -> oxcf . cpu_used < 0 ) //<S2SV> cpi -> Speed = - ( cpi -> oxcf . cpu_used ) ; //<S2SV> else //<S2SV> vp8_auto_select_speed ( cpi ) ; //<S2SV> } //<S2SV> if ( ! cm -> use_bilinear_mc_filter ) //<S2SV> { //<S2SV> xd -> subpixel_predict = vp8_sixtap_predict4x4 ; //<S2SV> xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; //<S2SV> xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; //<S2SV> xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> xd -> subpixel_predict = vp8_bilinear_predict4x4 ; //<S2SV> xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; //<S2SV> xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; //<S2SV> xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; //<S2SV> } //<S2SV> cpi -> mb . skip_true_count = 0 ; //<S2SV> cpi -> tok_count = 0 ; //<S2SV> # if 0 //<S2SV> cpi -> frame_distortion = 0 ; //<S2SV> cpi -> last_mb_distortion = 0 ; //<S2SV> # endif //<S2SV> xd -> mode_info_context = cm -> mi ; //<S2SV> vp8_zero ( cpi -> mb . MVcount ) ; //<S2SV> vp8cx_frame_init_quantizer ( cpi ) ; //<S2SV> vp8_initialize_rd_consts ( cpi , x , //<S2SV> vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; //<S2SV> vp8cx_initialize_me_consts ( cpi , cm -> base_qindex ) ; //<S2SV> if ( cpi -> oxcf . tuning == VP8_TUNE_SSIM ) //<S2SV> { //<S2SV> init_encode_frame_mb_context ( cpi ) ; //<S2SV> build_activity_map ( cpi ) ; //<S2SV> } //<S2SV> init_encode_frame_mb_context ( cpi ) ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> vp8_start_encode ( & bc [ i ] , cpi -> partition_d [ i + 1 ] , //<S2SV> cpi -> partition_d_end [ i + 1 ] ) ; //<S2SV> bc [ i ] . error = & cm -> error ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> { //<S2SV> struct vpx_usec_timer emr_timer ; //<S2SV> vpx_usec_timer_start ( & emr_timer ) ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( cpi -> b_multi_threaded ) //<S2SV> { //<S2SV> int i ; //<S2SV> vp8cx_init_mbrthread_data ( cpi , x , cpi -> mb_row_ei , //<S2SV> cpi -> encoding_thread_count ) ; //<S2SV> for ( i = 0 ; i < cm -> mb_rows ; i ++ ) //<S2SV> cpi -> mt_current_mb_col [ i ] = - 1 ; //<S2SV> for ( i = 0 ; i < cpi -> encoding_thread_count ; i ++ ) //<S2SV> { //<S2SV> sem_post ( & cpi -> h_event_start_encoding [ i ] ) ; //<S2SV> } //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row += ( cpi -> encoding_thread_count + 1 ) ) //<S2SV> { //<S2SV> vp8_zero ( cm -> left_context ) //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> tp = cpi -> tok ; //<S2SV> # else //<S2SV> tp = cpi -> tok + mb_row * ( cm -> mb_cols * 16 * 24 ) ; //<S2SV> # endif //<S2SV> encode_mb_row ( cpi , cm , mb_row , x , xd , & tp , segment_counts , & totalrate ) ; //<S2SV> x -> src . y_buffer += 16 * x -> src . y_stride * ( cpi -> encoding_thread_count + 1 ) - 16 * cm -> mb_cols ; //<S2SV> x -> src . u_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ; //<S2SV> x -> src . v_buffer += 8 * x -> src . uv_stride * ( cpi -> encoding_thread_count + 1 ) - 8 * cm -> mb_cols ; //<S2SV> xd -> mode_info_context += xd -> mode_info_stride * cpi -> encoding_thread_count ; //<S2SV> x -> partition_info += xd -> mode_info_stride * cpi -> encoding_thread_count ; //<S2SV> x -> gf_active_ptr += cm -> mb_cols * cpi -> encoding_thread_count ; //<S2SV> if ( mb_row == cm -> mb_rows - 1 ) //<S2SV> { //<S2SV> sem_post ( & cpi -> h_event_end_encoding ) ; //<S2SV> } //<S2SV> } //<S2SV> sem_wait ( & cpi -> h_event_end_encoding ) ; //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) //<S2SV> { //<S2SV> cpi -> tok_count += ( unsigned int ) //<S2SV> ( cpi -> tplist [ mb_row ] . stop - cpi -> tplist [ mb_row ] . start ) ; //<S2SV> } //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> int j ; //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> for ( i = 0 ; i < cpi -> encoding_thread_count ; i ++ ) //<S2SV> { //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> segment_counts [ j ] += cpi -> mb_row_ei [ i ] . segment_counts [ j ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < cpi -> encoding_thread_count ; i ++ ) //<S2SV> { //<S2SV> int mode_count ; //<S2SV> int c_idx ; //<S2SV> totalrate += cpi -> mb_row_ei [ i ] . totalrate ; //<S2SV> cpi -> mb . skip_true_count += cpi -> mb_row_ei [ i ] . mb . skip_true_count ; //<S2SV> for ( mode_count = 0 ; mode_count < VP8_YMODES ; mode_count ++ ) //<S2SV> cpi -> mb . ymode_count [ mode_count ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . ymode_count [ mode_count ] ; //<S2SV> for ( mode_count = 0 ; mode_count < VP8_UV_MODES ; mode_count ++ ) //<S2SV> cpi -> mb . uv_mode_count [ mode_count ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . uv_mode_count [ mode_count ] ; //<S2SV> for ( c_idx = 0 ; c_idx < MVvals ; c_idx ++ ) //<S2SV> { //<S2SV> cpi -> mb . MVcount [ 0 ] [ c_idx ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . MVcount [ 0 ] [ c_idx ] ; //<S2SV> cpi -> mb . MVcount [ 1 ] [ c_idx ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . MVcount [ 1 ] [ c_idx ] ; //<S2SV> } //<S2SV> cpi -> mb . prediction_error += //<S2SV> cpi -> mb_row_ei [ i ] . mb . prediction_error ; //<S2SV> cpi -> mb . intra_error += cpi -> mb_row_ei [ i ] . mb . intra_error ; //<S2SV> for ( c_idx = 0 ; c_idx < MAX_REF_FRAMES ; c_idx ++ ) //<S2SV> cpi -> mb . count_mb_ref_frame_usage [ c_idx ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . count_mb_ref_frame_usage [ c_idx ] ; //<S2SV> for ( c_idx = 0 ; c_idx < MAX_ERROR_BINS ; c_idx ++ ) //<S2SV> cpi -> mb . error_bins [ c_idx ] += //<S2SV> cpi -> mb_row_ei [ i ] . mb . error_bins [ c_idx ] ; //<S2SV> sum_coef_counts ( x , & cpi -> mb_row_ei [ i ] . mb ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> # endif //<S2SV> { //<S2SV> for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) //<S2SV> { //<S2SV> vp8_zero ( cm -> left_context ) //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> tp = cpi -> tok ; //<S2SV> # endif //<S2SV> encode_mb_row ( cpi , cm , mb_row , x , xd , & tp , segment_counts , & totalrate ) ; //<S2SV> x -> src . y_buffer += 16 * x -> src . y_stride - 16 * cm -> mb_cols ; //<S2SV> x -> src . u_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; //<S2SV> x -> src . v_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; //<S2SV> } //<S2SV> cpi -> tok_count = ( unsigned int ) ( tp - cpi -> tok ) ; //<S2SV> } //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> vp8_stop_encode ( & bc [ i ] ) ; //<S2SV> cpi -> partition_sz [ i + 1 ] = bc [ i ] . pos ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> vpx_usec_timer_mark ( & emr_timer ) ; //<S2SV> cpi -> time_encode_mb_row += vpx_usec_timer_elapsed ( & emr_timer ) ; //<S2SV> } //<S2SV> if ( xd -> segmentation_enabled && xd -> update_mb_segmentation_map ) //<S2SV> { //<S2SV> int tot_count ; //<S2SV> int i ; //<S2SV> memset ( xd -> mb_segment_tree_probs , 255 , sizeof ( xd -> mb_segment_tree_probs ) ) ; //<S2SV> tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] + segment_counts [ 2 ] + segment_counts [ 3 ] ; //<S2SV> if ( tot_count ) //<S2SV> { //<S2SV> xd -> mb_segment_tree_probs [ 0 ] = ( ( segment_counts [ 0 ] + segment_counts [ 1 ] ) * 255 ) / tot_count ; //<S2SV> tot_count = segment_counts [ 0 ] + segment_counts [ 1 ] ; //<S2SV> if ( tot_count > 0 ) //<S2SV> { //<S2SV> xd -> mb_segment_tree_probs [ 1 ] = ( segment_counts [ 0 ] * 255 ) / tot_count ; //<S2SV> } //<S2SV> tot_count = segment_counts [ 2 ] + segment_counts [ 3 ] ; //<S2SV> if ( tot_count > 0 ) //<S2SV> xd -> mb_segment_tree_probs [ 2 ] = ( segment_counts [ 2 ] * 255 ) / tot_count ; //<S2SV> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) //<S2SV> { //<S2SV> if ( xd -> mb_segment_tree_probs [ i ] == 0 ) //<S2SV> xd -> mb_segment_tree_probs [ i ] = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> cpi -> projected_frame_size = totalrate >> 8 ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) //<S2SV> { //<S2SV> cpi -> this_frame_percent_intra = 100 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int tot_modes ; //<S2SV> tot_modes = cpi -> mb . count_mb_ref_frame_usage [ INTRA_FRAME ] //<S2SV> + cpi -> mb . count_mb_ref_frame_usage [ LAST_FRAME ] //<S2SV> + cpi -> mb . count_mb_ref_frame_usage [ GOLDEN_FRAME ] //<S2SV> + cpi -> mb . count_mb_ref_frame_usage [ ALTREF_FRAME ] ; //<S2SV> if ( tot_modes ) //<S2SV> cpi -> this_frame_percent_intra = //<S2SV> cpi -> mb . count_mb_ref_frame_usage [ INTRA_FRAME ] * 100 / tot_modes ; //<S2SV> } //<S2SV> # if ! CONFIG_REALTIME_ONLY //<S2SV> if ( ( cm -> frame_type != KEY_FRAME ) && ( ( cpi -> oxcf . number_of_layers > 1 ) || //<S2SV> ( ! cm -> refresh_alt_ref_frame && ! cm -> refresh_golden_frame ) ) ) //<S2SV> { //<S2SV> vp8_convert_rfct_to_prob ( cpi ) ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> 