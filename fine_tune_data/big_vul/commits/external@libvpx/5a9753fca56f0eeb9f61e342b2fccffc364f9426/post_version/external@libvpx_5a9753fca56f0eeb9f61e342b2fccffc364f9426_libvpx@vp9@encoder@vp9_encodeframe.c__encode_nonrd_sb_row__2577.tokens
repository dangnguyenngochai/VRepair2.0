static void encode_nonrd_sb_row ( VP9_COMP * cpi , //<S2SV> ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> int mi_row , //<S2SV> TOKENEXTRA * * tp ) { //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> int mi_col ; //<S2SV> memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; //<S2SV> memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; //<S2SV> for ( mi_col = tile_info -> mi_col_start ; mi_col < tile_info -> mi_col_end ; //<S2SV> mi_col += MI_BLOCK_SIZE ) { //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> RD_COST dummy_rdc ; //<S2SV> const int idx_str = cm -> mi_stride * mi_row + mi_col ; //<S2SV> MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ; //<S2SV> PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type ; //<S2SV> BLOCK_SIZE bsize = BLOCK_64X64 ; //<S2SV> int seg_skip = 0 ; //<S2SV> x -> source_variance = UINT_MAX ; //<S2SV> vp9_zero ( x -> pred_mv ) ; //<S2SV> vp9_rd_cost_init ( & dummy_rdc ) ; //<S2SV> x -> color_sensitivity [ 0 ] = 0 ; //<S2SV> x -> color_sensitivity [ 1 ] = 0 ; //<S2SV> if ( seg -> enabled ) { //<S2SV> const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; //<S2SV> seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; //<S2SV> if ( seg_skip ) { //<S2SV> partition_search_type = FIXED_PARTITION ; //<S2SV> } //<S2SV> } //<S2SV> switch ( partition_search_type ) { //<S2SV> case VAR_BASED_PARTITION : //<S2SV> choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; //<S2SV> break ; //<S2SV> case SOURCE_VAR_BASED_PARTITION : //<S2SV> set_source_var_based_partition ( cpi , tile_info , x , mi , mi_row , mi_col ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; //<S2SV> break ; //<S2SV> case FIXED_PARTITION : //<S2SV> if ( ! seg_skip ) //<S2SV> bsize = sf -> always_this_block_size ; //<S2SV> set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; //<S2SV> break ; //<S2SV> case REFERENCE_PARTITION : //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && //<S2SV> xd -> mi [ 0 ] -> mbmi . segment_id ) { //<S2SV> if ( cm -> width <= 352 && cm -> height <= 288 ) //<S2SV> x -> max_partition_size = BLOCK_32X32 ; //<S2SV> else //<S2SV> x -> max_partition_size = BLOCK_64X64 ; //<S2SV> x -> min_partition_size = BLOCK_8X8 ; //<S2SV> nonrd_pick_partition ( cpi , td , tile_data , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , & dummy_rdc , 1 , //<S2SV> INT64_MAX , td -> pc_root ) ; //<S2SV> } else { //<S2SV> choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; //<S2SV> else //<S2SV> nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 