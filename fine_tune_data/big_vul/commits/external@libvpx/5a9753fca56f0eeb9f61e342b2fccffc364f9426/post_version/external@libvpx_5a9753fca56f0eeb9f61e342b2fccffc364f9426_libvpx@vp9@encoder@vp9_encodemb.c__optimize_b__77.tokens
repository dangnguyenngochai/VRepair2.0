static int optimize_b ( MACROBLOCK * mb , int plane , int block , //<S2SV> TX_SIZE tx_size , int ctx ) { //<S2SV> MACROBLOCKD * const xd = & mb -> e_mbd ; //<S2SV> struct macroblock_plane * const p = & mb -> plane [ plane ] ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; //<S2SV> const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; //<S2SV> vp9_token_state tokens [ 1025 ] [ 2 ] ; //<S2SV> unsigned best_index [ 1025 ] [ 2 ] ; //<S2SV> uint8_t token_cache [ 1024 ] ; //<S2SV> const tran_low_t * const coeff = BLOCK_OFFSET ( mb -> plane [ plane ] . coeff , block ) ; //<S2SV> tran_low_t * const qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; //<S2SV> tran_low_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; //<S2SV> const int eob = p -> eobs [ block ] ; //<S2SV> const PLANE_TYPE type = pd -> plane_type ; //<S2SV> const int default_eob = 16 << ( tx_size << 1 ) ; //<S2SV> const int mul = 1 + ( tx_size == TX_32X32 ) ; //<S2SV> const int16_t * dequant_ptr = pd -> dequant ; //<S2SV> const uint8_t * const band_translate = get_band_translate ( tx_size ) ; //<S2SV> const scan_order * const so = get_scan ( xd , tx_size , type , block ) ; //<S2SV> const int16_t * const scan = so -> scan ; //<S2SV> const int16_t * const nb = so -> neighbors ; //<S2SV> int next = eob , sz = 0 ; //<S2SV> int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ; //<S2SV> int64_t rd_cost0 , rd_cost1 ; //<S2SV> int rate0 , rate1 , error0 , error1 ; //<S2SV> int16_t t0 , t1 ; //<S2SV> EXTRABIT e0 ; //<S2SV> int best , band , pt , i , final_eob ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; //<S2SV> # else //<S2SV> const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; //<S2SV> # endif //<S2SV> assert ( ( ! type && ! plane ) || ( type && plane ) ) ; //<S2SV> assert ( eob <= default_eob ) ; //<S2SV> if ( ! ref ) //<S2SV> rdmult = ( rdmult * 9 ) >> 4 ; //<S2SV> tokens [ eob ] [ 0 ] . rate = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . error = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . next = default_eob ; //<S2SV> tokens [ eob ] [ 0 ] . token = EOB_TOKEN ; //<S2SV> tokens [ eob ] [ 0 ] . qc = 0 ; //<S2SV> tokens [ eob ] [ 1 ] = tokens [ eob ] [ 0 ] ; //<S2SV> for ( i = 0 ; i < eob ; i ++ ) //<S2SV> token_cache [ scan [ i ] ] = //<S2SV> vp9_pt_energy_class [ vp9_get_token ( qcoeff [ scan [ i ] ] ) ] ; //<S2SV> for ( i = eob ; i -- > 0 ; ) { //<S2SV> int base_bits , d2 , dx ; //<S2SV> const int rc = scan [ i ] ; //<S2SV> int x = qcoeff [ rc ] ; //<S2SV> if ( x ) { //<S2SV> int shortcut = 0 ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> vp9_get_token_extra ( x , & t0 , & e0 ) ; //<S2SV> if ( next < default_eob ) { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t0 , token_cache ) ; //<S2SV> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] //<S2SV> [ tokens [ next ] [ 0 ] . token ] ; //<S2SV> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ pt ] //<S2SV> [ tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ; //<S2SV> dx = mul * ( dqcoeff [ rc ] - coeff [ rc ] ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> dx >>= xd -> bd - 8 ; //<S2SV> } //<S2SV> # endif //<S2SV> d2 = dx * dx ; //<S2SV> tokens [ i ] [ 0 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 0 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 0 ] . next = next ; //<S2SV> tokens [ i ] [ 0 ] . token = t0 ; //<S2SV> tokens [ i ] [ 0 ] . qc = x ; //<S2SV> best_index [ i ] [ 0 ] = best ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> if ( ( abs ( x ) * dequant_ptr [ rc != 0 ] > abs ( coeff [ rc ] ) * mul ) && //<S2SV> ( abs ( x ) * dequant_ptr [ rc != 0 ] < abs ( coeff [ rc ] ) * mul + //<S2SV> dequant_ptr [ rc != 0 ] ) ) //<S2SV> shortcut = 1 ; //<S2SV> else //<S2SV> shortcut = 0 ; //<S2SV> if ( shortcut ) { //<S2SV> sz = - ( x < 0 ) ; //<S2SV> x -= 2 * sz + 1 ; //<S2SV> } //<S2SV> if ( ! x ) { //<S2SV> t0 = tokens [ next ] [ 0 ] . token == EOB_TOKEN ? EOB_TOKEN : ZERO_TOKEN ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token == EOB_TOKEN ? EOB_TOKEN : ZERO_TOKEN ; //<S2SV> e0 = 0 ; //<S2SV> } else { //<S2SV> vp9_get_token_extra ( x , & t0 , & e0 ) ; //<S2SV> t1 = t0 ; //<S2SV> } //<S2SV> if ( next < default_eob ) { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> if ( t0 != EOB_TOKEN ) { //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t0 , token_cache ) ; //<S2SV> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ ! x ] [ pt ] //<S2SV> [ tokens [ next ] [ 0 ] . token ] ; //<S2SV> } //<S2SV> if ( t1 != EOB_TOKEN ) { //<S2SV> pt = trellis_get_coeff_context ( scan , nb , i , t1 , token_cache ) ; //<S2SV> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ ! x ] [ pt ] //<S2SV> [ tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> } //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost ) ; //<S2SV> if ( shortcut ) { //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> dx -= ( ( dequant_ptr [ rc != 0 ] >> ( xd -> bd - 8 ) ) + sz ) ^ sz ; //<S2SV> } else { //<S2SV> dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; //<S2SV> } //<S2SV> # else //<S2SV> dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; //<S2SV> # endif //<S2SV> d2 = dx * dx ; //<S2SV> } //<S2SV> tokens [ i ] [ 1 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 1 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 1 ] . next = next ; //<S2SV> tokens [ i ] [ 1 ] . token = best ? t1 : t0 ; //<S2SV> tokens [ i ] [ 1 ] . qc = x ; //<S2SV> best_index [ i ] [ 1 ] = best ; //<S2SV> next = i ; //<S2SV> } else { //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> if ( t0 != EOB_TOKEN ) { //<S2SV> tokens [ next ] [ 0 ] . rate += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t0 ] ; //<S2SV> tokens [ next ] [ 0 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> if ( t1 != EOB_TOKEN ) { //<S2SV> tokens [ next ] [ 1 ] . rate += //<S2SV> mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 1 ] [ 0 ] [ t1 ] ; //<S2SV> tokens [ next ] [ 1 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> best_index [ i ] [ 0 ] = best_index [ i ] [ 1 ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> band = band_translate [ i + 1 ] ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> rate0 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ ctx ] [ t0 ] ; //<S2SV> rate1 += mb -> token_costs [ tx_size ] [ type ] [ ref ] [ band ] [ 0 ] [ ctx ] [ t1 ] ; //<S2SV> UPDATE_RD_COST ( ) ; //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> final_eob = - 1 ; //<S2SV> memset ( qcoeff , 0 , sizeof ( * qcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; //<S2SV> memset ( dqcoeff , 0 , sizeof ( * dqcoeff ) * ( 16 << ( tx_size * 2 ) ) ) ; //<S2SV> for ( i = next ; i < eob ; i = next ) { //<S2SV> const int x = tokens [ i ] [ best ] . qc ; //<S2SV> const int rc = scan [ i ] ; //<S2SV> if ( x ) { //<S2SV> final_eob = i ; //<S2SV> } //<S2SV> qcoeff [ rc ] = x ; //<S2SV> dqcoeff [ rc ] = ( x * dequant_ptr [ rc != 0 ] ) / mul ; //<S2SV> next = tokens [ i ] [ best ] . next ; //<S2SV> best = best_index [ i ] [ best ] ; //<S2SV> } //<S2SV> final_eob ++ ; //<S2SV> mb -> plane [ plane ] . eobs [ block ] = final_eob ; //<S2SV> return final_eob ; //<S2SV> } //<S2SV> 