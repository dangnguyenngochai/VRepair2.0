static void pack_mb_tokens ( vpx_writer * w , //<S2SV> TOKENEXTRA * * tp , const TOKENEXTRA * const stop , //<S2SV> vpx_bit_depth_t bit_depth ) { //<S2SV> TOKENEXTRA * p = * tp ; //<S2SV> while ( p < stop && p -> token != EOSB_TOKEN ) { //<S2SV> const int t = p -> token ; //<S2SV> const struct vp9_token * const a = & vp9_coef_encodings [ t ] ; //<S2SV> int i = 0 ; //<S2SV> int v = a -> value ; //<S2SV> int n = a -> len ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> const vp9_extra_bit * b ; //<S2SV> if ( bit_depth == VPX_BITS_12 ) //<S2SV> b = & vp9_extra_bits_high12 [ t ] ; //<S2SV> else if ( bit_depth == VPX_BITS_10 ) //<S2SV> b = & vp9_extra_bits_high10 [ t ] ; //<S2SV> else //<S2SV> b = & vp9_extra_bits [ t ] ; //<S2SV> # else //<S2SV> const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; //<S2SV> ( void ) bit_depth ; //<S2SV> # endif //<S2SV> if ( p -> skip_eob_node ) { //<S2SV> n -= p -> skip_eob_node ; //<S2SV> i = 2 * p -> skip_eob_node ; //<S2SV> } //<S2SV> if ( t >= TWO_TOKEN && t < EOB_TOKEN ) { //<S2SV> int len = UNCONSTRAINED_NODES - p -> skip_eob_node ; //<S2SV> int bits = v >> ( n - len ) ; //<S2SV> vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , bits , len , i ) ; //<S2SV> vp9_write_tree ( w , vp9_coef_con_tree , //<S2SV> vp9_pareto8_full [ p -> context_tree [ PIVOT_NODE ] - 1 ] , //<S2SV> v , n - len , 0 ) ; //<S2SV> } else { //<S2SV> vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , v , n , i ) ; //<S2SV> } //<S2SV> if ( b -> base_val ) { //<S2SV> const int e = p -> extra , l = b -> len ; //<S2SV> if ( l ) { //<S2SV> const unsigned char * pb = b -> prob ; //<S2SV> int v = e >> 1 ; //<S2SV> int n = l ; //<S2SV> int i = 0 ; //<S2SV> do { //<S2SV> const int bb = ( v >> -- n ) & 1 ; //<S2SV> vpx_write ( w , bb , pb [ i >> 1 ] ) ; //<S2SV> i = b -> tree [ i + bb ] ; //<S2SV> } while ( n ) ; //<S2SV> } //<S2SV> vpx_write_bit ( w , e & 1 ) ; //<S2SV> } //<S2SV> ++ p ; //<S2SV> } //<S2SV> * tp = p + ( p -> token == EOSB_TOKEN ) ; //<S2SV> } //<S2SV> 