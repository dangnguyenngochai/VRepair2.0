static vpx_codec_err_t init_decoder ( vpx_codec_alg_priv_t * ctx ) { //<S2SV> int i ; //<S2SV> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; //<S2SV> ctx -> last_show_frame = - 1 ; //<S2SV> ctx -> next_submit_worker_id = 0 ; //<S2SV> ctx -> last_submit_worker_id = 0 ; //<S2SV> ctx -> next_output_worker_id = 0 ; //<S2SV> ctx -> frame_cache_read = 0 ; //<S2SV> ctx -> frame_cache_write = 0 ; //<S2SV> ctx -> num_cache_frames = 0 ; //<S2SV> ctx -> need_resync = 1 ; //<S2SV> ctx -> num_frame_workers = //<S2SV> ( ctx -> frame_parallel_decode == 1 ) ? ctx -> cfg . threads : 1 ; //<S2SV> if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) //<S2SV> ctx -> num_frame_workers = MAX_DECODE_THREADS ; //<S2SV> ctx -> available_threads = ctx -> num_frame_workers ; //<S2SV> ctx -> flushed = 0 ; //<S2SV> ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; //<S2SV> if ( ctx -> buffer_pool == NULL ) //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> # endif //<S2SV> ctx -> frame_workers = ( VPxWorker * ) //<S2SV> vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ; //<S2SV> if ( ctx -> frame_workers == NULL ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { //<S2SV> VPxWorker * const worker = & ctx -> frame_workers [ i ] ; //<S2SV> FrameWorkerData * frame_worker_data = NULL ; //<S2SV> winterface -> init ( worker ) ; //<S2SV> worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ; //<S2SV> if ( worker -> data1 == NULL ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; //<S2SV> frame_worker_data -> pbi = vp9_decoder_create ( ctx -> buffer_pool ) ; //<S2SV> if ( frame_worker_data -> pbi == NULL ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> frame_worker_data -> pbi -> frame_worker_owner = worker ; //<S2SV> frame_worker_data -> worker_id = i ; //<S2SV> frame_worker_data -> scratch_buffer = NULL ; //<S2SV> frame_worker_data -> scratch_buffer_size = 0 ; //<S2SV> frame_worker_data -> frame_context_ready = 0 ; //<S2SV> frame_worker_data -> received_frame = 0 ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> # endif //<S2SV> frame_worker_data -> pbi -> max_threads = //<S2SV> ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ; //<S2SV> frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ; //<S2SV> frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ; //<S2SV> frame_worker_data -> pbi -> common . frame_parallel_decode = //<S2SV> ctx -> frame_parallel_decode ; //<S2SV> worker -> hook = ( VPxWorkerHook ) frame_worker_hook ; //<S2SV> if ( ! winterface -> reset ( worker ) ) { //<S2SV> set_error_detail ( ctx , "Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! ctx -> postproc_cfg_set && //<S2SV> ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) ) //<S2SV> set_default_ppflags ( & ctx -> postproc_cfg ) ; //<S2SV> init_buffer_callbacks ( ctx ) ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 