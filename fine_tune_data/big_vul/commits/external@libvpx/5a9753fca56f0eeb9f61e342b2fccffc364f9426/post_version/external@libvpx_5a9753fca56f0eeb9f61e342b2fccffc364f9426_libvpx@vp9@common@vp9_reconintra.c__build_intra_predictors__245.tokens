static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , //<S2SV> int ref_stride , uint8_t * dst , int dst_stride , //<S2SV> PREDICTION_MODE mode , TX_SIZE tx_size , //<S2SV> int up_available , int left_available , //<S2SV> int right_available , int x , int y , //<S2SV> int plane ) { //<S2SV> int i ; //<S2SV> DECLARE_ALIGNED ( 16 , uint8_t , left_col [ 32 ] ) ; //<S2SV> DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] ) ; //<S2SV> uint8_t * above_row = above_data + 16 ; //<S2SV> const uint8_t * const_above_row = above_row ; //<S2SV> const int bs = 4 << tx_size ; //<S2SV> int frame_width , frame_height ; //<S2SV> int x0 , y0 ; //<S2SV> const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; //<S2SV> if ( plane == 0 ) { //<S2SV> frame_width = xd -> cur_buf -> y_width ; //<S2SV> frame_height = xd -> cur_buf -> y_height ; //<S2SV> } else { //<S2SV> frame_width = xd -> cur_buf -> uv_width ; //<S2SV> frame_height = xd -> cur_buf -> uv_height ; //<S2SV> } //<S2SV> x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; //<S2SV> y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; //<S2SV> if ( extend_modes [ mode ] & NEED_LEFT ) { //<S2SV> if ( left_available ) { //<S2SV> if ( xd -> mb_to_bottom_edge < 0 ) { //<S2SV> if ( y0 + bs <= frame_height ) { //<S2SV> for ( i = 0 ; i < bs ; ++ i ) //<S2SV> left_col [ i ] = ref [ i * ref_stride - 1 ] ; //<S2SV> } else { //<S2SV> const int extend_bottom = frame_height - y0 ; //<S2SV> for ( i = 0 ; i < extend_bottom ; ++ i ) //<S2SV> left_col [ i ] = ref [ i * ref_stride - 1 ] ; //<S2SV> for ( ; i < bs ; ++ i ) //<S2SV> left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; //<S2SV> } //<S2SV> } else { //<S2SV> for ( i = 0 ; i < bs ; ++ i ) //<S2SV> left_col [ i ] = ref [ i * ref_stride - 1 ] ; //<S2SV> } //<S2SV> } else { //<S2SV> memset ( left_col , 129 , bs ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( extend_modes [ mode ] & NEED_ABOVE ) { //<S2SV> if ( up_available ) { //<S2SV> const uint8_t * above_ref = ref - ref_stride ; //<S2SV> if ( xd -> mb_to_right_edge < 0 ) { //<S2SV> if ( x0 + bs <= frame_width ) { //<S2SV> memcpy ( above_row , above_ref , bs ) ; //<S2SV> } else if ( x0 <= frame_width ) { //<S2SV> const int r = frame_width - x0 ; //<S2SV> memcpy ( above_row , above_ref , r ) ; //<S2SV> memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( bs == 4 && right_available && left_available ) { //<S2SV> const_above_row = above_ref ; //<S2SV> } else { //<S2SV> memcpy ( above_row , above_ref , bs ) ; //<S2SV> } //<S2SV> } //<S2SV> above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; //<S2SV> } else { //<S2SV> memset ( above_row , 127 , bs ) ; //<S2SV> above_row [ - 1 ] = 127 ; //<S2SV> } //<S2SV> } //<S2SV> if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { //<S2SV> if ( up_available ) { //<S2SV> const uint8_t * above_ref = ref - ref_stride ; //<S2SV> if ( xd -> mb_to_right_edge < 0 ) { //<S2SV> if ( x0 + 2 * bs <= frame_width ) { //<S2SV> if ( right_available && bs == 4 ) { //<S2SV> memcpy ( above_row , above_ref , 2 * bs ) ; //<S2SV> } else { //<S2SV> memcpy ( above_row , above_ref , bs ) ; //<S2SV> memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; //<S2SV> } //<S2SV> } else if ( x0 + bs <= frame_width ) { //<S2SV> const int r = frame_width - x0 ; //<S2SV> if ( right_available && bs == 4 ) { //<S2SV> memcpy ( above_row , above_ref , r ) ; //<S2SV> memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; //<S2SV> } else { //<S2SV> memcpy ( above_row , above_ref , bs ) ; //<S2SV> memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; //<S2SV> } //<S2SV> } else if ( x0 <= frame_width ) { //<S2SV> const int r = frame_width - x0 ; //<S2SV> memcpy ( above_row , above_ref , r ) ; //<S2SV> memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( bs == 4 && right_available && left_available ) { //<S2SV> const_above_row = above_ref ; //<S2SV> } else { //<S2SV> memcpy ( above_row , above_ref , bs ) ; //<S2SV> if ( bs == 4 && right_available ) //<S2SV> memcpy ( above_row + bs , above_ref + bs , bs ) ; //<S2SV> else //<S2SV> memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; //<S2SV> } //<S2SV> } //<S2SV> above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; //<S2SV> } else { //<S2SV> memset ( above_row , 127 , bs * 2 ) ; //<S2SV> above_row [ - 1 ] = 127 ; //<S2SV> } //<S2SV> } //<S2SV> if ( mode == DC_PRED ) { //<S2SV> dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , //<S2SV> const_above_row , left_col ) ; //<S2SV> } else { //<S2SV> pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; //<S2SV> } //<S2SV> } //<S2SV> 