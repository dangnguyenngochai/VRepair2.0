static void set_fixed_partitioning ( VP9_COMP * cpi , const TileInfo * const tile , //<S2SV> MODE_INFO * * mi_8x8 , int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int row8x8_remaining = tile -> mi_row_end - mi_row ; //<S2SV> const int col8x8_remaining = tile -> mi_col_end - mi_col ; //<S2SV> int block_row , block_col ; //<S2SV> MODE_INFO * mi_upper_left = cm -> mi + mi_row * mis + mi_col ; //<S2SV> int bh = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> int bw = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> assert ( ( row8x8_remaining > 0 ) && ( col8x8_remaining > 0 ) ) ; //<S2SV> if ( ( col8x8_remaining >= MI_BLOCK_SIZE ) && //<S2SV> ( row8x8_remaining >= MI_BLOCK_SIZE ) ) { //<S2SV> for ( block_row = 0 ; block_row < MI_BLOCK_SIZE ; block_row += bh ) { //<S2SV> for ( block_col = 0 ; block_col < MI_BLOCK_SIZE ; block_col += bw ) { //<S2SV> int index = block_row * mis + block_col ; //<S2SV> mi_8x8 [ index ] = mi_upper_left + index ; //<S2SV> mi_8x8 [ index ] -> mbmi . sb_type = bsize ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , //<S2SV> col8x8_remaining , bsize , mi_8x8 ) ; //<S2SV> } //<S2SV> } //<S2SV> 