static void nonrd_use_partition ( VP9_COMP * cpi , //<S2SV> ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> MODE_INFO * * mi , //<S2SV> TOKENEXTRA * * tp , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , int output_enabled , //<S2SV> RD_COST * dummy_cost , PC_TREE * pc_tree ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> PARTITION_TYPE partition ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> subsize = ( bsize >= BLOCK_8X8 ) ? mi [ 0 ] -> mbmi . sb_type : BLOCK_4X4 ; //<S2SV> partition = partition_lookup [ bsl ] [ subsize ] ; //<S2SV> if ( output_enabled && bsize != BLOCK_4X4 ) { //<S2SV> int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> td -> counts -> partition [ ctx ] [ partition ] ++ ; //<S2SV> } //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> pc_tree -> none . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , //<S2SV> subsize , & pc_tree -> none ) ; //<S2SV> pc_tree -> none . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> none . skip = x -> skip ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , //<S2SV> subsize , & pc_tree -> none ) ; //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , //<S2SV> subsize , & pc_tree -> vertical [ 0 ] ) ; //<S2SV> pc_tree -> vertical [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> vertical [ 0 ] . skip = x -> skip ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , //<S2SV> subsize , & pc_tree -> vertical [ 0 ] ) ; //<S2SV> if ( mi_col + hbs < cm -> mi_cols && bsize > BLOCK_8X8 ) { //<S2SV> pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + hbs , //<S2SV> dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; //<S2SV> pc_tree -> vertical [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> vertical [ 1 ] . skip = x -> skip ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , //<S2SV> output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , //<S2SV> subsize , & pc_tree -> horizontal [ 0 ] ) ; //<S2SV> pc_tree -> horizontal [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> horizontal [ 0 ] . skip = x -> skip ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , //<S2SV> subsize , & pc_tree -> horizontal [ 0 ] ) ; //<S2SV> if ( mi_row + hbs < cm -> mi_rows && bsize > BLOCK_8X8 ) { //<S2SV> pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row + hbs , mi_col , //<S2SV> dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; //<S2SV> pc_tree -> horizontal [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> horizontal [ 1 ] . skip = x -> skip ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , //<S2SV> output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> if ( bsize == BLOCK_8X8 ) { //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , //<S2SV> subsize , pc_tree -> leaf_split [ 0 ] ) ; //<S2SV> encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , //<S2SV> output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; //<S2SV> } else { //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> subsize , output_enabled , dummy_cost , //<S2SV> pc_tree -> split [ 0 ] ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi + hbs , tp , //<S2SV> mi_row , mi_col + hbs , subsize , output_enabled , //<S2SV> dummy_cost , pc_tree -> split [ 1 ] ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , //<S2SV> mi_row + hbs , mi_col , subsize , output_enabled , //<S2SV> dummy_cost , pc_tree -> split [ 2 ] ) ; //<S2SV> nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis + hbs , tp , //<S2SV> mi_row + hbs , mi_col + hbs , subsize , output_enabled , //<S2SV> dummy_cost , pc_tree -> split [ 3 ] ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 && "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) //<S2SV> update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; //<S2SV> } //<S2SV> 