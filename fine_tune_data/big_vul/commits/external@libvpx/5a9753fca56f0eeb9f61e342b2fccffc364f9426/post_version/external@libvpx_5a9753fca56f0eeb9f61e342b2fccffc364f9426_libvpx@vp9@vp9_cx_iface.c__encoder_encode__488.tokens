static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const vpx_image_t * img , //<S2SV> vpx_codec_pts_t pts , //<S2SV> unsigned long duration , //<S2SV> vpx_enc_frame_flags_t flags , //<S2SV> unsigned long deadline ) { //<S2SV> vpx_codec_err_t res = VPX_CODEC_OK ; //<S2SV> VP9_COMP * const cpi = ctx -> cpi ; //<S2SV> const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; //<S2SV> size_t data_sz ; //<S2SV> if ( img != NULL ) { //<S2SV> res = validate_img ( ctx , img ) ; //<S2SV> if ( res == VPX_CODEC_OK && cpi != NULL ) { //<S2SV> data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * //<S2SV> ( cpi -> multi_arf_allowed ? 8 : 2 ) ; //<S2SV> if ( data_sz < 4096 ) //<S2SV> data_sz = 4096 ; //<S2SV> if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { //<S2SV> ctx -> cx_data_sz = data_sz ; //<S2SV> free ( ctx -> cx_data ) ; //<S2SV> ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; //<S2SV> if ( ctx -> cx_data == NULL ) { //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> pick_quickcompress_mode ( ctx , duration , deadline ) ; //<S2SV> vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; //<S2SV> if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || //<S2SV> ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { //<S2SV> ctx -> base . err_detail = "Conflicting<S2SV_blank>flags." ; //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> } //<S2SV> vp9_apply_encoding_flags ( cpi , flags ) ; //<S2SV> if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && //<S2SV> ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) { //<S2SV> if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) { //<S2SV> flags |= VPX_EFLAG_FORCE_KF ; //<S2SV> ctx -> fixed_kf_cntr = 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( res == VPX_CODEC_OK && cpi != NULL ) { //<S2SV> unsigned int lib_flags = 0 ; //<S2SV> YV12_BUFFER_CONFIG sd ; //<S2SV> int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; //<S2SV> int64_t dst_end_time_stamp = //<S2SV> timebase_units_to_ticks ( timebase , pts + duration ) ; //<S2SV> size_t size , cx_data_sz ; //<S2SV> unsigned char * cx_data ; //<S2SV> if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) //<S2SV> cpi -> b_calculate_psnr = 1 ; //<S2SV> if ( img != NULL ) { //<S2SV> res = image2yuvconfig ( img , & sd ) ; //<S2SV> if ( vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags , //<S2SV> & sd , dst_time_stamp , dst_end_time_stamp ) ) { //<S2SV> res = update_error_state ( ctx , & cpi -> common . error ) ; //<S2SV> } //<S2SV> ctx -> next_frame_flags = 0 ; //<S2SV> } //<S2SV> cx_data = ctx -> cx_data ; //<S2SV> cx_data_sz = ctx -> cx_data_sz ; //<S2SV> if ( ctx -> pending_cx_data ) { //<S2SV> memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ; //<S2SV> ctx -> pending_cx_data = cx_data ; //<S2SV> cx_data += ctx -> pending_cx_data_sz ; //<S2SV> cx_data_sz -= ctx -> pending_cx_data_sz ; //<S2SV> if ( cx_data_sz < ctx -> cx_data_sz / 2 ) { //<S2SV> ctx -> base . err_detail = "Compressed<S2SV_blank>data<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small" ; //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> while ( cx_data_sz >= ctx -> cx_data_sz / 2 && //<S2SV> - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , //<S2SV> cx_data , & dst_time_stamp , //<S2SV> & dst_end_time_stamp , ! img ) ) { //<S2SV> if ( size ) { //<S2SV> vpx_codec_cx_pkt_t pkt ; //<S2SV> # if CONFIG_SPATIAL_SVC //<S2SV> if ( cpi -> use_svc ) //<S2SV> cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * //<S2SV> cpi -> svc . number_temporal_layers ] . layer_size += size ; //<S2SV> # endif //<S2SV> if ( ! cpi -> common . show_frame || //<S2SV> ( cpi -> use_svc && //<S2SV> cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) //<S2SV> ) { //<S2SV> if ( ctx -> pending_cx_data == 0 ) //<S2SV> ctx -> pending_cx_data = cx_data ; //<S2SV> ctx -> pending_cx_data_sz += size ; //<S2SV> ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; //<S2SV> ctx -> pending_frame_magnitude |= size ; //<S2SV> cx_data += size ; //<S2SV> cx_data_sz -= size ; //<S2SV> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { //<S2SV> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; //<S2SV> pkt . data . frame . pts = ticks_to_timebase_units ( timebase , //<S2SV> dst_time_stamp ) ; //<S2SV> pkt . data . frame . duration = //<S2SV> ( unsigned long ) ticks_to_timebase_units ( timebase , //<S2SV> dst_end_time_stamp - dst_time_stamp ) ; //<S2SV> pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; //<S2SV> pkt . data . frame . buf = ctx -> pending_cx_data ; //<S2SV> pkt . data . frame . sz = size ; //<S2SV> ctx -> pending_cx_data = NULL ; //<S2SV> ctx -> pending_cx_data_sz = 0 ; //<S2SV> ctx -> pending_frame_count = 0 ; //<S2SV> ctx -> pending_frame_magnitude = 0 ; //<S2SV> ctx -> output_cx_pkt_cb . output_cx_pkt ( //<S2SV> & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; //<S2SV> } //<S2SV> continue ; //<S2SV> } //<S2SV> pkt . kind = VPX_CODEC_CX_FRAME_PKT ; //<S2SV> pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; //<S2SV> pkt . data . frame . duration = //<S2SV> ( unsigned long ) ticks_to_timebase_units ( timebase , //<S2SV> dst_end_time_stamp - dst_time_stamp ) ; //<S2SV> pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; //<S2SV> if ( ctx -> pending_cx_data ) { //<S2SV> ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ; //<S2SV> ctx -> pending_frame_magnitude |= size ; //<S2SV> ctx -> pending_cx_data_sz += size ; //<S2SV> if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) //<S2SV> size += write_superframe_index ( ctx ) ; //<S2SV> pkt . data . frame . buf = ctx -> pending_cx_data ; //<S2SV> pkt . data . frame . sz = ctx -> pending_cx_data_sz ; //<S2SV> ctx -> pending_cx_data = NULL ; //<S2SV> ctx -> pending_cx_data_sz = 0 ; //<S2SV> ctx -> pending_frame_count = 0 ; //<S2SV> ctx -> pending_frame_magnitude = 0 ; //<S2SV> } else { //<S2SV> pkt . data . frame . buf = cx_data ; //<S2SV> pkt . data . frame . sz = size ; //<S2SV> } //<S2SV> pkt . data . frame . partition_id = - 1 ; //<S2SV> if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) //<S2SV> ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , //<S2SV> ctx -> output_cx_pkt_cb . user_priv ) ; //<S2SV> else //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ; //<S2SV> cx_data += size ; //<S2SV> cx_data_sz -= size ; //<S2SV> # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) //<S2SV> # if CONFIG_SPATIAL_SVC //<S2SV> if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { //<S2SV> vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; //<S2SV> int sl ; //<S2SV> vp9_zero ( pkt_sizes ) ; //<S2SV> vp9_zero ( pkt_psnr ) ; //<S2SV> pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; //<S2SV> pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; //<S2SV> for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { //<S2SV> LAYER_CONTEXT * lc = //<S2SV> & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; //<S2SV> pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; //<S2SV> pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; //<S2SV> lc -> layer_size = 0 ; //<S2SV> } //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; //<S2SV> vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # endif //<S2SV> if ( is_one_pass_cbr_svc ( cpi ) && //<S2SV> ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 