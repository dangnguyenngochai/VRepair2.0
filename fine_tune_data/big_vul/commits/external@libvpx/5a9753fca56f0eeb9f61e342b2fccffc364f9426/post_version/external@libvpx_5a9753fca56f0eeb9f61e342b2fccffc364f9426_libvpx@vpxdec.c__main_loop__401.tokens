static int main_loop ( int argc , const char * * argv_ ) { //<S2SV> vpx_codec_ctx_t decoder ; //<S2SV> char * fn = NULL ; //<S2SV> int i ; //<S2SV> uint8_t * buf = NULL ; //<S2SV> size_t bytes_in_buffer = 0 , buffer_size = 0 ; //<S2SV> FILE * infile ; //<S2SV> int frame_in = 0 , frame_out = 0 , flipuv = 0 , noblit = 0 ; //<S2SV> int do_md5 = 0 , progress = 0 , frame_parallel = 0 ; //<S2SV> int stop_after = 0 , postproc = 0 , summary = 0 , quiet = 1 ; //<S2SV> int arg_skip = 0 ; //<S2SV> int ec_enabled = 0 ; //<S2SV> int keep_going = 0 ; //<S2SV> const VpxInterface * interface = NULL ; //<S2SV> const VpxInterface * fourcc_interface = NULL ; //<S2SV> uint64_t dx_time = 0 ; //<S2SV> struct arg arg ; //<S2SV> char * * argv , * * argi , * * argj ; //<S2SV> int single_file ; //<S2SV> int use_y4m = 1 ; //<S2SV> int opt_yv12 = 0 ; //<S2SV> int opt_i420 = 0 ; //<S2SV> vpx_codec_dec_cfg_t cfg = { 0 , 0 , 0 } ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> int output_bit_depth = 0 ; //<S2SV> # endif //<S2SV> # if CONFIG_VP8_DECODER //<S2SV> vp8_postproc_cfg_t vp8_pp_cfg = { 0 } ; //<S2SV> int vp8_dbg_color_ref_frame = 0 ; //<S2SV> int vp8_dbg_color_mb_modes = 0 ; //<S2SV> int vp8_dbg_color_b_modes = 0 ; //<S2SV> int vp8_dbg_display_mv = 0 ; //<S2SV> # endif //<S2SV> int frames_corrupted = 0 ; //<S2SV> int dec_flags = 0 ; //<S2SV> int do_scale = 0 ; //<S2SV> vpx_image_t * scaled_img = NULL ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> vpx_image_t * img_shifted = NULL ; //<S2SV> # endif //<S2SV> int frame_avail , got_data , flush_decoder = 0 ; //<S2SV> int num_external_frame_buffers = 0 ; //<S2SV> struct ExternalFrameBufferList ext_fb_list = { 0 , NULL } ; //<S2SV> const char * outfile_pattern = NULL ; //<S2SV> char outfile_name [ PATH_MAX ] = { 0 } ; //<S2SV> FILE * outfile = NULL ; //<S2SV> MD5Context md5_ctx ; //<S2SV> unsigned char md5_digest [ 16 ] ; //<S2SV> struct VpxDecInputContext input = { NULL , NULL } ; //<S2SV> struct VpxInputContext vpx_input_ctx ; //<S2SV> # if CONFIG_WEBM_IO //<S2SV> struct WebmInputContext webm_ctx ; //<S2SV> memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) ; //<S2SV> input . webm_ctx = & webm_ctx ; //<S2SV> # endif //<S2SV> input . vpx_input_ctx = & vpx_input_ctx ; //<S2SV> exec_name = argv_ [ 0 ] ; //<S2SV> argv = argv_dup ( argc - 1 , argv_ + 1 ) ; //<S2SV> for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { //<S2SV> memset ( & arg , 0 , sizeof ( arg ) ) ; //<S2SV> arg . argv_step = 1 ; //<S2SV> if ( arg_match ( & arg , & codecarg , argi ) ) { //<S2SV> interface = get_vpx_decoder_by_name ( arg . val ) ; //<S2SV> if ( ! interface ) //<S2SV> die ( "Error:<S2SV_blank>Unrecognized<S2SV_blank>argument<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>--codec\\n" , arg . val ) ; //<S2SV> } else if ( arg_match ( & arg , & looparg , argi ) ) { //<S2SV> } else if ( arg_match ( & arg , & outputfile , argi ) ) //<S2SV> outfile_pattern = arg . val ; //<S2SV> else if ( arg_match ( & arg , & use_yv12 , argi ) ) { //<S2SV> use_y4m = 0 ; //<S2SV> flipuv = 1 ; //<S2SV> opt_yv12 = 1 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> output_bit_depth = 8 ; //<S2SV> # endif //<S2SV> } else if ( arg_match ( & arg , & use_i420 , argi ) ) { //<S2SV> use_y4m = 0 ; //<S2SV> flipuv = 0 ; //<S2SV> opt_i420 = 1 ; //<S2SV> } else if ( arg_match ( & arg , & rawvideo , argi ) ) { //<S2SV> use_y4m = 0 ; //<S2SV> } else if ( arg_match ( & arg , & flipuvarg , argi ) ) //<S2SV> flipuv = 1 ; //<S2SV> else if ( arg_match ( & arg , & noblitarg , argi ) ) //<S2SV> noblit = 1 ; //<S2SV> else if ( arg_match ( & arg , & progressarg , argi ) ) //<S2SV> progress = 1 ; //<S2SV> else if ( arg_match ( & arg , & limitarg , argi ) ) //<S2SV> stop_after = arg_parse_uint ( & arg ) ; //<S2SV> else if ( arg_match ( & arg , & skiparg , argi ) ) //<S2SV> arg_skip = arg_parse_uint ( & arg ) ; //<S2SV> else if ( arg_match ( & arg , & postprocarg , argi ) ) //<S2SV> postproc = 1 ; //<S2SV> else if ( arg_match ( & arg , & md5arg , argi ) ) //<S2SV> do_md5 = 1 ; //<S2SV> else if ( arg_match ( & arg , & summaryarg , argi ) ) //<S2SV> summary = 1 ; //<S2SV> else if ( arg_match ( & arg , & threadsarg , argi ) ) //<S2SV> cfg . threads = arg_parse_uint ( & arg ) ; //<S2SV> # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER //<S2SV> else if ( arg_match ( & arg , & frameparallelarg , argi ) ) //<S2SV> frame_parallel = 1 ; //<S2SV> # endif //<S2SV> else if ( arg_match ( & arg , & verbosearg , argi ) ) //<S2SV> quiet = 0 ; //<S2SV> else if ( arg_match ( & arg , & scalearg , argi ) ) //<S2SV> do_scale = 1 ; //<S2SV> else if ( arg_match ( & arg , & fb_arg , argi ) ) //<S2SV> num_external_frame_buffers = arg_parse_uint ( & arg ) ; //<S2SV> else if ( arg_match ( & arg , & continuearg , argi ) ) //<S2SV> keep_going = 1 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { //<S2SV> output_bit_depth = arg_parse_uint ( & arg ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if CONFIG_VP8_DECODER //<S2SV> else if ( arg_match ( & arg , & addnoise_level , argi ) ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_pp_cfg . post_proc_flag |= VP8_ADDNOISE ; //<S2SV> vp8_pp_cfg . noise_level = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & demacroblock_level , argi ) ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_pp_cfg . post_proc_flag |= VP8_DEMACROBLOCK ; //<S2SV> vp8_pp_cfg . deblocking_level = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & deblock , argi ) ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_pp_cfg . post_proc_flag |= VP8_DEBLOCK ; //<S2SV> } else if ( arg_match ( & arg , & mfqe , argi ) ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_pp_cfg . post_proc_flag |= VP8_MFQE ; //<S2SV> } else if ( arg_match ( & arg , & pp_debug_info , argi ) ) { //<S2SV> unsigned int level = arg_parse_uint ( & arg ) ; //<S2SV> postproc = 1 ; //<S2SV> vp8_pp_cfg . post_proc_flag &= ~ 0x7 ; //<S2SV> if ( level ) //<S2SV> vp8_pp_cfg . post_proc_flag |= level ; //<S2SV> } else if ( arg_match ( & arg , & pp_disp_ref_frame , argi ) ) { //<S2SV> unsigned int flags = arg_parse_int ( & arg ) ; //<S2SV> if ( flags ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_dbg_color_ref_frame = flags ; //<S2SV> } //<S2SV> } else if ( arg_match ( & arg , & pp_disp_mb_modes , argi ) ) { //<S2SV> unsigned int flags = arg_parse_int ( & arg ) ; //<S2SV> if ( flags ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_dbg_color_mb_modes = flags ; //<S2SV> } //<S2SV> } else if ( arg_match ( & arg , & pp_disp_b_modes , argi ) ) { //<S2SV> unsigned int flags = arg_parse_int ( & arg ) ; //<S2SV> if ( flags ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_dbg_color_b_modes = flags ; //<S2SV> } //<S2SV> } else if ( arg_match ( & arg , & pp_disp_mvs , argi ) ) { //<S2SV> unsigned int flags = arg_parse_int ( & arg ) ; //<S2SV> if ( flags ) { //<S2SV> postproc = 1 ; //<S2SV> vp8_dbg_display_mv = flags ; //<S2SV> } //<S2SV> } else if ( arg_match ( & arg , & error_concealment , argi ) ) { //<S2SV> ec_enabled = 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> else //<S2SV> argj ++ ; //<S2SV> } //<S2SV> for ( argi = argv ; * argi ; argi ++ ) //<S2SV> if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) //<S2SV> die ( "Error:<S2SV_blank>Unrecognized<S2SV_blank>option<S2SV_blank>%s\\n" , * argi ) ; //<S2SV> fn = argv [ 0 ] ; //<S2SV> if ( ! fn ) { //<S2SV> free ( argv ) ; //<S2SV> usage_exit ( ) ; //<S2SV> } //<S2SV> infile = strcmp ( fn , "-" ) ? fopen ( fn , "rb" ) : set_binary_mode ( stdin ) ; //<S2SV> if ( ! infile ) { //<S2SV> fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file<S2SV_blank>\'%s\'" , strcmp ( fn , "-" ) ? fn : "stdin" ) ; //<S2SV> } //<S2SV> # if CONFIG_OS_SUPPORT //<S2SV> if ( ! outfile_pattern && isatty ( fileno ( stdout ) ) && ! do_md5 && ! noblit ) { //<S2SV> fprintf ( stderr , //<S2SV> "Not<S2SV_blank>dumping<S2SV_blank>raw<S2SV_blank>video<S2SV_blank>to<S2SV_blank>your<S2SV_blank>terminal.<S2SV_blank>Use<S2SV_blank>\'-o<S2SV_blank>-\'<S2SV_blank>to<S2SV_blank>" //<S2SV> "override.\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> # endif //<S2SV> input . vpx_input_ctx -> file = infile ; //<S2SV> if ( file_is_ivf ( input . vpx_input_ctx ) ) //<S2SV> input . vpx_input_ctx -> file_type = FILE_TYPE_IVF ; //<S2SV> # if CONFIG_WEBM_IO //<S2SV> else if ( file_is_webm ( input . webm_ctx , input . vpx_input_ctx ) ) //<S2SV> input . vpx_input_ctx -> file_type = FILE_TYPE_WEBM ; //<S2SV> # endif //<S2SV> else if ( file_is_raw ( input . vpx_input_ctx ) ) //<S2SV> input . vpx_input_ctx -> file_type = FILE_TYPE_RAW ; //<S2SV> else { //<S2SV> fprintf ( stderr , "Unrecognized<S2SV_blank>input<S2SV_blank>file<S2SV_blank>type.\\n" ) ; //<S2SV> # if ! CONFIG_WEBM_IO //<S2SV> fprintf ( stderr , "vpxdec<S2SV_blank>was<S2SV_blank>built<S2SV_blank>without<S2SV_blank>WebM<S2SV_blank>container<S2SV_blank>support.\\n" ) ; //<S2SV> # endif //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> outfile_pattern = outfile_pattern ? outfile_pattern : "-" ; //<S2SV> single_file = is_single_file ( outfile_pattern ) ; //<S2SV> if ( ! noblit && single_file ) { //<S2SV> generate_filename ( outfile_pattern , outfile_name , PATH_MAX , //<S2SV> vpx_input_ctx . width , vpx_input_ctx . height , 0 ) ; //<S2SV> if ( do_md5 ) //<S2SV> MD5Init ( & md5_ctx ) ; //<S2SV> else //<S2SV> outfile = open_outfile ( outfile_name ) ; //<S2SV> } //<S2SV> if ( use_y4m && ! noblit ) { //<S2SV> if ( ! single_file ) { //<S2SV> fprintf ( stderr , "YUV4MPEG2<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>output<S2SV_blank>patterns," //<S2SV> "<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12<S2SV_blank>or<S2SV_blank>--rawvideo.\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> # if CONFIG_WEBM_IO //<S2SV> if ( vpx_input_ctx . file_type == FILE_TYPE_WEBM ) { //<S2SV> if ( webm_guess_framerate ( input . webm_ctx , input . vpx_input_ctx ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>guess<S2SV_blank>framerate<S2SV_blank>--<S2SV_blank>error<S2SV_blank>parsing<S2SV_blank>" //<S2SV> "webm<S2SV_blank>file?\\n" ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> fourcc_interface = get_vpx_decoder_by_fourcc ( vpx_input_ctx . fourcc ) ; //<S2SV> if ( interface && fourcc_interface && interface != fourcc_interface ) //<S2SV> warn ( "Header<S2SV_blank>indicates<S2SV_blank>codec:<S2SV_blank>%s\\n" , fourcc_interface -> name ) ; //<S2SV> else //<S2SV> interface = fourcc_interface ; //<S2SV> if ( ! interface ) //<S2SV> interface = get_vpx_decoder_by_index ( 0 ) ; //<S2SV> dec_flags = ( postproc ? VPX_CODEC_USE_POSTPROC : 0 ) | //<S2SV> ( ec_enabled ? VPX_CODEC_USE_ERROR_CONCEALMENT : 0 ) | //<S2SV> ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) ; //<S2SV> if ( vpx_codec_dec_init ( & decoder , interface -> codec_interface ( ) , //<S2SV> & cfg , dec_flags ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( ! quiet ) //<S2SV> fprintf ( stderr , "%s\\n" , decoder . name ) ; //<S2SV> # if CONFIG_VP8_DECODER //<S2SV> if ( vp8_pp_cfg . post_proc_flag //<S2SV> && vpx_codec_control ( & decoder , VP8_SET_POSTPROC , & vp8_pp_cfg ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>postproc:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( vp8_dbg_color_ref_frame //<S2SV> && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_REF_FRAME , //<S2SV> vp8_dbg_color_ref_frame ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>reference<S2SV_blank>block<S2SV_blank>visualizer:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( vp8_dbg_color_mb_modes //<S2SV> && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_MB_MODES , //<S2SV> vp8_dbg_color_mb_modes ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>macro<S2SV_blank>block<S2SV_blank>visualizer:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( vp8_dbg_color_b_modes //<S2SV> && vpx_codec_control ( & decoder , VP8_SET_DBG_COLOR_B_MODES , //<S2SV> vp8_dbg_color_b_modes ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>block<S2SV_blank>visualizer:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( vp8_dbg_display_mv //<S2SV> && vpx_codec_control ( & decoder , VP8_SET_DBG_DISPLAY_MV , //<S2SV> vp8_dbg_display_mv ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>motion<S2SV_blank>vector<S2SV_blank>visualizer:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( arg_skip ) //<S2SV> fprintf ( stderr , "Skipping<S2SV_blank>first<S2SV_blank>%d<S2SV_blank>frames.\\n" , arg_skip ) ; //<S2SV> while ( arg_skip ) { //<S2SV> if ( read_frame ( & input , & buf , & bytes_in_buffer , & buffer_size ) ) //<S2SV> break ; //<S2SV> arg_skip -- ; //<S2SV> } //<S2SV> if ( num_external_frame_buffers > 0 ) { //<S2SV> ext_fb_list . num_external_frame_buffers = num_external_frame_buffers ; //<S2SV> ext_fb_list . ext_fb = ( struct ExternalFrameBuffer * ) calloc ( //<S2SV> num_external_frame_buffers , sizeof ( * ext_fb_list . ext_fb ) ) ; //<S2SV> if ( vpx_codec_set_frame_buffer_functions ( //<S2SV> & decoder , get_vp9_frame_buffer , release_vp9_frame_buffer , //<S2SV> & ext_fb_list ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>configure<S2SV_blank>external<S2SV_blank>frame<S2SV_blank>buffers:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> frame_avail = 1 ; //<S2SV> got_data = 0 ; //<S2SV> while ( frame_avail || got_data ) { //<S2SV> vpx_codec_iter_t iter = NULL ; //<S2SV> vpx_image_t * img ; //<S2SV> struct vpx_usec_timer timer ; //<S2SV> int corrupted = 0 ; //<S2SV> frame_avail = 0 ; //<S2SV> if ( ! stop_after || frame_in < stop_after ) { //<S2SV> if ( ! read_frame ( & input , & buf , & bytes_in_buffer , & buffer_size ) ) { //<S2SV> frame_avail = 1 ; //<S2SV> frame_in ++ ; //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> if ( vpx_codec_decode ( & decoder , buf , ( unsigned int ) bytes_in_buffer , //<S2SV> NULL , 0 ) ) { //<S2SV> const char * detail = vpx_codec_error_detail ( & decoder ) ; //<S2SV> warn ( "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame<S2SV_blank>%d:<S2SV_blank>%s" , //<S2SV> frame_in , vpx_codec_error ( & decoder ) ) ; //<S2SV> if ( detail ) //<S2SV> warn ( "Additional<S2SV_blank>information:<S2SV_blank>%s" , detail ) ; //<S2SV> if ( ! keep_going ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> vpx_usec_timer_mark ( & timer ) ; //<S2SV> dx_time += vpx_usec_timer_elapsed ( & timer ) ; //<S2SV> } else { //<S2SV> flush_decoder = 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> flush_decoder = 1 ; //<S2SV> } //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> if ( flush_decoder ) { //<S2SV> if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { //<S2SV> warn ( "Failed<S2SV_blank>to<S2SV_blank>flush<S2SV_blank>decoder:<S2SV_blank>%s" , vpx_codec_error ( & decoder ) ) ; //<S2SV> } //<S2SV> } //<S2SV> got_data = 0 ; //<S2SV> if ( ( img = vpx_codec_get_frame ( & decoder , & iter ) ) ) { //<S2SV> ++ frame_out ; //<S2SV> got_data = 1 ; //<S2SV> } //<S2SV> vpx_usec_timer_mark ( & timer ) ; //<S2SV> dx_time += ( unsigned int ) vpx_usec_timer_elapsed ( & timer ) ; //<S2SV> if ( ! frame_parallel && //<S2SV> vpx_codec_control ( & decoder , VP8D_GET_FRAME_CORRUPTED , & corrupted ) ) { //<S2SV> warn ( "Failed<S2SV_blank>VP8_GET_FRAME_CORRUPTED:<S2SV_blank>%s" , vpx_codec_error ( & decoder ) ) ; //<S2SV> if ( ! keep_going ) //<S2SV> goto fail ; //<S2SV> } //<S2SV> frames_corrupted += corrupted ; //<S2SV> if ( progress ) //<S2SV> show_progress ( frame_in , frame_out , dx_time ) ; //<S2SV> if ( ! noblit && img ) { //<S2SV> const int PLANES_YUV [ ] = { VPX_PLANE_Y , VPX_PLANE_U , VPX_PLANE_V } ; //<S2SV> const int PLANES_YVU [ ] = { VPX_PLANE_Y , VPX_PLANE_V , VPX_PLANE_U } ; //<S2SV> const int * planes = flipuv ? PLANES_YVU : PLANES_YUV ; //<S2SV> if ( do_scale ) { //<S2SV> if ( frame_out == 1 ) { //<S2SV> int display_width = vpx_input_ctx . width ; //<S2SV> int display_height = vpx_input_ctx . height ; //<S2SV> if ( ! display_width || ! display_height ) { //<S2SV> int display_size [ 2 ] ; //<S2SV> if ( vpx_codec_control ( & decoder , VP9D_GET_DISPLAY_SIZE , //<S2SV> display_size ) ) { //<S2SV> display_width = img -> d_w ; //<S2SV> display_height = img -> d_h ; //<S2SV> } else { //<S2SV> display_width = display_size [ 0 ] ; //<S2SV> display_height = display_size [ 1 ] ; //<S2SV> } //<S2SV> } //<S2SV> scaled_img = vpx_img_alloc ( NULL , img -> fmt , display_width , //<S2SV> display_height , 16 ) ; //<S2SV> scaled_img -> bit_depth = img -> bit_depth ; //<S2SV> } //<S2SV> if ( img -> d_w != scaled_img -> d_w || img -> d_h != scaled_img -> d_h ) { //<S2SV> # if CONFIG_LIBYUV //<S2SV> libyuv_scale ( img , scaled_img , kFilterBox ) ; //<S2SV> img = scaled_img ; //<S2SV> # else //<S2SV> fprintf ( stderr , "Failed<S2SV_blank><S2SV_blank>to<S2SV_blank>scale<S2SV_blank>output<S2SV_blank>frame:<S2SV_blank>%s.\\n" //<S2SV> "Scaling<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>" //<S2SV> "To<S2SV_blank>enable<S2SV_blank>scaling,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( ! output_bit_depth ) { //<S2SV> output_bit_depth = img -> bit_depth ; //<S2SV> } //<S2SV> if ( output_bit_depth != img -> bit_depth ) { //<S2SV> const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? //<S2SV> img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : //<S2SV> img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; //<S2SV> if ( img_shifted && //<S2SV> img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { //<S2SV> vpx_img_free ( img_shifted ) ; //<S2SV> img_shifted = NULL ; //<S2SV> } //<S2SV> if ( ! img_shifted ) { //<S2SV> img_shifted = vpx_img_alloc ( NULL , shifted_fmt , //<S2SV> img -> d_w , img -> d_h , 16 ) ; //<S2SV> img_shifted -> bit_depth = output_bit_depth ; //<S2SV> } //<S2SV> if ( output_bit_depth > img -> bit_depth ) { //<S2SV> vpx_img_upshift ( img_shifted , img , //<S2SV> output_bit_depth - img -> bit_depth ) ; //<S2SV> } else { //<S2SV> vpx_img_downshift ( img_shifted , img , //<S2SV> img -> bit_depth - output_bit_depth ) ; //<S2SV> } //<S2SV> img = img_shifted ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( single_file ) { //<S2SV> if ( use_y4m ) { //<S2SV> char buf [ Y4M_BUFFER_SIZE ] = { 0 } ; //<S2SV> size_t len = 0 ; //<S2SV> if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>y4m<S2SV_blank>output<S2SV_blank>for<S2SV_blank>440<S2SV_blank>sampling.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> if ( frame_out == 1 ) { //<S2SV> len = y4m_write_file_header ( buf , sizeof ( buf ) , //<S2SV> vpx_input_ctx . width , //<S2SV> vpx_input_ctx . height , //<S2SV> & vpx_input_ctx . framerate , //<S2SV> img -> fmt , img -> bit_depth ) ; //<S2SV> if ( do_md5 ) { //<S2SV> MD5Update ( & md5_ctx , ( md5byte * ) buf , ( unsigned int ) len ) ; //<S2SV> } else { //<S2SV> fputs ( buf , outfile ) ; //<S2SV> } //<S2SV> } //<S2SV> len = y4m_write_frame_header ( buf , sizeof ( buf ) ) ; //<S2SV> if ( do_md5 ) { //<S2SV> MD5Update ( & md5_ctx , ( md5byte * ) buf , ( unsigned int ) len ) ; //<S2SV> } else { //<S2SV> fputs ( buf , outfile ) ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( frame_out == 1 ) { //<S2SV> if ( opt_i420 ) { //<S2SV> if ( img -> fmt != VPX_IMG_FMT_I420 && //<S2SV> img -> fmt != VPX_IMG_FMT_I42016 ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>i420<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> if ( opt_yv12 ) { //<S2SV> if ( ( img -> fmt != VPX_IMG_FMT_I420 && //<S2SV> img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { //<S2SV> fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>yv12<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; //<S2SV> goto fail ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( do_md5 ) { //<S2SV> update_image_md5 ( img , planes , & md5_ctx ) ; //<S2SV> } else { //<S2SV> write_image_file ( img , planes , outfile ) ; //<S2SV> } //<S2SV> } else { //<S2SV> generate_filename ( outfile_pattern , outfile_name , PATH_MAX , //<S2SV> img -> d_w , img -> d_h , frame_in ) ; //<S2SV> if ( do_md5 ) { //<S2SV> MD5Init ( & md5_ctx ) ; //<S2SV> update_image_md5 ( img , planes , & md5_ctx ) ; //<S2SV> MD5Final ( md5_digest , & md5_ctx ) ; //<S2SV> print_md5 ( md5_digest , outfile_name ) ; //<S2SV> } else { //<S2SV> outfile = open_outfile ( outfile_name ) ; //<S2SV> write_image_file ( img , planes , outfile ) ; //<S2SV> fclose ( outfile ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( summary || progress ) { //<S2SV> show_progress ( frame_in , frame_out , dx_time ) ; //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> } //<S2SV> if ( frames_corrupted ) //<S2SV> fprintf ( stderr , "WARNING:<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>corrupted.\\n" , frames_corrupted ) ; //<S2SV> fail : //<S2SV> if ( vpx_codec_destroy ( & decoder ) ) { //<S2SV> fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>decoder:<S2SV_blank>%s\\n" , //<S2SV> vpx_codec_error ( & decoder ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> if ( ! noblit && single_file ) { //<S2SV> if ( do_md5 ) { //<S2SV> MD5Final ( md5_digest , & md5_ctx ) ; //<S2SV> print_md5 ( md5_digest , outfile_name ) ; //<S2SV> } else { //<S2SV> fclose ( outfile ) ; //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_WEBM_IO //<S2SV> if ( input . vpx_input_ctx -> file_type == FILE_TYPE_WEBM ) //<S2SV> webm_free ( input . webm_ctx ) ; //<S2SV> # endif //<S2SV> if ( input . vpx_input_ctx -> file_type != FILE_TYPE_WEBM ) //<S2SV> free ( buf ) ; //<S2SV> if ( scaled_img ) vpx_img_free ( scaled_img ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( img_shifted ) vpx_img_free ( img_shifted ) ; //<S2SV> # endif //<S2SV> for ( i = 0 ; i < ext_fb_list . num_external_frame_buffers ; ++ i ) { //<S2SV> free ( ext_fb_list . ext_fb [ i ] . data ) ; //<S2SV> } //<S2SV> free ( ext_fb_list . ext_fb ) ; //<S2SV> fclose ( infile ) ; //<S2SV> free ( argv ) ; //<S2SV> return frames_corrupted ? EXIT_FAILURE : EXIT_SUCCESS ; //<S2SV> } //<S2SV> 