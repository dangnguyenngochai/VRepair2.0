void vp9_update_temporal_layer_framerate ( VP9_COMP * const cpi ) { //<S2SV> SVC * const svc = & cpi -> svc ; //<S2SV> const VP9EncoderConfig * const oxcf = & cpi -> oxcf ; //<S2SV> LAYER_CONTEXT * const lc = get_layer_context ( cpi ) ; //<S2SV> RATE_CONTROL * const lrc = & lc -> rc ; //<S2SV> const int st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + //<S2SV> svc -> temporal_layer_id ; //<S2SV> const int tl = svc -> temporal_layer_id ; //<S2SV> lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; //<S2SV> lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; //<S2SV> lrc -> max_frame_bandwidth = cpi -> rc . max_frame_bandwidth ; //<S2SV> if ( tl == 0 ) { //<S2SV> lc -> avg_frame_size = lrc -> avg_frame_bandwidth ; //<S2SV> } else { //<S2SV> const double prev_layer_framerate = //<S2SV> cpi -> framerate / oxcf -> ts_rate_decimator [ tl - 1 ] ; //<S2SV> const int prev_layer_target_bandwidth = //<S2SV> oxcf -> layer_target_bitrate [ st_idx - 1 ] ; //<S2SV> lc -> avg_frame_size = //<S2SV> ( int ) ( ( lc -> target_bandwidth - prev_layer_target_bandwidth ) / //<S2SV> ( lc -> framerate - prev_layer_framerate ) ) ; //<S2SV> } //<S2SV> } //<S2SV> 