static int choose_partitioning ( VP9_COMP * cpi , //<S2SV> const TileInfo * const tile , //<S2SV> MACROBLOCK * x , //<S2SV> int mi_row , int mi_col ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> int i , j , k , m ; //<S2SV> v64x64 vt ; //<S2SV> v16x16 vt2 [ 16 ] ; //<S2SV> int force_split [ 21 ] ; //<S2SV> uint8_t * s ; //<S2SV> const uint8_t * d ; //<S2SV> int sp ; //<S2SV> int dp ; //<S2SV> int pixels_wide = 64 , pixels_high = 64 ; //<S2SV> int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , //<S2SV> cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; //<S2SV> const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; //<S2SV> const int use_4x4_partition = is_key_frame ; //<S2SV> const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; //<S2SV> int variance4x4downsample [ 16 ] ; //<S2SV> int segment_id = CR_SEGMENT_ID_BASE ; //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { //<S2SV> const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : //<S2SV> cm -> last_frame_seg_map ; //<S2SV> segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; //<S2SV> if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { //<S2SV> int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; //<S2SV> set_vbp_thresholds ( cpi , thresholds , q ) ; //<S2SV> } //<S2SV> } //<S2SV> set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> if ( xd -> mb_to_right_edge < 0 ) //<S2SV> pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; //<S2SV> if ( xd -> mb_to_bottom_edge < 0 ) //<S2SV> pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; //<S2SV> s = x -> plane [ 0 ] . src . buf ; //<S2SV> sp = x -> plane [ 0 ] . src . stride ; //<S2SV> if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && //<S2SV> cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> unsigned int uv_sad ; //<S2SV> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; //<S2SV> const YV12_BUFFER_CONFIG * yv12_g = NULL ; //<S2SV> unsigned int y_sad , y_sad_g ; //<S2SV> const BLOCK_SIZE bsize = BLOCK_32X32 //<S2SV> + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; //<S2SV> assert ( yv12 != NULL ) ; //<S2SV> if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { //<S2SV> yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; //<S2SV> } //<S2SV> if ( yv12_g && yv12_g != yv12 && //<S2SV> ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { //<S2SV> vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , //<S2SV> & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; //<S2SV> y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , //<S2SV> x -> plane [ 0 ] . src . stride , //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . buf , //<S2SV> xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; //<S2SV> } else { //<S2SV> y_sad_g = UINT_MAX ; //<S2SV> } //<S2SV> vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , //<S2SV> & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ) ; //<S2SV> mbmi -> ref_frame [ 0 ] = LAST_FRAME ; //<S2SV> mbmi -> ref_frame [ 1 ] = NONE ; //<S2SV> mbmi -> sb_type = BLOCK_64X64 ; //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> mbmi -> interp_filter = BILINEAR ; //<S2SV> y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; //<S2SV> if ( y_sad_g < y_sad ) { //<S2SV> vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , //<S2SV> & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; //<S2SV> mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> y_sad = y_sad_g ; //<S2SV> } else { //<S2SV> x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; //<S2SV> } //<S2SV> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> for ( i = 1 ; i <= 2 ; ++ i ) { //<S2SV> struct macroblock_plane * p = & x -> plane [ i ] ; //<S2SV> struct macroblockd_plane * pd = & xd -> plane [ i ] ; //<S2SV> const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; //<S2SV> if ( bs == BLOCK_INVALID ) //<S2SV> uv_sad = UINT_MAX ; //<S2SV> else //<S2SV> uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , //<S2SV> pd -> dst . buf , pd -> dst . stride ) ; //<S2SV> x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; //<S2SV> } //<S2SV> d = xd -> plane [ 0 ] . dst . buf ; //<S2SV> dp = xd -> plane [ 0 ] . dst . stride ; //<S2SV> if ( segment_id == CR_SEGMENT_ID_BASE && //<S2SV> y_sad < cpi -> vbp_threshold_sad ) { //<S2SV> const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; //<S2SV> const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols && //<S2SV> mi_row + block_height / 2 < cm -> mi_rows ) { //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> d = VP9_VAR_OFFS ; //<S2SV> dp = 0 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> switch ( xd -> bd ) { //<S2SV> case 10 : //<S2SV> d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; //<S2SV> break ; //<S2SV> case 12 : //<S2SV> d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; //<S2SV> break ; //<S2SV> case 8 : //<S2SV> default : //<S2SV> d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> force_split [ 0 ] = 0 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> const int x32_idx = ( ( i & 1 ) << 5 ) ; //<S2SV> const int y32_idx = ( ( i >> 1 ) << 5 ) ; //<S2SV> const int i2 = i << 2 ; //<S2SV> force_split [ i + 1 ] = 0 ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) { //<S2SV> const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ; //<S2SV> const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ; //<S2SV> const int split_index = 5 + i2 + j ; //<S2SV> v16x16 * vst = & vt . split [ i ] . split [ j ] ; //<S2SV> force_split [ split_index ] = 0 ; //<S2SV> variance4x4downsample [ i2 + j ] = 0 ; //<S2SV> if ( ! is_key_frame ) { //<S2SV> fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> xd -> cur_buf -> flags , //<S2SV> # endif //<S2SV> pixels_wide , //<S2SV> pixels_high , //<S2SV> is_key_frame ) ; //<S2SV> fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; //<S2SV> get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; //<S2SV> if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > //<S2SV> thresholds [ 2 ] ) { //<S2SV> force_split [ split_index ] = 1 ; //<S2SV> force_split [ i + 1 ] = 1 ; //<S2SV> force_split [ 0 ] = 1 ; //<S2SV> } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > //<S2SV> thresholds [ 1 ] && //<S2SV> ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { //<S2SV> int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> xd -> cur_buf -> flags , //<S2SV> # endif //<S2SV> pixels_wide , pixels_high ) ; //<S2SV> if ( minmax > cpi -> vbp_threshold_minmax ) { //<S2SV> force_split [ split_index ] = 1 ; //<S2SV> force_split [ i + 1 ] = 1 ; //<S2SV> force_split [ 0 ] = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( is_key_frame || ( low_res && ! cpi -> use_svc && //<S2SV> vt . split [ i ] . split [ j ] . part_variances . none . variance > //<S2SV> ( thresholds [ 1 ] << 1 ) ) ) { //<S2SV> force_split [ split_index ] = 0 ; //<S2SV> variance4x4downsample [ i2 + j ] = 1 ; //<S2SV> for ( k = 0 ; k < 4 ; k ++ ) { //<S2SV> int x8_idx = x16_idx + ( ( k & 1 ) << 3 ) ; //<S2SV> int y8_idx = y16_idx + ( ( k >> 1 ) << 3 ) ; //<S2SV> v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : //<S2SV> & vt2 [ i2 + j ] . split [ k ] ; //<S2SV> fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> xd -> cur_buf -> flags , //<S2SV> # endif //<S2SV> pixels_wide , //<S2SV> pixels_high , //<S2SV> is_key_frame ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> const int i2 = i << 2 ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) { //<S2SV> if ( variance4x4downsample [ i2 + j ] == 1 ) { //<S2SV> v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : //<S2SV> & vt . split [ i ] . split [ j ] ; //<S2SV> for ( m = 0 ; m < 4 ; m ++ ) //<S2SV> fill_variance_tree ( & vtemp -> split [ m ] , BLOCK_8X8 ) ; //<S2SV> fill_variance_tree ( vtemp , BLOCK_16X16 ) ; //<S2SV> } //<S2SV> } //<S2SV> fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; //<S2SV> if ( ! force_split [ i + 1 ] ) { //<S2SV> get_variance ( & vt . split [ i ] . part_variances . none ) ; //<S2SV> if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { //<S2SV> force_split [ i + 1 ] = 1 ; //<S2SV> force_split [ 0 ] = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! force_split [ 0 ] ) { //<S2SV> fill_variance_tree ( & vt , BLOCK_64X64 ) ; //<S2SV> get_variance ( & vt . part_variances . none ) ; //<S2SV> } //<S2SV> if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || //<S2SV> ! set_vt_partitioning ( cpi , x , xd , & vt , BLOCK_64X64 , mi_row , mi_col , //<S2SV> thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] ) ) { //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) { //<S2SV> const int x32_idx = ( ( i & 1 ) << 2 ) ; //<S2SV> const int y32_idx = ( ( i >> 1 ) << 2 ) ; //<S2SV> const int i2 = i << 2 ; //<S2SV> if ( ! set_vt_partitioning ( cpi , x , xd , & vt . split [ i ] , BLOCK_32X32 , //<S2SV> ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , //<S2SV> thresholds [ 1 ] , BLOCK_16X16 , //<S2SV> force_split [ i + 1 ] ) ) { //<S2SV> for ( j = 0 ; j < 4 ; ++ j ) { //<S2SV> const int x16_idx = ( ( j & 1 ) << 1 ) ; //<S2SV> const int y16_idx = ( ( j >> 1 ) << 1 ) ; //<S2SV> v16x16 * vtemp = ( ! is_key_frame && //<S2SV> variance4x4downsample [ i2 + j ] == 1 ) ? //<S2SV> & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; //<S2SV> if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , //<S2SV> mi_row + y32_idx + y16_idx , //<S2SV> mi_col + x32_idx + x16_idx , //<S2SV> thresholds [ 2 ] , //<S2SV> cpi -> vbp_bsize_min , //<S2SV> force_split [ 5 + i2 + j ] ) ) { //<S2SV> for ( k = 0 ; k < 4 ; ++ k ) { //<S2SV> const int x8_idx = ( k & 1 ) ; //<S2SV> const int y8_idx = ( k >> 1 ) ; //<S2SV> if ( use_4x4_partition ) { //<S2SV> if ( ! set_vt_partitioning ( cpi , x , xd , & vtemp -> split [ k ] , //<S2SV> BLOCK_8X8 , //<S2SV> mi_row + y32_idx + y16_idx + y8_idx , //<S2SV> mi_col + x32_idx + x16_idx + x8_idx , //<S2SV> thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { //<S2SV> set_block_size ( cpi , x , xd , //<S2SV> ( mi_row + y32_idx + y16_idx + y8_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx + x8_idx ) , //<S2SV> BLOCK_4X4 ) ; //<S2SV> } //<S2SV> } else { //<S2SV> set_block_size ( cpi , x , xd , //<S2SV> ( mi_row + y32_idx + y16_idx + y8_idx ) , //<S2SV> ( mi_col + x32_idx + x16_idx + x8_idx ) , //<S2SV> BLOCK_8X8 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 