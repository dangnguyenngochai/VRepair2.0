void vp9_pick_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , //<S2SV> TileDataEnc * tile_data , //<S2SV> int mi_row , int mi_col , RD_COST * rd_cost , //<S2SV> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; //<S2SV> PREDICTION_MODE best_mode = ZEROMV ; //<S2SV> MV_REFERENCE_FRAME ref_frame , best_ref_frame = LAST_FRAME ; //<S2SV> MV_REFERENCE_FRAME usable_ref_frame ; //<S2SV> TX_SIZE best_tx_size = TX_SIZES ; //<S2SV> INTERP_FILTER best_pred_filter = EIGHTTAP ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> RD_COST this_rdc , best_rdc ; //<S2SV> uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; //<S2SV> unsigned int var_y = UINT_MAX ; //<S2SV> unsigned int sse_y = UINT_MAX ; //<S2SV> const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? //<S2SV> ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; //<S2SV> const int intra_cost_penalty = vp9_get_intra_cost_penalty ( //<S2SV> cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) >> reduction_fac ; //<S2SV> const int64_t inter_mode_thresh = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> intra_cost_penalty , 0 ) ; //<S2SV> const int * const rd_threshes = cpi -> rd . threshes [ mbmi -> segment_id ] [ bsize ] ; //<S2SV> const int * const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ; //<S2SV> INTERP_FILTER filter_ref ; //<S2SV> const int bsl = mi_width_log2_lookup [ bsize ] ; //<S2SV> const int pred_filter_search = cm -> interp_filter == SWITCHABLE ? //<S2SV> ( ( ( mi_row + mi_col ) >> bsl ) + //<S2SV> get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; //<S2SV> int const_motion [ MAX_REF_FRAMES ] = { 0 } ; //<S2SV> const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; //<S2SV> const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; //<S2SV> PRED_BUFFER tmp [ 4 ] ; //<S2SV> DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; //<S2SV> # endif //<S2SV> struct buf_2d orig_dst = pd -> dst ; //<S2SV> PRED_BUFFER * best_pred = NULL ; //<S2SV> PRED_BUFFER * this_mode_pred = NULL ; //<S2SV> const int pixels_in_block = bh * bw ; //<S2SV> int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; //<S2SV> int ref_frame_skip_mask = 0 ; //<S2SV> int idx ; //<S2SV> int best_pred_sad = INT_MAX ; //<S2SV> int best_early_term = 0 ; //<S2SV> int ref_frame_cost [ MAX_REF_FRAMES ] ; //<S2SV> init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; //<S2SV> if ( reuse_inter_pred ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < 3 ; i ++ ) { //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) //<S2SV> tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; //<S2SV> else //<S2SV> tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; //<S2SV> # else //<S2SV> tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; //<S2SV> # endif //<S2SV> tmp [ i ] . stride = bw ; //<S2SV> tmp [ i ] . in_use = 0 ; //<S2SV> } //<S2SV> tmp [ 3 ] . data = pd -> dst . buf ; //<S2SV> tmp [ 3 ] . stride = pd -> dst . stride ; //<S2SV> tmp [ 3 ] . in_use = 0 ; //<S2SV> } //<S2SV> x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> x -> skip = 0 ; //<S2SV> if ( xd -> up_available ) //<S2SV> filter_ref = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; //<S2SV> else if ( xd -> left_available ) //<S2SV> filter_ref = xd -> mi [ - 1 ] -> mbmi . interp_filter ; //<S2SV> else //<S2SV> filter_ref = cm -> interp_filter ; //<S2SV> vp9_rd_cost_reset ( & best_rdc ) ; //<S2SV> vp9_rd_cost_reset ( rd_cost ) ; //<S2SV> mbmi -> sb_type = bsize ; //<S2SV> mbmi -> ref_frame [ 0 ] = NONE ; //<S2SV> mbmi -> ref_frame [ 1 ] = NONE ; //<S2SV> mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , //<S2SV> tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; //<S2SV> # if CONFIG_VP9_TEMPORAL_DENOISING //<S2SV> vp9_denoiser_reset_frame_stats ( ctx ) ; //<S2SV> # endif //<S2SV> if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { //<S2SV> usable_ref_frame = LAST_FRAME ; //<S2SV> } else { //<S2SV> usable_ref_frame = GOLDEN_FRAME ; //<S2SV> } //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= usable_ref_frame ; ++ ref_frame ) { //<S2SV> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; //<S2SV> x -> pred_mv_sad [ ref_frame ] = INT_MAX ; //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { //<S2SV> int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; //<S2SV> const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; //<S2SV> vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , //<S2SV> sf , sf ) ; //<S2SV> if ( cm -> use_prev_frame_mvs ) //<S2SV> vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , //<S2SV> candidates , mi_row , mi_col , NULL , NULL , //<S2SV> x -> mbmi_ext -> mode_context ) ; //<S2SV> else //<S2SV> const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , //<S2SV> xd -> mi [ 0 ] , //<S2SV> ref_frame , candidates , //<S2SV> mi_row , mi_col ) ; //<S2SV> vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , //<S2SV> & frame_mv [ NEARESTMV ] [ ref_frame ] , //<S2SV> & frame_mv [ NEARMV ] [ ref_frame ] ) ; //<S2SV> if ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) //<S2SV> vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , //<S2SV> ref_frame , bsize ) ; //<S2SV> } else { //<S2SV> ref_frame_skip_mask |= ( 1 << ref_frame ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { //<S2SV> int rate_mv = 0 ; //<S2SV> int mode_rd_thresh ; //<S2SV> int mode_index ; //<S2SV> int i ; //<S2SV> int64_t this_sse ; //<S2SV> int is_skippable ; //<S2SV> int this_early_term = 0 ; //<S2SV> PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; //<S2SV> if ( cpi -> use_svc ) //<S2SV> this_mode = ref_mode_set_svc [ idx ] . pred_mode ; //<S2SV> if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) //<S2SV> continue ; //<S2SV> ref_frame = ref_mode_set [ idx ] . ref_frame ; //<S2SV> if ( cpi -> use_svc ) //<S2SV> ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) //<S2SV> continue ; //<S2SV> if ( const_motion [ ref_frame ] && this_mode == NEARMV ) //<S2SV> continue ; //<S2SV> i = ( ref_frame == LAST_FRAME ) ? GOLDEN_FRAME : LAST_FRAME ; //<S2SV> if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) //<S2SV> if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) //<S2SV> ref_frame_skip_mask |= ( 1 << ref_frame ) ; //<S2SV> if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) //<S2SV> continue ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) //<S2SV> xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; //<S2SV> mode_index = mode_idx [ ref_frame ] [ INTER_OFFSET ( this_mode ) ] ; //<S2SV> mode_rd_thresh = best_mode_skip_txfm ? //<S2SV> rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; //<S2SV> if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , //<S2SV> rd_thresh_freq_fact [ mode_index ] ) ) //<S2SV> continue ; //<S2SV> if ( this_mode == NEWMV ) { //<S2SV> if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { //<S2SV> int tmp_sad ; //<S2SV> int dis , cost_list [ 5 ] ; //<S2SV> if ( bsize < BLOCK_16X16 ) //<S2SV> continue ; //<S2SV> tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; //<S2SV> if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) //<S2SV> continue ; //<S2SV> if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) //<S2SV> continue ; //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; //<S2SV> rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , //<S2SV> & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , //<S2SV> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; //<S2SV> cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , //<S2SV> & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , //<S2SV> cpi -> common . allow_high_precision_mv , //<S2SV> x -> errorperbit , //<S2SV> & cpi -> fn_ptr [ bsize ] , //<S2SV> cpi -> sf . mv . subpel_force_stop , //<S2SV> cpi -> sf . mv . subpel_iters_per_step , //<S2SV> cond_cost_list ( cpi , cost_list ) , //<S2SV> x -> nmvjointcost , x -> mvcost , & dis , //<S2SV> & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; //<S2SV> } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , //<S2SV> & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> if ( this_mode == NEWMV && ref_frame == LAST_FRAME && //<S2SV> frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { //<S2SV> const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; //<S2SV> const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + //<S2SV> ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + //<S2SV> ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; //<S2SV> best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , //<S2SV> x -> plane [ 0 ] . src . stride , //<S2SV> pre_buf , pre_stride ) ; //<S2SV> x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; //<S2SV> } //<S2SV> if ( cpi -> use_svc ) { //<S2SV> if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && //<S2SV> frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) { //<S2SV> const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; //<S2SV> const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + //<S2SV> ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + //<S2SV> ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; //<S2SV> best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , //<S2SV> x -> plane [ 0 ] . src . stride , //<S2SV> pre_buf , pre_stride ) ; //<S2SV> x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; //<S2SV> } //<S2SV> } //<S2SV> if ( this_mode != NEARESTMV && //<S2SV> frame_mv [ this_mode ] [ ref_frame ] . as_int == //<S2SV> frame_mv [ NEARESTMV ] [ ref_frame ] . as_int ) //<S2SV> continue ; //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> mv [ 0 ] . as_int = frame_mv [ this_mode ] [ ref_frame ] . as_int ; //<S2SV> if ( reuse_inter_pred ) { //<S2SV> if ( ! this_mode_pred ) { //<S2SV> this_mode_pred = & tmp [ 3 ] ; //<S2SV> } else { //<S2SV> this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; //<S2SV> pd -> dst . buf = this_mode_pred -> data ; //<S2SV> pd -> dst . stride = bw ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( this_mode == NEWMV || filter_ref == SWITCHABLE ) && pred_filter_search //<S2SV> && ( ref_frame == LAST_FRAME || //<S2SV> ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) //<S2SV> && ( ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) != 0 ) ) { //<S2SV> int pf_rate [ 3 ] ; //<S2SV> int64_t pf_dist [ 3 ] ; //<S2SV> unsigned int pf_var [ 3 ] ; //<S2SV> unsigned int pf_sse [ 3 ] ; //<S2SV> TX_SIZE pf_tx_size [ 3 ] ; //<S2SV> int64_t best_cost = INT64_MAX ; //<S2SV> INTERP_FILTER best_filter = SWITCHABLE , filter ; //<S2SV> PRED_BUFFER * current_pred = this_mode_pred ; //<S2SV> for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { //<S2SV> int64_t cost ; //<S2SV> mbmi -> interp_filter = filter ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & pf_rate [ filter ] , & pf_dist [ filter ] , //<S2SV> & pf_var [ filter ] , & pf_sse [ filter ] ) ; //<S2SV> pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; //<S2SV> cost = RDCOST ( x -> rdmult , x -> rddiv , pf_rate [ filter ] , pf_dist [ filter ] ) ; //<S2SV> pf_tx_size [ filter ] = mbmi -> tx_size ; //<S2SV> if ( cost < best_cost ) { //<S2SV> best_filter = filter ; //<S2SV> best_cost = cost ; //<S2SV> skip_txfm = x -> skip_txfm [ 0 ] ; //<S2SV> if ( reuse_inter_pred ) { //<S2SV> if ( this_mode_pred != current_pred ) { //<S2SV> free_pred_buffer ( this_mode_pred ) ; //<S2SV> this_mode_pred = current_pred ; //<S2SV> } //<S2SV> if ( filter < EIGHTTAP_SHARP ) { //<S2SV> current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; //<S2SV> pd -> dst . buf = current_pred -> data ; //<S2SV> pd -> dst . stride = bw ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( reuse_inter_pred && this_mode_pred != current_pred ) //<S2SV> free_pred_buffer ( current_pred ) ; //<S2SV> mbmi -> interp_filter = best_filter ; //<S2SV> mbmi -> tx_size = pf_tx_size [ best_filter ] ; //<S2SV> this_rdc . rate = pf_rate [ best_filter ] ; //<S2SV> this_rdc . dist = pf_dist [ best_filter ] ; //<S2SV> var_y = pf_var [ best_filter ] ; //<S2SV> sse_y = pf_sse [ best_filter ] ; //<S2SV> x -> skip_txfm [ 0 ] = skip_txfm ; //<S2SV> if ( reuse_inter_pred ) { //<S2SV> pd -> dst . buf = this_mode_pred -> data ; //<S2SV> pd -> dst . stride = this_mode_pred -> stride ; //<S2SV> } //<S2SV> } else { //<S2SV> mbmi -> interp_filter = ( filter_ref == SWITCHABLE ) ? EIGHTTAP : filter_ref ; //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( bsize > BLOCK_32X32 && //<S2SV> ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && //<S2SV> cm -> base_qindex ) { //<S2SV> model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , //<S2SV> & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , //<S2SV> & this_early_term ) ; //<S2SV> } else { //<S2SV> model_rd_for_sb_y ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , //<S2SV> & var_y , & sse_y ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! this_early_term ) { //<S2SV> this_sse = ( int64_t ) sse_y ; //<S2SV> block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , //<S2SV> & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; //<S2SV> x -> skip_txfm [ 0 ] = is_skippable ; //<S2SV> if ( is_skippable ) { //<S2SV> this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> } else { //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { //<S2SV> this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } else { //<S2SV> this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> this_rdc . dist = this_sse ; //<S2SV> x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) { //<S2SV> if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) //<S2SV> this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; //<S2SV> } //<S2SV> } else { //<S2SV> this_rdc . rate += cm -> interp_filter == SWITCHABLE ? //<S2SV> vp9_get_switchable_rate ( cpi , xd ) : 0 ; //<S2SV> this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> } //<S2SV> if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { //<S2SV> int uv_rate = 0 ; //<S2SV> int64_t uv_dist = 0 ; //<S2SV> if ( x -> color_sensitivity [ 0 ] ) //<S2SV> vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; //<S2SV> if ( x -> color_sensitivity [ 1 ] ) //<S2SV> vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; //<S2SV> model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , //<S2SV> & var_y , & sse_y ) ; //<S2SV> this_rdc . rate += uv_rate ; //<S2SV> this_rdc . dist += uv_dist ; //<S2SV> } //<S2SV> this_rdc . rate += rate_mv ; //<S2SV> this_rdc . rate += //<S2SV> cpi -> inter_mode_cost [ x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( //<S2SV> this_mode ) ] ; //<S2SV> this_rdc . rate += ref_frame_cost [ ref_frame ] ; //<S2SV> this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; //<S2SV> if ( cpi -> allow_encode_breakout ) { //<S2SV> encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , //<S2SV> var_y , sse_y , yv12_mb , & this_rdc . rate , //<S2SV> & this_rdc . dist ) ; //<S2SV> if ( x -> skip ) { //<S2SV> this_rdc . rate += rate_mv ; //<S2SV> this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , //<S2SV> this_rdc . dist ) ; //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_VP9_TEMPORAL_DENOISING //<S2SV> if ( cpi -> oxcf . noise_sensitivity > 0 ) //<S2SV> vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; //<S2SV> # else //<S2SV> ( void ) ctx ; //<S2SV> # endif //<S2SV> if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { //<S2SV> best_rdc = this_rdc ; //<S2SV> best_mode = this_mode ; //<S2SV> best_pred_filter = mbmi -> interp_filter ; //<S2SV> best_tx_size = mbmi -> tx_size ; //<S2SV> best_ref_frame = ref_frame ; //<S2SV> best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; //<S2SV> best_early_term = this_early_term ; //<S2SV> if ( reuse_inter_pred ) { //<S2SV> free_pred_buffer ( best_pred ) ; //<S2SV> best_pred = this_mode_pred ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( reuse_inter_pred ) //<S2SV> free_pred_buffer ( this_mode_pred ) ; //<S2SV> } //<S2SV> if ( x -> skip ) //<S2SV> break ; //<S2SV> if ( best_early_term && idx > 0 ) { //<S2SV> x -> skip = 1 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> mbmi -> mode = best_mode ; //<S2SV> mbmi -> interp_filter = best_pred_filter ; //<S2SV> mbmi -> tx_size = best_tx_size ; //<S2SV> mbmi -> ref_frame [ 0 ] = best_ref_frame ; //<S2SV> mbmi -> mv [ 0 ] . as_int = frame_mv [ best_mode ] [ best_ref_frame ] . as_int ; //<S2SV> xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = mbmi -> mv [ 0 ] . as_int ; //<S2SV> x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; //<S2SV> if ( best_rdc . rdcost == INT64_MAX || //<S2SV> ( ! x -> skip && best_rdc . rdcost > inter_mode_thresh && //<S2SV> bsize <= cpi -> sf . max_intra_bsize ) ) { //<S2SV> struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; //<S2SV> const TX_SIZE intra_tx_size = //<S2SV> MIN ( max_txsize_lookup [ bsize ] , //<S2SV> tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; //<S2SV> int i ; //<S2SV> TX_SIZE best_intra_tx_size = TX_SIZES ; //<S2SV> if ( reuse_inter_pred && best_pred != NULL ) { //<S2SV> if ( best_pred -> data == orig_dst . buf ) { //<S2SV> this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) //<S2SV> vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> this_mode_pred -> data , this_mode_pred -> stride , //<S2SV> NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; //<S2SV> else //<S2SV> vpx_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> this_mode_pred -> data , this_mode_pred -> stride , //<S2SV> NULL , 0 , NULL , 0 , bw , bh ) ; //<S2SV> # else //<S2SV> vpx_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> this_mode_pred -> data , this_mode_pred -> stride , //<S2SV> NULL , 0 , NULL , 0 , bw , bh ) ; //<S2SV> # endif //<S2SV> best_pred = this_mode_pred ; //<S2SV> } //<S2SV> } //<S2SV> pd -> dst = orig_dst ; //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) { //<S2SV> const PREDICTION_MODE this_mode = intra_mode_list [ i ] ; //<S2SV> THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; //<S2SV> int mode_rd_thresh = rd_threshes [ mode_index ] ; //<S2SV> if ( ! ( ( 1 << this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) //<S2SV> continue ; //<S2SV> if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , //<S2SV> rd_thresh_freq_fact [ mode_index ] ) ) //<S2SV> continue ; //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; //<S2SV> args . mode = this_mode ; //<S2SV> args . rate = 0 ; //<S2SV> args . dist = 0 ; //<S2SV> mbmi -> tx_size = intra_tx_size ; //<S2SV> vp9_foreach_transformed_block_in_plane ( xd , bsize , 0 , //<S2SV> estimate_block_intra , & args ) ; //<S2SV> this_rdc . rate = args . rate ; //<S2SV> this_rdc . dist = args . dist ; //<S2SV> this_rdc . rate += cpi -> mbmode_cost [ this_mode ] ; //<S2SV> this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; //<S2SV> this_rdc . rate += intra_cost_penalty ; //<S2SV> this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> this_rdc . rate , this_rdc . dist ) ; //<S2SV> if ( this_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = this_rdc ; //<S2SV> best_mode = this_mode ; //<S2SV> best_intra_tx_size = mbmi -> tx_size ; //<S2SV> best_ref_frame = INTRA_FRAME ; //<S2SV> mbmi -> uv_mode = this_mode ; //<S2SV> mbmi -> mv [ 0 ] . as_int = INVALID_MV ; //<S2SV> best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( best_ref_frame != INTRA_FRAME ) { //<S2SV> mbmi -> tx_size = best_tx_size ; //<S2SV> } else { //<S2SV> mbmi -> tx_size = best_intra_tx_size ; //<S2SV> } //<S2SV> } //<S2SV> pd -> dst = orig_dst ; //<S2SV> mbmi -> mode = best_mode ; //<S2SV> mbmi -> ref_frame [ 0 ] = best_ref_frame ; //<S2SV> x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; //<S2SV> if ( reuse_inter_pred && best_pred != NULL ) { //<S2SV> if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) //<S2SV> vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> pd -> dst . buf , pd -> dst . stride , NULL , 0 , //<S2SV> NULL , 0 , bw , bh , xd -> bd ) ; //<S2SV> else //<S2SV> vpx_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> pd -> dst . buf , pd -> dst . stride , NULL , 0 , //<S2SV> NULL , 0 , bw , bh ) ; //<S2SV> # else //<S2SV> vpx_convolve_copy ( best_pred -> data , best_pred -> stride , //<S2SV> pd -> dst . buf , pd -> dst . stride , NULL , 0 , //<S2SV> NULL , 0 , bw , bh ) ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_rd_thresh ) { //<S2SV> THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; //<S2SV> if ( best_ref_frame == INTRA_FRAME ) { //<S2SV> int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < intra_modes ; i ++ ) { //<S2SV> update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , //<S2SV> best_mode_idx , intra_mode_list [ i ] ) ; //<S2SV> } //<S2SV> } else { //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { //<S2SV> PREDICTION_MODE this_mode ; //<S2SV> if ( best_ref_frame != ref_frame ) continue ; //<S2SV> for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { //<S2SV> update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , //<S2SV> best_mode_idx , this_mode ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> * rd_cost = best_rdc ; //<S2SV> } //<S2SV> 