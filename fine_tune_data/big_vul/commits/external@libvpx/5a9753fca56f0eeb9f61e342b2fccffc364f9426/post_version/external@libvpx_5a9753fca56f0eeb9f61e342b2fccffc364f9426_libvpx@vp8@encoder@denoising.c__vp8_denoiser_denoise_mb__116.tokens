void vp8_denoiser_denoise_mb ( VP8_DENOISER * denoiser , //<S2SV> MACROBLOCK * x , //<S2SV> unsigned int best_sse , //<S2SV> unsigned int zero_mv_sse , //<S2SV> int recon_yoffset , //<S2SV> int recon_uvoffset , //<S2SV> loop_filter_info_n * lfi_n , //<S2SV> int mb_row , //<S2SV> int mb_col , //<S2SV> int block_index ) //<S2SV> { //<S2SV> int mv_row ; //<S2SV> int mv_col ; //<S2SV> unsigned int motion_threshold ; //<S2SV> unsigned int motion_magnitude2 ; //<S2SV> unsigned int sse_thresh ; //<S2SV> int sse_diff_thresh = 0 ; //<S2SV> int apply_spatial_loop_filter = 1 ; //<S2SV> MV_REFERENCE_FRAME frame = x -> best_reference_frame ; //<S2SV> MV_REFERENCE_FRAME zero_frame = x -> best_zeromv_reference_frame ; //<S2SV> enum vp8_denoiser_decision decision = FILTER_BLOCK ; //<S2SV> enum vp8_denoiser_decision decision_u = COPY_BLOCK ; //<S2SV> enum vp8_denoiser_decision decision_v = COPY_BLOCK ; //<S2SV> if ( zero_frame ) //<S2SV> { //<S2SV> YV12_BUFFER_CONFIG * src = & denoiser -> yv12_running_avg [ frame ] ; //<S2SV> YV12_BUFFER_CONFIG * dst = & denoiser -> yv12_mc_running_avg ; //<S2SV> YV12_BUFFER_CONFIG saved_pre , saved_dst ; //<S2SV> MB_MODE_INFO saved_mbmi ; //<S2SV> MACROBLOCKD * filter_xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & filter_xd -> mode_info_context -> mbmi ; //<S2SV> int sse_diff = 0 ; //<S2SV> const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ; //<S2SV> zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ; //<S2SV> sse_diff = zero_mv_sse - best_sse ; //<S2SV> saved_mbmi = * mbmi ; //<S2SV> mbmi -> ref_frame = x -> best_reference_frame ; //<S2SV> mbmi -> mode = x -> best_sse_inter_mode ; //<S2SV> mbmi -> mv = x -> best_sse_mv ; //<S2SV> mbmi -> need_to_clamp_mvs = x -> need_to_clamp_best_mvs ; //<S2SV> mv_col = x -> best_sse_mv . as_mv . col ; //<S2SV> mv_row = x -> best_sse_mv . as_mv . row ; //<S2SV> if ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) //<S2SV> <= NOISE_MOTION_THRESHOLD ) //<S2SV> sse_diff_thresh = ( int ) SSE_DIFF_THRESHOLD ; //<S2SV> if ( frame == INTRA_FRAME || //<S2SV> sse_diff <= sse_diff_thresh ) //<S2SV> { //<S2SV> x -> denoise_zeromv = 1 ; //<S2SV> mbmi -> ref_frame = //<S2SV> x -> best_zeromv_reference_frame ; //<S2SV> src = & denoiser -> yv12_running_avg [ zero_frame ] ; //<S2SV> mbmi -> mode = ZEROMV ; //<S2SV> mbmi -> mv . as_int = 0 ; //<S2SV> x -> best_sse_inter_mode = ZEROMV ; //<S2SV> x -> best_sse_mv . as_int = 0 ; //<S2SV> best_sse = zero_mv_sse ; //<S2SV> } //<S2SV> saved_pre = filter_xd -> pre ; //<S2SV> saved_dst = filter_xd -> dst ; //<S2SV> filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; //<S2SV> filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; //<S2SV> filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; //<S2SV> filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; //<S2SV> filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; //<S2SV> filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; //<S2SV> if ( ! x -> skip ) //<S2SV> { //<S2SV> vp8_build_inter_predictors_mb ( filter_xd ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_build_inter16x16_predictors_mb ( filter_xd , //<S2SV> filter_xd -> dst . y_buffer , //<S2SV> filter_xd -> dst . u_buffer , //<S2SV> filter_xd -> dst . v_buffer , //<S2SV> filter_xd -> dst . y_stride , //<S2SV> filter_xd -> dst . uv_stride ) ; //<S2SV> } //<S2SV> filter_xd -> pre = saved_pre ; //<S2SV> filter_xd -> dst = saved_dst ; //<S2SV> * mbmi = saved_mbmi ; //<S2SV> } //<S2SV> mv_row = x -> best_sse_mv . as_mv . row ; //<S2SV> mv_col = x -> best_sse_mv . as_mv . col ; //<S2SV> motion_magnitude2 = mv_row * mv_row + mv_col * mv_col ; //<S2SV> motion_threshold = denoiser -> denoise_pars . scale_motion_thresh * //<S2SV> NOISE_MOTION_THRESHOLD ; //<S2SV> if ( x -> is_skin ) //<S2SV> motion_threshold = 1 ; //<S2SV> if ( motion_magnitude2 < //<S2SV> denoiser -> denoise_pars . scale_increase_filter * NOISE_MOTION_THRESHOLD ) //<S2SV> x -> increase_denoising = 1 ; //<S2SV> sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD ; //<S2SV> if ( x -> increase_denoising ) //<S2SV> sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD_HIGH ; //<S2SV> if ( best_sse > sse_thresh || motion_magnitude2 > motion_threshold ) //<S2SV> decision = COPY_BLOCK ; //<S2SV> if ( decision == FILTER_BLOCK ) //<S2SV> { //<S2SV> unsigned char * mc_running_avg_y = //<S2SV> denoiser -> yv12_mc_running_avg . y_buffer + recon_yoffset ; //<S2SV> int mc_avg_y_stride = denoiser -> yv12_mc_running_avg . y_stride ; //<S2SV> unsigned char * running_avg_y = //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset ; //<S2SV> int avg_y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; //<S2SV> decision = vp8_denoiser_filter ( mc_running_avg_y , mc_avg_y_stride , //<S2SV> running_avg_y , avg_y_stride , //<S2SV> x -> thismb , 16 , motion_magnitude2 , //<S2SV> x -> increase_denoising ) ; //<S2SV> denoiser -> denoise_state [ block_index ] = motion_magnitude2 > 0 ? //<S2SV> kFilterNonZeroMV : kFilterZeroMV ; //<S2SV> if ( denoiser -> denoiser_mode != kDenoiserOnYOnly && //<S2SV> motion_magnitude2 == 0 && //<S2SV> decision == FILTER_BLOCK ) { //<S2SV> unsigned char * mc_running_avg_u = //<S2SV> denoiser -> yv12_mc_running_avg . u_buffer + recon_uvoffset ; //<S2SV> unsigned char * running_avg_u = //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset ; //<S2SV> unsigned char * mc_running_avg_v = //<S2SV> denoiser -> yv12_mc_running_avg . v_buffer + recon_uvoffset ; //<S2SV> unsigned char * running_avg_v = //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset ; //<S2SV> int mc_avg_uv_stride = denoiser -> yv12_mc_running_avg . uv_stride ; //<S2SV> int avg_uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; //<S2SV> int signal_stride = x -> block [ 16 ] . src_stride ; //<S2SV> decision_u = //<S2SV> vp8_denoiser_filter_uv ( mc_running_avg_u , mc_avg_uv_stride , //<S2SV> running_avg_u , avg_uv_stride , //<S2SV> x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , //<S2SV> signal_stride , motion_magnitude2 , 0 ) ; //<S2SV> decision_v = //<S2SV> vp8_denoiser_filter_uv ( mc_running_avg_v , mc_avg_uv_stride , //<S2SV> running_avg_v , avg_uv_stride , //<S2SV> x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , //<S2SV> signal_stride , motion_magnitude2 , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( decision == COPY_BLOCK ) //<S2SV> { //<S2SV> x -> denoise_zeromv = 0 ; //<S2SV> vp8_copy_mem16x16 ( //<S2SV> x -> thismb , 16 , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ) ; //<S2SV> denoiser -> denoise_state [ block_index ] = kNoFilter ; //<S2SV> } //<S2SV> if ( denoiser -> denoiser_mode != kDenoiserOnYOnly ) { //<S2SV> if ( decision_u == COPY_BLOCK ) { //<S2SV> vp8_copy_mem8x8 ( //<S2SV> x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , x -> block [ 16 ] . src_stride , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; //<S2SV> } //<S2SV> if ( decision_v == COPY_BLOCK ) { //<S2SV> vp8_copy_mem8x8 ( //<S2SV> x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , x -> block [ 16 ] . src_stride , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset , //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( apply_spatial_loop_filter ) { //<S2SV> loop_filter_info lfi ; //<S2SV> int apply_filter_col = 0 ; //<S2SV> int apply_filter_row = 0 ; //<S2SV> int apply_filter = 0 ; //<S2SV> int y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; //<S2SV> int uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; //<S2SV> int filter_level = 48 ; //<S2SV> int hev_index = lfi_n -> hev_thr_lut [ INTER_FRAME ] [ filter_level ] ; //<S2SV> lfi . mblim = lfi_n -> mblim [ filter_level ] ; //<S2SV> lfi . blim = lfi_n -> blim [ filter_level ] ; //<S2SV> lfi . lim = lfi_n -> lim [ filter_level ] ; //<S2SV> lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; //<S2SV> if ( mb_col > 0 ) { //<S2SV> apply_filter_col = ! ( ( denoiser -> denoise_state [ block_index ] == //<S2SV> denoiser -> denoise_state [ block_index - 1 ] ) && //<S2SV> denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; //<S2SV> if ( apply_filter_col ) { //<S2SV> apply_filter = 1 ; //<S2SV> vp8_loop_filter_mbv ( //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , //<S2SV> NULL , NULL , y_stride , uv_stride , & lfi ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( mb_row > 0 ) { //<S2SV> apply_filter_row = ! ( ( denoiser -> denoise_state [ block_index ] == //<S2SV> denoiser -> denoise_state [ block_index - denoiser -> num_mb_cols ] ) && //<S2SV> denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; //<S2SV> if ( apply_filter_row ) { //<S2SV> apply_filter = 1 ; //<S2SV> vp8_loop_filter_mbh ( //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , //<S2SV> NULL , NULL , y_stride , uv_stride , & lfi ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( apply_filter ) { //<S2SV> vp8_copy_mem16x16 ( //<S2SV> denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , //<S2SV> y_stride , x -> thismb , 16 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 