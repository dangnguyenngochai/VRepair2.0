static vpx_codec_err_t decode_one ( vpx_codec_alg_priv_t * ctx , //<S2SV> const uint8_t * * data , unsigned int data_sz , //<S2SV> void * user_priv , int64_t deadline ) { //<S2SV> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; //<S2SV> ( void ) deadline ; //<S2SV> if ( ! ctx -> si . h ) { //<S2SV> int is_intra_only = 0 ; //<S2SV> const vpx_codec_err_t res = //<S2SV> decoder_peek_si_internal ( * data , data_sz , & ctx -> si , & is_intra_only , //<S2SV> ctx -> decrypt_cb , ctx -> decrypt_state ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> if ( ! ctx -> si . is_kf && ! is_intra_only ) //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> } //<S2SV> if ( ! ctx -> frame_parallel_decode ) { //<S2SV> VPxWorker * const worker = ctx -> frame_workers ; //<S2SV> FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; //<S2SV> frame_worker_data -> data = * data ; //<S2SV> frame_worker_data -> data_size = data_sz ; //<S2SV> frame_worker_data -> user_priv = user_priv ; //<S2SV> frame_worker_data -> received_frame = 1 ; //<S2SV> frame_worker_data -> pbi -> decrypt_cb = ctx -> decrypt_cb ; //<S2SV> frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ; //<S2SV> worker -> had_error = 0 ; //<S2SV> winterface -> execute ( worker ) ; //<S2SV> * data = frame_worker_data -> data_end ; //<S2SV> if ( worker -> had_error ) //<S2SV> return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ; //<S2SV> check_resync ( ctx , frame_worker_data -> pbi ) ; //<S2SV> } else { //<S2SV> VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ; //<S2SV> FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; //<S2SV> if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) //<S2SV> vp9_frameworker_copy_context ( //<S2SV> & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , //<S2SV> & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ; //<S2SV> frame_worker_data -> pbi -> ready_for_new_data = 0 ; //<S2SV> if ( frame_worker_data -> scratch_buffer_size < data_sz ) { //<S2SV> frame_worker_data -> scratch_buffer = //<S2SV> ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ; //<S2SV> if ( frame_worker_data -> scratch_buffer == NULL ) { //<S2SV> set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer" ) ; //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> } //<S2SV> frame_worker_data -> scratch_buffer_size = data_sz ; //<S2SV> } //<S2SV> frame_worker_data -> data_size = data_sz ; //<S2SV> memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ; //<S2SV> frame_worker_data -> frame_decoded = 0 ; //<S2SV> frame_worker_data -> frame_context_ready = 0 ; //<S2SV> frame_worker_data -> received_frame = 1 ; //<S2SV> frame_worker_data -> data = frame_worker_data -> scratch_buffer ; //<S2SV> frame_worker_data -> user_priv = user_priv ; //<S2SV> if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) //<S2SV> ctx -> last_submit_worker_id = //<S2SV> ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ; //<S2SV> ctx -> next_submit_worker_id = //<S2SV> ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ; //<S2SV> -- ctx -> available_threads ; //<S2SV> worker -> had_error = 0 ; //<S2SV> winterface -> launch ( worker ) ; //<S2SV> } //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 