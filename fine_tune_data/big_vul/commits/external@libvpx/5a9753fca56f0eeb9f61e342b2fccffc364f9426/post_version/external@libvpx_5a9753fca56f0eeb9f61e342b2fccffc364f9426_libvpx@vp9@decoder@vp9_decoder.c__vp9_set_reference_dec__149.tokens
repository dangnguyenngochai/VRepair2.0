vpx_codec_err_t vp9_set_reference_dec ( VP9_COMMON * cm , //<S2SV> VP9_REFFRAME ref_frame_flag , //<S2SV> YV12_BUFFER_CONFIG * sd ) { //<S2SV> RefBuffer * ref_buf = NULL ; //<S2SV> RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; //<S2SV> if ( ref_frame_flag == VP9_LAST_FLAG ) { //<S2SV> ref_buf = & cm -> frame_refs [ 0 ] ; //<S2SV> } else if ( ref_frame_flag == VP9_GOLD_FLAG ) { //<S2SV> ref_buf = & cm -> frame_refs [ 1 ] ; //<S2SV> } else if ( ref_frame_flag == VP9_ALT_FLAG ) { //<S2SV> ref_buf = & cm -> frame_refs [ 2 ] ; //<S2SV> } else { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Invalid<S2SV_blank>reference<S2SV_blank>frame" ) ; //<S2SV> return cm -> error . error_code ; //<S2SV> } //<S2SV> if ( ! equal_dimensions ( ref_buf -> buf , sd ) ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Incorrect<S2SV_blank>buffer<S2SV_blank>dimensions" ) ; //<S2SV> } else { //<S2SV> int * ref_fb_ptr = & ref_buf -> idx ; //<S2SV> const int free_fb = get_free_fb ( cm ) ; //<S2SV> if ( cm -> new_fb_idx == INVALID_IDX ) //<S2SV> return VPX_CODEC_MEM_ERROR ; //<S2SV> -- frame_bufs [ free_fb ] . ref_count ; //<S2SV> ref_cnt_fb ( frame_bufs , ref_fb_ptr , free_fb ) ; //<S2SV> ref_buf -> buf = & frame_bufs [ * ref_fb_ptr ] . buf ; //<S2SV> vp8_yv12_copy_frame ( sd , ref_buf -> buf ) ; //<S2SV> } //<S2SV> return cm -> error . error_code ; //<S2SV> } //<S2SV> 