static void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , //<S2SV> vpx_reader * r , //<S2SV> MB_MODE_INFO * const mbmi , //<S2SV> int plane , //<S2SV> int row , int col , //<S2SV> TX_SIZE tx_size ) { //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; //<S2SV> PREDICTION_MODE mode = ( plane == 0 ) ? mbmi -> mode : mbmi -> uv_mode ; //<S2SV> uint8_t * dst ; //<S2SV> dst = & pd -> dst . buf [ 4 * row * pd -> dst . stride + 4 * col ] ; //<S2SV> if ( mbmi -> sb_type < BLOCK_8X8 ) //<S2SV> if ( plane == 0 ) //<S2SV> mode = xd -> mi [ 0 ] -> bmi [ ( row << 1 ) + col ] . as_mode ; //<S2SV> vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , //<S2SV> dst , pd -> dst . stride , dst , pd -> dst . stride , //<S2SV> col , row , plane ) ; //<S2SV> if ( ! mbmi -> skip ) { //<S2SV> const TX_TYPE tx_type = ( plane || xd -> lossless ) ? //<S2SV> DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; //<S2SV> const scan_order * sc = ( plane || xd -> lossless ) ? //<S2SV> & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; //<S2SV> const int eob = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , //<S2SV> r , mbmi -> segment_id ) ; //<S2SV> inverse_transform_block_intra ( xd , plane , tx_type , tx_size , //<S2SV> dst , pd -> dst . stride , eob ) ; //<S2SV> } //<S2SV> } //<S2SV> 