static int set_vt_partitioning ( VP9_COMP * cpi , //<S2SV> MACROBLOCK * const x , //<S2SV> MACROBLOCKD * const xd , //<S2SV> void * data , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int mi_row , //<S2SV> int mi_col , //<S2SV> int64_t threshold , //<S2SV> BLOCK_SIZE bsize_min , //<S2SV> int force_split ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> variance_node vt ; //<S2SV> const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; //<S2SV> assert ( block_height == block_width ) ; //<S2SV> tree_to_node ( data , bsize , & vt ) ; //<S2SV> if ( force_split == 1 ) //<S2SV> return 0 ; //<S2SV> if ( bsize == bsize_min ) { //<S2SV> if ( low_res || cm -> frame_type == KEY_FRAME ) //<S2SV> get_variance ( & vt . part_variances -> none ) ; //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols && //<S2SV> mi_row + block_height / 2 < cm -> mi_rows && //<S2SV> vt . part_variances -> none . variance < threshold ) { //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } else if ( bsize > bsize_min ) { //<S2SV> if ( low_res || cm -> frame_type == KEY_FRAME ) //<S2SV> get_variance ( & vt . part_variances -> none ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME && //<S2SV> ( bsize > BLOCK_32X32 || //<S2SV> vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { //<S2SV> return 0 ; //<S2SV> } //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols && //<S2SV> mi_row + block_height / 2 < cm -> mi_rows && //<S2SV> vt . part_variances -> none . variance < threshold ) { //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> if ( mi_row + block_height / 2 < cm -> mi_rows ) { //<S2SV> BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> get_variance ( & vt . part_variances -> vert [ 0 ] ) ; //<S2SV> get_variance ( & vt . part_variances -> vert [ 1 ] ) ; //<S2SV> if ( vt . part_variances -> vert [ 0 ] . variance < threshold && //<S2SV> vt . part_variances -> vert [ 1 ] . variance < threshold && //<S2SV> get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col , subsize ) ; //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col + block_width / 2 , subsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( mi_col + block_width / 2 < cm -> mi_cols ) { //<S2SV> BLOCK_SIZE subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> get_variance ( & vt . part_variances -> horz [ 0 ] ) ; //<S2SV> get_variance ( & vt . part_variances -> horz [ 1 ] ) ; //<S2SV> if ( vt . part_variances -> horz [ 0 ] . variance < threshold && //<S2SV> vt . part_variances -> horz [ 1 ] . variance < threshold && //<S2SV> get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { //<S2SV> set_block_size ( cpi , x , xd , mi_row , mi_col , subsize ) ; //<S2SV> set_block_size ( cpi , x , xd , mi_row + block_height / 2 , mi_col , subsize ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> return 0 ; //<S2SV> } //<S2SV> 