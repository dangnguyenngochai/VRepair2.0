void vp8_pack_bitstream ( VP8_COMP * cpi , unsigned char * dest , unsigned char * dest_end , unsigned long * size ) //<S2SV> { //<S2SV> int i , j ; //<S2SV> VP8_HEADER oh ; //<S2SV> VP8_COMMON * const pc = & cpi -> common ; //<S2SV> vp8_writer * const bc = cpi -> bc ; //<S2SV> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; //<S2SV> int extra_bytes_packed = 0 ; //<S2SV> unsigned char * cx_data = dest ; //<S2SV> unsigned char * cx_data_end = dest_end ; //<S2SV> const int * mb_feature_data_bits ; //<S2SV> oh . show_frame = ( int ) pc -> show_frame ; //<S2SV> oh . type = ( int ) pc -> frame_type ; //<S2SV> oh . version = pc -> version ; //<S2SV> oh . first_partition_length_in_bytes = 0 ; //<S2SV> mb_feature_data_bits = vp8_mb_feature_data_bits ; //<S2SV> bc [ 0 ] . error = & pc -> error ; //<S2SV> validate_buffer ( cx_data , 3 , cx_data_end , & cpi -> common . error ) ; //<S2SV> cx_data += 3 ; //<S2SV> # if defined ( SECTIONBITS_OUTPUT ) //<S2SV> Sectionbits [ active_section = 1 ] += sizeof ( VP8_HEADER ) * 8 * 256 ; //<S2SV> # endif //<S2SV> if ( oh . type == KEY_FRAME ) //<S2SV> { //<S2SV> int v ; //<S2SV> validate_buffer ( cx_data , 7 , cx_data_end , & cpi -> common . error ) ; //<S2SV> cx_data [ 0 ] = 0x9D ; //<S2SV> cx_data [ 1 ] = 0x01 ; //<S2SV> cx_data [ 2 ] = 0x2a ; //<S2SV> v = ( pc -> horiz_scale << 14 ) | pc -> Width ; //<S2SV> cx_data [ 3 ] = v ; //<S2SV> cx_data [ 4 ] = v >> 8 ; //<S2SV> v = ( pc -> vert_scale << 14 ) | pc -> Height ; //<S2SV> cx_data [ 5 ] = v ; //<S2SV> cx_data [ 6 ] = v >> 8 ; //<S2SV> extra_bytes_packed = 7 ; //<S2SV> cx_data += extra_bytes_packed ; //<S2SV> vp8_start_encode ( bc , cx_data , cx_data_end ) ; //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> vp8_write_bit ( bc , pc -> clamp_type ) ; //<S2SV> } //<S2SV> else //<S2SV> vp8_start_encode ( bc , cx_data , cx_data_end ) ; //<S2SV> vp8_write_bit ( bc , xd -> segmentation_enabled ) ; //<S2SV> if ( xd -> segmentation_enabled ) //<S2SV> { //<S2SV> vp8_write_bit ( bc , xd -> update_mb_segmentation_map ) ; //<S2SV> vp8_write_bit ( bc , xd -> update_mb_segmentation_data ) ; //<S2SV> if ( xd -> update_mb_segmentation_data ) //<S2SV> { //<S2SV> signed char Data ; //<S2SV> vp8_write_bit ( bc , xd -> mb_segement_abs_delta ) ; //<S2SV> for ( i = 0 ; i < MB_LVL_MAX ; i ++ ) //<S2SV> { //<S2SV> for ( j = 0 ; j < MAX_MB_SEGMENTS ; j ++ ) //<S2SV> { //<S2SV> Data = xd -> segment_feature_data [ i ] [ j ] ; //<S2SV> if ( Data ) //<S2SV> { //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> if ( Data < 0 ) //<S2SV> { //<S2SV> Data = - Data ; //<S2SV> vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> vp8_write_literal ( bc , Data , mb_feature_data_bits [ i ] ) ; //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( xd -> update_mb_segmentation_map ) //<S2SV> { //<S2SV> for ( i = 0 ; i < MB_FEATURE_TREE_PROBS ; i ++ ) //<S2SV> { //<S2SV> int Data = xd -> mb_segment_tree_probs [ i ] ; //<S2SV> if ( Data != 255 ) //<S2SV> { //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> vp8_write_literal ( bc , Data , 8 ) ; //<S2SV> } //<S2SV> else //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> vp8_write_bit ( bc , pc -> filter_type ) ; //<S2SV> vp8_write_literal ( bc , pc -> filter_level , 6 ) ; //<S2SV> vp8_write_literal ( bc , pc -> sharpness_level , 3 ) ; //<S2SV> vp8_write_bit ( bc , xd -> mode_ref_lf_delta_enabled ) ; //<S2SV> if ( xd -> mode_ref_lf_delta_enabled ) //<S2SV> { //<S2SV> int send_update = xd -> mode_ref_lf_delta_update //<S2SV> || cpi -> oxcf . error_resilient_mode ; //<S2SV> vp8_write_bit ( bc , send_update ) ; //<S2SV> if ( send_update ) //<S2SV> { //<S2SV> int Data ; //<S2SV> for ( i = 0 ; i < MAX_REF_LF_DELTAS ; i ++ ) //<S2SV> { //<S2SV> Data = xd -> ref_lf_deltas [ i ] ; //<S2SV> if ( xd -> ref_lf_deltas [ i ] != xd -> last_ref_lf_deltas [ i ] //<S2SV> || cpi -> oxcf . error_resilient_mode ) //<S2SV> { //<S2SV> xd -> last_ref_lf_deltas [ i ] = xd -> ref_lf_deltas [ i ] ; //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> if ( Data > 0 ) //<S2SV> { //<S2SV> vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Data = - Data ; //<S2SV> vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < MAX_MODE_LF_DELTAS ; i ++ ) //<S2SV> { //<S2SV> Data = xd -> mode_lf_deltas [ i ] ; //<S2SV> if ( xd -> mode_lf_deltas [ i ] != xd -> last_mode_lf_deltas [ i ] //<S2SV> || cpi -> oxcf . error_resilient_mode ) //<S2SV> { //<S2SV> xd -> last_mode_lf_deltas [ i ] = xd -> mode_lf_deltas [ i ] ; //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> if ( Data > 0 ) //<S2SV> { //<S2SV> vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> Data = - Data ; //<S2SV> vp8_write_literal ( bc , ( Data & 0x3F ) , 6 ) ; //<S2SV> vp8_write_bit ( bc , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> else //<S2SV> vp8_write_bit ( bc , 0 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> vp8_write_literal ( bc , pc -> multi_token_partition , 2 ) ; //<S2SV> vp8_write_literal ( bc , pc -> base_qindex , 7 ) ; //<S2SV> put_delta_q ( bc , pc -> y1dc_delta_q ) ; //<S2SV> put_delta_q ( bc , pc -> y2dc_delta_q ) ; //<S2SV> put_delta_q ( bc , pc -> y2ac_delta_q ) ; //<S2SV> put_delta_q ( bc , pc -> uvdc_delta_q ) ; //<S2SV> put_delta_q ( bc , pc -> uvac_delta_q ) ; //<S2SV> if ( pc -> frame_type != KEY_FRAME ) //<S2SV> { //<S2SV> vp8_write_bit ( bc , pc -> refresh_golden_frame ) ; //<S2SV> vp8_write_bit ( bc , pc -> refresh_alt_ref_frame ) ; //<S2SV> if ( ! pc -> refresh_golden_frame ) //<S2SV> vp8_write_literal ( bc , pc -> copy_buffer_to_gf , 2 ) ; //<S2SV> if ( ! pc -> refresh_alt_ref_frame ) //<S2SV> vp8_write_literal ( bc , pc -> copy_buffer_to_arf , 2 ) ; //<S2SV> vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) ; //<S2SV> vp8_write_bit ( bc , pc -> ref_frame_sign_bias [ ALTREF_FRAME ] ) ; //<S2SV> } //<S2SV> # if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) //<S2SV> if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) //<S2SV> { //<S2SV> if ( pc -> frame_type == KEY_FRAME ) //<S2SV> pc -> refresh_entropy_probs = 1 ; //<S2SV> else //<S2SV> pc -> refresh_entropy_probs = 0 ; //<S2SV> } //<S2SV> # endif //<S2SV> vp8_write_bit ( bc , pc -> refresh_entropy_probs ) ; //<S2SV> if ( pc -> frame_type != KEY_FRAME ) //<S2SV> vp8_write_bit ( bc , pc -> refresh_last_frame ) ; //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> if ( pc -> frame_type == INTER_FRAME ) //<S2SV> active_section = 0 ; //<S2SV> else //<S2SV> active_section = 7 ; //<S2SV> # endif //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> pack_coef_probs ( cpi ) ; //<S2SV> # else //<S2SV> if ( pc -> refresh_entropy_probs == 0 ) //<S2SV> { //<S2SV> memcpy ( & cpi -> common . lfc , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; //<S2SV> } //<S2SV> vp8_update_coef_probs ( cpi ) ; //<S2SV> # endif //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> active_section = 2 ; //<S2SV> # endif //<S2SV> vp8_write_bit ( bc , pc -> mb_no_coeff_skip ) ; //<S2SV> if ( pc -> frame_type == KEY_FRAME ) //<S2SV> { //<S2SV> write_kfmodes ( cpi ) ; //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> active_section = 8 ; //<S2SV> # endif //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> pack_inter_mode_mvs ( cpi ) ; //<S2SV> # ifdef VP8_ENTROPY_STATS //<S2SV> active_section = 1 ; //<S2SV> # endif //<S2SV> } //<S2SV> vp8_stop_encode ( bc ) ; //<S2SV> cx_data += bc -> pos ; //<S2SV> oh . first_partition_length_in_bytes = cpi -> bc -> pos ; //<S2SV> { //<S2SV> int v = ( oh . first_partition_length_in_bytes << 5 ) | //<S2SV> ( oh . show_frame << 4 ) | //<S2SV> ( oh . version << 1 ) | //<S2SV> oh . type ; //<S2SV> dest [ 0 ] = v ; //<S2SV> dest [ 1 ] = v >> 8 ; //<S2SV> dest [ 2 ] = v >> 16 ; //<S2SV> } //<S2SV> * size = VP8_HEADER_SIZE + extra_bytes_packed + cpi -> bc -> pos ; //<S2SV> cpi -> partition_sz [ 0 ] = * size ; //<S2SV> # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING //<S2SV> { //<S2SV> const int num_part = ( 1 << pc -> multi_token_partition ) ; //<S2SV> unsigned char * dp = cpi -> partition_d [ 0 ] + cpi -> partition_sz [ 0 ] ; //<S2SV> if ( num_part > 1 ) //<S2SV> { //<S2SV> validate_buffer ( dp , 3 * ( num_part - 1 ) , cpi -> partition_d_end [ 0 ] , //<S2SV> & pc -> error ) ; //<S2SV> cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; //<S2SV> for ( i = 1 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> write_partition_size ( dp , cpi -> partition_sz [ i ] ) ; //<S2SV> dp += 3 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! cpi -> output_partition ) //<S2SV> { //<S2SV> for ( i = 0 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> memmove ( dp , cpi -> partition_d [ i + 1 ] , cpi -> partition_sz [ i + 1 ] ) ; //<S2SV> cpi -> partition_d [ i + 1 ] = dp ; //<S2SV> dp += cpi -> partition_sz [ i + 1 ] ; //<S2SV> } //<S2SV> } //<S2SV> * size = 0 ; //<S2SV> for ( i = 0 ; i < num_part + 1 ; i ++ ) //<S2SV> { //<S2SV> * size += cpi -> partition_sz [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> # else //<S2SV> if ( pc -> multi_token_partition != ONE_PARTITION ) //<S2SV> { //<S2SV> int num_part = 1 << pc -> multi_token_partition ; //<S2SV> cpi -> partition_sz [ 0 ] += 3 * ( num_part - 1 ) ; //<S2SV> * size += 3 * ( num_part - 1 ) ; //<S2SV> validate_buffer ( cx_data , 3 * ( num_part - 1 ) , cx_data_end , //<S2SV> & pc -> error ) ; //<S2SV> for ( i = 1 ; i < num_part + 1 ; i ++ ) //<S2SV> { //<S2SV> cpi -> bc [ i ] . error = & pc -> error ; //<S2SV> } //<S2SV> pack_tokens_into_partitions ( cpi , cx_data + 3 * ( num_part - 1 ) , //<S2SV> cx_data_end , num_part ) ; //<S2SV> for ( i = 1 ; i < num_part ; i ++ ) //<S2SV> { //<S2SV> cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; //<S2SV> write_partition_size ( cx_data , cpi -> partition_sz [ i ] ) ; //<S2SV> cx_data += 3 ; //<S2SV> * size += cpi -> partition_sz [ i ] ; //<S2SV> } //<S2SV> cpi -> partition_sz [ i ] = cpi -> bc [ i ] . pos ; //<S2SV> * size += cpi -> partition_sz [ i ] ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> bc [ 1 ] . error = & pc -> error ; //<S2SV> vp8_start_encode ( & cpi -> bc [ 1 ] , cx_data , cx_data_end ) ; //<S2SV> # if CONFIG_MULTITHREAD //<S2SV> if ( cpi -> b_multi_threaded ) //<S2SV> pack_mb_row_tokens ( cpi , & cpi -> bc [ 1 ] ) ; //<S2SV> else //<S2SV> # endif //<S2SV> vp8_pack_tokens ( & cpi -> bc [ 1 ] , cpi -> tok , cpi -> tok_count ) ; //<S2SV> vp8_stop_encode ( & cpi -> bc [ 1 ] ) ; //<S2SV> * size += cpi -> bc [ 1 ] . pos ; //<S2SV> cpi -> partition_sz [ 1 ] = cpi -> bc [ 1 ] . pos ; //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> 