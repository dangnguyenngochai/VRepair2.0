static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , //<S2SV> const uint8_t * data , //<S2SV> const uint8_t * data_end ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; //<S2SV> const uint8_t * bit_reader_end = NULL ; //<S2SV> const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> const int num_workers = MIN ( pbi -> max_threads & ~ 1 , tile_cols ) ; //<S2SV> TileBuffer tile_buffers [ 1 ] [ 1 << 6 ] ; //<S2SV> int n ; //<S2SV> int final_worker = - 1 ; //<S2SV> assert ( tile_cols <= ( 1 << 6 ) ) ; //<S2SV> assert ( tile_rows == 1 ) ; //<S2SV> ( void ) tile_rows ; //<S2SV> if ( pbi -> num_tile_workers == 0 ) { //<S2SV> const int num_threads = pbi -> max_threads & ~ 1 ; //<S2SV> int i ; //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> tile_workers , //<S2SV> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; //<S2SV> assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , //<S2SV> vpx_memalign ( 32 , num_threads * //<S2SV> sizeof ( * pbi -> tile_worker_data ) ) ) ; //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , //<S2SV> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info ) ) ) ; //<S2SV> for ( i = 0 ; i < num_threads ; ++ i ) { //<S2SV> VPxWorker * const worker = & pbi -> tile_workers [ i ] ; //<S2SV> ++ pbi -> num_tile_workers ; //<S2SV> winterface -> init ( worker ) ; //<S2SV> if ( i < num_threads - 1 && ! winterface -> reset ( worker ) ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( n = 0 ; n < num_workers ; ++ n ) { //<S2SV> VPxWorker * const worker = & pbi -> tile_workers [ n ] ; //<S2SV> winterface -> sync ( worker ) ; //<S2SV> worker -> hook = ( VPxWorkerHook ) tile_worker_hook ; //<S2SV> worker -> data1 = & pbi -> tile_worker_data [ n ] ; //<S2SV> worker -> data2 = & pbi -> tile_worker_info [ n ] ; //<S2SV> } //<S2SV> memset ( cm -> above_context , 0 , //<S2SV> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; //<S2SV> memset ( cm -> above_seg_context , 0 , //<S2SV> sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ; //<S2SV> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; //<S2SV> qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , //<S2SV> compare_tile_buffers ) ; //<S2SV> { //<S2SV> int group_start = 0 ; //<S2SV> while ( group_start < tile_cols ) { //<S2SV> const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; //<S2SV> const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; //<S2SV> memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , //<S2SV> ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; //<S2SV> tile_buffers [ 0 ] [ group_end ] = largest ; //<S2SV> group_start = group_end + 1 ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! cm -> frame_parallel_decoding_mode ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < num_workers ; ++ i ) { //<S2SV> TileWorkerData * const tile_data = //<S2SV> ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; //<S2SV> vp9_zero ( tile_data -> counts ) ; //<S2SV> } //<S2SV> } //<S2SV> n = 0 ; //<S2SV> while ( n < tile_cols ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { //<S2SV> VPxWorker * const worker = & pbi -> tile_workers [ i ] ; //<S2SV> TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; //<S2SV> TileInfo * const tile = ( TileInfo * ) worker -> data2 ; //<S2SV> TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; //<S2SV> tile_data -> pbi = pbi ; //<S2SV> tile_data -> xd = pbi -> mb ; //<S2SV> tile_data -> xd . corrupted = 0 ; //<S2SV> tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? //<S2SV> 0 : & tile_data -> counts ; //<S2SV> vp9_zero ( tile_data -> dqcoeff ) ; //<S2SV> vp9_tile_init ( tile , cm , 0 , buf -> col ) ; //<S2SV> vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; //<S2SV> setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , //<S2SV> & tile_data -> bit_reader , pbi -> decrypt_cb , //<S2SV> pbi -> decrypt_state ) ; //<S2SV> vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; //<S2SV> worker -> had_error = 0 ; //<S2SV> if ( i == num_workers - 1 || n == tile_cols - 1 ) { //<S2SV> winterface -> execute ( worker ) ; //<S2SV> } else { //<S2SV> winterface -> launch ( worker ) ; //<S2SV> } //<S2SV> if ( buf -> col == tile_cols - 1 ) { //<S2SV> final_worker = i ; //<S2SV> } //<S2SV> ++ n ; //<S2SV> } //<S2SV> for ( ; i > 0 ; -- i ) { //<S2SV> VPxWorker * const worker = & pbi -> tile_workers [ i - 1 ] ; //<S2SV> pbi -> mb . corrupted |= ! winterface -> sync ( worker ) ; //<S2SV> } //<S2SV> if ( final_worker > - 1 ) { //<S2SV> TileWorkerData * const tile_data = //<S2SV> ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ; //<S2SV> bit_reader_end = vpx_reader_find_end ( & tile_data -> bit_reader ) ; //<S2SV> final_worker = - 1 ; //<S2SV> } //<S2SV> if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { //<S2SV> for ( i = 0 ; i < num_workers ; ++ i ) { //<S2SV> TileWorkerData * const tile_data = //<S2SV> ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; //<S2SV> vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return bit_reader_end ; //<S2SV> } //<S2SV> 