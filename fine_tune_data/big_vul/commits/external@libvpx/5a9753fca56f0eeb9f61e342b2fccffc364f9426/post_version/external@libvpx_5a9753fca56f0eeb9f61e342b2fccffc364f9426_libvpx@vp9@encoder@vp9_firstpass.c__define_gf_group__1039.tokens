static void define_gf_group ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> VP9EncoderConfig * const oxcf = & cpi -> oxcf ; //<S2SV> TWO_PASS * const twopass = & cpi -> twopass ; //<S2SV> FIRSTPASS_STATS next_frame ; //<S2SV> const FIRSTPASS_STATS * const start_pos = twopass -> stats_in ; //<S2SV> int i ; //<S2SV> double boost_score = 0.0 ; //<S2SV> double old_boost_score = 0.0 ; //<S2SV> double gf_group_err = 0.0 ; //<S2SV> # if GROUP_ADAPTIVE_MAXQ //<S2SV> double gf_group_raw_error = 0.0 ; //<S2SV> # endif //<S2SV> double gf_group_skip_pct = 0.0 ; //<S2SV> double gf_group_inactive_zone_rows = 0.0 ; //<S2SV> double gf_first_frame_err = 0.0 ; //<S2SV> double mod_frame_err = 0.0 ; //<S2SV> double mv_ratio_accumulator = 0.0 ; //<S2SV> double decay_accumulator = 1.0 ; //<S2SV> double zero_motion_accumulator = 1.0 ; //<S2SV> double loop_decay_rate = 1.00 ; //<S2SV> double last_loop_decay_rate = 1.00 ; //<S2SV> double this_frame_mv_in_out = 0.0 ; //<S2SV> double mv_in_out_accumulator = 0.0 ; //<S2SV> double abs_mv_in_out_accumulator = 0.0 ; //<S2SV> double mv_ratio_accumulator_thresh ; //<S2SV> unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; //<S2SV> int f_boost = 0 ; //<S2SV> int b_boost = 0 ; //<S2SV> int flash_detected ; //<S2SV> int active_max_gf_interval ; //<S2SV> int active_min_gf_interval ; //<S2SV> int64_t gf_group_bits ; //<S2SV> double gf_group_error_left ; //<S2SV> int gf_arf_bits ; //<S2SV> const int is_key_frame = frame_is_intra_only ( cm ) ; //<S2SV> const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; //<S2SV> if ( is_key_frame == 0 ) { //<S2SV> vp9_zero ( twopass -> gf_group ) ; //<S2SV> } //<S2SV> vpx_clear_system_state ( ) ; //<S2SV> vp9_zero ( next_frame ) ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> gf_first_frame_err = mod_frame_err ; //<S2SV> if ( arf_active_or_kf ) { //<S2SV> gf_group_err -= gf_first_frame_err ; //<S2SV> # if GROUP_ADAPTIVE_MAXQ //<S2SV> gf_group_raw_error -= this_frame -> coded_error ; //<S2SV> # endif //<S2SV> gf_group_skip_pct -= this_frame -> intra_skip_pct ; //<S2SV> gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; //<S2SV> } //<S2SV> mv_ratio_accumulator_thresh = //<S2SV> ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; //<S2SV> { //<S2SV> int int_max_q = //<S2SV> ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , //<S2SV> cpi -> common . bit_depth ) ) ; //<S2SV> int int_lbq = //<S2SV> ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , //<S2SV> cpi -> common . bit_depth ) ) ; //<S2SV> active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; //<S2SV> if ( active_min_gf_interval > rc -> max_gf_interval ) //<S2SV> active_min_gf_interval = rc -> max_gf_interval ; //<S2SV> if ( cpi -> multi_arf_allowed ) { //<S2SV> active_max_gf_interval = rc -> max_gf_interval ; //<S2SV> } else { //<S2SV> active_max_gf_interval = 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; //<S2SV> if ( active_max_gf_interval < active_min_gf_interval ) //<S2SV> active_max_gf_interval = active_min_gf_interval ; //<S2SV> if ( active_max_gf_interval > rc -> max_gf_interval ) //<S2SV> active_max_gf_interval = rc -> max_gf_interval ; //<S2SV> if ( active_max_gf_interval < active_min_gf_interval ) //<S2SV> active_max_gf_interval = active_min_gf_interval ; //<S2SV> } //<S2SV> } //<S2SV> i = 0 ; //<S2SV> while ( i < rc -> static_scene_max_gf_interval && i < rc -> frames_to_key ) { //<S2SV> ++ i ; //<S2SV> mod_frame_err = calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> gf_group_err += mod_frame_err ; //<S2SV> # if GROUP_ADAPTIVE_MAXQ //<S2SV> gf_group_raw_error += this_frame -> coded_error ; //<S2SV> # endif //<S2SV> gf_group_skip_pct += this_frame -> intra_skip_pct ; //<S2SV> gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; //<S2SV> if ( EOF == input_stats ( twopass , & next_frame ) ) //<S2SV> break ; //<S2SV> flash_detected = detect_flash ( twopass , 0 ) ; //<S2SV> accumulate_frame_motion_stats ( & next_frame , //<S2SV> & this_frame_mv_in_out , & mv_in_out_accumulator , //<S2SV> & abs_mv_in_out_accumulator , //<S2SV> & mv_ratio_accumulator ) ; //<S2SV> if ( ! flash_detected ) { //<S2SV> last_loop_decay_rate = loop_decay_rate ; //<S2SV> loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; //<S2SV> decay_accumulator = decay_accumulator * loop_decay_rate ; //<S2SV> zero_motion_accumulator = //<S2SV> MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; //<S2SV> if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , //<S2SV> last_loop_decay_rate ) ) { //<S2SV> allow_alt_ref = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> boost_score += decay_accumulator * calc_frame_boost ( cpi , & next_frame , //<S2SV> this_frame_mv_in_out , //<S2SV> GF_MAX_BOOST ) ; //<S2SV> if ( //<S2SV> ( i >= ( active_max_gf_interval + arf_active_or_kf ) && //<S2SV> zero_motion_accumulator < 0.995 ) || //<S2SV> ( //<S2SV> ( i >= active_min_gf_interval + arf_active_or_kf ) && //<S2SV> ( ! flash_detected ) && //<S2SV> ( ( mv_ratio_accumulator > mv_ratio_accumulator_thresh ) || //<S2SV> ( abs_mv_in_out_accumulator > 3.0 ) || //<S2SV> ( mv_in_out_accumulator < - 2.0 ) || //<S2SV> ( ( boost_score - old_boost_score ) < BOOST_BREAKOUT ) ) ) ) { //<S2SV> boost_score = old_boost_score ; //<S2SV> break ; //<S2SV> } //<S2SV> * this_frame = next_frame ; //<S2SV> old_boost_score = boost_score ; //<S2SV> } //<S2SV> twopass -> gf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 1000.0 ) ; //<S2SV> rc -> constrained_gf_group = ( i >= rc -> frames_to_key ) ? 1 : 0 ; //<S2SV> if ( allow_alt_ref && //<S2SV> ( i < cpi -> oxcf . lag_in_frames ) && //<S2SV> ( i >= rc -> min_gf_interval ) ) { //<S2SV> rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , //<S2SV> & b_boost ) ; //<S2SV> rc -> source_alt_ref_pending = 1 ; //<S2SV> cpi -> multi_arf_enabled = //<S2SV> ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && //<S2SV> ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; //<S2SV> } else { //<S2SV> rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; //<S2SV> rc -> source_alt_ref_pending = 0 ; //<S2SV> } //<S2SV> rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; //<S2SV> if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { //<S2SV> int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; //<S2SV> int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; //<S2SV> int j ; //<S2SV> for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { //<S2SV> if ( EOF == input_stats ( twopass , this_frame ) ) //<S2SV> break ; //<S2SV> gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; //<S2SV> # if GROUP_ADAPTIVE_MAXQ //<S2SV> gf_group_raw_error += this_frame -> coded_error ; //<S2SV> # endif //<S2SV> gf_group_skip_pct += this_frame -> intra_skip_pct ; //<S2SV> gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; //<S2SV> } //<S2SV> rc -> baseline_gf_interval = new_gf_interval ; //<S2SV> } //<S2SV> rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; //<S2SV> # if GROUP_ADAPTIVE_MAXQ //<S2SV> if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( rc -> baseline_gf_interval > 1 ) ) { //<S2SV> const int vbr_group_bits_per_frame = //<S2SV> ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; //<S2SV> const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; //<S2SV> const double group_av_skip_pct = //<S2SV> gf_group_skip_pct / rc -> baseline_gf_interval ; //<S2SV> const double group_av_inactive_zone = //<S2SV> ( ( gf_group_inactive_zone_rows * 2 ) / //<S2SV> ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; //<S2SV> int tmp_q ; //<S2SV> double rc_factor = 1.0 ; //<S2SV> if ( rc -> rate_error_estimate > 0 ) { //<S2SV> rc_factor = MAX ( RC_FACTOR_MIN , //<S2SV> ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; //<S2SV> } else { //<S2SV> rc_factor = MIN ( RC_FACTOR_MAX , //<S2SV> ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; //<S2SV> } //<S2SV> tmp_q = //<S2SV> get_twopass_worst_quality ( cpi , group_av_err , //<S2SV> ( group_av_skip_pct + group_av_inactive_zone ) , //<S2SV> vbr_group_bits_per_frame , //<S2SV> twopass -> kfgroup_inter_fraction * rc_factor ) ; //<S2SV> twopass -> active_worst_quality = //<S2SV> MAX ( tmp_q , twopass -> active_worst_quality >> 1 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , //<S2SV> rc -> gfu_boost , gf_group_bits ) ; //<S2SV> twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; //<S2SV> if ( rc -> source_alt_ref_pending ) { //<S2SV> gf_group_error_left = gf_group_err - mod_frame_err ; //<S2SV> } else if ( is_key_frame == 0 ) { //<S2SV> gf_group_error_left = gf_group_err - gf_first_frame_err ; //<S2SV> } else { //<S2SV> gf_group_error_left = gf_group_err ; //<S2SV> } //<S2SV> allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; //<S2SV> reset_fpf_position ( twopass , start_pos ) ; //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME ) { //<S2SV> twopass -> section_intra_rating = //<S2SV> calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , //<S2SV> rc -> baseline_gf_interval ) ; //<S2SV> } //<S2SV> if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { //<S2SV> cpi -> rc . next_frame_size_selector = UNSCALED ; //<S2SV> } //<S2SV> } //<S2SV> 