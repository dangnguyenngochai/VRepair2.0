void vp8_build_intra_predictors_mbuv_s_c ( MACROBLOCKD * x , //<S2SV> unsigned char * uabove_row , //<S2SV> unsigned char * vabove_row , //<S2SV> unsigned char * uleft , //<S2SV> unsigned char * vleft , //<S2SV> int left_stride , //<S2SV> unsigned char * upred_ptr , //<S2SV> unsigned char * vpred_ptr , //<S2SV> int pred_stride ) //<S2SV> { //<S2SV> unsigned char uleft_col [ 8 ] ; //<S2SV> unsigned char utop_left = uabove_row [ - 1 ] ; //<S2SV> unsigned char vleft_col [ 8 ] ; //<S2SV> unsigned char vtop_left = vabove_row [ - 1 ] ; //<S2SV> int i , j ; //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> uleft_col [ i ] = uleft [ i * left_stride ] ; //<S2SV> vleft_col [ i ] = vleft [ i * left_stride ] ; //<S2SV> } //<S2SV> switch ( x -> mode_info_context -> mbmi . uv_mode ) //<S2SV> { //<S2SV> case DC_PRED : //<S2SV> { //<S2SV> int expected_udc ; //<S2SV> int expected_vdc ; //<S2SV> int shift ; //<S2SV> int Uaverage = 0 ; //<S2SV> int Vaverage = 0 ; //<S2SV> if ( x -> up_available ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> Uaverage += uabove_row [ i ] ; //<S2SV> Vaverage += vabove_row [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( x -> left_available ) //<S2SV> { //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> Uaverage += uleft_col [ i ] ; //<S2SV> Vaverage += vleft_col [ i ] ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! x -> up_available && ! x -> left_available ) //<S2SV> { //<S2SV> expected_udc = 128 ; //<S2SV> expected_vdc = 128 ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> shift = 2 + x -> up_available + x -> left_available ; //<S2SV> expected_udc = ( Uaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; //<S2SV> expected_vdc = ( Vaverage + ( 1 << ( shift - 1 ) ) ) >> shift ; //<S2SV> } //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> memset ( upred_ptr , expected_udc , 8 ) ; //<S2SV> memset ( vpred_ptr , expected_vdc , 8 ) ; //<S2SV> upred_ptr += pred_stride ; //<S2SV> vpred_ptr += pred_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case V_PRED : //<S2SV> { //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> memcpy ( upred_ptr , uabove_row , 8 ) ; //<S2SV> memcpy ( vpred_ptr , vabove_row , 8 ) ; //<S2SV> upred_ptr += pred_stride ; //<S2SV> vpred_ptr += pred_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case H_PRED : //<S2SV> { //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> memset ( upred_ptr , uleft_col [ i ] , 8 ) ; //<S2SV> memset ( vpred_ptr , vleft_col [ i ] , 8 ) ; //<S2SV> upred_ptr += pred_stride ; //<S2SV> vpred_ptr += pred_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case TM_PRED : //<S2SV> { //<S2SV> for ( i = 0 ; i < 8 ; i ++ ) //<S2SV> { //<S2SV> for ( j = 0 ; j < 8 ; j ++ ) //<S2SV> { //<S2SV> int predu = uleft_col [ i ] + uabove_row [ j ] - utop_left ; //<S2SV> int predv = vleft_col [ i ] + vabove_row [ j ] - vtop_left ; //<S2SV> if ( predu < 0 ) //<S2SV> predu = 0 ; //<S2SV> if ( predu > 255 ) //<S2SV> predu = 255 ; //<S2SV> if ( predv < 0 ) //<S2SV> predv = 0 ; //<S2SV> if ( predv > 255 ) //<S2SV> predv = 255 ; //<S2SV> upred_ptr [ j ] = predu ; //<S2SV> vpred_ptr [ j ] = predv ; //<S2SV> } //<S2SV> upred_ptr += pred_stride ; //<S2SV> vpred_ptr += pred_stride ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> case B_PRED : //<S2SV> case NEARESTMV : //<S2SV> case NEARMV : //<S2SV> case ZEROMV : //<S2SV> case NEWMV : //<S2SV> case SPLITMV : //<S2SV> case MB_MODE_COUNT : //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> 