int main ( int argc , const char * * argv_ ) { //<S2SV> int pass ; //<S2SV> vpx_image_t raw ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> vpx_image_t raw_shift ; //<S2SV> int allocated_raw_shift = 0 ; //<S2SV> int use_16bit_internal = 0 ; //<S2SV> int input_shift = 0 ; //<S2SV> # endif //<S2SV> int frame_avail , got_data ; //<S2SV> struct VpxInputContext input ; //<S2SV> struct VpxEncoderConfig global ; //<S2SV> struct stream_state * streams = NULL ; //<S2SV> char * * argv , * * argi ; //<S2SV> uint64_t cx_time = 0 ; //<S2SV> int stream_cnt = 0 ; //<S2SV> int res = 0 ; //<S2SV> memset ( & input , 0 , sizeof ( input ) ) ; //<S2SV> exec_name = argv_ [ 0 ] ; //<S2SV> if ( argc < 3 ) //<S2SV> usage_exit ( ) ; //<S2SV> input . framerate . numerator = 30 ; //<S2SV> input . framerate . denominator = 1 ; //<S2SV> input . only_i420 = 1 ; //<S2SV> input . bit_depth = 0 ; //<S2SV> argv = argv_dup ( argc - 1 , argv_ + 1 ) ; //<S2SV> parse_global_config ( & global , argv ) ; //<S2SV> switch ( global . color_type ) { //<S2SV> case I420 : //<S2SV> input . fmt = VPX_IMG_FMT_I420 ; //<S2SV> break ; //<S2SV> case I422 : //<S2SV> input . fmt = VPX_IMG_FMT_I422 ; //<S2SV> break ; //<S2SV> case I444 : //<S2SV> input . fmt = VPX_IMG_FMT_I444 ; //<S2SV> break ; //<S2SV> case I440 : //<S2SV> input . fmt = VPX_IMG_FMT_I440 ; //<S2SV> break ; //<S2SV> case YV12 : //<S2SV> input . fmt = VPX_IMG_FMT_YV12 ; //<S2SV> break ; //<S2SV> } //<S2SV> { //<S2SV> struct stream_state * stream = NULL ; //<S2SV> do { //<S2SV> stream = new_stream ( & global , stream ) ; //<S2SV> stream_cnt ++ ; //<S2SV> if ( ! streams ) //<S2SV> streams = stream ; //<S2SV> } while ( parse_stream_params ( & global , stream , argv ) ) ; //<S2SV> } //<S2SV> for ( argi = argv ; * argi ; argi ++ ) //<S2SV> if ( argi [ 0 ] [ 0 ] == '-' && argi [ 0 ] [ 1 ] ) //<S2SV> die ( "Error:<S2SV_blank>Unrecognized<S2SV_blank>option<S2SV_blank>%s\\n" , * argi ) ; //<S2SV> FOREACH_STREAM ( check_encoder_config ( global . disable_warning_prompt , //<S2SV> & global , & stream -> config . cfg ) ; ) ; //<S2SV> input . filename = argv [ 0 ] ; //<S2SV> if ( ! input . filename ) //<S2SV> usage_exit ( ) ; //<S2SV> if ( global . codec -> fourcc == VP9_FOURCC ) //<S2SV> input . only_i420 = 0 ; //<S2SV> for ( pass = global . pass ? global . pass - 1 : 0 ; pass < global . passes ; pass ++ ) { //<S2SV> int frames_in = 0 , seen_frames = 0 ; //<S2SV> int64_t estimated_time_left = - 1 ; //<S2SV> int64_t average_rate = - 1 ; //<S2SV> int64_t lagged_count = 0 ; //<S2SV> open_input_file ( & input ) ; //<S2SV> if ( ! input . width || ! input . height ) { //<S2SV> FOREACH_STREAM ( { //<S2SV> if ( stream -> config . cfg . g_w && stream -> config . cfg . g_h ) { //<S2SV> input . width = stream -> config . cfg . g_w ; //<S2SV> input . height = stream -> config . cfg . g_h ; //<S2SV> break ; //<S2SV> } //<S2SV> } ) ; //<S2SV> } //<S2SV> if ( ! input . width || ! input . height ) //<S2SV> fatal ( "Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>" //<S2SV> "<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)" ) ; //<S2SV> if ( ! input . bit_depth ) { //<S2SV> FOREACH_STREAM ( { //<S2SV> if ( stream -> config . cfg . g_input_bit_depth ) //<S2SV> input . bit_depth = stream -> config . cfg . g_input_bit_depth ; //<S2SV> else //<S2SV> input . bit_depth = stream -> config . cfg . g_input_bit_depth = //<S2SV> ( int ) stream -> config . cfg . g_bit_depth ; //<S2SV> } ) ; //<S2SV> if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; //<S2SV> } else { //<S2SV> FOREACH_STREAM ( { //<S2SV> stream -> config . cfg . g_input_bit_depth = input . bit_depth ; //<S2SV> } ) ; //<S2SV> } //<S2SV> FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ; //<S2SV> FOREACH_STREAM ( validate_stream_config ( stream , & global ) ) ; //<S2SV> if ( global . pass && global . passes == 2 ) //<S2SV> FOREACH_STREAM ( { //<S2SV> if ( ! stream -> config . stats_fn ) //<S2SV> die ( "Stream<S2SV_blank>%d:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>--fpf<S2SV_blank>when<S2SV_blank>--pass=%d" //<S2SV> "<S2SV_blank>and<S2SV_blank>--passes=2\\n" , stream -> index , global . pass ) ; //<S2SV> } ) ; //<S2SV> # if ! CONFIG_WEBM_IO //<S2SV> FOREACH_STREAM ( { //<S2SV> stream -> config . write_webm = 0 ; //<S2SV> warn ( "vpxenc<S2SV_blank>was<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>WebM<S2SV_blank>container<S2SV_blank>support." //<S2SV> "Producing<S2SV_blank>IVF<S2SV_blank>output" ) ; //<S2SV> } ) ; //<S2SV> # endif //<S2SV> if ( ! global . have_framerate ) { //<S2SV> global . framerate . num = input . framerate . numerator ; //<S2SV> global . framerate . den = input . framerate . denominator ; //<S2SV> } //<S2SV> FOREACH_STREAM ( set_default_kf_interval ( stream , & global ) ) ; //<S2SV> if ( global . verbose && pass == 0 ) //<S2SV> FOREACH_STREAM ( show_stream_config ( stream , & global , & input ) ) ; //<S2SV> if ( pass == ( global . pass ? global . pass - 1 : 0 ) ) { //<S2SV> if ( input . file_type == FILE_TYPE_Y4M ) //<S2SV> memset ( & raw , 0 , sizeof ( raw ) ) ; //<S2SV> else //<S2SV> vpx_img_alloc ( & raw , input . fmt , input . width , input . height , 32 ) ; //<S2SV> FOREACH_STREAM ( stream -> rate_hist = //<S2SV> init_rate_histogram ( & stream -> config . cfg , //<S2SV> & global . framerate ) ) ; //<S2SV> } //<S2SV> FOREACH_STREAM ( setup_pass ( stream , & global , pass ) ) ; //<S2SV> FOREACH_STREAM ( open_output_file ( stream , & global , //<S2SV> & input . pixel_aspect_ratio ) ) ; //<S2SV> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( strcmp ( global . codec -> name , "vp9" ) == 0 || //<S2SV> strcmp ( global . codec -> name , "vp10" ) == 0 ) { //<S2SV> FOREACH_STREAM ( { //<S2SV> if ( stream -> config . use_16bit_internal ) { //<S2SV> use_16bit_internal = 1 ; //<S2SV> } //<S2SV> if ( stream -> config . cfg . g_profile == 0 ) { //<S2SV> input_shift = 0 ; //<S2SV> } else { //<S2SV> input_shift = ( int ) stream -> config . cfg . g_bit_depth - //<S2SV> stream -> config . cfg . g_input_bit_depth ; //<S2SV> } //<S2SV> } ) ; //<S2SV> } //<S2SV> # endif //<S2SV> frame_avail = 1 ; //<S2SV> got_data = 0 ; //<S2SV> while ( frame_avail || got_data ) { //<S2SV> struct vpx_usec_timer timer ; //<S2SV> if ( ! global . limit || frames_in < global . limit ) { //<S2SV> frame_avail = read_frame ( & input , & raw ) ; //<S2SV> if ( frame_avail ) //<S2SV> frames_in ++ ; //<S2SV> seen_frames = frames_in > global . skip_frames ? //<S2SV> frames_in - global . skip_frames : 0 ; //<S2SV> if ( ! global . quiet ) { //<S2SV> float fps = usec_to_fps ( cx_time , seen_frames ) ; //<S2SV> fprintf ( stderr , "\\rPass<S2SV_blank>%d/%d<S2SV_blank>" , pass + 1 , global . passes ) ; //<S2SV> if ( stream_cnt == 1 ) //<S2SV> fprintf ( stderr , //<S2SV> "frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7" PRId64 "B<S2SV_blank>" , //<S2SV> frames_in , streams -> frames_out , ( int64_t ) streams -> nbytes ) ; //<S2SV> else //<S2SV> fprintf ( stderr , "frame<S2SV_blank>%4d<S2SV_blank>" , frames_in ) ; //<S2SV> fprintf ( stderr , "%7" PRId64 "<S2SV_blank>%s<S2SV_blank>%.2f<S2SV_blank>%s<S2SV_blank>" , //<S2SV> cx_time > 9999999 ? cx_time / 1000 : cx_time , //<S2SV> cx_time > 9999999 ? "ms" : "us" , //<S2SV> fps >= 1.0 ? fps : fps * 60 , //<S2SV> fps >= 1.0 ? "fps" : "fpm" ) ; //<S2SV> print_time ( "ETA" , estimated_time_left ) ; //<S2SV> } //<S2SV> } else //<S2SV> frame_avail = 0 ; //<S2SV> if ( frames_in > global . skip_frames ) { //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> vpx_image_t * frame_to_encode ; //<S2SV> if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { //<S2SV> assert ( use_16bit_internal ) ; //<S2SV> if ( ! allocated_raw_shift ) { //<S2SV> vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , //<S2SV> input . width , input . height , 32 ) ; //<S2SV> allocated_raw_shift = 1 ; //<S2SV> } //<S2SV> vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; //<S2SV> frame_to_encode = & raw_shift ; //<S2SV> } else { //<S2SV> frame_to_encode = & raw ; //<S2SV> } //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> if ( use_16bit_internal ) { //<S2SV> assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; //<S2SV> FOREACH_STREAM ( { //<S2SV> if ( stream -> config . use_16bit_internal ) //<S2SV> encode_frame ( stream , & global , //<S2SV> frame_avail ? frame_to_encode : NULL , //<S2SV> frames_in ) ; //<S2SV> else //<S2SV> assert ( 0 ) ; //<S2SV> } ) ; //<S2SV> } else { //<S2SV> assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; //<S2SV> FOREACH_STREAM ( encode_frame ( stream , & global , //<S2SV> frame_avail ? frame_to_encode : NULL , //<S2SV> frames_in ) ) ; //<S2SV> } //<S2SV> # else //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> FOREACH_STREAM ( encode_frame ( stream , & global , //<S2SV> frame_avail ? & raw : NULL , //<S2SV> frames_in ) ) ; //<S2SV> # endif //<S2SV> vpx_usec_timer_mark ( & timer ) ; //<S2SV> cx_time += vpx_usec_timer_elapsed ( & timer ) ; //<S2SV> FOREACH_STREAM ( update_quantizer_histogram ( stream ) ) ; //<S2SV> got_data = 0 ; //<S2SV> FOREACH_STREAM ( get_cx_data ( stream , & global , & got_data ) ) ; //<S2SV> if ( ! got_data && input . length && streams != NULL && //<S2SV> ! streams -> frames_out ) { //<S2SV> lagged_count = global . limit ? seen_frames : ftello ( input . file ) ; //<S2SV> } else if ( input . length ) { //<S2SV> int64_t remaining ; //<S2SV> int64_t rate ; //<S2SV> if ( global . limit ) { //<S2SV> const int64_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; //<S2SV> rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ; //<S2SV> remaining = 1000 * ( global . limit - global . skip_frames //<S2SV> - seen_frames + lagged_count ) ; //<S2SV> } else { //<S2SV> const int64_t input_pos = ftello ( input . file ) ; //<S2SV> const int64_t input_pos_lagged = input_pos - lagged_count ; //<S2SV> const int64_t limit = input . length ; //<S2SV> rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ; //<S2SV> remaining = limit - input_pos + lagged_count ; //<S2SV> } //<S2SV> average_rate = ( average_rate <= 0 ) //<S2SV> ? rate //<S2SV> : ( average_rate * 7 + rate ) / 8 ; //<S2SV> estimated_time_left = average_rate ? remaining / average_rate : - 1 ; //<S2SV> } //<S2SV> if ( got_data && global . test_decode != TEST_DECODE_OFF ) //<S2SV> FOREACH_STREAM ( test_decode ( stream , global . test_decode , global . codec ) ) ; //<S2SV> } //<S2SV> fflush ( stdout ) ; //<S2SV> if ( ! global . quiet ) //<S2SV> fprintf ( stderr , "\\033[K" ) ; //<S2SV> } //<S2SV> if ( stream_cnt > 1 ) //<S2SV> fprintf ( stderr , "\\n" ) ; //<S2SV> if ( ! global . quiet ) { //<S2SV> FOREACH_STREAM ( fprintf ( stderr , //<S2SV> "\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7" PRId64 "B<S2SV_blank>%7" PRId64 "b/f<S2SV_blank>%7" PRId64 "b/s" //<S2SV> "<S2SV_blank>%7" PRId64 "<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\033[K\\n" , //<S2SV> pass + 1 , //<S2SV> global . passes , frames_in , stream -> frames_out , ( int64_t ) stream -> nbytes , //<S2SV> seen_frames ? ( int64_t ) ( stream -> nbytes * 8 / seen_frames ) : 0 , //<S2SV> seen_frames ? ( int64_t ) stream -> nbytes * 8 * //<S2SV> ( int64_t ) global . framerate . num / global . framerate . den / //<S2SV> seen_frames : 0 , //<S2SV> stream -> cx_time > 9999999 ? stream -> cx_time / 1000 : stream -> cx_time , //<S2SV> stream -> cx_time > 9999999 ? "ms" : "us" , //<S2SV> usec_to_fps ( stream -> cx_time , seen_frames ) ) ) ; //<S2SV> } //<S2SV> if ( global . show_psnr ) { //<S2SV> if ( global . codec -> fourcc == VP9_FOURCC ) { //<S2SV> FOREACH_STREAM ( //<S2SV> show_psnr ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; //<S2SV> } else { //<S2SV> FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; //<S2SV> } //<S2SV> } //<S2SV> FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ; //<S2SV> if ( global . test_decode != TEST_DECODE_OFF ) { //<S2SV> FOREACH_STREAM ( vpx_codec_destroy ( & stream -> decoder ) ) ; //<S2SV> } //<S2SV> close_input_file ( & input ) ; //<S2SV> if ( global . test_decode == TEST_DECODE_FATAL ) { //<S2SV> FOREACH_STREAM ( res |= stream -> mismatch_seen ) ; //<S2SV> } //<S2SV> FOREACH_STREAM ( close_output_file ( stream , global . codec -> fourcc ) ) ; //<S2SV> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; //<S2SV> # endif //<S2SV> if ( global . pass ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( global . show_q_hist_buckets ) //<S2SV> FOREACH_STREAM ( show_q_histogram ( stream -> counts , //<S2SV> global . show_q_hist_buckets ) ) ; //<S2SV> if ( global . show_rate_hist_buckets ) //<S2SV> FOREACH_STREAM ( show_rate_histogram ( stream -> rate_hist , //<S2SV> & stream -> config . cfg , //<S2SV> global . show_rate_hist_buckets ) ) ; //<S2SV> FOREACH_STREAM ( destroy_rate_histogram ( stream -> rate_hist ) ) ; //<S2SV> # if CONFIG_INTERNAL_STATS //<S2SV> if ( ! ( global . pass == 1 && global . passes == 2 ) ) //<S2SV> FOREACH_STREAM ( { //<S2SV> FILE * f = fopen ( "opsnr.stt" , "a" ) ; //<S2SV> if ( stream -> mismatch_seen ) { //<S2SV> fprintf ( f , "First<S2SV_blank>mismatch<S2SV_blank>occurred<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>%d\\n" , //<S2SV> stream -> mismatch_seen ) ; //<S2SV> } else { //<S2SV> fprintf ( f , "No<S2SV_blank>mismatch<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>recon<S2SV_blank>buffers\\n" ) ; //<S2SV> } //<S2SV> fclose ( f ) ; //<S2SV> } ) ; //<S2SV> # endif //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( allocated_raw_shift ) //<S2SV> vpx_img_free ( & raw_shift ) ; //<S2SV> # endif //<S2SV> vpx_img_free ( & raw ) ; //<S2SV> free ( argv ) ; //<S2SV> free ( streams ) ; //<S2SV> return res ? EXIT_FAILURE : EXIT_SUCCESS ; //<S2SV> } //<S2SV> 