static int parse_stream_params ( struct VpxEncoderConfig * global , //<S2SV> struct stream_state * stream , //<S2SV> char * * argv ) { //<S2SV> char * * argi , * * argj ; //<S2SV> struct arg arg ; //<S2SV> static const arg_def_t * * ctrl_args = no_args ; //<S2SV> static const int * ctrl_args_map = NULL ; //<S2SV> struct stream_config * config = & stream -> config ; //<S2SV> int eos_mark_found = 0 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> int test_16bit_internal = 0 ; //<S2SV> # endif //<S2SV> if ( 0 ) { //<S2SV> # if CONFIG_VP8_ENCODER //<S2SV> } else if ( strcmp ( global -> codec -> name , "vp8" ) == 0 ) { //<S2SV> ctrl_args = vp8_args ; //<S2SV> ctrl_args_map = vp8_arg_ctrl_map ; //<S2SV> # endif //<S2SV> # if CONFIG_VP9_ENCODER //<S2SV> } else if ( strcmp ( global -> codec -> name , "vp9" ) == 0 ) { //<S2SV> ctrl_args = vp9_args ; //<S2SV> ctrl_args_map = vp9_arg_ctrl_map ; //<S2SV> # endif //<S2SV> # if CONFIG_VP10_ENCODER //<S2SV> } else if ( strcmp ( global -> codec -> name , "vp10" ) == 0 ) { //<S2SV> ctrl_args = vp10_args ; //<S2SV> ctrl_args_map = vp10_arg_ctrl_map ; //<S2SV> # endif //<S2SV> } //<S2SV> for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { //<S2SV> arg . argv_step = 1 ; //<S2SV> if ( eos_mark_found ) { //<S2SV> argj ++ ; //<S2SV> continue ; //<S2SV> } else if ( ! strcmp ( * argj , "--" ) ) { //<S2SV> eos_mark_found = 1 ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( arg_match ( & arg , & outputfile , argi ) ) { //<S2SV> config -> out_fn = arg . val ; //<S2SV> } else if ( arg_match ( & arg , & fpf_name , argi ) ) { //<S2SV> config -> stats_fn = arg . val ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { //<S2SV> config -> fpmb_stats_fn = arg . val ; //<S2SV> # endif //<S2SV> } else if ( arg_match ( & arg , & use_webm , argi ) ) { //<S2SV> # if CONFIG_WEBM_IO //<S2SV> config -> write_webm = 1 ; //<S2SV> # else //<S2SV> die ( "Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled." ) ; //<S2SV> # endif //<S2SV> } else if ( arg_match ( & arg , & use_ivf , argi ) ) { //<S2SV> config -> write_webm = 0 ; //<S2SV> } else if ( arg_match ( & arg , & threads , argi ) ) { //<S2SV> config -> cfg . g_threads = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & profile , argi ) ) { //<S2SV> config -> cfg . g_profile = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & width , argi ) ) { //<S2SV> config -> cfg . g_w = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & height , argi ) ) { //<S2SV> config -> cfg . g_h = arg_parse_uint ( & arg ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { //<S2SV> config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { //<S2SV> config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; //<S2SV> # endif //<S2SV> # if CONFIG_WEBM_IO //<S2SV> } else if ( arg_match ( & arg , & stereo_mode , argi ) ) { //<S2SV> config -> stereo_fmt = arg_parse_enum_or_int ( & arg ) ; //<S2SV> # endif //<S2SV> } else if ( arg_match ( & arg , & timebase , argi ) ) { //<S2SV> config -> cfg . g_timebase = arg_parse_rational ( & arg ) ; //<S2SV> validate_positive_rational ( arg . name , & config -> cfg . g_timebase ) ; //<S2SV> } else if ( arg_match ( & arg , & error_resilient , argi ) ) { //<S2SV> config -> cfg . g_error_resilient = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & lag_in_frames , argi ) ) { //<S2SV> config -> cfg . g_lag_in_frames = arg_parse_uint ( & arg ) ; //<S2SV> if ( global -> deadline == VPX_DL_REALTIME && //<S2SV> config -> cfg . g_lag_in_frames != 0 ) { //<S2SV> warn ( "non-zero<S2SV_blank>%s<S2SV_blank>option<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>realtime<S2SV_blank>mode.\\n" , arg . name ) ; //<S2SV> config -> cfg . g_lag_in_frames = 0 ; //<S2SV> } //<S2SV> } else if ( arg_match ( & arg , & dropframe_thresh , argi ) ) { //<S2SV> config -> cfg . rc_dropframe_thresh = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & resize_allowed , argi ) ) { //<S2SV> config -> cfg . rc_resize_allowed = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & resize_width , argi ) ) { //<S2SV> config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & resize_height , argi ) ) { //<S2SV> config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & resize_up_thresh , argi ) ) { //<S2SV> config -> cfg . rc_resize_up_thresh = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & resize_down_thresh , argi ) ) { //<S2SV> config -> cfg . rc_resize_down_thresh = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & end_usage , argi ) ) { //<S2SV> config -> cfg . rc_end_usage = arg_parse_enum_or_int ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & target_bitrate , argi ) ) { //<S2SV> config -> cfg . rc_target_bitrate = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & min_quantizer , argi ) ) { //<S2SV> config -> cfg . rc_min_quantizer = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & max_quantizer , argi ) ) { //<S2SV> config -> cfg . rc_max_quantizer = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & undershoot_pct , argi ) ) { //<S2SV> config -> cfg . rc_undershoot_pct = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & overshoot_pct , argi ) ) { //<S2SV> config -> cfg . rc_overshoot_pct = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & buf_sz , argi ) ) { //<S2SV> config -> cfg . rc_buf_sz = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & buf_initial_sz , argi ) ) { //<S2SV> config -> cfg . rc_buf_initial_sz = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & buf_optimal_sz , argi ) ) { //<S2SV> config -> cfg . rc_buf_optimal_sz = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & bias_pct , argi ) ) { //<S2SV> config -> cfg . rc_2pass_vbr_bias_pct = arg_parse_uint ( & arg ) ; //<S2SV> if ( global -> passes < 2 ) //<S2SV> warn ( "option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n" , arg . name ) ; //<S2SV> } else if ( arg_match ( & arg , & minsection_pct , argi ) ) { //<S2SV> config -> cfg . rc_2pass_vbr_minsection_pct = arg_parse_uint ( & arg ) ; //<S2SV> if ( global -> passes < 2 ) //<S2SV> warn ( "option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n" , arg . name ) ; //<S2SV> } else if ( arg_match ( & arg , & maxsection_pct , argi ) ) { //<S2SV> config -> cfg . rc_2pass_vbr_maxsection_pct = arg_parse_uint ( & arg ) ; //<S2SV> if ( global -> passes < 2 ) //<S2SV> warn ( "option<S2SV_blank>%s<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>one-pass<S2SV_blank>mode.\\n" , arg . name ) ; //<S2SV> } else if ( arg_match ( & arg , & kf_min_dist , argi ) ) { //<S2SV> config -> cfg . kf_min_dist = arg_parse_uint ( & arg ) ; //<S2SV> } else if ( arg_match ( & arg , & kf_max_dist , argi ) ) { //<S2SV> config -> cfg . kf_max_dist = arg_parse_uint ( & arg ) ; //<S2SV> config -> have_kf_max_dist = 1 ; //<S2SV> } else if ( arg_match ( & arg , & kf_disabled , argi ) ) { //<S2SV> config -> cfg . kf_mode = VPX_KF_DISABLED ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { //<S2SV> if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || //<S2SV> strcmp ( global -> codec -> name , "vp10" ) == 0 ) { //<S2SV> test_16bit_internal = 1 ; //<S2SV> } //<S2SV> # endif //<S2SV> } else { //<S2SV> int i , match = 0 ; //<S2SV> for ( i = 0 ; ctrl_args [ i ] ; i ++ ) { //<S2SV> if ( arg_match ( & arg , ctrl_args [ i ] , argi ) ) { //<S2SV> int j ; //<S2SV> match = 1 ; //<S2SV> for ( j = 0 ; j < config -> arg_ctrl_cnt ; j ++ ) //<S2SV> if ( ctrl_args_map != NULL && //<S2SV> config -> arg_ctrls [ j ] [ 0 ] == ctrl_args_map [ i ] ) //<S2SV> break ; //<S2SV> assert ( j < ( int ) ARG_CTRL_CNT_MAX ) ; //<S2SV> if ( ctrl_args_map != NULL && j < ( int ) ARG_CTRL_CNT_MAX ) { //<S2SV> config -> arg_ctrls [ j ] [ 0 ] = ctrl_args_map [ i ] ; //<S2SV> config -> arg_ctrls [ j ] [ 1 ] = arg_parse_enum_or_int ( & arg ) ; //<S2SV> if ( j == config -> arg_ctrl_cnt ) //<S2SV> config -> arg_ctrl_cnt ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! match ) //<S2SV> argj ++ ; //<S2SV> } //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || //<S2SV> strcmp ( global -> codec -> name , "vp10" ) == 0 ) { //<S2SV> config -> use_16bit_internal = test_16bit_internal | //<S2SV> ( config -> cfg . g_profile > 1 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> return eos_mark_found ; //<S2SV> } //<S2SV> 