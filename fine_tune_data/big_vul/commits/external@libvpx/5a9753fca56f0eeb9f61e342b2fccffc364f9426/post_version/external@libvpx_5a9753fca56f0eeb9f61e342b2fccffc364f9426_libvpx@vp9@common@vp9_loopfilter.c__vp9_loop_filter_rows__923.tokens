void vp9_loop_filter_rows ( YV12_BUFFER_CONFIG * frame_buffer , //<S2SV> VP9_COMMON * cm , //<S2SV> struct macroblockd_plane planes [ MAX_MB_PLANE ] , //<S2SV> int start , int stop , int y_only ) { //<S2SV> const int num_planes = y_only ? 1 : MAX_MB_PLANE ; //<S2SV> enum lf_path path ; //<S2SV> LOOP_FILTER_MASK lfm ; //<S2SV> int mi_row , mi_col ; //<S2SV> if ( y_only ) //<S2SV> path = LF_PATH_444 ; //<S2SV> else if ( planes [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) //<S2SV> path = LF_PATH_420 ; //<S2SV> else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) //<S2SV> path = LF_PATH_444 ; //<S2SV> else //<S2SV> path = LF_PATH_SLOW ; //<S2SV> for ( mi_row = start ; mi_row < stop ; mi_row += MI_BLOCK_SIZE ) { //<S2SV> MODE_INFO * * mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ; //<S2SV> for ( mi_col = 0 ; mi_col < cm -> mi_cols ; mi_col += MI_BLOCK_SIZE ) { //<S2SV> int plane ; //<S2SV> vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ; //<S2SV> vp9_setup_mask ( cm , mi_row , mi_col , mi + mi_col , cm -> mi_stride , //<S2SV> & lfm ) ; //<S2SV> vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ; //<S2SV> for ( plane = 1 ; plane < num_planes ; ++ plane ) { //<S2SV> switch ( path ) { //<S2SV> case LF_PATH_420 : //<S2SV> vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ; //<S2SV> break ; //<S2SV> case LF_PATH_444 : //<S2SV> vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ; //<S2SV> break ; //<S2SV> case LF_PATH_SLOW : //<S2SV> vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , //<S2SV> mi_row , mi_col ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 