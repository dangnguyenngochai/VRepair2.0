static void encode_frame_internal ( VP9_COMP * cpi ) { //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> ThreadData * const td = & cpi -> td ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> RD_COUNTS * const rdc = & cpi -> td . rd_counts ; //<S2SV> xd -> mi = cm -> mi_grid_visible ; //<S2SV> xd -> mi [ 0 ] = cm -> mi ; //<S2SV> vp9_zero ( * td -> counts ) ; //<S2SV> vp9_zero ( rdc -> coef_counts ) ; //<S2SV> vp9_zero ( rdc -> comp_pred_diff ) ; //<S2SV> vp9_zero ( rdc -> filter_diff ) ; //<S2SV> xd -> lossless = cm -> base_qindex == 0 && //<S2SV> cm -> y_dc_delta_q == 0 && //<S2SV> cm -> uv_dc_delta_q == 0 && //<S2SV> cm -> uv_ac_delta_q == 0 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( cm -> use_highbitdepth ) //<S2SV> x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; //<S2SV> else //<S2SV> x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; //<S2SV> x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : //<S2SV> vp9_highbd_idct4x4_add ; //<S2SV> # else //<S2SV> x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; //<S2SV> # endif //<S2SV> x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; //<S2SV> if ( xd -> lossless ) //<S2SV> x -> optimize = 0 ; //<S2SV> cm -> tx_mode = select_tx_mode ( cpi , xd ) ; //<S2SV> vp9_frame_init_quantizer ( cpi ) ; //<S2SV> vp9_initialize_rd_consts ( cpi ) ; //<S2SV> vp9_initialize_me_consts ( cpi , x , cm -> base_qindex ) ; //<S2SV> init_encode_frame_mb_context ( cpi ) ; //<S2SV> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && //<S2SV> cm -> width == cm -> last_width && //<S2SV> cm -> height == cm -> last_height && //<S2SV> ! cm -> intra_only && //<S2SV> cm -> last_show_frame ; //<S2SV> cm -> prev_mi = cm -> use_prev_frame_mvs ? //<S2SV> cm -> prev_mip + cm -> mi_stride + 1 : NULL ; //<S2SV> x -> quant_fp = cpi -> sf . use_quant_fp ; //<S2SV> vp9_zero ( x -> skip_txfm ) ; //<S2SV> if ( sf -> use_nonrd_pick_mode ) { //<S2SV> int i ; //<S2SV> struct macroblock_plane * const p = x -> plane ; //<S2SV> struct macroblockd_plane * const pd = xd -> plane ; //<S2SV> PICK_MODE_CONTEXT * ctx = & cpi -> td . pc_root -> none ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { //<S2SV> p [ i ] . coeff = ctx -> coeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . qcoeff = ctx -> qcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> pd [ i ] . dqcoeff = ctx -> dqcoeff_pbuf [ i ] [ 0 ] ; //<S2SV> p [ i ] . eobs = ctx -> eobs_pbuf [ i ] [ 0 ] ; //<S2SV> } //<S2SV> vp9_zero ( x -> zcoeff_blk ) ; //<S2SV> if ( cm -> frame_type != KEY_FRAME && //<S2SV> cpi -> rc . frames_since_golden == 0 && //<S2SV> ! cpi -> use_svc ) //<S2SV> cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; //<S2SV> if ( sf -> partition_search_type == SOURCE_VAR_BASED_PARTITION ) //<S2SV> source_var_based_partition_search_method ( cpi ) ; //<S2SV> } //<S2SV> { //<S2SV> struct vpx_usec_timer emr_timer ; //<S2SV> vpx_usec_timer_start ( & emr_timer ) ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , //<S2SV> & cpi -> twopass . this_frame_mb_stats ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( MIN ( cpi -> oxcf . max_threads , 1 << cm -> log2_tile_cols ) > 1 ) //<S2SV> vp9_encode_tiles_mt ( cpi ) ; //<S2SV> else //<S2SV> encode_tiles ( cpi ) ; //<S2SV> vpx_usec_timer_mark ( & emr_timer ) ; //<S2SV> cpi -> time_encode_sb_row += vpx_usec_timer_elapsed ( & emr_timer ) ; //<S2SV> } //<S2SV> sf -> skip_encode_frame = sf -> skip_encode_sb ? //<S2SV> get_skip_encode_frame ( cm , td ) : 0 ; //<S2SV> # if 0 //<S2SV> cpi -> last_frame_distortion = cpi -> frame_distortion ; //<S2SV> # endif //<S2SV> } //<S2SV> 