static void encode_superblock ( VP9_COMP * cpi , ThreadData * td , //<S2SV> TOKENEXTRA * * t , int output_enabled , //<S2SV> int mi_row , int mi_col , BLOCK_SIZE bsize , //<S2SV> PICK_MODE_CONTEXT * ctx ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MODE_INFO * * mi_8x8 = xd -> mi ; //<S2SV> MODE_INFO * mi = mi_8x8 [ 0 ] ; //<S2SV> MB_MODE_INFO * mbmi = & mi -> mbmi ; //<S2SV> const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , //<S2SV> SEG_LVL_SKIP ) ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; //<S2SV> const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; //<S2SV> x -> skip_recode = ! x -> select_tx_size && mbmi -> sb_type >= BLOCK_8X8 && //<S2SV> cpi -> oxcf . aq_mode != COMPLEXITY_AQ && //<S2SV> cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && //<S2SV> cpi -> sf . allow_skip_recode ; //<S2SV> if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) //<S2SV> memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; //<S2SV> x -> skip_optimize = ctx -> is_coded ; //<S2SV> ctx -> is_coded = 1 ; //<S2SV> x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; //<S2SV> x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && //<S2SV> x -> q_index < QIDX_SKIP_THRESH ) ; //<S2SV> if ( x -> skip_encode ) //<S2SV> return ; //<S2SV> if ( ! is_inter_block ( mbmi ) ) { //<S2SV> int plane ; //<S2SV> mbmi -> skip = 1 ; //<S2SV> for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) //<S2SV> vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; //<S2SV> if ( output_enabled ) //<S2SV> sum_intra_stats ( td -> counts , mi ) ; //<S2SV> vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> } else { //<S2SV> int ref ; //<S2SV> const int is_compound = has_second_ref ( mbmi ) ; //<S2SV> set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; //<S2SV> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { //<S2SV> YV12_BUFFER_CONFIG * cfg = get_ref_frame_buffer ( cpi , //<S2SV> mbmi -> ref_frame [ ref ] ) ; //<S2SV> assert ( cfg != NULL ) ; //<S2SV> vp9_setup_pre_planes ( xd , ref , cfg , mi_row , mi_col , //<S2SV> & xd -> block_refs [ ref ] -> sf ) ; //<S2SV> } //<S2SV> if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) //<S2SV> vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> vp9_encode_sb ( x , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; //<S2SV> } //<S2SV> if ( output_enabled ) { //<S2SV> if ( cm -> tx_mode == TX_MODE_SELECT && //<S2SV> mbmi -> sb_type >= BLOCK_8X8 && //<S2SV> ! ( is_inter_block ( mbmi ) && ( mbmi -> skip || seg_skip ) ) ) { //<S2SV> ++ get_tx_counts ( max_txsize_lookup [ bsize ] , get_tx_size_context ( xd ) , //<S2SV> & td -> counts -> tx ) [ mbmi -> tx_size ] ; //<S2SV> } else { //<S2SV> int x , y ; //<S2SV> TX_SIZE tx_size ; //<S2SV> if ( is_inter_block ( & mi -> mbmi ) ) { //<S2SV> tx_size = MIN ( tx_mode_to_biggest_tx_size [ cm -> tx_mode ] , //<S2SV> max_txsize_lookup [ bsize ] ) ; //<S2SV> } else { //<S2SV> tx_size = ( bsize >= BLOCK_8X8 ) ? mbmi -> tx_size : TX_4X4 ; //<S2SV> } //<S2SV> for ( y = 0 ; y < mi_height ; y ++ ) //<S2SV> for ( x = 0 ; x < mi_width ; x ++ ) //<S2SV> if ( mi_col + x < cm -> mi_cols && mi_row + y < cm -> mi_rows ) //<S2SV> mi_8x8 [ mis * y + x ] -> mbmi . tx_size = tx_size ; //<S2SV> } //<S2SV> ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; //<S2SV> ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ; //<S2SV> } //<S2SV> } //<S2SV> 