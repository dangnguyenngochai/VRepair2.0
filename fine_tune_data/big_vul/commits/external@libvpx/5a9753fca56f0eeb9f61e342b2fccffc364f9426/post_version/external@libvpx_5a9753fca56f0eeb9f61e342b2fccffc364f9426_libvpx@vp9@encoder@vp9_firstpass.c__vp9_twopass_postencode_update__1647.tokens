void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { //<S2SV> TWO_PASS * const twopass = & cpi -> twopass ; //<S2SV> RATE_CONTROL * const rc = & cpi -> rc ; //<S2SV> const int bits_used = rc -> base_frame_target ; //<S2SV> rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; //<S2SV> twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; //<S2SV> if ( rc -> total_actual_bits ) { //<S2SV> rc -> rate_error_estimate = //<S2SV> ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; //<S2SV> rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; //<S2SV> } else { //<S2SV> rc -> rate_error_estimate = 0 ; //<S2SV> } //<S2SV> if ( cpi -> common . frame_type != KEY_FRAME && //<S2SV> ! vp9_is_upper_layer_key_frame ( cpi ) ) { //<S2SV> twopass -> kf_group_bits -= bits_used ; //<S2SV> twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; //<S2SV> } //<S2SV> twopass -> kf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ; //<S2SV> ++ twopass -> gf_group . index ; //<S2SV> if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && //<S2SV> ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && //<S2SV> ! cpi -> rc . is_src_frame_alt_ref ) { //<S2SV> const int maxq_adj_limit = //<S2SV> rc -> worst_quality - twopass -> active_worst_quality ; //<S2SV> const int minq_adj_limit = //<S2SV> ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; //<S2SV> if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { //<S2SV> -- twopass -> extend_maxq ; //<S2SV> if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) //<S2SV> ++ twopass -> extend_minq ; //<S2SV> } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { //<S2SV> -- twopass -> extend_minq ; //<S2SV> if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) //<S2SV> ++ twopass -> extend_maxq ; //<S2SV> } else { //<S2SV> if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && //<S2SV> rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) //<S2SV> ++ twopass -> extend_maxq ; //<S2SV> if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) //<S2SV> -- twopass -> extend_minq ; //<S2SV> else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) //<S2SV> -- twopass -> extend_maxq ; //<S2SV> } //<S2SV> twopass -> extend_minq = clamp ( twopass -> extend_minq , 0 , minq_adj_limit ) ; //<S2SV> twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; //<S2SV> if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { //<S2SV> int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; //<S2SV> if ( rc -> projected_frame_size < fast_extra_thresh ) { //<S2SV> rc -> vbr_bits_off_target_fast += //<S2SV> fast_extra_thresh - rc -> projected_frame_size ; //<S2SV> rc -> vbr_bits_off_target_fast = //<S2SV> MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; //<S2SV> if ( rc -> avg_frame_bandwidth ) { //<S2SV> twopass -> extend_minq_fast = //<S2SV> ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; //<S2SV> } //<S2SV> twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , //<S2SV> minq_adj_limit - twopass -> extend_minq ) ; //<S2SV> } else if ( rc -> vbr_bits_off_target_fast ) { //<S2SV> twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , //<S2SV> minq_adj_limit - twopass -> extend_minq ) ; //<S2SV> } else { //<S2SV> twopass -> extend_minq_fast = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 