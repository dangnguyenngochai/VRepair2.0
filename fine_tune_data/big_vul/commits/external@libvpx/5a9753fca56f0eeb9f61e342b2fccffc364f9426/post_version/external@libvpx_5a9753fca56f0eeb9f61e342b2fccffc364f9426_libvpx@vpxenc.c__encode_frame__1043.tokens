static void encode_frame ( struct stream_state * stream , //<S2SV> struct VpxEncoderConfig * global , //<S2SV> struct vpx_image * img , //<S2SV> unsigned int frames_in ) { //<S2SV> vpx_codec_pts_t frame_start , next_frame_start ; //<S2SV> struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; //<S2SV> struct vpx_usec_timer timer ; //<S2SV> frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in - 1 ) //<S2SV> * global -> framerate . den ) //<S2SV> / cfg -> g_timebase . num / global -> framerate . num ; //<S2SV> next_frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in ) //<S2SV> * global -> framerate . den ) //<S2SV> / cfg -> g_timebase . num / global -> framerate . num ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( img ) { //<S2SV> if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) && //<S2SV> ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { //<S2SV> if ( img -> fmt != VPX_IMG_FMT_I42016 ) { //<S2SV> fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n" , exec_name ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # if CONFIG_LIBYUV //<S2SV> if ( ! stream -> img ) { //<S2SV> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I42016 , //<S2SV> cfg -> g_w , cfg -> g_h , 16 ) ; //<S2SV> } //<S2SV> I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , //<S2SV> img -> stride [ VPX_PLANE_Y ] / 2 , //<S2SV> ( uint16 * ) img -> planes [ VPX_PLANE_U ] , //<S2SV> img -> stride [ VPX_PLANE_U ] / 2 , //<S2SV> ( uint16 * ) img -> planes [ VPX_PLANE_V ] , //<S2SV> img -> stride [ VPX_PLANE_V ] / 2 , //<S2SV> img -> d_w , img -> d_h , //<S2SV> ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_Y ] / 2 , //<S2SV> ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_U ] / 2 , //<S2SV> ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_V ] / 2 , //<S2SV> stream -> img -> d_w , stream -> img -> d_h , //<S2SV> kFilterBox ) ; //<S2SV> img = stream -> img ; //<S2SV> # else //<S2SV> stream -> encoder . err = 1 ; //<S2SV> ctx_exit_on_error ( & stream -> encoder , //<S2SV> "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" //<S2SV> "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" //<S2SV> "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , //<S2SV> stream -> index ) ; //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { //<S2SV> if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { //<S2SV> fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n" , exec_name ) ; //<S2SV> exit ( EXIT_FAILURE ) ; //<S2SV> } //<S2SV> # if CONFIG_LIBYUV //<S2SV> if ( ! stream -> img ) //<S2SV> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , //<S2SV> cfg -> g_w , cfg -> g_h , 16 ) ; //<S2SV> I420Scale ( img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] , //<S2SV> img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] , //<S2SV> img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] , //<S2SV> img -> d_w , img -> d_h , //<S2SV> stream -> img -> planes [ VPX_PLANE_Y ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_Y ] , //<S2SV> stream -> img -> planes [ VPX_PLANE_U ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_U ] , //<S2SV> stream -> img -> planes [ VPX_PLANE_V ] , //<S2SV> stream -> img -> stride [ VPX_PLANE_V ] , //<S2SV> stream -> img -> d_w , stream -> img -> d_h , //<S2SV> kFilterBox ) ; //<S2SV> img = stream -> img ; //<S2SV> # else //<S2SV> stream -> encoder . err = 1 ; //<S2SV> ctx_exit_on_error ( & stream -> encoder , //<S2SV> "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" //<S2SV> "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" //<S2SV> "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , //<S2SV> stream -> index ) ; //<S2SV> # endif //<S2SV> } //<S2SV> vpx_usec_timer_start ( & timer ) ; //<S2SV> vpx_codec_encode ( & stream -> encoder , img , frame_start , //<S2SV> ( unsigned long ) ( next_frame_start - frame_start ) , //<S2SV> 0 , global -> deadline ) ; //<S2SV> vpx_usec_timer_mark ( & timer ) ; //<S2SV> stream -> cx_time += vpx_usec_timer_elapsed ( & timer ) ; //<S2SV> ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" , //<S2SV> stream -> index ) ; //<S2SV> } //<S2SV> 