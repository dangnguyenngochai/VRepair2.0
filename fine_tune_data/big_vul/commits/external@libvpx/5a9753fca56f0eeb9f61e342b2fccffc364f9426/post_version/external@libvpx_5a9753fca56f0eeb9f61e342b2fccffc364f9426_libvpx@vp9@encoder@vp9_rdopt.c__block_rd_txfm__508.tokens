static void block_rd_txfm ( int plane , int block , BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , void * arg ) { //<S2SV> struct rdcost_block_args * args = arg ; //<S2SV> MACROBLOCK * const x = args -> x ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> int64_t rd1 , rd2 , rd ; //<S2SV> int rate ; //<S2SV> int64_t dist ; //<S2SV> int64_t sse ; //<S2SV> if ( args -> exit_early ) //<S2SV> return ; //<S2SV> if ( ! is_inter_block ( mbmi ) ) { //<S2SV> struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; //<S2SV> vp9_encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ; //<S2SV> dist_block ( x , plane , block , tx_size , & dist , & sse ) ; //<S2SV> } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { //<S2SV> if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == //<S2SV> SKIP_TXFM_NONE ) { //<S2SV> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; //<S2SV> dist_block ( x , plane , block , tx_size , & dist , & sse ) ; //<S2SV> } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == //<S2SV> SKIP_TXFM_AC_ONLY ) { //<S2SV> tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; //<S2SV> tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; //<S2SV> vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; //<S2SV> sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; //<S2SV> dist = sse ; //<S2SV> if ( x -> plane [ plane ] . eobs [ block ] ) { //<S2SV> const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; //<S2SV> const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; //<S2SV> int64_t dc_correct = orig_sse - resd_sse * resd_sse ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; //<S2SV> # endif //<S2SV> if ( tx_size != TX_32X32 ) //<S2SV> dc_correct >>= 2 ; //<S2SV> dist = MAX ( 0 , sse - dc_correct ) ; //<S2SV> } //<S2SV> } else { //<S2SV> x -> plane [ plane ] . eobs [ block ] = 0 ; //<S2SV> sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; //<S2SV> dist = sse ; //<S2SV> } //<S2SV> } else { //<S2SV> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; //<S2SV> dist_block ( x , plane , block , tx_size , & dist , & sse ) ; //<S2SV> } //<S2SV> rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; //<S2SV> if ( args -> this_rd + rd > args -> best_rd ) { //<S2SV> args -> exit_early = 1 ; //<S2SV> return ; //<S2SV> } //<S2SV> rate = rate_block ( plane , block , plane_bsize , tx_size , args ) ; //<S2SV> rd1 = RDCOST ( x -> rdmult , x -> rddiv , rate , dist ) ; //<S2SV> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , sse ) ; //<S2SV> rd = MIN ( rd1 , rd2 ) ; //<S2SV> if ( plane == 0 ) //<S2SV> x -> zcoeff_blk [ tx_size ] [ block ] = ! x -> plane [ plane ] . eobs [ block ] || //<S2SV> ( rd1 > rd2 && ! xd -> lossless ) ; //<S2SV> args -> this_rate += rate ; //<S2SV> args -> this_dist += dist ; //<S2SV> args -> this_sse += sse ; //<S2SV> args -> this_rd += rd ; //<S2SV> if ( args -> this_rd > args -> best_rd ) { //<S2SV> args -> exit_early = 1 ; //<S2SV> return ; //<S2SV> } //<S2SV> args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ; //<S2SV> } //<S2SV> 