int vp8dx_receive_compressed_data ( VP8D_COMP * pbi , size_t size , //<S2SV> const uint8_t * source , //<S2SV> int64_t time_stamp ) //<S2SV> { //<S2SV> VP8_COMMON * cm = & pbi -> common ; //<S2SV> int retcode = - 1 ; //<S2SV> ( void ) size ; //<S2SV> ( void ) source ; //<S2SV> pbi -> common . error . error_code = VPX_CODEC_OK ; //<S2SV> retcode = check_fragments_for_errors ( pbi ) ; //<S2SV> if ( retcode <= 0 ) //<S2SV> return retcode ; //<S2SV> cm -> new_fb_idx = get_free_fb ( cm ) ; //<S2SV> pbi -> dec_fb_ref [ INTRA_FRAME ] = & cm -> yv12_fb [ cm -> new_fb_idx ] ; //<S2SV> pbi -> dec_fb_ref [ LAST_FRAME ] = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; //<S2SV> pbi -> dec_fb_ref [ GOLDEN_FRAME ] = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; //<S2SV> pbi -> dec_fb_ref [ ALTREF_FRAME ] = & cm -> yv12_fb [ cm -> alt_fb_idx ] ; //<S2SV> if ( setjmp ( pbi -> common . error . jmp ) ) //<S2SV> { //<S2SV> cm -> yv12_fb [ cm -> lst_fb_idx ] . corrupted = 1 ; //<S2SV> if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) //<S2SV> cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; //<S2SV> goto decode_exit ; //<S2SV> } //<S2SV> pbi -> common . error . setjmp = 1 ; //<S2SV> retcode = vp8_decode_frame ( pbi ) ; //<S2SV> if ( retcode < 0 ) //<S2SV> { //<S2SV> if ( cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] > 0 ) //<S2SV> cm -> fb_idx_ref_cnt [ cm -> new_fb_idx ] -- ; //<S2SV> pbi -> common . error . error_code = VPX_CODEC_ERROR ; //<S2SV> goto decode_exit ; //<S2SV> } //<S2SV> if ( swap_frame_buffers ( cm ) ) //<S2SV> { //<S2SV> pbi -> common . error . error_code = VPX_CODEC_ERROR ; //<S2SV> goto decode_exit ; //<S2SV> } //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> if ( cm -> show_frame ) //<S2SV> { //<S2SV> cm -> current_video_frame ++ ; //<S2SV> cm -> show_frame_mi = cm -> mi ; //<S2SV> } //<S2SV> # if CONFIG_ERROR_CONCEALMENT //<S2SV> if ( pbi -> ec_enabled && pbi -> common . prev_mi ) //<S2SV> { //<S2SV> MODE_INFO * tmp = pbi -> common . prev_mi ; //<S2SV> int row , col ; //<S2SV> pbi -> common . prev_mi = pbi -> common . mi ; //<S2SV> pbi -> common . mi = tmp ; //<S2SV> for ( row = 0 ; row < pbi -> common . mb_rows ; ++ row ) //<S2SV> { //<S2SV> for ( col = 0 ; col < pbi -> common . mb_cols ; ++ col ) //<S2SV> { //<S2SV> const int i = row * pbi -> common . mode_info_stride + col ; //<S2SV> pbi -> common . mi [ i ] . mbmi . segment_id = //<S2SV> pbi -> common . prev_mi [ i ] . mbmi . segment_id ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> pbi -> ready_for_new_data = 0 ; //<S2SV> pbi -> last_time_stamp = time_stamp ; //<S2SV> decode_exit : //<S2SV> pbi -> common . error . setjmp = 0 ; //<S2SV> vp8_clear_system_state ( ) ; //<S2SV> return retcode ; //<S2SV> } //<S2SV> 