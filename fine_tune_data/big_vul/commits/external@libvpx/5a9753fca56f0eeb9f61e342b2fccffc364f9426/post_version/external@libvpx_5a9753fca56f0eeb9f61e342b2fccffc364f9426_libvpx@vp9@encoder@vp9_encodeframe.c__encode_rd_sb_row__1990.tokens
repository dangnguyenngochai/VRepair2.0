static void encode_rd_sb_row ( VP9_COMP * cpi , //<S2SV> ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> int mi_row , //<S2SV> TOKENEXTRA * * tp ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> int mi_col ; //<S2SV> memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; //<S2SV> memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; //<S2SV> for ( mi_col = tile_info -> mi_col_start ; mi_col < tile_info -> mi_col_end ; //<S2SV> mi_col += MI_BLOCK_SIZE ) { //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> int dummy_rate ; //<S2SV> int64_t dummy_dist ; //<S2SV> RD_COST dummy_rdc ; //<S2SV> int i ; //<S2SV> int seg_skip = 0 ; //<S2SV> const int idx_str = cm -> mi_stride * mi_row + mi_col ; //<S2SV> MODE_INFO * * mi = cm -> mi_grid_visible + idx_str ; //<S2SV> if ( sf -> adaptive_pred_interp_filter ) { //<S2SV> for ( i = 0 ; i < 64 ; ++ i ) //<S2SV> td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; //<S2SV> for ( i = 0 ; i < 64 ; ++ i ) { //<S2SV> td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; //<S2SV> td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; //<S2SV> td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; //<S2SV> td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; //<S2SV> } //<S2SV> } //<S2SV> vp9_zero ( x -> pred_mv ) ; //<S2SV> td -> pc_root -> index = 0 ; //<S2SV> if ( seg -> enabled ) { //<S2SV> const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map //<S2SV> : cm -> last_frame_seg_map ; //<S2SV> int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; //<S2SV> seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; //<S2SV> } //<S2SV> x -> source_variance = UINT_MAX ; //<S2SV> if ( sf -> partition_search_type == FIXED_PARTITION || seg_skip ) { //<S2SV> const BLOCK_SIZE bsize = //<S2SV> seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; //<S2SV> rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; //<S2SV> } else if ( cpi -> partition_search_skippable_frame ) { //<S2SV> BLOCK_SIZE bsize ; //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; //<S2SV> set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; //<S2SV> rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; //<S2SV> } else if ( sf -> partition_search_type == VAR_BASED_PARTITION && //<S2SV> cm -> frame_type != KEY_FRAME ) { //<S2SV> choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; //<S2SV> rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , //<S2SV> BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; //<S2SV> } else { //<S2SV> if ( sf -> auto_min_max_partition_size ) { //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; //<S2SV> rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , //<S2SV> & x -> min_partition_size , //<S2SV> & x -> max_partition_size ) ; //<S2SV> } //<S2SV> rd_pick_partition ( cpi , td , tile_data , tp , mi_row , mi_col , BLOCK_64X64 , //<S2SV> & dummy_rdc , INT64_MAX , td -> pc_root ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 