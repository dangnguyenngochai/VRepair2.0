static void nonrd_pick_sb_modes ( VP9_COMP * cpi , //<S2SV> TileDataEnc * tile_data , MACROBLOCK * const x , //<S2SV> int mi_row , int mi_col , RD_COST * rd_cost , //<S2SV> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi ; //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; //<S2SV> mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> mbmi -> sb_type = bsize ; //<S2SV> if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) //<S2SV> if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) //<S2SV> x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; //<S2SV> if ( cm -> frame_type == KEY_FRAME ) //<S2SV> hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; //<S2SV> else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) //<S2SV> set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; //<S2SV> else if ( bsize >= BLOCK_8X8 ) //<S2SV> vp9_pick_inter_mode ( cpi , x , tile_data , mi_row , mi_col , //<S2SV> rd_cost , bsize , ctx ) ; //<S2SV> else //<S2SV> vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , //<S2SV> rd_cost , bsize , ctx ) ; //<S2SV> duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( rd_cost -> rate == INT_MAX ) //<S2SV> vp9_rd_cost_reset ( rd_cost ) ; //<S2SV> ctx -> rate = rd_cost -> rate ; //<S2SV> ctx -> dist = rd_cost -> dist ; //<S2SV> } //<S2SV> 