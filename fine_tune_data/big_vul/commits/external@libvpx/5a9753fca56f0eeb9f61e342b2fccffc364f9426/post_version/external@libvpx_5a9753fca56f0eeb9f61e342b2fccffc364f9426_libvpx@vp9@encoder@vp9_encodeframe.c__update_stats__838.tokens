static void update_stats ( VP9_COMMON * cm , ThreadData * td ) { //<S2SV> const MACROBLOCK * x = & td -> mb ; //<S2SV> const MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const MODE_INFO * const mi = xd -> mi [ 0 ] ; //<S2SV> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; //<S2SV> const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; //<S2SV> const BLOCK_SIZE bsize = mbmi -> sb_type ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> FRAME_COUNTS * const counts = td -> counts ; //<S2SV> const int inter_block = is_inter_block ( mbmi ) ; //<S2SV> const int seg_ref_active = segfeature_active ( & cm -> seg , mbmi -> segment_id , //<S2SV> SEG_LVL_REF_FRAME ) ; //<S2SV> if ( ! seg_ref_active ) { //<S2SV> counts -> intra_inter [ vp9_get_intra_inter_context ( xd ) ] [ inter_block ] ++ ; //<S2SV> if ( inter_block ) { //<S2SV> const MV_REFERENCE_FRAME ref0 = mbmi -> ref_frame [ 0 ] ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) //<S2SV> counts -> comp_inter [ vp9_get_reference_mode_context ( cm , xd ) ] //<S2SV> [ has_second_ref ( mbmi ) ] ++ ; //<S2SV> if ( has_second_ref ( mbmi ) ) { //<S2SV> counts -> comp_ref [ vp9_get_pred_context_comp_ref_p ( cm , xd ) ] //<S2SV> [ ref0 == GOLDEN_FRAME ] ++ ; //<S2SV> } else { //<S2SV> counts -> single_ref [ vp9_get_pred_context_single_ref_p1 ( xd ) ] [ 0 ] //<S2SV> [ ref0 != LAST_FRAME ] ++ ; //<S2SV> if ( ref0 != LAST_FRAME ) //<S2SV> counts -> single_ref [ vp9_get_pred_context_single_ref_p2 ( xd ) ] [ 1 ] //<S2SV> [ ref0 != GOLDEN_FRAME ] ++ ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( inter_block && //<S2SV> ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { //<S2SV> const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; //<S2SV> if ( bsize >= BLOCK_8X8 ) { //<S2SV> const PREDICTION_MODE mode = mbmi -> mode ; //<S2SV> ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; //<S2SV> } else { //<S2SV> const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; //<S2SV> const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; //<S2SV> int idx , idy ; //<S2SV> for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { //<S2SV> for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { //<S2SV> const int j = idy * 2 + idx ; //<S2SV> const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; //<S2SV> ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 