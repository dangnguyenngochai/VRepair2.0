void vp9_rd_pick_inter_mode_sub8x8 ( VP9_COMP * cpi , //<S2SV> TileDataEnc * tile_data , //<S2SV> MACROBLOCK * x , //<S2SV> int mi_row , int mi_col , //<S2SV> RD_COST * rd_cost , //<S2SV> BLOCK_SIZE bsize , //<S2SV> PICK_MODE_CONTEXT * ctx , //<S2SV> int64_t best_rd_so_far ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> RD_OPT * const rd_opt = & cpi -> rd ; //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> MV_REFERENCE_FRAME ref_frame , second_ref_frame ; //<S2SV> unsigned char segment_id = mbmi -> segment_id ; //<S2SV> int comp_pred , i ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> int64_t best_rd = best_rd_so_far ; //<S2SV> int64_t best_yrd = best_rd_so_far ; //<S2SV> int64_t best_pred_diff [ REFERENCE_MODES ] ; //<S2SV> int64_t best_pred_rd [ REFERENCE_MODES ] ; //<S2SV> int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> MB_MODE_INFO best_mbmode ; //<S2SV> int ref_index , best_ref_index = 0 ; //<S2SV> unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; //<S2SV> vpx_prob comp_mode_p ; //<S2SV> INTERP_FILTER tmp_best_filter = SWITCHABLE ; //<S2SV> int rate_uv_intra , rate_uv_tokenonly ; //<S2SV> int64_t dist_uv ; //<S2SV> int skip_uv ; //<S2SV> PREDICTION_MODE mode_uv = DC_PRED ; //<S2SV> const int intra_cost_penalty = vp9_get_intra_cost_penalty ( //<S2SV> cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ; //<S2SV> int_mv seg_mvs [ 4 ] [ MAX_REF_FRAMES ] ; //<S2SV> b_mode_info best_bmodes [ 4 ] ; //<S2SV> int best_skip2 = 0 ; //<S2SV> int ref_frame_skip_mask [ 2 ] = { 0 } ; //<S2SV> int64_t mask_filter = 0 ; //<S2SV> int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> int internal_active_edge = //<S2SV> vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) ; //<S2SV> x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> memset ( x -> zcoeff_blk [ TX_4X4 ] , 0 , 4 ) ; //<S2SV> vp9_zero ( best_mbmode ) ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> filter_cache [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int j ; //<S2SV> for ( j = 0 ; j < MAX_REF_FRAMES ; j ++ ) //<S2SV> seg_mvs [ i ] [ j ] . as_int = INVALID_MV ; //<S2SV> } //<S2SV> estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , //<S2SV> & comp_mode_p ) ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = INT64_MAX ; //<S2SV> rate_uv_intra = INT_MAX ; //<S2SV> rd_cost -> rate = INT_MAX ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ref_frame ++ ) { //<S2SV> if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { //<S2SV> setup_buffer_inter ( cpi , x , ref_frame , bsize , mi_row , mi_col , //<S2SV> frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , //<S2SV> yv12_mb ) ; //<S2SV> } else { //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> } //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> } //<S2SV> for ( ref_index = 0 ; ref_index < MAX_REFS ; ++ ref_index ) { //<S2SV> int mode_excluded = 0 ; //<S2SV> int64_t this_rd = INT64_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int compmode_cost = 0 ; //<S2SV> int rate2 = 0 , rate_y = 0 , rate_uv = 0 ; //<S2SV> int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ; //<S2SV> int skippable = 0 ; //<S2SV> int i ; //<S2SV> int this_skip2 = 0 ; //<S2SV> int64_t total_sse = INT_MAX ; //<S2SV> int early_term = 0 ; //<S2SV> ref_frame = vp9_ref_order [ ref_index ] . ref_frame [ 0 ] ; //<S2SV> second_ref_frame = vp9_ref_order [ ref_index ] . ref_frame [ 1 ] ; //<S2SV> if ( ref_index > 2 && sf -> mode_skip_start < MAX_MODES ) { //<S2SV> if ( ref_index == 3 ) { //<S2SV> switch ( best_mbmode . ref_frame [ 0 ] ) { //<S2SV> case INTRA_FRAME : //<S2SV> break ; //<S2SV> case LAST_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << ALTREF_FRAME ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> break ; //<S2SV> case GOLDEN_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << LAST_FRAME ) | ( 1 << ALTREF_FRAME ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> break ; //<S2SV> case ALTREF_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << LAST_FRAME ) ; //<S2SV> break ; //<S2SV> case NONE : //<S2SV> case MAX_REF_FRAMES : //<S2SV> assert ( 0 && "Invalid<S2SV_blank>Reference<S2SV_blank>frame" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && //<S2SV> ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) //<S2SV> continue ; //<S2SV> if ( ! internal_active_edge && //<S2SV> rd_less_than_thresh ( best_rd , //<S2SV> rd_opt -> threshes [ segment_id ] [ bsize ] [ ref_index ] , //<S2SV> tile_data -> thresh_freq_fact [ bsize ] [ ref_index ] ) ) //<S2SV> continue ; //<S2SV> comp_pred = second_ref_frame > INTRA_FRAME ; //<S2SV> if ( comp_pred ) { //<S2SV> if ( ! cpi -> allow_comp_inter_inter ) //<S2SV> continue ; //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) //<S2SV> continue ; //<S2SV> if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) //<S2SV> continue ; //<S2SV> if ( ( sf -> mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && //<S2SV> best_mbmode . ref_frame [ 0 ] == INTRA_FRAME ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ref_frame > INTRA_FRAME && //<S2SV> vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) //<S2SV> continue ; //<S2SV> if ( second_ref_frame > INTRA_FRAME && //<S2SV> vp9_is_scaled ( & cm -> frame_refs [ second_ref_frame - 1 ] . sf ) ) //<S2SV> continue ; //<S2SV> if ( comp_pred ) //<S2SV> mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; //<S2SV> else if ( ref_frame != INTRA_FRAME ) //<S2SV> mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && //<S2SV> get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { //<S2SV> continue ; //<S2SV> } else if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { //<S2SV> if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> mbmi -> tx_size = TX_4X4 ; //<S2SV> mbmi -> uv_mode = DC_PRED ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> mbmi -> ref_frame [ 1 ] = second_ref_frame ; //<S2SV> mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP //<S2SV> : cm -> interp_filter ; //<S2SV> x -> skip = 0 ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; //<S2SV> if ( comp_pred ) //<S2SV> xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ; //<S2SV> } //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> int rate ; //<S2SV> if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate , & rate_y , //<S2SV> & distortion_y , best_rd ) >= best_rd ) //<S2SV> continue ; //<S2SV> rate2 += rate ; //<S2SV> rate2 += intra_cost_penalty ; //<S2SV> distortion2 += distortion_y ; //<S2SV> if ( rate_uv_intra == INT_MAX ) { //<S2SV> choose_intra_uv_mode ( cpi , x , ctx , bsize , TX_4X4 , //<S2SV> & rate_uv_intra , //<S2SV> & rate_uv_tokenonly , //<S2SV> & dist_uv , & skip_uv , //<S2SV> & mode_uv ) ; //<S2SV> } //<S2SV> rate2 += rate_uv_intra ; //<S2SV> rate_uv = rate_uv_tokenonly ; //<S2SV> distortion2 += dist_uv ; //<S2SV> distortion_uv = dist_uv ; //<S2SV> mbmi -> uv_mode = mode_uv ; //<S2SV> } else { //<S2SV> int rate ; //<S2SV> int64_t distortion ; //<S2SV> int64_t this_rd_thresh ; //<S2SV> int64_t tmp_rd , tmp_best_rd = INT64_MAX , tmp_best_rdu = INT64_MAX ; //<S2SV> int tmp_best_rate = INT_MAX , tmp_best_ratey = INT_MAX ; //<S2SV> int64_t tmp_best_distortion = INT_MAX , tmp_best_sse , uv_sse ; //<S2SV> int tmp_best_skippable = 0 ; //<S2SV> int switchable_filter_index ; //<S2SV> int_mv * second_ref = comp_pred ? //<S2SV> & x -> mbmi_ext -> ref_mvs [ second_ref_frame ] [ 0 ] : NULL ; //<S2SV> b_mode_info tmp_best_bmodes [ 16 ] ; //<S2SV> MB_MODE_INFO tmp_best_mbmode ; //<S2SV> BEST_SEG_INFO bsi [ SWITCHABLE_FILTERS ] ; //<S2SV> int pred_exists = 0 ; //<S2SV> int uv_skippable ; //<S2SV> this_rd_thresh = ( ref_frame == LAST_FRAME ) ? //<S2SV> rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_LAST ] : //<S2SV> rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_ALTR ] ; //<S2SV> this_rd_thresh = ( ref_frame == GOLDEN_FRAME ) ? //<S2SV> rd_opt -> threshes [ segment_id ] [ bsize ] [ THR_GOLD ] : this_rd_thresh ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> filter_cache [ i ] = INT64_MAX ; //<S2SV> if ( cm -> interp_filter != BILINEAR ) { //<S2SV> tmp_best_filter = EIGHTTAP ; //<S2SV> if ( x -> source_variance < sf -> disable_filter_search_var_thresh ) { //<S2SV> tmp_best_filter = EIGHTTAP ; //<S2SV> } else if ( sf -> adaptive_pred_interp_filter == 1 && //<S2SV> ctx -> pred_interp_filter < SWITCHABLE ) { //<S2SV> tmp_best_filter = ctx -> pred_interp_filter ; //<S2SV> } else if ( sf -> adaptive_pred_interp_filter == 2 ) { //<S2SV> tmp_best_filter = ctx -> pred_interp_filter < SWITCHABLE ? //<S2SV> ctx -> pred_interp_filter : 0 ; //<S2SV> } else { //<S2SV> for ( switchable_filter_index = 0 ; //<S2SV> switchable_filter_index < SWITCHABLE_FILTERS ; //<S2SV> ++ switchable_filter_index ) { //<S2SV> int newbest , rs ; //<S2SV> int64_t rs_rd ; //<S2SV> MB_MODE_INFO_EXT * mbmi_ext = x -> mbmi_ext ; //<S2SV> mbmi -> interp_filter = switchable_filter_index ; //<S2SV> tmp_rd = rd_pick_best_sub8x8_mode ( cpi , x , //<S2SV> & mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] , //<S2SV> second_ref , best_yrd , & rate , //<S2SV> & rate_y , & distortion , //<S2SV> & skippable , & total_sse , //<S2SV> ( int ) this_rd_thresh , seg_mvs , //<S2SV> bsi , switchable_filter_index , //<S2SV> mi_row , mi_col ) ; //<S2SV> if ( tmp_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> rs = vp9_get_switchable_rate ( cpi , xd ) ; //<S2SV> rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; //<S2SV> filter_cache [ switchable_filter_index ] = tmp_rd ; //<S2SV> filter_cache [ SWITCHABLE_FILTERS ] = //<S2SV> MIN ( filter_cache [ SWITCHABLE_FILTERS ] , //<S2SV> tmp_rd + rs_rd ) ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> tmp_rd += rs_rd ; //<S2SV> mask_filter = MAX ( mask_filter , tmp_rd ) ; //<S2SV> newbest = ( tmp_rd < tmp_best_rd ) ; //<S2SV> if ( newbest ) { //<S2SV> tmp_best_filter = mbmi -> interp_filter ; //<S2SV> tmp_best_rd = tmp_rd ; //<S2SV> } //<S2SV> if ( ( newbest && cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( mbmi -> interp_filter == cm -> interp_filter && //<S2SV> cm -> interp_filter != SWITCHABLE ) ) { //<S2SV> tmp_best_rdu = tmp_rd ; //<S2SV> tmp_best_rate = rate ; //<S2SV> tmp_best_ratey = rate_y ; //<S2SV> tmp_best_distortion = distortion ; //<S2SV> tmp_best_sse = total_sse ; //<S2SV> tmp_best_skippable = skippable ; //<S2SV> tmp_best_mbmode = * mbmi ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> tmp_best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ; //<S2SV> x -> zcoeff_blk [ TX_4X4 ] [ i ] = ! x -> plane [ 0 ] . eobs [ i ] ; //<S2SV> } //<S2SV> pred_exists = 1 ; //<S2SV> if ( switchable_filter_index == 0 && //<S2SV> sf -> use_rd_breakout && //<S2SV> best_rd < INT64_MAX ) { //<S2SV> if ( tmp_best_rdu / 2 > best_rd ) { //<S2SV> tmp_best_filter = mbmi -> interp_filter ; //<S2SV> tmp_best_rdu = INT64_MAX ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( tmp_best_rdu == INT64_MAX && pred_exists ) //<S2SV> continue ; //<S2SV> mbmi -> interp_filter = ( cm -> interp_filter == SWITCHABLE ? //<S2SV> tmp_best_filter : cm -> interp_filter ) ; //<S2SV> if ( ! pred_exists ) { //<S2SV> tmp_rd = rd_pick_best_sub8x8_mode ( cpi , x , //<S2SV> & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] , //<S2SV> second_ref , best_yrd , & rate , & rate_y , //<S2SV> & distortion , & skippable , & total_sse , //<S2SV> ( int ) this_rd_thresh , seg_mvs , bsi , 0 , //<S2SV> mi_row , mi_col ) ; //<S2SV> if ( tmp_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> } else { //<S2SV> total_sse = tmp_best_sse ; //<S2SV> rate = tmp_best_rate ; //<S2SV> rate_y = tmp_best_ratey ; //<S2SV> distortion = tmp_best_distortion ; //<S2SV> skippable = tmp_best_skippable ; //<S2SV> * mbmi = tmp_best_mbmode ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> xd -> mi [ 0 ] -> bmi [ i ] = tmp_best_bmodes [ i ] ; //<S2SV> } //<S2SV> rate2 += rate ; //<S2SV> distortion2 += distortion ; //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> rate2 += vp9_get_switchable_rate ( cpi , xd ) ; //<S2SV> if ( ! mode_excluded ) //<S2SV> mode_excluded = comp_pred ? cm -> reference_mode == SINGLE_REFERENCE //<S2SV> : cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ; //<S2SV> tmp_best_rdu = best_rd - //<S2SV> MIN ( RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) , //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) ; //<S2SV> if ( tmp_best_rdu > 0 ) { //<S2SV> vp9_build_inter_predictors_sbuv ( & x -> e_mbd , mi_row , mi_col , //<S2SV> BLOCK_8X8 ) ; //<S2SV> memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; //<S2SV> if ( ! super_block_uvrd ( cpi , x , & rate_uv , & distortion_uv , & uv_skippable , //<S2SV> & uv_sse , BLOCK_8X8 , tmp_best_rdu ) ) //<S2SV> continue ; //<S2SV> rate2 += rate_uv ; //<S2SV> distortion2 += distortion_uv ; //<S2SV> skippable = skippable && uv_skippable ; //<S2SV> total_sse += uv_sse ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) //<S2SV> rate2 += compmode_cost ; //<S2SV> if ( second_ref_frame > INTRA_FRAME ) { //<S2SV> rate2 += ref_costs_comp [ ref_frame ] ; //<S2SV> } else { //<S2SV> rate2 += ref_costs_single [ ref_frame ] ; //<S2SV> } //<S2SV> if ( ! disable_skip ) { //<S2SV> if ( ref_frame != INTRA_FRAME && ! xd -> lossless ) { //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> distortion2 = total_sse ; //<S2SV> assert ( total_sse >= 0 ) ; //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> rate_y = 0 ; //<S2SV> rate_uv = 0 ; //<S2SV> this_skip2 = 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame == INTRA_FRAME ) { //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; //<S2SV> } //<S2SV> if ( this_rd < best_rd || x -> skip ) { //<S2SV> if ( ! mode_excluded ) { //<S2SV> int max_plane = MAX_MB_PLANE ; //<S2SV> best_ref_index = ref_index ; //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> max_plane = 1 ; //<S2SV> } //<S2SV> rd_cost -> rate = rate2 ; //<S2SV> rd_cost -> dist = distortion2 ; //<S2SV> rd_cost -> rdcost = this_rd ; //<S2SV> best_rd = this_rd ; //<S2SV> best_yrd = best_rd - //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , rate_uv , distortion_uv ) ; //<S2SV> best_mbmode = * mbmi ; //<S2SV> best_skip2 = this_skip2 ; //<S2SV> if ( ! x -> select_tx_size ) //<S2SV> swap_block_ptr ( x , ctx , 1 , 0 , 0 , max_plane ) ; //<S2SV> memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ TX_4X4 ] , //<S2SV> sizeof ( ctx -> zcoeff_blk [ 0 ] ) * ctx -> num_4x4_blk ) ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> best_bmodes [ i ] = xd -> mi [ 0 ] -> bmi [ i ] ; //<S2SV> if ( ( sf -> mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && //<S2SV> ( ref_index > MIN_EARLY_TERM_INDEX ) ) { //<S2SV> int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; //<S2SV> int scale = 4 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> qstep >>= ( xd -> bd - 8 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( x -> source_variance < UINT_MAX ) { //<S2SV> const int var_adjust = ( x -> source_variance < 16 ) ; //<S2SV> scale -= var_adjust ; //<S2SV> } //<S2SV> if ( ref_frame > INTRA_FRAME && //<S2SV> distortion2 * scale < qstep * qstep ) { //<S2SV> early_term = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame != INTRA_FRAME ) { //<S2SV> int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { //<S2SV> single_rate = rate2 - compmode_cost ; //<S2SV> hybrid_rate = rate2 ; //<S2SV> } else { //<S2SV> single_rate = rate2 ; //<S2SV> hybrid_rate = rate2 + compmode_cost ; //<S2SV> } //<S2SV> single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ; //<S2SV> hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ; //<S2SV> if ( ! comp_pred && single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) //<S2SV> best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; //<S2SV> else if ( comp_pred && single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) //<S2SV> best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; //<S2SV> if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) //<S2SV> best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ; //<S2SV> } //<S2SV> if ( ! mode_excluded && ! disable_skip && ref_frame != INTRA_FRAME && //<S2SV> cm -> interp_filter != BILINEAR ) { //<S2SV> int64_t ref = filter_cache [ cm -> interp_filter == SWITCHABLE ? //<S2SV> SWITCHABLE_FILTERS : cm -> interp_filter ] ; //<S2SV> int64_t adj_rd ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( ref == INT64_MAX ) //<S2SV> adj_rd = 0 ; //<S2SV> else if ( filter_cache [ i ] == INT64_MAX ) //<S2SV> adj_rd = mask_filter - ref + 10 ; //<S2SV> else //<S2SV> adj_rd = filter_cache [ i ] - ref ; //<S2SV> adj_rd += this_rd ; //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( early_term ) //<S2SV> break ; //<S2SV> if ( x -> skip && ! comp_pred ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( best_rd >= best_rd_so_far ) { //<S2SV> rd_cost -> rate = INT_MAX ; //<S2SV> rd_cost -> rdcost = INT64_MAX ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( sf -> use_uv_intra_rd_estimate ) { //<S2SV> if ( best_mbmode . ref_frame [ 0 ] == INTRA_FRAME ) { //<S2SV> * mbmi = best_mbmode ; //<S2SV> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra , //<S2SV> & rate_uv_tokenonly , //<S2SV> & dist_uv , //<S2SV> & skip_uv , //<S2SV> BLOCK_8X8 , TX_4X4 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( best_rd == INT64_MAX ) { //<S2SV> rd_cost -> rate = INT_MAX ; //<S2SV> rd_cost -> dist = INT64_MAX ; //<S2SV> rd_cost -> rdcost = INT64_MAX ; //<S2SV> return ; //<S2SV> } //<S2SV> assert ( ( cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( cm -> interp_filter == best_mbmode . interp_filter ) || //<S2SV> ! is_inter_block ( & best_mbmode ) ) ; //<S2SV> vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , //<S2SV> sf -> adaptive_rd_thresh , bsize , best_ref_index ) ; //<S2SV> * mbmi = best_mbmode ; //<S2SV> x -> skip |= best_skip2 ; //<S2SV> if ( ! is_inter_block ( & best_mbmode ) ) { //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) //<S2SV> xd -> mi [ 0 ] -> bmi [ i ] . as_mode = best_bmodes [ i ] . as_mode ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < 4 ; ++ i ) //<S2SV> memcpy ( & xd -> mi [ 0 ] -> bmi [ i ] , & best_bmodes [ i ] , sizeof ( b_mode_info ) ) ; //<S2SV> mbmi -> mv [ 0 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; //<S2SV> mbmi -> mv [ 1 ] . as_int = xd -> mi [ 0 ] -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; //<S2SV> } //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { //<S2SV> if ( best_pred_rd [ i ] == INT64_MAX ) //<S2SV> best_pred_diff [ i ] = INT_MIN ; //<S2SV> else //<S2SV> best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ; //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( best_filter_rd [ i ] == INT64_MAX ) //<S2SV> best_filter_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ; //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; //<S2SV> } else { //<S2SV> vp9_zero ( best_filter_diff ) ; //<S2SV> } //<S2SV> store_coding_context ( x , ctx , best_ref_index , //<S2SV> best_pred_diff , best_filter_diff , 0 ) ; //<S2SV> } //<S2SV> 