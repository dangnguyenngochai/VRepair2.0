static const uint8_t * decode_tiles ( VP9Decoder * pbi , //<S2SV> const uint8_t * data , //<S2SV> const uint8_t * data_end ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; //<S2SV> const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; //<S2SV> int tile_row , tile_col ; //<S2SV> int mi_row , mi_col ; //<S2SV> TileData * tile_data = NULL ; //<S2SV> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && //<S2SV> pbi -> lf_worker . data1 == NULL ) { //<S2SV> CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , //<S2SV> vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; //<S2SV> pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; //<S2SV> if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , //<S2SV> "Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { //<S2SV> LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; //<S2SV> winterface -> sync ( & pbi -> lf_worker ) ; //<S2SV> vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , //<S2SV> pbi -> mb . plane ) ; //<S2SV> } //<S2SV> assert ( tile_rows <= 4 ) ; //<S2SV> assert ( tile_cols <= ( 1 << 6 ) ) ; //<S2SV> memset ( cm -> above_context , 0 , //<S2SV> sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; //<S2SV> memset ( cm -> above_seg_context , 0 , //<S2SV> sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; //<S2SV> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; //<S2SV> if ( pbi -> tile_data == NULL || //<S2SV> ( tile_cols * tile_rows ) != pbi -> total_tiles ) { //<S2SV> vpx_free ( pbi -> tile_data ) ; //<S2SV> CHECK_MEM_ERROR ( //<S2SV> cm , //<S2SV> pbi -> tile_data , //<S2SV> vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; //<S2SV> pbi -> total_tiles = tile_rows * tile_cols ; //<S2SV> } //<S2SV> for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { //<S2SV> for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { //<S2SV> const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; //<S2SV> tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; //<S2SV> tile_data -> cm = cm ; //<S2SV> tile_data -> xd = pbi -> mb ; //<S2SV> tile_data -> xd . corrupted = 0 ; //<S2SV> tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? //<S2SV> NULL : & cm -> counts ; //<S2SV> vp9_zero ( tile_data -> dqcoeff ) ; //<S2SV> vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; //<S2SV> setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , //<S2SV> & tile_data -> bit_reader , pbi -> decrypt_cb , //<S2SV> pbi -> decrypt_state ) ; //<S2SV> vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; //<S2SV> } //<S2SV> } //<S2SV> for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { //<S2SV> TileInfo tile ; //<S2SV> vp9_tile_set_row ( & tile , cm , tile_row ) ; //<S2SV> for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; //<S2SV> mi_row += MI_BLOCK_SIZE ) { //<S2SV> for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { //<S2SV> const int col = pbi -> inv_tile_order ? //<S2SV> tile_cols - tile_col - 1 : tile_col ; //<S2SV> tile_data = pbi -> tile_data + tile_cols * tile_row + col ; //<S2SV> vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; //<S2SV> vp9_zero ( tile_data -> xd . left_context ) ; //<S2SV> vp9_zero ( tile_data -> xd . left_seg_context ) ; //<S2SV> for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; //<S2SV> mi_col += MI_BLOCK_SIZE ) { //<S2SV> decode_partition ( pbi , & tile_data -> xd , mi_row , //<S2SV> mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; //<S2SV> } //<S2SV> pbi -> mb . corrupted |= tile_data -> xd . corrupted ; //<S2SV> if ( pbi -> mb . corrupted ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data" ) ; //<S2SV> } //<S2SV> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { //<S2SV> const int lf_start = mi_row - MI_BLOCK_SIZE ; //<S2SV> LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; //<S2SV> if ( lf_start < 0 ) continue ; //<S2SV> if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; //<S2SV> winterface -> sync ( & pbi -> lf_worker ) ; //<S2SV> lf_data -> start = lf_start ; //<S2SV> lf_data -> stop = mi_row ; //<S2SV> if ( pbi -> max_threads > 1 ) { //<S2SV> winterface -> launch ( & pbi -> lf_worker ) ; //<S2SV> } else { //<S2SV> winterface -> execute ( & pbi -> lf_worker ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( pbi -> frame_parallel_decode ) //<S2SV> vp9_frameworker_broadcast ( pbi -> cur_buf , //<S2SV> mi_row << MI_BLOCK_SIZE_LOG2 ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { //<S2SV> LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; //<S2SV> winterface -> sync ( & pbi -> lf_worker ) ; //<S2SV> lf_data -> start = lf_data -> stop ; //<S2SV> lf_data -> stop = cm -> mi_rows ; //<S2SV> winterface -> execute ( & pbi -> lf_worker ) ; //<S2SV> } //<S2SV> tile_data = pbi -> tile_data + tile_cols * tile_rows - 1 ; //<S2SV> if ( pbi -> frame_parallel_decode ) //<S2SV> vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; //<S2SV> return vpx_reader_find_end ( & tile_data -> bit_reader ) ; //<S2SV> } //<S2SV> 