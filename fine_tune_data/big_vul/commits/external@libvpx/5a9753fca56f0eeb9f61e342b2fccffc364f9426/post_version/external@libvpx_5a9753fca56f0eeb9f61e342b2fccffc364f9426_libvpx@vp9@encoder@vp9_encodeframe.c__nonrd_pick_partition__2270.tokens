static void nonrd_pick_partition ( VP9_COMP * cpi , ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> TOKENEXTRA * * tp , int mi_row , //<S2SV> int mi_col , BLOCK_SIZE bsize , RD_COST * rd_cost , //<S2SV> int do_recon , int64_t best_rd , //<S2SV> PC_TREE * pc_tree ) { //<S2SV> const SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int ms = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> TOKENEXTRA * tp_orig = * tp ; //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; //<S2SV> int i ; //<S2SV> BLOCK_SIZE subsize = bsize ; //<S2SV> RD_COST this_rdc , sum_rdc , best_rdc ; //<S2SV> int do_split = bsize >= BLOCK_8X8 ; //<S2SV> int do_rect = 1 ; //<S2SV> const int force_horz_split = ( mi_row + ms >= cm -> mi_rows ) ; //<S2SV> const int force_vert_split = ( mi_col + ms >= cm -> mi_cols ) ; //<S2SV> const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; //<S2SV> const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; //<S2SV> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; //<S2SV> int partition_horz_allowed = ! force_vert_split && yss <= xss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> int partition_vert_allowed = ! force_horz_split && xss <= yss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> ( void ) * tp_orig ; //<S2SV> assert ( num_8x8_blocks_wide_lookup [ bsize ] == //<S2SV> num_8x8_blocks_high_lookup [ bsize ] ) ; //<S2SV> vp9_rd_cost_init ( & sum_rdc ) ; //<S2SV> vp9_rd_cost_reset ( & best_rdc ) ; //<S2SV> best_rdc . rdcost = best_rd ; //<S2SV> if ( sf -> auto_min_max_partition_size ) { //<S2SV> partition_none_allowed &= ( bsize <= x -> max_partition_size && //<S2SV> bsize >= x -> min_partition_size ) ; //<S2SV> partition_horz_allowed &= ( ( bsize <= x -> max_partition_size && //<S2SV> bsize > x -> min_partition_size ) || //<S2SV> force_horz_split ) ; //<S2SV> partition_vert_allowed &= ( ( bsize <= x -> max_partition_size && //<S2SV> bsize > x -> min_partition_size ) || //<S2SV> force_vert_split ) ; //<S2SV> do_split &= bsize > x -> min_partition_size ; //<S2SV> } //<S2SV> if ( sf -> use_square_partition_only ) { //<S2SV> partition_horz_allowed &= force_horz_split ; //<S2SV> partition_vert_allowed &= force_vert_split ; //<S2SV> } //<S2SV> ctx -> pred_pixel_ready = ! ( partition_vert_allowed || //<S2SV> partition_horz_allowed || //<S2SV> do_split ) ; //<S2SV> if ( partition_none_allowed ) { //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , //<S2SV> & this_rdc , bsize , ctx ) ; //<S2SV> ctx -> mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> ctx -> mbmi_ext = * x -> mbmi_ext ; //<S2SV> ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> ctx -> skip = x -> skip ; //<S2SV> if ( this_rdc . rate != INT_MAX ) { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> this_rdc . rate , this_rdc . dist ) ; //<S2SV> if ( this_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr ; //<S2SV> int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; //<S2SV> dist_breakout_thr >>= 8 - ( b_width_log2_lookup [ bsize ] + //<S2SV> b_height_log2_lookup [ bsize ] ) ; //<S2SV> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; //<S2SV> best_rdc = this_rdc ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> pc_tree -> partitioning = PARTITION_NONE ; //<S2SV> if ( ! x -> e_mbd . lossless && //<S2SV> this_rdc . rate < rate_breakout_thr && //<S2SV> this_rdc . dist < dist_breakout_thr ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> store_pred_mv ( x , ctx ) ; //<S2SV> if ( do_split ) { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> for ( i = 0 ; i < 4 && sum_rdc . rdcost < best_rdc . rdcost ; ++ i ) { //<S2SV> const int x_idx = ( i & 1 ) * ms ; //<S2SV> const int y_idx = ( i >> 1 ) * ms ; //<S2SV> if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) //<S2SV> continue ; //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> nonrd_pick_partition ( cpi , td , tile_data , tp , //<S2SV> mi_row + y_idx , mi_col + x_idx , //<S2SV> subsize , & this_rdc , 0 , //<S2SV> best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> vp9_rd_cost_reset ( & sum_rdc ) ; //<S2SV> } else { //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost += this_rdc . rdcost ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_SPLIT ; //<S2SV> } else { //<S2SV> if ( sf -> less_rectangular_check ) //<S2SV> do_rect &= ! partition_none_allowed ; //<S2SV> } //<S2SV> } //<S2SV> if ( partition_horz_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> if ( sf -> adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , //<S2SV> & pc_tree -> horizontal [ 0 ] ) ; //<S2SV> pc_tree -> horizontal [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> horizontal [ 0 ] . skip = x -> skip ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost && mi_row + ms < cm -> mi_rows ) { //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row + ms , mi_col , //<S2SV> & this_rdc , subsize , //<S2SV> & pc_tree -> horizontal [ 1 ] ) ; //<S2SV> pc_tree -> horizontal [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> horizontal [ 1 ] . skip = x -> skip ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> vp9_rd_cost_reset ( & sum_rdc ) ; //<S2SV> } else { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_HORZ ; //<S2SV> } else { //<S2SV> pred_pixel_ready_reset ( pc_tree , bsize ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( partition_vert_allowed && do_rect ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> if ( sf -> adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , //<S2SV> & pc_tree -> vertical [ 0 ] ) ; //<S2SV> pc_tree -> vertical [ 0 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> vertical [ 0 ] . skip = x -> skip ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost && mi_col + ms < cm -> mi_cols ) { //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; //<S2SV> nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + ms , //<S2SV> & this_rdc , subsize , //<S2SV> & pc_tree -> vertical [ 1 ] ) ; //<S2SV> pc_tree -> vertical [ 1 ] . mic . mbmi = xd -> mi [ 0 ] -> mbmi ; //<S2SV> pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; //<S2SV> pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; //<S2SV> pc_tree -> vertical [ 1 ] . skip = x -> skip ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> vp9_rd_cost_reset ( & sum_rdc ) ; //<S2SV> } else { //<S2SV> int pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_VERT ; //<S2SV> } else { //<S2SV> pred_pixel_ready_reset ( pc_tree , bsize ) ; //<S2SV> } //<S2SV> } //<S2SV> * rd_cost = best_rdc ; //<S2SV> if ( best_rdc . rate == INT_MAX ) { //<S2SV> vp9_rd_cost_reset ( rd_cost ) ; //<S2SV> return ; //<S2SV> } //<S2SV> fill_mode_info_sb ( cm , x , mi_row , mi_col , bsize , pc_tree ) ; //<S2SV> if ( best_rdc . rate < INT_MAX && best_rdc . dist < INT64_MAX && do_recon ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> encode_sb_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , //<S2SV> bsize , pc_tree ) ; //<S2SV> } //<S2SV> if ( bsize == BLOCK_64X64 && do_recon ) { //<S2SV> assert ( tp_orig < * tp ) ; //<S2SV> assert ( best_rdc . rate < INT_MAX ) ; //<S2SV> assert ( best_rdc . dist < INT64_MAX ) ; //<S2SV> } else { //<S2SV> assert ( tp_orig == * tp ) ; //<S2SV> } //<S2SV> } //<S2SV> 