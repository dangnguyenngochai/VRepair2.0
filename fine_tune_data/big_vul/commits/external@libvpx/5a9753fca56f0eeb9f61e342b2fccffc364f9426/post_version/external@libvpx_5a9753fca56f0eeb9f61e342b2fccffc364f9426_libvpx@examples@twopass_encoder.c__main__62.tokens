int main ( int argc , char * * argv ) { //<S2SV> FILE * infile = NULL ; //<S2SV> int w , h ; //<S2SV> vpx_codec_ctx_t codec ; //<S2SV> vpx_codec_enc_cfg_t cfg ; //<S2SV> vpx_image_t raw ; //<S2SV> vpx_codec_err_t res ; //<S2SV> vpx_fixed_buf_t stats ; //<S2SV> const VpxInterface * encoder = NULL ; //<S2SV> const int fps = 30 ; //<S2SV> const int bitrate = 200 ; //<S2SV> const char * const codec_arg = argv [ 1 ] ; //<S2SV> const char * const width_arg = argv [ 2 ] ; //<S2SV> const char * const height_arg = argv [ 3 ] ; //<S2SV> const char * const infile_arg = argv [ 4 ] ; //<S2SV> const char * const outfile_arg = argv [ 5 ] ; //<S2SV> exec_name = argv [ 0 ] ; //<S2SV> if ( argc != 6 ) //<S2SV> die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; //<S2SV> encoder = get_vpx_encoder_by_name ( codec_arg ) ; //<S2SV> if ( ! encoder ) //<S2SV> die ( "Unsupported<S2SV_blank>codec." ) ; //<S2SV> w = strtol ( width_arg , NULL , 0 ) ; //<S2SV> h = strtol ( height_arg , NULL , 0 ) ; //<S2SV> if ( w <= 0 || h <= 0 || ( w % 2 ) != 0 || ( h % 2 ) != 0 ) //<S2SV> die ( "Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d" , w , h ) ; //<S2SV> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , w , h , 1 ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image" , w , h ) ; //<S2SV> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; //<S2SV> res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; //<S2SV> if ( res ) //<S2SV> die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config." ) ; //<S2SV> cfg . g_w = w ; //<S2SV> cfg . g_h = h ; //<S2SV> cfg . g_timebase . num = 1 ; //<S2SV> cfg . g_timebase . den = fps ; //<S2SV> cfg . rc_target_bitrate = bitrate ; //<S2SV> if ( ! ( infile = fopen ( infile_arg , "rb" ) ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading" , infile_arg ) ; //<S2SV> cfg . g_pass = VPX_RC_FIRST_PASS ; //<S2SV> stats = pass0 ( & raw , infile , encoder , & cfg ) ; //<S2SV> rewind ( infile ) ; //<S2SV> cfg . g_pass = VPX_RC_LAST_PASS ; //<S2SV> cfg . rc_twopass_stats_in = stats ; //<S2SV> pass1 ( & raw , infile , outfile_arg , encoder , & cfg ) ; //<S2SV> free ( stats . buf ) ; //<S2SV> vpx_img_free ( & raw ) ; //<S2SV> fclose ( infile ) ; //<S2SV> return EXIT_SUCCESS ; //<S2SV> } //<S2SV> 