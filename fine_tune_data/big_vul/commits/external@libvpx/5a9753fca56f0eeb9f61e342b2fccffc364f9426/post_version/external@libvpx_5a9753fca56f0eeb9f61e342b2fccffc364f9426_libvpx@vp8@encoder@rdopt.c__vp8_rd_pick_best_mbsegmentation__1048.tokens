static int vp8_rd_pick_best_mbsegmentation ( VP8_COMP * cpi , MACROBLOCK * x , //<S2SV> int_mv * best_ref_mv , int best_rd , //<S2SV> int * mdcounts , int * returntotrate , //<S2SV> int * returnyrate , int * returndistortion , //<S2SV> int mvthresh ) //<S2SV> { //<S2SV> int i ; //<S2SV> BEST_SEG_INFO bsi ; //<S2SV> memset ( & bsi , 0 , sizeof ( bsi ) ) ; //<S2SV> bsi . segment_rd = best_rd ; //<S2SV> bsi . ref_mv = best_ref_mv ; //<S2SV> bsi . mvp . as_int = best_ref_mv -> as_int ; //<S2SV> bsi . mvthresh = mvthresh ; //<S2SV> bsi . mdcounts = mdcounts ; //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> bsi . modes [ i ] = ZERO4X4 ; //<S2SV> } //<S2SV> if ( cpi -> compressor_speed == 0 ) //<S2SV> { //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> int sr ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_8X8 ) ; //<S2SV> if ( bsi . segment_rd < best_rd ) //<S2SV> { //<S2SV> int col_min = ( ( best_ref_mv -> as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int row_min = ( ( best_ref_mv -> as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; //<S2SV> int col_max = ( best_ref_mv -> as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; //<S2SV> int row_max = ( best_ref_mv -> as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; //<S2SV> int tmp_col_min = x -> mv_col_min ; //<S2SV> int tmp_col_max = x -> mv_col_max ; //<S2SV> int tmp_row_min = x -> mv_row_min ; //<S2SV> int tmp_row_max = x -> mv_row_max ; //<S2SV> if ( x -> mv_col_min < col_min ) //<S2SV> x -> mv_col_min = col_min ; //<S2SV> if ( x -> mv_col_max > col_max ) //<S2SV> x -> mv_col_max = col_max ; //<S2SV> if ( x -> mv_row_min < row_min ) //<S2SV> x -> mv_row_min = row_min ; //<S2SV> if ( x -> mv_row_max > row_max ) //<S2SV> x -> mv_row_max = row_max ; //<S2SV> bsi . sv_mvp [ 0 ] . as_int = bsi . mvs [ 0 ] . as_int ; //<S2SV> bsi . sv_mvp [ 1 ] . as_int = bsi . mvs [ 2 ] . as_int ; //<S2SV> bsi . sv_mvp [ 2 ] . as_int = bsi . mvs [ 8 ] . as_int ; //<S2SV> bsi . sv_mvp [ 3 ] . as_int = bsi . mvs [ 10 ] . as_int ; //<S2SV> { //<S2SV> sr = MAXF ( ( abs ( bsi . sv_mvp [ 0 ] . as_mv . row - bsi . sv_mvp [ 2 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 0 ] . as_mv . col - bsi . sv_mvp [ 2 ] . as_mv . col ) ) >> 3 ) ; //<S2SV> vp8_cal_step_param ( sr , & bsi . sv_istep [ 0 ] ) ; //<S2SV> sr = MAXF ( ( abs ( bsi . sv_mvp [ 1 ] . as_mv . row - bsi . sv_mvp [ 3 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 1 ] . as_mv . col - bsi . sv_mvp [ 3 ] . as_mv . col ) ) >> 3 ) ; //<S2SV> vp8_cal_step_param ( sr , & bsi . sv_istep [ 1 ] ) ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_8X16 ) ; //<S2SV> } //<S2SV> { //<S2SV> sr = MAXF ( ( abs ( bsi . sv_mvp [ 0 ] . as_mv . row - bsi . sv_mvp [ 1 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 0 ] . as_mv . col - bsi . sv_mvp [ 1 ] . as_mv . col ) ) >> 3 ) ; //<S2SV> vp8_cal_step_param ( sr , & bsi . sv_istep [ 0 ] ) ; //<S2SV> sr = MAXF ( ( abs ( bsi . sv_mvp [ 2 ] . as_mv . row - bsi . sv_mvp [ 3 ] . as_mv . row ) ) >> 3 , ( abs ( bsi . sv_mvp [ 2 ] . as_mv . col - bsi . sv_mvp [ 3 ] . as_mv . col ) ) >> 3 ) ; //<S2SV> vp8_cal_step_param ( sr , & bsi . sv_istep [ 1 ] ) ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_16X8 ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . no_skip_block4x4_search || bsi . segment_num == BLOCK_8X8 ) //<S2SV> { //<S2SV> bsi . mvp . as_int = bsi . sv_mvp [ 0 ] . as_int ; //<S2SV> rd_check_segment ( cpi , x , & bsi , BLOCK_4X4 ) ; //<S2SV> } //<S2SV> x -> mv_col_min = tmp_col_min ; //<S2SV> x -> mv_col_max = tmp_col_max ; //<S2SV> x -> mv_row_min = tmp_row_min ; //<S2SV> x -> mv_row_max = tmp_row_max ; //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < 16 ; i ++ ) //<S2SV> { //<S2SV> BLOCKD * bd = & x -> e_mbd . block [ i ] ; //<S2SV> bd -> bmi . mv . as_int = bsi . mvs [ i ] . as_int ; //<S2SV> * bd -> eob = bsi . eobs [ i ] ; //<S2SV> } //<S2SV> * returntotrate = bsi . r ; //<S2SV> * returndistortion = bsi . d ; //<S2SV> * returnyrate = bsi . segment_yrate ; //<S2SV> x -> e_mbd . mode_info_context -> mbmi . partitioning = bsi . segment_num ; //<S2SV> x -> partition_info -> count = vp8_mbsplit_count [ bsi . segment_num ] ; //<S2SV> for ( i = 0 ; i < x -> partition_info -> count ; i ++ ) //<S2SV> { //<S2SV> int j ; //<S2SV> j = vp8_mbsplit_offset [ bsi . segment_num ] [ i ] ; //<S2SV> x -> partition_info -> bmi [ i ] . mode = bsi . modes [ j ] ; //<S2SV> x -> partition_info -> bmi [ i ] . mv . as_mv = bsi . mvs [ j ] . as_mv ; //<S2SV> } //<S2SV> x -> partition_info -> bmi [ 15 ] . mv . as_int = bsi . mvs [ 15 ] . as_int ; //<S2SV> return bsi . segment_rd ; //<S2SV> } //<S2SV> 