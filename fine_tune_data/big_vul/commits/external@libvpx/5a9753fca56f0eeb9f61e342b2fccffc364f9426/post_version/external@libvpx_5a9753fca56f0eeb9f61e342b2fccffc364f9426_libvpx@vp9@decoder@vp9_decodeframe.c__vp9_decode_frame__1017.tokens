void vp9_decode_frame ( VP9Decoder * pbi , //<S2SV> const uint8_t * data , const uint8_t * data_end , //<S2SV> const uint8_t * * p_data_end ) { //<S2SV> VP9_COMMON * const cm = & pbi -> common ; //<S2SV> MACROBLOCKD * const xd = & pbi -> mb ; //<S2SV> struct vpx_read_bit_buffer rb ; //<S2SV> int context_updated = 0 ; //<S2SV> uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] ; //<S2SV> const size_t first_partition_size = read_uncompressed_header ( pbi , //<S2SV> init_read_bit_buffer ( pbi , & rb , data , data_end , clear_data ) ) ; //<S2SV> const int tile_rows = 1 << cm -> log2_tile_rows ; //<S2SV> const int tile_cols = 1 << cm -> log2_tile_cols ; //<S2SV> YV12_BUFFER_CONFIG * const new_fb = get_frame_new_buffer ( cm ) ; //<S2SV> xd -> cur_buf = new_fb ; //<S2SV> if ( ! first_partition_size ) { //<S2SV> * p_data_end = data + ( cm -> profile <= PROFILE_2 ? 1 : 2 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> data += vpx_rb_bytes_read ( & rb ) ; //<S2SV> if ( ! read_is_valid ( data , first_partition_size , data_end ) ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Truncated<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>corrupt<S2SV_blank>header<S2SV_blank>length" ) ; //<S2SV> cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && //<S2SV> cm -> width == cm -> last_width && //<S2SV> cm -> height == cm -> last_height && //<S2SV> ! cm -> last_intra_only && //<S2SV> cm -> last_show_frame && //<S2SV> ( cm -> last_frame_type != KEY_FRAME ) ; //<S2SV> vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; //<S2SV> * cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; //<S2SV> if ( ! cm -> fc -> initialized ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Uninitialized<S2SV_blank>entropy<S2SV_blank>context." ) ; //<S2SV> vp9_zero ( cm -> counts ) ; //<S2SV> xd -> corrupted = 0 ; //<S2SV> new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; //<S2SV> if ( new_fb -> corrupted ) //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted." ) ; //<S2SV> if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { //<S2SV> vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ; //<S2SV> } //<S2SV> if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) { //<S2SV> VPxWorker * const worker = pbi -> frame_worker_owner ; //<S2SV> FrameWorkerData * const frame_worker_data = worker -> data1 ; //<S2SV> if ( cm -> refresh_frame_context ) { //<S2SV> context_updated = 1 ; //<S2SV> cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; //<S2SV> } //<S2SV> vp9_frameworker_lock_stats ( worker ) ; //<S2SV> pbi -> cur_buf -> row = - 1 ; //<S2SV> pbi -> cur_buf -> col = - 1 ; //<S2SV> frame_worker_data -> frame_context_ready = 1 ; //<S2SV> vp9_frameworker_signal_stats ( worker ) ; //<S2SV> vp9_frameworker_unlock_stats ( worker ) ; //<S2SV> } //<S2SV> if ( pbi -> max_threads > 1 && tile_rows == 1 && tile_cols > 1 ) { //<S2SV> * p_data_end = decode_tiles_mt ( pbi , data + first_partition_size , data_end ) ; //<S2SV> if ( ! xd -> corrupted ) { //<S2SV> if ( ! cm -> skip_loop_filter ) { //<S2SV> vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , //<S2SV> cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , //<S2SV> pbi -> num_tile_workers , & pbi -> lf_row_sync ) ; //<S2SV> } //<S2SV> } else { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted." ) ; //<S2SV> } //<S2SV> } else { //<S2SV> * p_data_end = decode_tiles ( pbi , data + first_partition_size , data_end ) ; //<S2SV> } //<S2SV> if ( ! xd -> corrupted ) { //<S2SV> if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { //<S2SV> vp9_adapt_coef_probs ( cm ) ; //<S2SV> if ( ! frame_is_intra_only ( cm ) ) { //<S2SV> vp9_adapt_mode_probs ( cm ) ; //<S2SV> vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; //<S2SV> } //<S2SV> } else { //<S2SV> debug_check_frame_counts ( cm ) ; //<S2SV> } //<S2SV> } else { //<S2SV> vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , //<S2SV> "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted." ) ; //<S2SV> } //<S2SV> if ( cm -> refresh_frame_context && ! context_updated ) //<S2SV> cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; //<S2SV> } //<S2SV> 