void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { //<S2SV> int i , j ; //<S2SV> nmv_context * fc = & cm -> fc -> nmvc ; //<S2SV> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; //<S2SV> const nmv_context_counts * counts = & cm -> counts . mv ; //<S2SV> vpx_tree_merge_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , //<S2SV> fc -> joints ) ; //<S2SV> for ( i = 0 ; i < 2 ; ++ i ) { //<S2SV> nmv_component * comp = & fc -> comps [ i ] ; //<S2SV> const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; //<S2SV> const nmv_component_counts * c = & counts -> comps [ i ] ; //<S2SV> comp -> sign = mode_mv_merge_probs ( pre_comp -> sign , c -> sign ) ; //<S2SV> vpx_tree_merge_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , //<S2SV> comp -> classes ) ; //<S2SV> vpx_tree_merge_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , //<S2SV> comp -> class0 ) ; //<S2SV> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) //<S2SV> comp -> bits [ j ] = mode_mv_merge_probs ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; //<S2SV> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) //<S2SV> vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , //<S2SV> c -> class0_fp [ j ] , comp -> class0_fp [ j ] ) ; //<S2SV> vpx_tree_merge_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; //<S2SV> if ( allow_hp ) { //<S2SV> comp -> class0_hp = mode_mv_merge_probs ( pre_comp -> class0_hp , c -> class0_hp ) ; //<S2SV> comp -> hp = mode_mv_merge_probs ( pre_comp -> hp , c -> hp ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 