static vpx_codec_err_t decoder_decode ( vpx_codec_alg_priv_t * ctx , //<S2SV> const uint8_t * data , unsigned int data_sz , //<S2SV> void * user_priv , long deadline ) { //<S2SV> const uint8_t * data_start = data ; //<S2SV> const uint8_t * const data_end = data + data_sz ; //<S2SV> vpx_codec_err_t res ; //<S2SV> uint32_t frame_sizes [ 8 ] ; //<S2SV> int frame_count ; //<S2SV> if ( data == NULL && data_sz == 0 ) { //<S2SV> ctx -> flushed = 1 ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> ctx -> flushed = 0 ; //<S2SV> if ( ctx -> frame_workers == NULL ) { //<S2SV> const vpx_codec_err_t res = init_decoder ( ctx ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> } //<S2SV> res = vp9_parse_superframe_index ( data , data_sz , frame_sizes , & frame_count , //<S2SV> ctx -> decrypt_cb , ctx -> decrypt_state ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> if ( ctx -> frame_parallel_decode ) { //<S2SV> if ( frame_count > 0 ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < frame_count ; ++ i ) { //<S2SV> const uint8_t * data_start_copy = data_start ; //<S2SV> const uint32_t frame_size = frame_sizes [ i ] ; //<S2SV> if ( data_start < data //<S2SV> || frame_size > ( uint32_t ) ( data_end - data_start ) ) { //<S2SV> set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; //<S2SV> return VPX_CODEC_CORRUPT_FRAME ; //<S2SV> } //<S2SV> if ( ctx -> available_threads == 0 ) { //<S2SV> if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { //<S2SV> wait_worker_and_cache_frame ( ctx ) ; //<S2SV> } else { //<S2SV> set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , //<S2SV> deadline ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> data_start += frame_size ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( ctx -> available_threads == 0 ) { //<S2SV> if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { //<S2SV> wait_worker_and_cache_frame ( ctx ) ; //<S2SV> } else { //<S2SV> set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; //<S2SV> return VPX_CODEC_ERROR ; //<S2SV> } //<S2SV> } //<S2SV> res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( frame_count > 0 ) { //<S2SV> int i ; //<S2SV> for ( i = 0 ; i < frame_count ; ++ i ) { //<S2SV> const uint8_t * data_start_copy = data_start ; //<S2SV> const uint32_t frame_size = frame_sizes [ i ] ; //<S2SV> vpx_codec_err_t res ; //<S2SV> if ( data_start < data //<S2SV> || frame_size > ( uint32_t ) ( data_end - data_start ) ) { //<S2SV> set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; //<S2SV> return VPX_CODEC_CORRUPT_FRAME ; //<S2SV> } //<S2SV> res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , //<S2SV> deadline ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> data_start += frame_size ; //<S2SV> } //<S2SV> } else { //<S2SV> while ( data_start < data_end ) { //<S2SV> const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; //<S2SV> const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , //<S2SV> user_priv , deadline ) ; //<S2SV> if ( res != VPX_CODEC_OK ) //<S2SV> return res ; //<S2SV> while ( data_start < data_end ) { //<S2SV> const uint8_t marker = read_marker ( ctx -> decrypt_cb , //<S2SV> ctx -> decrypt_state , data_start ) ; //<S2SV> if ( marker ) //<S2SV> break ; //<S2SV> ++ data_start ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> return res ; //<S2SV> } //<S2SV> 