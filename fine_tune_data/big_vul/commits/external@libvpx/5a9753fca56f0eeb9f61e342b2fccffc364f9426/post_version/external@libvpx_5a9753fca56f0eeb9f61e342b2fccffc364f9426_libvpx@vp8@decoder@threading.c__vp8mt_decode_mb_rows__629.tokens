void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) //<S2SV> { //<S2SV> VP8_COMMON * pc = & pbi -> common ; //<S2SV> unsigned int i ; //<S2SV> int j ; //<S2SV> int filter_level = pc -> filter_level ; //<S2SV> YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; //<S2SV> if ( filter_level ) //<S2SV> { //<S2SV> memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; //<S2SV> memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; //<S2SV> memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; //<S2SV> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) //<S2SV> { //<S2SV> memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; //<S2SV> memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; //<S2SV> memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; //<S2SV> } //<S2SV> for ( j = 0 ; j < pc -> mb_rows ; j ++ ) //<S2SV> { //<S2SV> memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; //<S2SV> memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; //<S2SV> memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; //<S2SV> } //<S2SV> vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; //<S2SV> } //<S2SV> else //<S2SV> vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; //<S2SV> setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; //<S2SV> for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) //<S2SV> sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; //<S2SV> mt_decode_mb_rows ( pbi , xd , 0 ) ; //<S2SV> sem_wait ( & pbi -> h_event_end_decoding ) ; //<S2SV> } //<S2SV> 