static void rd_use_partition ( VP9_COMP * cpi , //<S2SV> ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> MODE_INFO * * mi_8x8 , TOKENEXTRA * * tp , //<S2SV> int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , //<S2SV> int * rate , int64_t * dist , //<S2SV> int do_recon , PC_TREE * pc_tree ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int mis = cm -> mi_stride ; //<S2SV> const int bsl = b_width_log2_lookup [ bsize ] ; //<S2SV> const int mi_step = num_4x4_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> const int bss = ( 1 << bsl ) / 4 ; //<S2SV> int i , pl ; //<S2SV> PARTITION_TYPE partition = PARTITION_NONE ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> RD_COST last_part_rdc , none_rdc , chosen_rdc ; //<S2SV> BLOCK_SIZE sub_subsize = BLOCK_4X4 ; //<S2SV> int splits_below = 0 ; //<S2SV> BLOCK_SIZE bs_type = mi_8x8 [ 0 ] -> mbmi . sb_type ; //<S2SV> int do_partition_search = 1 ; //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; //<S2SV> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) //<S2SV> return ; //<S2SV> assert ( num_4x4_blocks_wide_lookup [ bsize ] == //<S2SV> num_4x4_blocks_high_lookup [ bsize ] ) ; //<S2SV> vp9_rd_cost_reset ( & last_part_rdc ) ; //<S2SV> vp9_rd_cost_reset ( & none_rdc ) ; //<S2SV> vp9_rd_cost_reset ( & chosen_rdc ) ; //<S2SV> partition = partition_lookup [ bsl ] [ bs_type ] ; //<S2SV> subsize = get_subsize ( bsize , partition ) ; //<S2SV> pc_tree -> partitioning = partition ; //<S2SV> save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) { //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; //<S2SV> x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> } //<S2SV> if ( do_partition_search && //<S2SV> cpi -> sf . partition_search_type == SEARCH_PARTITION && //<S2SV> cpi -> sf . adjust_partitioning_from_last_frame ) { //<S2SV> if ( partition == PARTITION_SPLIT && subsize > BLOCK_8X8 ) { //<S2SV> sub_subsize = get_subsize ( subsize , PARTITION_SPLIT ) ; //<S2SV> splits_below = 1 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int jj = i >> 1 , ii = i & 0x01 ; //<S2SV> MODE_INFO * this_mi = mi_8x8 [ jj * bss * mis + ii * bss ] ; //<S2SV> if ( this_mi && this_mi -> mbmi . sb_type >= sub_subsize ) { //<S2SV> splits_below = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( partition != PARTITION_NONE && ! splits_below && //<S2SV> mi_row + ( mi_step >> 1 ) < cm -> mi_rows && //<S2SV> mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { //<S2SV> pc_tree -> partitioning = PARTITION_NONE ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & none_rdc , bsize , //<S2SV> ctx , INT64_MAX ) ; //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( none_rdc . rate < INT_MAX ) { //<S2SV> none_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> none_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , none_rdc . rate , //<S2SV> none_rdc . dist ) ; //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> mi_8x8 [ 0 ] -> mbmi . sb_type = bs_type ; //<S2SV> pc_tree -> partitioning = partition ; //<S2SV> } //<S2SV> } //<S2SV> switch ( partition ) { //<S2SV> case PARTITION_NONE : //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , //<S2SV> bsize , ctx , INT64_MAX ) ; //<S2SV> break ; //<S2SV> case PARTITION_HORZ : //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , //<S2SV> subsize , & pc_tree -> horizontal [ 0 ] , //<S2SV> INT64_MAX ) ; //<S2SV> if ( last_part_rdc . rate != INT_MAX && //<S2SV> bsize >= BLOCK_8X8 && mi_row + ( mi_step >> 1 ) < cm -> mi_rows ) { //<S2SV> RD_COST tmp_rdc ; //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; //<S2SV> vp9_rd_cost_init ( & tmp_rdc ) ; //<S2SV> update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , //<S2SV> mi_row + ( mi_step >> 1 ) , mi_col , & tmp_rdc , //<S2SV> subsize , & pc_tree -> horizontal [ 1 ] , INT64_MAX ) ; //<S2SV> if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { //<S2SV> vp9_rd_cost_reset ( & last_part_rdc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rdc . rate += tmp_rdc . rate ; //<S2SV> last_part_rdc . dist += tmp_rdc . dist ; //<S2SV> last_part_rdc . rdcost += tmp_rdc . rdcost ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_VERT : //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , //<S2SV> subsize , & pc_tree -> vertical [ 0 ] , INT64_MAX ) ; //<S2SV> if ( last_part_rdc . rate != INT_MAX && //<S2SV> bsize >= BLOCK_8X8 && mi_col + ( mi_step >> 1 ) < cm -> mi_cols ) { //<S2SV> RD_COST tmp_rdc ; //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; //<S2SV> vp9_rd_cost_init ( & tmp_rdc ) ; //<S2SV> update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , //<S2SV> mi_row , mi_col + ( mi_step >> 1 ) , & tmp_rdc , //<S2SV> subsize , & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , //<S2SV> INT64_MAX ) ; //<S2SV> if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { //<S2SV> vp9_rd_cost_reset ( & last_part_rdc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rdc . rate += tmp_rdc . rate ; //<S2SV> last_part_rdc . dist += tmp_rdc . dist ; //<S2SV> last_part_rdc . rdcost += tmp_rdc . rdcost ; //<S2SV> } //<S2SV> break ; //<S2SV> case PARTITION_SPLIT : //<S2SV> if ( bsize == BLOCK_8X8 ) { //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , //<S2SV> subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rdc . rate = 0 ; //<S2SV> last_part_rdc . dist = 0 ; //<S2SV> last_part_rdc . rdcost = 0 ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; //<S2SV> int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; //<S2SV> int jj = i >> 1 , ii = i & 0x01 ; //<S2SV> RD_COST tmp_rdc ; //<S2SV> if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) //<S2SV> continue ; //<S2SV> vp9_rd_cost_init ( & tmp_rdc ) ; //<S2SV> rd_use_partition ( cpi , td , tile_data , //<S2SV> mi_8x8 + jj * bss * mis + ii * bss , tp , //<S2SV> mi_row + y_idx , mi_col + x_idx , subsize , //<S2SV> & tmp_rdc . rate , & tmp_rdc . dist , //<S2SV> i != 3 , pc_tree -> split [ i ] ) ; //<S2SV> if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { //<S2SV> vp9_rd_cost_reset ( & last_part_rdc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> last_part_rdc . rate += tmp_rdc . rate ; //<S2SV> last_part_rdc . dist += tmp_rdc . dist ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( last_part_rdc . rate < INT_MAX ) { //<S2SV> last_part_rdc . rate += cpi -> partition_cost [ pl ] [ partition ] ; //<S2SV> last_part_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> last_part_rdc . rate , last_part_rdc . dist ) ; //<S2SV> } //<S2SV> if ( do_partition_search //<S2SV> && cpi -> sf . adjust_partitioning_from_last_frame //<S2SV> && cpi -> sf . partition_search_type == SEARCH_PARTITION //<S2SV> && partition != PARTITION_SPLIT && bsize > BLOCK_8X8 //<S2SV> && ( mi_row + mi_step < cm -> mi_rows || //<S2SV> mi_row + ( mi_step >> 1 ) == cm -> mi_rows ) //<S2SV> && ( mi_col + mi_step < cm -> mi_cols || //<S2SV> mi_col + ( mi_step >> 1 ) == cm -> mi_cols ) ) { //<S2SV> BLOCK_SIZE split_subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> chosen_rdc . rate = 0 ; //<S2SV> chosen_rdc . dist = 0 ; //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> pc_tree -> partitioning = PARTITION_SPLIT ; //<S2SV> for ( i = 0 ; i < 4 ; i ++ ) { //<S2SV> int x_idx = ( i & 1 ) * ( mi_step >> 1 ) ; //<S2SV> int y_idx = ( i >> 1 ) * ( mi_step >> 1 ) ; //<S2SV> RD_COST tmp_rdc ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> if ( ( mi_row + y_idx >= cm -> mi_rows ) || ( mi_col + x_idx >= cm -> mi_cols ) ) //<S2SV> continue ; //<S2SV> save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , //<S2SV> mi_row + y_idx , mi_col + x_idx , & tmp_rdc , //<S2SV> split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( tmp_rdc . rate == INT_MAX || tmp_rdc . dist == INT64_MAX ) { //<S2SV> vp9_rd_cost_reset ( & chosen_rdc ) ; //<S2SV> break ; //<S2SV> } //<S2SV> chosen_rdc . rate += tmp_rdc . rate ; //<S2SV> chosen_rdc . dist += tmp_rdc . dist ; //<S2SV> if ( i != 3 ) //<S2SV> encode_sb ( cpi , td , tile_info , tp , mi_row + y_idx , mi_col + x_idx , 0 , //<S2SV> split_subsize , pc_tree -> split [ i ] ) ; //<S2SV> pl = partition_plane_context ( xd , mi_row + y_idx , mi_col + x_idx , //<S2SV> split_subsize ) ; //<S2SV> chosen_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> } //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> if ( chosen_rdc . rate < INT_MAX ) { //<S2SV> chosen_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> chosen_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> chosen_rdc . rate , chosen_rdc . dist ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( last_part_rdc . rdcost < chosen_rdc . rdcost ) { //<S2SV> mi_8x8 [ 0 ] -> mbmi . sb_type = bsize ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> pc_tree -> partitioning = partition ; //<S2SV> chosen_rdc = last_part_rdc ; //<S2SV> } //<S2SV> if ( none_rdc . rdcost < chosen_rdc . rdcost ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> pc_tree -> partitioning = PARTITION_NONE ; //<S2SV> chosen_rdc = none_rdc ; //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> if ( bsize == BLOCK_64X64 ) //<S2SV> assert ( chosen_rdc . rate < INT_MAX && chosen_rdc . dist < INT64_MAX ) ; //<S2SV> if ( do_recon ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , bsize , //<S2SV> pc_tree ) ; //<S2SV> } //<S2SV> * rate = chosen_rdc . rate ; //<S2SV> * dist = chosen_rdc . dist ; //<S2SV> } //<S2SV> 