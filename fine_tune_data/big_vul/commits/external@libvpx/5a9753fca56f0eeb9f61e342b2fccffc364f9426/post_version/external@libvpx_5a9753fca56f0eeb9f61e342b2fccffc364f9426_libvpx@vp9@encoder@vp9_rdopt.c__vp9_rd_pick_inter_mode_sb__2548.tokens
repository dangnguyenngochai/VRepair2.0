void vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , //<S2SV> TileDataEnc * tile_data , //<S2SV> MACROBLOCK * x , //<S2SV> int mi_row , int mi_col , //<S2SV> RD_COST * rd_cost , BLOCK_SIZE bsize , //<S2SV> PICK_MODE_CONTEXT * ctx , //<S2SV> int64_t best_rd_so_far ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> RD_OPT * const rd_opt = & cpi -> rd ; //<S2SV> SPEED_FEATURES * const sf = & cpi -> sf ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> PREDICTION_MODE this_mode ; //<S2SV> MV_REFERENCE_FRAME ref_frame , second_ref_frame ; //<S2SV> unsigned char segment_id = mbmi -> segment_id ; //<S2SV> int comp_pred , i , k ; //<S2SV> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; //<S2SV> int_mv single_newmv [ MAX_REF_FRAMES ] = { { 0 } } ; //<S2SV> INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; //<S2SV> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , //<S2SV> VP9_ALT_FLAG } ; //<S2SV> int64_t best_rd = best_rd_so_far ; //<S2SV> int64_t best_pred_diff [ REFERENCE_MODES ] ; //<S2SV> int64_t best_pred_rd [ REFERENCE_MODES ] ; //<S2SV> int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> MB_MODE_INFO best_mbmode ; //<S2SV> int best_mode_skippable = 0 ; //<S2SV> int midx , best_mode_index = - 1 ; //<S2SV> unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; //<S2SV> vpx_prob comp_mode_p ; //<S2SV> int64_t best_intra_rd = INT64_MAX ; //<S2SV> unsigned int best_pred_sse = UINT_MAX ; //<S2SV> PREDICTION_MODE best_intra_mode = DC_PRED ; //<S2SV> int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; //<S2SV> int64_t dist_uv [ TX_SIZES ] ; //<S2SV> int skip_uv [ TX_SIZES ] ; //<S2SV> PREDICTION_MODE mode_uv [ TX_SIZES ] ; //<S2SV> const int intra_cost_penalty = vp9_get_intra_cost_penalty ( //<S2SV> cm -> base_qindex , cm -> y_dc_delta_q , cm -> bit_depth ) ; //<S2SV> int best_skip2 = 0 ; //<S2SV> uint8_t ref_frame_skip_mask [ 2 ] = { 0 } ; //<S2SV> uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = { 0 } ; //<S2SV> int mode_skip_start = sf -> mode_skip_start + 1 ; //<S2SV> const int * const rd_threshes = rd_opt -> threshes [ segment_id ] [ bsize ] ; //<S2SV> const int * const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ; //<S2SV> int64_t mode_threshold [ MAX_MODES ] ; //<S2SV> int * mode_map = tile_data -> mode_map [ bsize ] ; //<S2SV> const int mode_search_skip_flags = sf -> mode_search_skip_flags ; //<S2SV> int64_t mask_filter = 0 ; //<S2SV> int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; //<S2SV> vp9_zero ( best_mbmode ) ; //<S2SV> x -> skip_encode = sf -> skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) //<S2SV> filter_cache [ i ] = INT64_MAX ; //<S2SV> estimate_ref_frame_costs ( cm , xd , segment_id , ref_costs_single , ref_costs_comp , //<S2SV> & comp_mode_p ) ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = INT64_MAX ; //<S2SV> for ( i = 0 ; i < TX_SIZES ; i ++ ) //<S2SV> rate_uv_intra [ i ] = INT_MAX ; //<S2SV> for ( i = 0 ; i < MAX_REF_FRAMES ; ++ i ) //<S2SV> x -> pred_sse [ i ] = INT_MAX ; //<S2SV> for ( i = 0 ; i < MB_MODE_COUNT ; ++ i ) { //<S2SV> for ( k = 0 ; k < MAX_REF_FRAMES ; ++ k ) { //<S2SV> single_inter_filter [ i ] [ k ] = SWITCHABLE ; //<S2SV> single_skippable [ i ] [ k ] = 0 ; //<S2SV> } //<S2SV> } //<S2SV> rd_cost -> rate = INT_MAX ; //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> x -> pred_mv_sad [ ref_frame ] = INT_MAX ; //<S2SV> if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { //<S2SV> assert ( get_ref_frame_buffer ( cpi , ref_frame ) != NULL ) ; //<S2SV> setup_buffer_inter ( cpi , x , ref_frame , bsize , mi_row , mi_col , //<S2SV> frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ; //<S2SV> } //<S2SV> frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; //<S2SV> frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; //<S2SV> } //<S2SV> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) { //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> } else if ( sf -> reference_masking ) { //<S2SV> for ( i = LAST_FRAME ; i <= ALTREF_FRAME ; ++ i ) { //<S2SV> if ( ( x -> pred_mv_sad [ ref_frame ] >> 2 ) > x -> pred_mv_sad [ i ] ) { //<S2SV> mode_skip_mask [ ref_frame ] |= INTER_NEAREST_NEAR_ZERO ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && //<S2SV> get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { //<S2SV> if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { //<S2SV> ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ; //<S2SV> ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; //<S2SV> mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO ; //<S2SV> if ( frame_mv [ NEARMV ] [ ALTREF_FRAME ] . as_int != 0 ) //<S2SV> mode_skip_mask [ ALTREF_FRAME ] |= ( 1 << NEARMV ) ; //<S2SV> if ( frame_mv [ NEARESTMV ] [ ALTREF_FRAME ] . as_int != 0 ) //<S2SV> mode_skip_mask [ ALTREF_FRAME ] |= ( 1 << NEARESTMV ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cpi -> rc . is_src_frame_alt_ref ) { //<S2SV> if ( sf -> alt_ref_search_fp ) { //<S2SV> mode_skip_mask [ ALTREF_FRAME ] = 0 ; //<S2SV> ref_frame_skip_mask [ 0 ] = ~ ( 1 << ALTREF_FRAME ) ; //<S2SV> ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; //<S2SV> } //<S2SV> } //<S2SV> if ( sf -> alt_ref_search_fp ) //<S2SV> if ( ! cm -> show_frame && x -> pred_mv_sad [ GOLDEN_FRAME ] < INT_MAX ) //<S2SV> if ( x -> pred_mv_sad [ ALTREF_FRAME ] > ( x -> pred_mv_sad [ GOLDEN_FRAME ] << 1 ) ) //<S2SV> mode_skip_mask [ ALTREF_FRAME ] |= INTER_ALL ; //<S2SV> if ( sf -> adaptive_mode_search ) { //<S2SV> if ( cm -> show_frame && ! cpi -> rc . is_src_frame_alt_ref && //<S2SV> cpi -> rc . frames_since_golden >= 3 ) //<S2SV> if ( x -> pred_mv_sad [ GOLDEN_FRAME ] > ( x -> pred_mv_sad [ LAST_FRAME ] << 1 ) ) //<S2SV> mode_skip_mask [ GOLDEN_FRAME ] |= INTER_ALL ; //<S2SV> } //<S2SV> if ( bsize > sf -> max_intra_bsize ) { //<S2SV> ref_frame_skip_mask [ 0 ] |= ( 1 << INTRA_FRAME ) ; //<S2SV> ref_frame_skip_mask [ 1 ] |= ( 1 << INTRA_FRAME ) ; //<S2SV> } //<S2SV> mode_skip_mask [ INTRA_FRAME ] |= //<S2SV> ~ ( sf -> intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ) ; //<S2SV> for ( i = 0 ; i <= LAST_NEW_MV_INDEX ; ++ i ) //<S2SV> mode_threshold [ i ] = 0 ; //<S2SV> for ( i = LAST_NEW_MV_INDEX + 1 ; i < MAX_MODES ; ++ i ) //<S2SV> mode_threshold [ i ] = ( ( int64_t ) rd_threshes [ i ] * rd_thresh_freq_fact [ i ] ) >> 5 ; //<S2SV> midx = sf -> schedule_mode_search ? mode_skip_start : 0 ; //<S2SV> while ( midx > 4 ) { //<S2SV> uint8_t end_pos = 0 ; //<S2SV> for ( i = 5 ; i < midx ; ++ i ) { //<S2SV> if ( mode_threshold [ mode_map [ i - 1 ] ] > mode_threshold [ mode_map [ i ] ] ) { //<S2SV> uint8_t tmp = mode_map [ i ] ; //<S2SV> mode_map [ i ] = mode_map [ i - 1 ] ; //<S2SV> mode_map [ i - 1 ] = tmp ; //<S2SV> end_pos = i ; //<S2SV> } //<S2SV> } //<S2SV> midx = end_pos ; //<S2SV> } //<S2SV> for ( midx = 0 ; midx < MAX_MODES ; ++ midx ) { //<S2SV> int mode_index = mode_map [ midx ] ; //<S2SV> int mode_excluded = 0 ; //<S2SV> int64_t this_rd = INT64_MAX ; //<S2SV> int disable_skip = 0 ; //<S2SV> int compmode_cost = 0 ; //<S2SV> int rate2 = 0 , rate_y = 0 , rate_uv = 0 ; //<S2SV> int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ; //<S2SV> int skippable = 0 ; //<S2SV> int this_skip2 = 0 ; //<S2SV> int64_t total_sse = INT64_MAX ; //<S2SV> int early_term = 0 ; //<S2SV> this_mode = vp9_mode_order [ mode_index ] . mode ; //<S2SV> ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; //<S2SV> second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; //<S2SV> if ( midx == mode_skip_start && best_mode_index >= 0 ) { //<S2SV> switch ( best_mbmode . ref_frame [ 0 ] ) { //<S2SV> case INTRA_FRAME : //<S2SV> break ; //<S2SV> case LAST_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= LAST_FRAME_MODE_MASK ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> break ; //<S2SV> case GOLDEN_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= GOLDEN_FRAME_MODE_MASK ; //<S2SV> ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; //<S2SV> break ; //<S2SV> case ALTREF_FRAME : //<S2SV> ref_frame_skip_mask [ 0 ] |= ALT_REF_MODE_MASK ; //<S2SV> break ; //<S2SV> case NONE : //<S2SV> case MAX_REF_FRAMES : //<S2SV> assert ( 0 && "Invalid<S2SV_blank>Reference<S2SV_blank>frame" ) ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && //<S2SV> ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) //<S2SV> continue ; //<S2SV> if ( mode_skip_mask [ ref_frame ] & ( 1 << this_mode ) ) //<S2SV> continue ; //<S2SV> if ( best_mode_skippable && sf -> schedule_mode_search ) //<S2SV> mode_threshold [ mode_index ] <<= 1 ; //<S2SV> if ( best_rd < mode_threshold [ mode_index ] ) //<S2SV> continue ; //<S2SV> if ( sf -> motion_field_mode_search ) { //<S2SV> const int mi_width = MIN ( num_8x8_blocks_wide_lookup [ bsize ] , //<S2SV> tile_info -> mi_col_end - mi_col ) ; //<S2SV> const int mi_height = MIN ( num_8x8_blocks_high_lookup [ bsize ] , //<S2SV> tile_info -> mi_row_end - mi_row ) ; //<S2SV> const int bsl = mi_width_log2_lookup [ bsize ] ; //<S2SV> int cb_partition_search_ctrl = ( ( ( mi_row + mi_col ) >> bsl ) //<S2SV> + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; //<S2SV> MB_MODE_INFO * ref_mbmi ; //<S2SV> int const_motion = 1 ; //<S2SV> int skip_ref_frame = ! cb_partition_search_ctrl ; //<S2SV> MV_REFERENCE_FRAME rf = NONE ; //<S2SV> int_mv ref_mv ; //<S2SV> ref_mv . as_int = INVALID_MV ; //<S2SV> if ( ( mi_row - 1 ) >= tile_info -> mi_row_start ) { //<S2SV> ref_mv = xd -> mi [ - xd -> mi_stride ] -> mbmi . mv [ 0 ] ; //<S2SV> rf = xd -> mi [ - xd -> mi_stride ] -> mbmi . ref_frame [ 0 ] ; //<S2SV> for ( i = 0 ; i < mi_width ; ++ i ) { //<S2SV> ref_mbmi = & xd -> mi [ - xd -> mi_stride + i ] -> mbmi ; //<S2SV> const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && //<S2SV> ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; //<S2SV> skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( ( mi_col - 1 ) >= tile_info -> mi_col_start ) { //<S2SV> if ( ref_mv . as_int == INVALID_MV ) //<S2SV> ref_mv = xd -> mi [ - 1 ] -> mbmi . mv [ 0 ] ; //<S2SV> if ( rf == NONE ) //<S2SV> rf = xd -> mi [ - 1 ] -> mbmi . ref_frame [ 0 ] ; //<S2SV> for ( i = 0 ; i < mi_height ; ++ i ) { //<S2SV> ref_mbmi = & xd -> mi [ i * xd -> mi_stride - 1 ] -> mbmi ; //<S2SV> const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && //<S2SV> ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; //<S2SV> skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( skip_ref_frame && this_mode != NEARESTMV && this_mode != NEWMV ) //<S2SV> if ( rf > INTRA_FRAME ) //<S2SV> if ( ref_frame != rf ) //<S2SV> continue ; //<S2SV> if ( const_motion ) //<S2SV> if ( this_mode == NEARMV || this_mode == ZEROMV ) //<S2SV> continue ; //<S2SV> } //<S2SV> comp_pred = second_ref_frame > INTRA_FRAME ; //<S2SV> if ( comp_pred ) { //<S2SV> if ( ! cpi -> allow_comp_inter_inter ) //<S2SV> continue ; //<S2SV> if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) //<S2SV> continue ; //<S2SV> if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) //<S2SV> continue ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && //<S2SV> best_mode_index >= 0 && best_mbmode . ref_frame [ 0 ] == INTRA_FRAME ) //<S2SV> continue ; //<S2SV> mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; //<S2SV> } else { //<S2SV> if ( ref_frame != INTRA_FRAME ) //<S2SV> mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; //<S2SV> } //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> if ( sf -> adaptive_mode_search ) //<S2SV> if ( ( x -> source_variance << num_pels_log2_lookup [ bsize ] ) > best_pred_sse ) //<S2SV> continue ; //<S2SV> if ( this_mode != DC_PRED ) { //<S2SV> const unsigned int skip_intra_var_thresh = 64 ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_LOWVAR ) && //<S2SV> x -> source_variance < skip_intra_var_thresh ) //<S2SV> continue ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_BESTINTER ) && //<S2SV> ( this_mode >= D45_PRED && this_mode <= TM_PRED ) ) { //<S2SV> if ( best_mode_index >= 0 && //<S2SV> best_mbmode . ref_frame [ 0 ] > INTRA_FRAME ) //<S2SV> continue ; //<S2SV> } //<S2SV> if ( mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { //<S2SV> if ( conditional_skipintra ( this_mode , best_intra_mode ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> const MV_REFERENCE_FRAME ref_frames [ 2 ] = { ref_frame , second_ref_frame } ; //<S2SV> if ( ! check_best_zero_mv ( cpi , mbmi_ext -> mode_context , frame_mv , //<S2SV> this_mode , ref_frames ) ) //<S2SV> continue ; //<S2SV> } //<S2SV> mbmi -> mode = this_mode ; //<S2SV> mbmi -> uv_mode = DC_PRED ; //<S2SV> mbmi -> ref_frame [ 0 ] = ref_frame ; //<S2SV> mbmi -> ref_frame [ 1 ] = second_ref_frame ; //<S2SV> mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP //<S2SV> : cm -> interp_filter ; //<S2SV> mbmi -> mv [ 0 ] . as_int = mbmi -> mv [ 1 ] . as_int = 0 ; //<S2SV> x -> skip = 0 ; //<S2SV> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; //<S2SV> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { //<S2SV> xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; //<S2SV> if ( comp_pred ) //<S2SV> xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ; //<S2SV> } //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> TX_SIZE uv_tx ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ 1 ] ; //<S2SV> memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; //<S2SV> super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , //<S2SV> NULL , bsize , best_rd ) ; //<S2SV> if ( rate_y == INT_MAX ) //<S2SV> continue ; //<S2SV> uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize , pd -> subsampling_x , //<S2SV> pd -> subsampling_y ) ; //<S2SV> if ( rate_uv_intra [ uv_tx ] == INT_MAX ) { //<S2SV> choose_intra_uv_mode ( cpi , x , ctx , bsize , uv_tx , //<S2SV> & rate_uv_intra [ uv_tx ] , & rate_uv_tokenonly [ uv_tx ] , //<S2SV> & dist_uv [ uv_tx ] , & skip_uv [ uv_tx ] , & mode_uv [ uv_tx ] ) ; //<S2SV> } //<S2SV> rate_uv = rate_uv_tokenonly [ uv_tx ] ; //<S2SV> distortion_uv = dist_uv [ uv_tx ] ; //<S2SV> skippable = skippable && skip_uv [ uv_tx ] ; //<S2SV> mbmi -> uv_mode = mode_uv [ uv_tx ] ; //<S2SV> rate2 = rate_y + cpi -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ; //<S2SV> if ( this_mode != DC_PRED && this_mode != TM_PRED ) //<S2SV> rate2 += intra_cost_penalty ; //<S2SV> distortion2 = distortion_y + distortion_uv ; //<S2SV> } else { //<S2SV> this_rd = handle_inter_mode ( cpi , x , bsize , //<S2SV> & rate2 , & distortion2 , & skippable , //<S2SV> & rate_y , & rate_uv , //<S2SV> & disable_skip , frame_mv , //<S2SV> mi_row , mi_col , //<S2SV> single_newmv , single_inter_filter , //<S2SV> single_skippable , & total_sse , best_rd , //<S2SV> & mask_filter , filter_cache ) ; //<S2SV> if ( this_rd == INT64_MAX ) //<S2SV> continue ; //<S2SV> compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) //<S2SV> rate2 += compmode_cost ; //<S2SV> } //<S2SV> if ( comp_pred ) { //<S2SV> rate2 += ref_costs_comp [ ref_frame ] ; //<S2SV> } else { //<S2SV> rate2 += ref_costs_single [ ref_frame ] ; //<S2SV> } //<S2SV> if ( ! disable_skip ) { //<S2SV> if ( skippable ) { //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> } else if ( ref_frame != INTRA_FRAME && ! xd -> lossless ) { //<S2SV> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < //<S2SV> RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; //<S2SV> distortion2 = total_sse ; //<S2SV> assert ( total_sse >= 0 ) ; //<S2SV> rate2 -= ( rate_y + rate_uv ) ; //<S2SV> this_skip2 = 1 ; //<S2SV> } //<S2SV> } else { //<S2SV> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; //<S2SV> } //<S2SV> this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; //<S2SV> } //<S2SV> rd_variance_adjustment ( cpi , x , bsize , & this_rd , //<S2SV> ref_frame , x -> source_variance ) ; //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> if ( this_rd < best_intra_rd ) { //<S2SV> best_intra_rd = this_rd ; //<S2SV> best_intra_mode = mbmi -> mode ; //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame == INTRA_FRAME ) { //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) //<S2SV> best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; //<S2SV> } //<S2SV> if ( this_rd < best_rd || x -> skip ) { //<S2SV> int max_plane = MAX_MB_PLANE ; //<S2SV> if ( ! mode_excluded ) { //<S2SV> best_mode_index = mode_index ; //<S2SV> if ( ref_frame == INTRA_FRAME ) { //<S2SV> mbmi -> mv [ 0 ] . as_int = 0 ; //<S2SV> max_plane = 1 ; //<S2SV> } else { //<S2SV> best_pred_sse = x -> pred_sse [ ref_frame ] ; //<S2SV> } //<S2SV> rd_cost -> rate = rate2 ; //<S2SV> rd_cost -> dist = distortion2 ; //<S2SV> rd_cost -> rdcost = this_rd ; //<S2SV> best_rd = this_rd ; //<S2SV> best_mbmode = * mbmi ; //<S2SV> best_skip2 = this_skip2 ; //<S2SV> best_mode_skippable = skippable ; //<S2SV> if ( ! x -> select_tx_size ) //<S2SV> swap_block_ptr ( x , ctx , 1 , 0 , 0 , max_plane ) ; //<S2SV> memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , //<S2SV> sizeof ( ctx -> zcoeff_blk [ 0 ] ) * ctx -> num_4x4_blk ) ; //<S2SV> if ( ( mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && //<S2SV> ( mode_index > MIN_EARLY_TERM_INDEX ) ) { //<S2SV> int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; //<S2SV> int scale = 4 ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> qstep >>= ( xd -> bd - 8 ) ; //<S2SV> } //<S2SV> # endif //<S2SV> if ( x -> source_variance < UINT_MAX ) { //<S2SV> const int var_adjust = ( x -> source_variance < 16 ) ; //<S2SV> scale -= var_adjust ; //<S2SV> } //<S2SV> if ( ref_frame > INTRA_FRAME && //<S2SV> distortion2 * scale < qstep * qstep ) { //<S2SV> early_term = 1 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( ! disable_skip && ref_frame != INTRA_FRAME ) { //<S2SV> int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ; //<S2SV> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { //<S2SV> single_rate = rate2 - compmode_cost ; //<S2SV> hybrid_rate = rate2 ; //<S2SV> } else { //<S2SV> single_rate = rate2 ; //<S2SV> hybrid_rate = rate2 + compmode_cost ; //<S2SV> } //<S2SV> single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ; //<S2SV> hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ; //<S2SV> if ( ! comp_pred ) { //<S2SV> if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) //<S2SV> best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; //<S2SV> } else { //<S2SV> if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) //<S2SV> best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; //<S2SV> } //<S2SV> if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) //<S2SV> best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ; //<S2SV> if ( ! mode_excluded && cm -> interp_filter != BILINEAR ) { //<S2SV> int64_t ref = filter_cache [ cm -> interp_filter == SWITCHABLE ? //<S2SV> SWITCHABLE_FILTERS : cm -> interp_filter ] ; //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> int64_t adj_rd ; //<S2SV> if ( ref == INT64_MAX ) //<S2SV> adj_rd = 0 ; //<S2SV> else if ( filter_cache [ i ] == INT64_MAX ) //<S2SV> adj_rd = mask_filter - ref + 10 ; //<S2SV> else //<S2SV> adj_rd = filter_cache [ i ] - ref ; //<S2SV> adj_rd += this_rd ; //<S2SV> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( early_term ) //<S2SV> break ; //<S2SV> if ( x -> skip && ! comp_pred ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( best_mbmode . mode == NEWMV ) { //<S2SV> const MV_REFERENCE_FRAME refs [ 2 ] = { best_mbmode . ref_frame [ 0 ] , //<S2SV> best_mbmode . ref_frame [ 1 ] } ; //<S2SV> int comp_pred_mode = refs [ 1 ] > INTRA_FRAME ; //<S2SV> if ( frame_mv [ NEARESTMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && //<S2SV> ( ( comp_pred_mode && frame_mv [ NEARESTMV ] [ refs [ 1 ] ] . as_int == //<S2SV> best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) //<S2SV> best_mbmode . mode = NEARESTMV ; //<S2SV> else if ( frame_mv [ NEARMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && //<S2SV> ( ( comp_pred_mode && frame_mv [ NEARMV ] [ refs [ 1 ] ] . as_int == //<S2SV> best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) //<S2SV> best_mbmode . mode = NEARMV ; //<S2SV> else if ( best_mbmode . mv [ 0 ] . as_int == 0 && //<S2SV> ( ( comp_pred_mode && best_mbmode . mv [ 1 ] . as_int == 0 ) || ! comp_pred_mode ) ) //<S2SV> best_mbmode . mode = ZEROMV ; //<S2SV> } //<S2SV> if ( best_mode_index < 0 || best_rd >= best_rd_so_far ) { //<S2SV> rd_cost -> rate = INT_MAX ; //<S2SV> rd_cost -> rdcost = INT64_MAX ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( sf -> use_uv_intra_rd_estimate ) { //<S2SV> if ( best_mbmode . ref_frame [ 0 ] == INTRA_FRAME ) { //<S2SV> TX_SIZE uv_tx_size ; //<S2SV> * mbmi = best_mbmode ; //<S2SV> uv_tx_size = get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ; //<S2SV> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , //<S2SV> & rate_uv_tokenonly [ uv_tx_size ] , //<S2SV> & dist_uv [ uv_tx_size ] , //<S2SV> & skip_uv [ uv_tx_size ] , //<S2SV> bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , //<S2SV> uv_tx_size ) ; //<S2SV> } //<S2SV> } //<S2SV> assert ( ( cm -> interp_filter == SWITCHABLE ) || //<S2SV> ( cm -> interp_filter == best_mbmode . interp_filter ) || //<S2SV> ! is_inter_block ( & best_mbmode ) ) ; //<S2SV> if ( ! cpi -> rc . is_src_frame_alt_ref ) //<S2SV> vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , //<S2SV> sf -> adaptive_rd_thresh , bsize , best_mode_index ) ; //<S2SV> * mbmi = best_mbmode ; //<S2SV> x -> skip |= best_skip2 ; //<S2SV> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { //<S2SV> if ( best_pred_rd [ i ] == INT64_MAX ) //<S2SV> best_pred_diff [ i ] = INT_MIN ; //<S2SV> else //<S2SV> best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ; //<S2SV> } //<S2SV> if ( ! x -> skip ) { //<S2SV> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { //<S2SV> if ( best_filter_rd [ i ] == INT64_MAX ) //<S2SV> best_filter_diff [ i ] = 0 ; //<S2SV> else //<S2SV> best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ; //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) //<S2SV> assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; //<S2SV> } else { //<S2SV> vp9_zero ( best_filter_diff ) ; //<S2SV> } //<S2SV> x -> skip |= best_mode_skippable ; //<S2SV> if ( ! x -> skip && ! x -> select_tx_size ) { //<S2SV> int has_high_freq_coeff = 0 ; //<S2SV> int plane ; //<S2SV> int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) //<S2SV> ? MAX_MB_PLANE : 1 ; //<S2SV> for ( plane = 0 ; plane < max_plane ; ++ plane ) { //<S2SV> x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ; //<S2SV> has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; //<S2SV> } //<S2SV> for ( plane = max_plane ; plane < MAX_MB_PLANE ; ++ plane ) { //<S2SV> x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ; //<S2SV> has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; //<S2SV> } //<S2SV> best_mode_skippable |= ! has_high_freq_coeff ; //<S2SV> } //<S2SV> assert ( best_mode_index >= 0 ) ; //<S2SV> store_coding_context ( x , ctx , best_mode_index , best_pred_diff , //<S2SV> best_filter_diff , best_mode_skippable ) ; //<S2SV> } //<S2SV> 