static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , //<S2SV> MACROBLOCK * x , //<S2SV> int64_t best_yrd , //<S2SV> int i , //<S2SV> int * labelyrate , //<S2SV> int64_t * distortion , int64_t * sse , //<S2SV> ENTROPY_CONTEXT * ta , //<S2SV> ENTROPY_CONTEXT * tl , //<S2SV> int mi_row , int mi_col ) { //<S2SV> int k ; //<S2SV> MACROBLOCKD * xd = & x -> e_mbd ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; //<S2SV> struct macroblock_plane * const p = & x -> plane [ 0 ] ; //<S2SV> MODE_INFO * const mi = xd -> mi [ 0 ] ; //<S2SV> const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ; //<S2SV> const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; //<S2SV> const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; //<S2SV> int idx , idy ; //<S2SV> const uint8_t * const src = //<S2SV> & p -> src . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , p -> src . stride ) ] ; //<S2SV> uint8_t * const dst = & pd -> dst . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , //<S2SV> pd -> dst . stride ) ] ; //<S2SV> int64_t thisdistortion = 0 , thissse = 0 ; //<S2SV> int thisrate = 0 , ref ; //<S2SV> const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; //<S2SV> const int is_compound = has_second_ref ( & mi -> mbmi ) ; //<S2SV> const InterpKernel * kernel = vp9_filter_kernels [ mi -> mbmi . interp_filter ] ; //<S2SV> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { //<S2SV> const uint8_t * pre = & pd -> pre [ ref ] . buf [ vp9_raster_block_offset ( BLOCK_8X8 , i , //<S2SV> pd -> pre [ ref ] . stride ) ] ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> vp9_highbd_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , //<S2SV> dst , pd -> dst . stride , //<S2SV> & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , //<S2SV> & xd -> block_refs [ ref ] -> sf , width , height , //<S2SV> ref , kernel , MV_PRECISION_Q3 , //<S2SV> mi_col * MI_SIZE + 4 * ( i % 2 ) , //<S2SV> mi_row * MI_SIZE + 4 * ( i / 2 ) , xd -> bd ) ; //<S2SV> } else { //<S2SV> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , //<S2SV> dst , pd -> dst . stride , //<S2SV> & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , //<S2SV> & xd -> block_refs [ ref ] -> sf , width , height , ref , //<S2SV> kernel , MV_PRECISION_Q3 , //<S2SV> mi_col * MI_SIZE + 4 * ( i % 2 ) , //<S2SV> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; //<S2SV> } //<S2SV> # else //<S2SV> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , //<S2SV> dst , pd -> dst . stride , //<S2SV> & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , //<S2SV> & xd -> block_refs [ ref ] -> sf , width , height , ref , //<S2SV> kernel , MV_PRECISION_Q3 , //<S2SV> mi_col * MI_SIZE + 4 * ( i % 2 ) , //<S2SV> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; //<S2SV> # endif //<S2SV> } //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> vpx_highbd_subtract_block ( //<S2SV> height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , //<S2SV> 8 , src , p -> src . stride , dst , pd -> dst . stride , xd -> bd ) ; //<S2SV> } else { //<S2SV> vpx_subtract_block ( //<S2SV> height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , //<S2SV> 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; //<S2SV> } //<S2SV> # else //<S2SV> vpx_subtract_block ( height , width , //<S2SV> vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , //<S2SV> 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; //<S2SV> # endif //<S2SV> k = i ; //<S2SV> for ( idy = 0 ; idy < height / 4 ; ++ idy ) { //<S2SV> for ( idx = 0 ; idx < width / 4 ; ++ idx ) { //<S2SV> int64_t ssz , rd , rd1 , rd2 ; //<S2SV> tran_low_t * coeff ; //<S2SV> k += ( idy * 2 + idx ) ; //<S2SV> coeff = BLOCK_OFFSET ( p -> coeff , k ) ; //<S2SV> x -> fwd_txm4x4 ( vp9_raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , //<S2SV> coeff , 8 ) ; //<S2SV> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> thisdistortion += vp9_highbd_block_error ( coeff , //<S2SV> BLOCK_OFFSET ( pd -> dqcoeff , k ) , //<S2SV> 16 , & ssz , xd -> bd ) ; //<S2SV> } else { //<S2SV> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , //<S2SV> 16 , & ssz ) ; //<S2SV> } //<S2SV> # else //<S2SV> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , //<S2SV> 16 , & ssz ) ; //<S2SV> # endif //<S2SV> thissse += ssz ; //<S2SV> thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , //<S2SV> so -> scan , so -> neighbors , //<S2SV> cpi -> sf . use_fast_coef_costing ) ; //<S2SV> rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ; //<S2SV> rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ; //<S2SV> rd = MIN ( rd1 , rd2 ) ; //<S2SV> if ( rd >= best_yrd ) //<S2SV> return INT64_MAX ; //<S2SV> } //<S2SV> } //<S2SV> * distortion = thisdistortion >> 2 ; //<S2SV> * labelyrate = thisrate ; //<S2SV> * sse = thissse >> 2 ; //<S2SV> return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ; //<S2SV> } //<S2SV> 