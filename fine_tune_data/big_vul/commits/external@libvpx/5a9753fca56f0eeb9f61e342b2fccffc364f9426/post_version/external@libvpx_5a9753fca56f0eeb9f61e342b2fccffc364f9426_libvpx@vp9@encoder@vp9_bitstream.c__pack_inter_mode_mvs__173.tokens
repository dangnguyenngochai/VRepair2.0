static void pack_inter_mode_mvs ( VP9_COMP * cpi , const MODE_INFO * mi , //<S2SV> vpx_writer * w ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> const nmv_context * nmvc = & cm -> fc -> nmvc ; //<S2SV> const MACROBLOCK * const x = & cpi -> td . mb ; //<S2SV> const MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const struct segmentation * const seg = & cm -> seg ; //<S2SV> const MB_MODE_INFO * const mbmi = & mi -> mbmi ; //<S2SV> const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; //<S2SV> const PREDICTION_MODE mode = mbmi -> mode ; //<S2SV> const int segment_id = mbmi -> segment_id ; //<S2SV> const BLOCK_SIZE bsize = mbmi -> sb_type ; //<S2SV> const int allow_hp = cm -> allow_high_precision_mv ; //<S2SV> const int is_inter = is_inter_block ( mbmi ) ; //<S2SV> const int is_compound = has_second_ref ( mbmi ) ; //<S2SV> int skip , ref ; //<S2SV> if ( seg -> update_map ) { //<S2SV> if ( seg -> temporal_update ) { //<S2SV> const int pred_flag = mbmi -> seg_id_predicted ; //<S2SV> vpx_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ; //<S2SV> vpx_write ( w , pred_flag , pred_prob ) ; //<S2SV> if ( ! pred_flag ) //<S2SV> write_segment_id ( w , seg , segment_id ) ; //<S2SV> } else { //<S2SV> write_segment_id ( w , seg , segment_id ) ; //<S2SV> } //<S2SV> } //<S2SV> skip = write_skip ( cm , xd , segment_id , mi , w ) ; //<S2SV> if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) //<S2SV> vpx_write ( w , is_inter , vp9_get_intra_inter_prob ( cm , xd ) ) ; //<S2SV> if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT && //<S2SV> ! ( is_inter && skip ) ) { //<S2SV> write_selected_tx_size ( cm , xd , w ) ; //<S2SV> } //<S2SV> if ( ! is_inter ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) { //<S2SV> write_intra_mode ( w , mode , cm -> fc -> y_mode_prob [ size_group_lookup [ bsize ] ] ) ; //<S2SV> } else { //<S2SV> int idx , idy ; //<S2SV> const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; //<S2SV> const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; //<S2SV> for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { //<S2SV> for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { //<S2SV> const PREDICTION_MODE b_mode = mi -> bmi [ idy * 2 + idx ] . as_mode ; //<S2SV> write_intra_mode ( w , b_mode , cm -> fc -> y_mode_prob [ 0 ] ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> write_intra_mode ( w , mbmi -> uv_mode , cm -> fc -> uv_mode_prob [ mode ] ) ; //<S2SV> } else { //<S2SV> const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; //<S2SV> const vpx_prob * const inter_probs = cm -> fc -> inter_mode_probs [ mode_ctx ] ; //<S2SV> write_ref_frames ( cm , xd , w ) ; //<S2SV> if ( ! segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) { //<S2SV> write_inter_mode ( w , mode , inter_probs ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( cm -> interp_filter == SWITCHABLE ) { //<S2SV> const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ; //<S2SV> vp9_write_token ( w , vp9_switchable_interp_tree , //<S2SV> cm -> fc -> switchable_interp_prob [ ctx ] , //<S2SV> & switchable_interp_encodings [ mbmi -> interp_filter ] ) ; //<S2SV> ++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] ; //<S2SV> } else { //<S2SV> assert ( mbmi -> interp_filter == cm -> interp_filter ) ; //<S2SV> } //<S2SV> if ( bsize < BLOCK_8X8 ) { //<S2SV> const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; //<S2SV> const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; //<S2SV> int idx , idy ; //<S2SV> for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { //<S2SV> for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { //<S2SV> const int j = idy * 2 + idx ; //<S2SV> const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; //<S2SV> write_inter_mode ( w , b_mode , inter_probs ) ; //<S2SV> if ( b_mode == NEWMV ) { //<S2SV> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) //<S2SV> vp9_encode_mv ( cpi , w , & mi -> bmi [ j ] . as_mv [ ref ] . as_mv , //<S2SV> & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , //<S2SV> nmvc , allow_hp ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } else { //<S2SV> if ( mode == NEWMV ) { //<S2SV> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) //<S2SV> vp9_encode_mv ( cpi , w , & mbmi -> mv [ ref ] . as_mv , //<S2SV> & mbmi_ext -> ref_mvs [ mbmi -> ref_frame [ ref ] ] [ 0 ] . as_mv , nmvc , //<S2SV> allow_hp ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> 