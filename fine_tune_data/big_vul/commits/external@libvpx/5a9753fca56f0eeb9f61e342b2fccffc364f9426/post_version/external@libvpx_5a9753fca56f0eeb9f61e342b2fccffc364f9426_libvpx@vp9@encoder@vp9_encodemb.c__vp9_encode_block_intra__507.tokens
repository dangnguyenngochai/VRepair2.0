void vp9_encode_block_intra ( int plane , int block , BLOCK_SIZE plane_bsize , //<S2SV> TX_SIZE tx_size , void * arg ) { //<S2SV> struct encode_b_args * const args = arg ; //<S2SV> MACROBLOCK * const x = args -> x ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; //<S2SV> struct macroblock_plane * const p = & x -> plane [ plane ] ; //<S2SV> struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; //<S2SV> tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ; //<S2SV> tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; //<S2SV> tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; //<S2SV> const scan_order * scan_order ; //<S2SV> TX_TYPE tx_type = DCT_DCT ; //<S2SV> PREDICTION_MODE mode ; //<S2SV> const int bwl = b_width_log2_lookup [ plane_bsize ] ; //<S2SV> const int diff_stride = 4 * ( 1 << bwl ) ; //<S2SV> uint8_t * src , * dst ; //<S2SV> int16_t * src_diff ; //<S2SV> uint16_t * eob = & p -> eobs [ block ] ; //<S2SV> const int src_stride = p -> src . stride ; //<S2SV> const int dst_stride = pd -> dst . stride ; //<S2SV> int i , j ; //<S2SV> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; //<S2SV> dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ; //<S2SV> src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ; //<S2SV> src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; //<S2SV> if ( tx_size == TX_4X4 ) { //<S2SV> tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ; //<S2SV> scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; //<S2SV> mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ; //<S2SV> } else { //<S2SV> mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ; //<S2SV> if ( tx_size == TX_32X32 ) { //<S2SV> scan_order = & vp9_default_scan_orders [ TX_32X32 ] ; //<S2SV> } else { //<S2SV> tx_type = get_tx_type ( pd -> plane_type , xd ) ; //<S2SV> scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ; //<S2SV> } //<S2SV> } //<S2SV> vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , //<S2SV> x -> skip_encode ? src_stride : dst_stride , //<S2SV> dst , dst_stride , i , j , plane ) ; //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { //<S2SV> switch ( tx_size ) { //<S2SV> case TX_32X32 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride , xd -> bd ) ; //<S2SV> highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; //<S2SV> vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , //<S2SV> p -> round , p -> quant , p -> quant_shift , //<S2SV> qcoeff , dqcoeff , pd -> dequant , eob , //<S2SV> scan_order -> scan , scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) { //<S2SV> vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TX_16X16 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride , xd -> bd ) ; //<S2SV> if ( tx_type == DCT_DCT ) //<S2SV> vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; //<S2SV> else //<S2SV> vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , //<S2SV> p -> quant , p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , //<S2SV> scan_order -> scan , scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) { //<S2SV> vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , //<S2SV> * eob , xd -> bd ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TX_8X8 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride , xd -> bd ) ; //<S2SV> if ( tx_type == DCT_DCT ) //<S2SV> vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; //<S2SV> else //<S2SV> vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , //<S2SV> p -> quant , p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , //<S2SV> scan_order -> scan , scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) { //<S2SV> vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , //<S2SV> xd -> bd ) ; //<S2SV> } //<S2SV> break ; //<S2SV> case TX_4X4 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride , xd -> bd ) ; //<S2SV> if ( tx_type != DCT_DCT ) //<S2SV> vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> else //<S2SV> x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; //<S2SV> vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , //<S2SV> p -> quant , p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , //<S2SV> scan_order -> scan , scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) { //<S2SV> if ( tx_type == DCT_DCT ) { //<S2SV> x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; //<S2SV> } else { //<S2SV> vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ; //<S2SV> } //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> return ; //<S2SV> } //<S2SV> if ( * eob ) //<S2SV> * ( args -> skip ) = 0 ; //<S2SV> return ; //<S2SV> } //<S2SV> # endif //<S2SV> switch ( tx_size ) { //<S2SV> case TX_32X32 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride ) ; //<S2SV> fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; //<S2SV> vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , //<S2SV> p -> quant , p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , scan_order -> scan , //<S2SV> scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) //<S2SV> vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ; //<S2SV> break ; //<S2SV> case TX_16X16 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride ) ; //<S2SV> vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , //<S2SV> p -> quant , p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , scan_order -> scan , //<S2SV> scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) //<S2SV> vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; //<S2SV> break ; //<S2SV> case TX_8X8 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride ) ; //<S2SV> vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , //<S2SV> p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , scan_order -> scan , //<S2SV> scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) //<S2SV> vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; //<S2SV> break ; //<S2SV> case TX_4X4 : //<S2SV> if ( ! x -> skip_recode ) { //<S2SV> vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , //<S2SV> src , src_stride , dst , dst_stride ) ; //<S2SV> if ( tx_type != DCT_DCT ) //<S2SV> vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; //<S2SV> else //<S2SV> x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; //<S2SV> vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , //<S2SV> p -> quant_shift , qcoeff , dqcoeff , //<S2SV> pd -> dequant , eob , scan_order -> scan , //<S2SV> scan_order -> iscan ) ; //<S2SV> } //<S2SV> if ( ! x -> skip_encode && * eob ) { //<S2SV> if ( tx_type == DCT_DCT ) //<S2SV> x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ; //<S2SV> else //<S2SV> vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> assert ( 0 ) ; //<S2SV> break ; //<S2SV> } //<S2SV> if ( * eob ) //<S2SV> * ( args -> skip ) = 0 ; //<S2SV> } //<S2SV> 