int main ( int argc , char * * argv ) //<S2SV> { //<S2SV> FILE * infile , * outfile [ NUM_ENCODERS ] ; //<S2SV> FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; //<S2SV> char filename [ 50 ] ; //<S2SV> vpx_codec_ctx_t codec [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_enc_cfg_t cfg [ NUM_ENCODERS ] ; //<S2SV> int frame_cnt = 0 ; //<S2SV> vpx_image_t raw [ NUM_ENCODERS ] ; //<S2SV> vpx_codec_err_t res [ NUM_ENCODERS ] ; //<S2SV> int i ; //<S2SV> long width ; //<S2SV> long height ; //<S2SV> int length_frame ; //<S2SV> int frame_avail ; //<S2SV> int got_data ; //<S2SV> int flags = 0 ; //<S2SV> int layer_id = 0 ; //<S2SV> int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] //<S2SV> = { 0 } ; //<S2SV> int flag_periodicity ; //<S2SV> int arg_deadline = VPX_DL_REALTIME ; //<S2SV> int show_psnr = 0 ; //<S2SV> int key_frame_insert = 0 ; //<S2SV> uint64_t psnr_sse_total [ NUM_ENCODERS ] = { 0 } ; //<S2SV> uint64_t psnr_samples_total [ NUM_ENCODERS ] = { 0 } ; //<S2SV> double psnr_totals [ NUM_ENCODERS ] [ 4 ] = { { 0 , 0 } } ; //<S2SV> int psnr_count [ NUM_ENCODERS ] = { 0 } ; //<S2SV> double cx_time = 0 ; //<S2SV> struct timeval tv1 , tv2 , difftv ; //<S2SV> unsigned int target_bitrate [ NUM_ENCODERS ] = { 1000 , 500 , 100 } ; //<S2SV> int framerate = 30 ; //<S2SV> vpx_rational_t dsf [ NUM_ENCODERS ] = { { 2 , 1 } , { 2 , 1 } , { 1 , 1 } } ; //<S2SV> unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; //<S2SV> if ( argc != ( 7 + 3 * NUM_ENCODERS ) ) //<S2SV> die ( "Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><frame_rate><S2SV_blank><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank>" //<S2SV> "<rate_encoder(s)><S2SV_blank><temporal_layer(s)><S2SV_blank><key_frame_insert><S2SV_blank><output<S2SV_blank>psnr?><S2SV_blank>\\n" , //<S2SV> argv [ 0 ] ) ; //<S2SV> printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( interface ) ) ; //<S2SV> width = strtol ( argv [ 1 ] , NULL , 0 ) ; //<S2SV> height = strtol ( argv [ 2 ] , NULL , 0 ) ; //<S2SV> framerate = strtol ( argv [ 3 ] , NULL , 0 ) ; //<S2SV> if ( width < 16 || width % 2 || height < 16 || height % 2 ) //<S2SV> die ( "Invalid<S2SV_blank>resolution:<S2SV_blank>%ldx%ld" , width , height ) ; //<S2SV> if ( ! ( infile = fopen ( argv [ 4 ] , "rb" ) ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading" , argv [ 4 ] ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( ! target_bitrate [ i ] ) //<S2SV> { //<S2SV> outfile [ i ] = NULL ; //<S2SV> continue ; //<S2SV> } //<S2SV> if ( ! ( outfile [ i ] = fopen ( argv [ i + 5 ] , "wb" ) ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing" , argv [ i + 4 ] ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> target_bitrate [ i ] = strtol ( argv [ NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; //<S2SV> if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) //<S2SV> die ( "Invalid<S2SV_blank>temporal<S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>or<S2SV_blank>3.<S2SV_blank>\\n" , //<S2SV> num_temporal_layers ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) //<S2SV> { //<S2SV> if ( sprintf ( filename , "ds%d.yuv" , NUM_ENCODERS - i ) < 0 ) //<S2SV> { //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> downsampled_input [ i ] = fopen ( filename , "wb" ) ; //<S2SV> } //<S2SV> key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; //<S2SV> show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; //<S2SV> if ( res [ i ] ) { //<S2SV> printf ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n" , vpx_codec_err_to_string ( res [ i ] ) ) ; //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> cfg [ 0 ] . g_w = width ; //<S2SV> cfg [ 0 ] . g_h = height ; //<S2SV> cfg [ 0 ] . rc_dropframe_thresh = 0 ; //<S2SV> cfg [ 0 ] . rc_end_usage = VPX_CBR ; //<S2SV> cfg [ 0 ] . rc_resize_allowed = 0 ; //<S2SV> cfg [ 0 ] . rc_min_quantizer = 2 ; //<S2SV> cfg [ 0 ] . rc_max_quantizer = 56 ; //<S2SV> cfg [ 0 ] . rc_undershoot_pct = 100 ; //<S2SV> cfg [ 0 ] . rc_overshoot_pct = 15 ; //<S2SV> cfg [ 0 ] . rc_buf_initial_sz = 500 ; //<S2SV> cfg [ 0 ] . rc_buf_optimal_sz = 600 ; //<S2SV> cfg [ 0 ] . rc_buf_sz = 1000 ; //<S2SV> cfg [ 0 ] . g_error_resilient = 1 ; //<S2SV> cfg [ 0 ] . g_lag_in_frames = 0 ; //<S2SV> cfg [ 0 ] . kf_mode = VPX_KF_AUTO ; //<S2SV> cfg [ 0 ] . kf_min_dist = 3000 ; //<S2SV> cfg [ 0 ] . kf_max_dist = 3000 ; //<S2SV> cfg [ 0 ] . rc_target_bitrate = target_bitrate [ 0 ] ; //<S2SV> cfg [ 0 ] . g_timebase . num = 1 ; //<S2SV> cfg [ 0 ] . g_timebase . den = framerate ; //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> memcpy ( & cfg [ i ] , & cfg [ 0 ] , sizeof ( vpx_codec_enc_cfg_t ) ) ; //<S2SV> cfg [ i ] . rc_target_bitrate = target_bitrate [ i ] ; //<S2SV> { //<S2SV> unsigned int iw = cfg [ i - 1 ] . g_w * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; //<S2SV> unsigned int ih = cfg [ i - 1 ] . g_h * dsf [ i - 1 ] . den + dsf [ i - 1 ] . num - 1 ; //<S2SV> cfg [ i ] . g_w = iw / dsf [ i - 1 ] . num ; //<S2SV> cfg [ i ] . g_h = ih / dsf [ i - 1 ] . num ; //<S2SV> } //<S2SV> if ( ( cfg [ i ] . g_w ) % 2 ) cfg [ i ] . g_w ++ ; //<S2SV> if ( ( cfg [ i ] . g_h ) % 2 ) cfg [ i ] . g_h ++ ; //<S2SV> } //<S2SV> cfg [ 0 ] . g_threads = 2 ; //<S2SV> cfg [ 1 ] . g_threads = 1 ; //<S2SV> cfg [ 2 ] . g_threads = 1 ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> if ( ! vpx_img_alloc ( & raw [ i ] , VPX_IMG_FMT_I420 , cfg [ i ] . g_w , cfg [ i ] . g_h , 32 ) ) //<S2SV> die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image" , cfg [ i ] . g_w , cfg [ i ] . g_h ) ; //<S2SV> if ( raw [ 0 ] . stride [ VPX_PLANE_Y ] == raw [ 0 ] . d_w ) //<S2SV> read_frame_p = read_frame ; //<S2SV> else //<S2SV> read_frame_p = read_frame_by_row ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> if ( outfile [ i ] ) //<S2SV> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , 0 ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> set_temporal_layer_pattern ( num_temporal_layers [ i ] , //<S2SV> & cfg [ i ] , //<S2SV> cfg [ i ] . rc_target_bitrate , //<S2SV> & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; //<S2SV> } //<S2SV> if ( vpx_codec_enc_init_multi ( & codec [ 0 ] , interface , & cfg [ 0 ] , NUM_ENCODERS , //<S2SV> ( show_psnr ? VPX_CODEC_USE_PSNR : 0 ) , & dsf [ 0 ] ) ) //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> int speed = - 6 ; //<S2SV> if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_CPUUSED , speed ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" ) ; //<S2SV> } //<S2SV> if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" ) ; //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> unsigned int max_intra_size_pct = //<S2SV> ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) ; //<S2SV> if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , //<S2SV> max_intra_size_pct ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" ) ; //<S2SV> } //<S2SV> frame_avail = 1 ; //<S2SV> got_data = 0 ; //<S2SV> while ( frame_avail || got_data ) //<S2SV> { //<S2SV> vpx_codec_iter_t iter [ NUM_ENCODERS ] = { NULL } ; //<S2SV> const vpx_codec_cx_pkt_t * pkt [ NUM_ENCODERS ] ; //<S2SV> flags = 0 ; //<S2SV> frame_avail = read_frame_p ( infile , & raw [ 0 ] ) ; //<S2SV> if ( frame_avail ) //<S2SV> { //<S2SV> for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> I420Scale ( raw [ i - 1 ] . planes [ VPX_PLANE_Y ] , raw [ i - 1 ] . stride [ VPX_PLANE_Y ] , //<S2SV> raw [ i - 1 ] . planes [ VPX_PLANE_U ] , raw [ i - 1 ] . stride [ VPX_PLANE_U ] , //<S2SV> raw [ i - 1 ] . planes [ VPX_PLANE_V ] , raw [ i - 1 ] . stride [ VPX_PLANE_V ] , //<S2SV> raw [ i - 1 ] . d_w , raw [ i - 1 ] . d_h , //<S2SV> raw [ i ] . planes [ VPX_PLANE_Y ] , raw [ i ] . stride [ VPX_PLANE_Y ] , //<S2SV> raw [ i ] . planes [ VPX_PLANE_U ] , raw [ i ] . stride [ VPX_PLANE_U ] , //<S2SV> raw [ i ] . planes [ VPX_PLANE_V ] , raw [ i ] . stride [ VPX_PLANE_V ] , //<S2SV> raw [ i ] . d_w , raw [ i ] . d_h , 1 ) ; //<S2SV> length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; //<S2SV> if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , //<S2SV> downsampled_input [ NUM_ENCODERS - i - 1 ] ) != //<S2SV> length_frame ) //<S2SV> { //<S2SV> return EXIT_FAILURE ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; //<S2SV> flags = 0 ; //<S2SV> flag_periodicity = periodicity_to_num_layers //<S2SV> [ num_temporal_layers [ i ] - 1 ] ; //<S2SV> flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + //<S2SV> frame_cnt % flag_periodicity ] ; //<S2SV> if ( frame_cnt == 0 ) //<S2SV> { //<S2SV> flags |= VPX_EFLAG_FORCE_KF ; //<S2SV> } //<S2SV> if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) //<S2SV> { //<S2SV> flags = VPX_EFLAG_FORCE_KF ; //<S2SV> } //<S2SV> vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; //<S2SV> vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; //<S2SV> } //<S2SV> gettimeofday ( & tv1 , NULL ) ; //<S2SV> if ( vpx_codec_encode ( & codec [ 0 ] , frame_avail ? & raw [ 0 ] : NULL , //<S2SV> frame_cnt , 1 , 0 , arg_deadline ) ) //<S2SV> { //<S2SV> die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" ) ; //<S2SV> } //<S2SV> gettimeofday ( & tv2 , NULL ) ; //<S2SV> timersub ( & tv2 , & tv1 , & difftv ) ; //<S2SV> cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec ) ; //<S2SV> for ( i = NUM_ENCODERS - 1 ; i >= 0 ; i -- ) //<S2SV> { //<S2SV> got_data = 0 ; //<S2SV> while ( ( pkt [ i ] = vpx_codec_get_cx_data ( & codec [ i ] , & iter [ i ] ) ) ) //<S2SV> { //<S2SV> got_data = 1 ; //<S2SV> switch ( pkt [ i ] -> kind ) { //<S2SV> case VPX_CODEC_CX_FRAME_PKT : //<S2SV> write_ivf_frame_header ( outfile [ i ] , pkt [ i ] ) ; //<S2SV> ( void ) fwrite ( pkt [ i ] -> data . frame . buf , 1 , //<S2SV> pkt [ i ] -> data . frame . sz , outfile [ i ] ) ; //<S2SV> break ; //<S2SV> case VPX_CODEC_PSNR_PKT : //<S2SV> if ( show_psnr ) //<S2SV> { //<S2SV> int j ; //<S2SV> psnr_sse_total [ i ] += pkt [ i ] -> data . psnr . sse [ 0 ] ; //<S2SV> psnr_samples_total [ i ] += pkt [ i ] -> data . psnr . samples [ 0 ] ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> psnr_totals [ i ] [ j ] += pkt [ i ] -> data . psnr . psnr [ j ] ; //<S2SV> } //<S2SV> psnr_count [ i ] ++ ; //<S2SV> } //<S2SV> break ; //<S2SV> default : //<S2SV> break ; //<S2SV> } //<S2SV> printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT //<S2SV> && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? "K" : "" ) ; //<S2SV> fflush ( stdout ) ; //<S2SV> } //<S2SV> } //<S2SV> frame_cnt ++ ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> printf ( "FPS<S2SV_blank>for<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>%f<S2SV_blank>%f<S2SV_blank>\\n" , frame_cnt , ( float ) cx_time / 1000000 , //<S2SV> 1000000 * ( double ) frame_cnt / ( double ) cx_time ) ; //<S2SV> fclose ( infile ) ; //<S2SV> printf ( "Processed<S2SV_blank>%ld<S2SV_blank>frames.\\n" , ( long int ) frame_cnt - 1 ) ; //<S2SV> for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) //<S2SV> { //<S2SV> if ( ( show_psnr ) && ( psnr_count [ i ] > 0 ) ) //<S2SV> { //<S2SV> int j ; //<S2SV> double ovpsnr = sse_to_psnr ( psnr_samples_total [ i ] , 255.0 , //<S2SV> psnr_sse_total [ i ] ) ; //<S2SV> fprintf ( stderr , "\\n<S2SV_blank>ENC%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)" , i ) ; //<S2SV> fprintf ( stderr , "<S2SV_blank>%.3lf" , ovpsnr ) ; //<S2SV> for ( j = 0 ; j < 4 ; j ++ ) //<S2SV> { //<S2SV> fprintf ( stderr , "<S2SV_blank>%.3lf" , psnr_totals [ i ] [ j ] / psnr_count [ i ] ) ; //<S2SV> } //<S2SV> } //<S2SV> if ( vpx_codec_destroy ( & codec [ i ] ) ) //<S2SV> die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec" ) ; //<S2SV> vpx_img_free ( & raw [ i ] ) ; //<S2SV> if ( ! outfile [ i ] ) //<S2SV> continue ; //<S2SV> if ( ! fseek ( outfile [ i ] , 0 , SEEK_SET ) ) //<S2SV> write_ivf_file_header ( outfile [ i ] , & cfg [ i ] , frame_cnt - 1 ) ; //<S2SV> fclose ( outfile [ i ] ) ; //<S2SV> } //<S2SV> printf ( "\\n" ) ; //<S2SV> return EXIT_SUCCESS ; //<S2SV> } //<S2SV> 