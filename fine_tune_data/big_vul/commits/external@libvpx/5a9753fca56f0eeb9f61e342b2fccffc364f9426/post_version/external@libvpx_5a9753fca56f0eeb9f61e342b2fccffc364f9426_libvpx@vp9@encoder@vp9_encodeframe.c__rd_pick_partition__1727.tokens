static void rd_pick_partition ( VP9_COMP * cpi , ThreadData * td , //<S2SV> TileDataEnc * tile_data , //<S2SV> TOKENEXTRA * * tp , int mi_row , int mi_col , //<S2SV> BLOCK_SIZE bsize , RD_COST * rd_cost , //<S2SV> int64_t best_rd , PC_TREE * pc_tree ) { //<S2SV> VP9_COMMON * const cm = & cpi -> common ; //<S2SV> TileInfo * const tile_info = & tile_data -> tile_info ; //<S2SV> MACROBLOCK * const x = & td -> mb ; //<S2SV> MACROBLOCKD * const xd = & x -> e_mbd ; //<S2SV> const int mi_step = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; //<S2SV> ENTROPY_CONTEXT l [ 16 * MAX_MB_PLANE ] , a [ 16 * MAX_MB_PLANE ] ; //<S2SV> PARTITION_CONTEXT sl [ 8 ] , sa [ 8 ] ; //<S2SV> TOKENEXTRA * tp_orig = * tp ; //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; //<S2SV> int i , pl ; //<S2SV> BLOCK_SIZE subsize ; //<S2SV> RD_COST this_rdc , sum_rdc , best_rdc ; //<S2SV> int do_split = bsize >= BLOCK_8X8 ; //<S2SV> int do_rect = 1 ; //<S2SV> const int force_horz_split = ( mi_row + mi_step >= cm -> mi_rows ) ; //<S2SV> const int force_vert_split = ( mi_col + mi_step >= cm -> mi_cols ) ; //<S2SV> const int xss = x -> e_mbd . plane [ 1 ] . subsampling_x ; //<S2SV> const int yss = x -> e_mbd . plane [ 1 ] . subsampling_y ; //<S2SV> BLOCK_SIZE min_size = x -> min_partition_size ; //<S2SV> BLOCK_SIZE max_size = x -> max_partition_size ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> unsigned int src_diff_var = UINT_MAX ; //<S2SV> int none_complexity = 0 ; //<S2SV> # endif //<S2SV> int partition_none_allowed = ! force_horz_split && ! force_vert_split ; //<S2SV> int partition_horz_allowed = ! force_vert_split && yss <= xss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> int partition_vert_allowed = ! force_horz_split && xss <= yss && //<S2SV> bsize >= BLOCK_8X8 ; //<S2SV> ( void ) * tp_orig ; //<S2SV> assert ( num_8x8_blocks_wide_lookup [ bsize ] == //<S2SV> num_8x8_blocks_high_lookup [ bsize ] ) ; //<S2SV> vp9_rd_cost_init ( & this_rdc ) ; //<S2SV> vp9_rd_cost_init ( & sum_rdc ) ; //<S2SV> vp9_rd_cost_reset ( & best_rdc ) ; //<S2SV> best_rdc . rdcost = best_rd ; //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; //<S2SV> if ( bsize == BLOCK_16X16 && cpi -> oxcf . aq_mode ) //<S2SV> x -> mb_energy = vp9_block_energy ( cpi , x , bsize ) ; //<S2SV> if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { //<S2SV> int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) //<S2SV> + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; //<S2SV> if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) //<S2SV> set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . auto_min_max_partition_size ) { //<S2SV> partition_none_allowed &= ( bsize <= max_size && bsize >= min_size ) ; //<S2SV> partition_horz_allowed &= ( ( bsize <= max_size && bsize > min_size ) || //<S2SV> force_horz_split ) ; //<S2SV> partition_vert_allowed &= ( ( bsize <= max_size && bsize > min_size ) || //<S2SV> force_vert_split ) ; //<S2SV> do_split &= bsize > min_size ; //<S2SV> } //<S2SV> if ( cpi -> sf . use_square_partition_only ) { //<S2SV> partition_horz_allowed &= force_horz_split ; //<S2SV> partition_vert_allowed &= force_vert_split ; //<S2SV> } //<S2SV> save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats ) { //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; //<S2SV> src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , //<S2SV> mi_row , mi_col , bsize ) ; //<S2SV> } //<S2SV> # endif //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && //<S2SV> partition_none_allowed && src_diff_var > 4 && //<S2SV> cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { //<S2SV> int mb_row = mi_row >> 1 ; //<S2SV> int mb_col = mi_col >> 1 ; //<S2SV> int mb_row_end = //<S2SV> MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; //<S2SV> int mb_col_end = //<S2SV> MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; //<S2SV> int r , c ; //<S2SV> for ( r = mb_row ; r < mb_row_end ; r ++ ) { //<S2SV> for ( c = mb_col ; c < mb_col_end ; c ++ ) { //<S2SV> const int mb_index = r * cm -> mb_cols + c ; //<S2SV> MOTION_DIRECTION this_mv ; //<S2SV> MOTION_DIRECTION right_mv ; //<S2SV> MOTION_DIRECTION bottom_mv ; //<S2SV> this_mv = //<S2SV> get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; //<S2SV> if ( c != mb_col_end - 1 ) { //<S2SV> right_mv = get_motion_direction_fp ( //<S2SV> cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; //<S2SV> none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; //<S2SV> } //<S2SV> if ( r != mb_row_end - 1 ) { //<S2SV> bottom_mv = get_motion_direction_fp ( //<S2SV> cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; //<S2SV> none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { //<S2SV> partition_none_allowed = 0 ; //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> if ( partition_none_allowed ) { //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , //<S2SV> & this_rdc , bsize , ctx , best_rdc . rdcost ) ; //<S2SV> if ( this_rdc . rate != INT_MAX ) { //<S2SV> if ( bsize >= BLOCK_8X8 ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> this_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_NONE ] ; //<S2SV> this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> this_rdc . rate , this_rdc . dist ) ; //<S2SV> } //<S2SV> if ( this_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; //<S2SV> int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; //<S2SV> best_rdc = this_rdc ; //<S2SV> if ( bsize >= BLOCK_8X8 ) //<S2SV> pc_tree -> partitioning = PARTITION_NONE ; //<S2SV> dist_breakout_thr >>= 8 - ( b_width_log2_lookup [ bsize ] + //<S2SV> b_height_log2_lookup [ bsize ] ) ; //<S2SV> rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; //<S2SV> if ( ! x -> e_mbd . lossless && //<S2SV> ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && //<S2SV> best_rdc . rate < rate_breakout_thr ) ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> # if CONFIG_FP_MB_STATS //<S2SV> if ( cpi -> use_fp_mb_stats && do_split != 0 && //<S2SV> cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { //<S2SV> int mb_row = mi_row >> 1 ; //<S2SV> int mb_col = mi_col >> 1 ; //<S2SV> int mb_row_end = //<S2SV> MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; //<S2SV> int mb_col_end = //<S2SV> MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; //<S2SV> int r , c ; //<S2SV> int skip = 1 ; //<S2SV> for ( r = mb_row ; r < mb_row_end ; r ++ ) { //<S2SV> for ( c = mb_col ; c < mb_col_end ; c ++ ) { //<S2SV> const int mb_index = r * cm -> mb_cols + c ; //<S2SV> if ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & //<S2SV> FPMB_MOTION_ZERO_MASK ) || //<S2SV> ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & //<S2SV> FPMB_ERROR_SMALL_MASK ) ) { //<S2SV> skip = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( skip == 0 ) { //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( skip ) { //<S2SV> if ( src_diff_var == UINT_MAX ) { //<S2SV> set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; //<S2SV> src_diff_var = get_sby_perpixel_diff_variance ( //<S2SV> cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; //<S2SV> } //<S2SV> if ( src_diff_var < 8 ) { //<S2SV> do_split = 0 ; //<S2SV> do_rect = 0 ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> # endif //<S2SV> } //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> store_pred_mv ( x , ctx ) ; //<S2SV> if ( do_split ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; //<S2SV> if ( bsize == BLOCK_8X8 ) { //<S2SV> i = 4 ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) //<S2SV> pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , //<S2SV> pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; //<S2SV> if ( sum_rdc . rate == INT_MAX ) //<S2SV> sum_rdc . rdcost = INT64_MAX ; //<S2SV> } else { //<S2SV> for ( i = 0 ; i < 4 && sum_rdc . rdcost < best_rdc . rdcost ; ++ i ) { //<S2SV> const int x_idx = ( i & 1 ) * mi_step ; //<S2SV> const int y_idx = ( i >> 1 ) * mi_step ; //<S2SV> if ( mi_row + y_idx >= cm -> mi_rows || mi_col + x_idx >= cm -> mi_cols ) //<S2SV> continue ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> pc_tree -> split [ i ] -> index = i ; //<S2SV> rd_pick_partition ( cpi , td , tile_data , tp , //<S2SV> mi_row + y_idx , mi_col + x_idx , //<S2SV> subsize , & this_rdc , //<S2SV> best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> sum_rdc . rdcost = INT64_MAX ; //<S2SV> break ; //<S2SV> } else { //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost += this_rdc . rdcost ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost && i == 4 ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_SPLIT ] ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_SPLIT ; //<S2SV> } //<S2SV> } else { //<S2SV> if ( cpi -> sf . less_rectangular_check ) //<S2SV> do_rect &= ! partition_none_allowed ; //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( partition_horz_allowed && //<S2SV> ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_HORZ ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> pc_tree -> horizontal [ 0 ] . pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , //<S2SV> & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost && mi_row + mi_step < cm -> mi_rows && //<S2SV> bsize > BLOCK_8X8 ) { //<S2SV> PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; //<S2SV> update_state ( cpi , td , ctx , mi_row , mi_col , subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> pc_tree -> horizontal [ 1 ] . pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row + mi_step , mi_col , //<S2SV> & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , //<S2SV> best_rdc . rdcost - sum_rdc . rdcost ) ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> sum_rdc . rdcost = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost += this_rdc . rdcost ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_HORZ ; //<S2SV> } //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> if ( partition_vert_allowed && //<S2SV> ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { //<S2SV> subsize = get_subsize ( bsize , PARTITION_VERT ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> pc_tree -> vertical [ 0 ] . pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , //<S2SV> & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost && mi_col + mi_step < cm -> mi_cols && //<S2SV> bsize > BLOCK_8X8 ) { //<S2SV> update_state ( cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col , subsize , 0 ) ; //<S2SV> encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , subsize , //<S2SV> & pc_tree -> vertical [ 0 ] ) ; //<S2SV> if ( cpi -> sf . adaptive_motion_search ) //<S2SV> load_pred_mv ( x , ctx ) ; //<S2SV> if ( cpi -> sf . adaptive_pred_interp_filter && bsize == BLOCK_8X8 && //<S2SV> partition_none_allowed ) //<S2SV> pc_tree -> vertical [ 1 ] . pred_interp_filter = //<S2SV> ctx -> mic . mbmi . interp_filter ; //<S2SV> rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col + mi_step , //<S2SV> & this_rdc , subsize , //<S2SV> & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; //<S2SV> if ( this_rdc . rate == INT_MAX ) { //<S2SV> sum_rdc . rdcost = INT64_MAX ; //<S2SV> } else { //<S2SV> sum_rdc . rate += this_rdc . rate ; //<S2SV> sum_rdc . dist += this_rdc . dist ; //<S2SV> sum_rdc . rdcost += this_rdc . rdcost ; //<S2SV> } //<S2SV> } //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; //<S2SV> sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; //<S2SV> sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , //<S2SV> sum_rdc . rate , sum_rdc . dist ) ; //<S2SV> if ( sum_rdc . rdcost < best_rdc . rdcost ) { //<S2SV> best_rdc = sum_rdc ; //<S2SV> pc_tree -> partitioning = PARTITION_VERT ; //<S2SV> } //<S2SV> } //<S2SV> restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; //<S2SV> } //<S2SV> ( void ) best_rd ; //<S2SV> * rd_cost = best_rdc ; //<S2SV> if ( best_rdc . rate < INT_MAX && best_rdc . dist < INT64_MAX && //<S2SV> pc_tree -> index != 3 ) { //<S2SV> int output_enabled = ( bsize == BLOCK_64X64 ) ; //<S2SV> encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , //<S2SV> bsize , pc_tree ) ; //<S2SV> } //<S2SV> if ( bsize == BLOCK_64X64 ) { //<S2SV> assert ( tp_orig < * tp ) ; //<S2SV> assert ( best_rdc . rate < INT_MAX ) ; //<S2SV> assert ( best_rdc . dist < INT64_MAX ) ; //<S2SV> } else { //<S2SV> assert ( tp_orig == * tp ) ; //<S2SV> } //<S2SV> } //<S2SV> 