static void optimize_b ( MACROBLOCK * mb , int ib , int type , //<S2SV> ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) //<S2SV> { //<S2SV> BLOCK * b ; //<S2SV> BLOCKD * d ; //<S2SV> vp8_token_state tokens [ 17 ] [ 2 ] ; //<S2SV> unsigned best_mask [ 2 ] ; //<S2SV> const short * dequant_ptr ; //<S2SV> const short * coeff_ptr ; //<S2SV> short * qcoeff_ptr ; //<S2SV> short * dqcoeff_ptr ; //<S2SV> int eob ; //<S2SV> int i0 ; //<S2SV> int rc ; //<S2SV> int x ; //<S2SV> int sz = 0 ; //<S2SV> int next ; //<S2SV> int rdmult ; //<S2SV> int rddiv ; //<S2SV> int final_eob ; //<S2SV> int rd_cost0 ; //<S2SV> int rd_cost1 ; //<S2SV> int rate0 ; //<S2SV> int rate1 ; //<S2SV> int error0 ; //<S2SV> int error1 ; //<S2SV> int t0 ; //<S2SV> int t1 ; //<S2SV> int best ; //<S2SV> int band ; //<S2SV> int pt ; //<S2SV> int i ; //<S2SV> int err_mult = plane_rd_mult [ type ] ; //<S2SV> b = & mb -> block [ ib ] ; //<S2SV> d = & mb -> e_mbd . block [ ib ] ; //<S2SV> dequant_ptr = d -> dequant ; //<S2SV> coeff_ptr = b -> coeff ; //<S2SV> qcoeff_ptr = d -> qcoeff ; //<S2SV> dqcoeff_ptr = d -> dqcoeff ; //<S2SV> i0 = ! type ; //<S2SV> eob = * d -> eob ; //<S2SV> rdmult = mb -> rdmult * err_mult ; //<S2SV> if ( mb -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) //<S2SV> rdmult = ( rdmult * 9 ) >> 4 ; //<S2SV> rddiv = mb -> rddiv ; //<S2SV> best_mask [ 0 ] = best_mask [ 1 ] = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . rate = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . error = 0 ; //<S2SV> tokens [ eob ] [ 0 ] . next = 16 ; //<S2SV> tokens [ eob ] [ 0 ] . token = DCT_EOB_TOKEN ; //<S2SV> tokens [ eob ] [ 0 ] . qc = 0 ; //<S2SV> * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; //<S2SV> next = eob ; //<S2SV> for ( i = eob ; i -- > i0 ; ) //<S2SV> { //<S2SV> int base_bits ; //<S2SV> int d2 ; //<S2SV> int dx ; //<S2SV> rc = vp8_default_zig_zag1d [ i ] ; //<S2SV> x = qcoeff_ptr [ rc ] ; //<S2SV> if ( x ) //<S2SV> { //<S2SV> int shortcut = 0 ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> t0 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; //<S2SV> if ( next < 16 ) //<S2SV> { //<S2SV> band = vp8_coef_bands [ i + 1 ] ; //<S2SV> pt = vp8_prev_token_class [ t0 ] ; //<S2SV> rate0 += //<S2SV> mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 0 ] . token ] ; //<S2SV> rate1 += //<S2SV> mb -> token_costs [ type ] [ band ] [ pt ] [ tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> if ( rd_cost0 == rd_cost1 ) //<S2SV> { //<S2SV> rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> } //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = * ( vp8_dct_value_cost_ptr + x ) ; //<S2SV> dx = dqcoeff_ptr [ rc ] - coeff_ptr [ rc ] ; //<S2SV> d2 = dx * dx ; //<S2SV> tokens [ i ] [ 0 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 0 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 0 ] . next = next ; //<S2SV> tokens [ i ] [ 0 ] . token = t0 ; //<S2SV> tokens [ i ] [ 0 ] . qc = x ; //<S2SV> best_mask [ 0 ] |= best << i ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> if ( ( abs ( x ) * dequant_ptr [ rc ] > abs ( coeff_ptr [ rc ] ) ) && //<S2SV> ( abs ( x ) * dequant_ptr [ rc ] < abs ( coeff_ptr [ rc ] ) + dequant_ptr [ rc ] ) ) //<S2SV> shortcut = 1 ; //<S2SV> else //<S2SV> shortcut = 0 ; //<S2SV> if ( shortcut ) //<S2SV> { //<S2SV> sz = - ( x < 0 ) ; //<S2SV> x -= 2 * sz + 1 ; //<S2SV> } //<S2SV> if ( ! x ) //<S2SV> { //<S2SV> t0 = tokens [ next ] [ 0 ] . token == DCT_EOB_TOKEN ? //<S2SV> DCT_EOB_TOKEN : ZERO_TOKEN ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token == DCT_EOB_TOKEN ? //<S2SV> DCT_EOB_TOKEN : ZERO_TOKEN ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> t0 = t1 = ( vp8_dct_value_tokens_ptr + x ) -> Token ; //<S2SV> } //<S2SV> if ( next < 16 ) //<S2SV> { //<S2SV> band = vp8_coef_bands [ i + 1 ] ; //<S2SV> if ( t0 != DCT_EOB_TOKEN ) //<S2SV> { //<S2SV> pt = vp8_prev_token_class [ t0 ] ; //<S2SV> rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ //<S2SV> tokens [ next ] [ 0 ] . token ] ; //<S2SV> } //<S2SV> if ( t1 != DCT_EOB_TOKEN ) //<S2SV> { //<S2SV> pt = vp8_prev_token_class [ t1 ] ; //<S2SV> rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ //<S2SV> tokens [ next ] [ 1 ] . token ] ; //<S2SV> } //<S2SV> } //<S2SV> rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> if ( rd_cost0 == rd_cost1 ) //<S2SV> { //<S2SV> rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> } //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> base_bits = * ( vp8_dct_value_cost_ptr + x ) ; //<S2SV> if ( shortcut ) //<S2SV> { //<S2SV> dx -= ( dequant_ptr [ rc ] + sz ) ^ sz ; //<S2SV> d2 = dx * dx ; //<S2SV> } //<S2SV> tokens [ i ] [ 1 ] . rate = base_bits + ( best ? rate1 : rate0 ) ; //<S2SV> tokens [ i ] [ 1 ] . error = d2 + ( best ? error1 : error0 ) ; //<S2SV> tokens [ i ] [ 1 ] . next = next ; //<S2SV> tokens [ i ] [ 1 ] . token = best ? t1 : t0 ; //<S2SV> tokens [ i ] [ 1 ] . qc = x ; //<S2SV> best_mask [ 1 ] |= best << i ; //<S2SV> next = i ; //<S2SV> } //<S2SV> else //<S2SV> { //<S2SV> band = vp8_coef_bands [ i + 1 ] ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> if ( t0 != DCT_EOB_TOKEN ) //<S2SV> { //<S2SV> tokens [ next ] [ 0 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t0 ] ; //<S2SV> tokens [ next ] [ 0 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> if ( t1 != DCT_EOB_TOKEN ) //<S2SV> { //<S2SV> tokens [ next ] [ 1 ] . rate += mb -> token_costs [ type ] [ band ] [ 0 ] [ t1 ] ; //<S2SV> tokens [ next ] [ 1 ] . token = ZERO_TOKEN ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> band = vp8_coef_bands [ i + 1 ] ; //<S2SV> VP8_COMBINEENTROPYCONTEXTS ( pt , * a , * l ) ; //<S2SV> rate0 = tokens [ next ] [ 0 ] . rate ; //<S2SV> rate1 = tokens [ next ] [ 1 ] . rate ; //<S2SV> error0 = tokens [ next ] [ 0 ] . error ; //<S2SV> error1 = tokens [ next ] [ 1 ] . error ; //<S2SV> t0 = tokens [ next ] [ 0 ] . token ; //<S2SV> t1 = tokens [ next ] [ 1 ] . token ; //<S2SV> rate0 += mb -> token_costs [ type ] [ band ] [ pt ] [ t0 ] ; //<S2SV> rate1 += mb -> token_costs [ type ] [ band ] [ pt ] [ t1 ] ; //<S2SV> rd_cost0 = RDCOST ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDCOST ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> if ( rd_cost0 == rd_cost1 ) //<S2SV> { //<S2SV> rd_cost0 = RDTRUNC ( rdmult , rddiv , rate0 , error0 ) ; //<S2SV> rd_cost1 = RDTRUNC ( rdmult , rddiv , rate1 , error1 ) ; //<S2SV> } //<S2SV> best = rd_cost1 < rd_cost0 ; //<S2SV> final_eob = i0 - 1 ; //<S2SV> for ( i = next ; i < eob ; i = next ) //<S2SV> { //<S2SV> x = tokens [ i ] [ best ] . qc ; //<S2SV> if ( x ) //<S2SV> final_eob = i ; //<S2SV> rc = vp8_default_zig_zag1d [ i ] ; //<S2SV> qcoeff_ptr [ rc ] = x ; //<S2SV> dqcoeff_ptr [ rc ] = x * dequant_ptr [ rc ] ; //<S2SV> next = tokens [ i ] [ best ] . next ; //<S2SV> best = ( best_mask [ best ] >> i ) & 1 ; //<S2SV> } //<S2SV> final_eob ++ ; //<S2SV> * a = * l = ( final_eob != ! type ) ; //<S2SV> * d -> eob = ( char ) final_eob ; //<S2SV> } //<S2SV> 