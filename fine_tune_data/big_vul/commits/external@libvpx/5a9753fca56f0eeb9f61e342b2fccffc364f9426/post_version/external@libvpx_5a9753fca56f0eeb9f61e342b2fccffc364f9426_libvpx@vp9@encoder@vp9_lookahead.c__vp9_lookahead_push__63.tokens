int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , //<S2SV> int64_t ts_start , int64_t ts_end , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> int use_highbitdepth , //<S2SV> # endif //<S2SV> unsigned int flags ) { //<S2SV> struct lookahead_entry * buf ; //<S2SV> # if USE_PARTIAL_COPY //<S2SV> int row , col , active_end ; //<S2SV> int mb_rows = ( src -> y_height + 15 ) >> 4 ; //<S2SV> int mb_cols = ( src -> y_width + 15 ) >> 4 ; //<S2SV> # endif //<S2SV> int width = src -> y_crop_width ; //<S2SV> int height = src -> y_crop_height ; //<S2SV> int uv_width = src -> uv_crop_width ; //<S2SV> int uv_height = src -> uv_crop_height ; //<S2SV> int subsampling_x = src -> subsampling_x ; //<S2SV> int subsampling_y = src -> subsampling_y ; //<S2SV> int larger_dimensions , new_dimensions ; //<S2SV> if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) //<S2SV> return 1 ; //<S2SV> ctx -> sz ++ ; //<S2SV> buf = pop ( ctx , & ctx -> write_idx ) ; //<S2SV> new_dimensions = width != buf -> img . y_crop_width || //<S2SV> height != buf -> img . y_crop_height || //<S2SV> uv_width != buf -> img . uv_crop_width || //<S2SV> uv_height != buf -> img . uv_crop_height ; //<S2SV> larger_dimensions = width > buf -> img . y_width || //<S2SV> height > buf -> img . y_height || //<S2SV> uv_width > buf -> img . uv_width || //<S2SV> uv_height > buf -> img . uv_height ; //<S2SV> assert ( ! larger_dimensions || new_dimensions ) ; //<S2SV> # if USE_PARTIAL_COPY //<S2SV> if ( ! new_dimensions && ctx -> max_sz == 1 && active_map && ! flags ) { //<S2SV> for ( row = 0 ; row < mb_rows ; ++ row ) { //<S2SV> col = 0 ; //<S2SV> while ( 1 ) { //<S2SV> for ( ; col < mb_cols ; ++ col ) { //<S2SV> if ( active_map [ col ] ) //<S2SV> break ; //<S2SV> } //<S2SV> if ( col == mb_cols ) //<S2SV> break ; //<S2SV> active_end = col ; //<S2SV> for ( ; active_end < mb_cols ; ++ active_end ) { //<S2SV> if ( ! active_map [ active_end ] ) //<S2SV> break ; //<S2SV> } //<S2SV> vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , //<S2SV> row << 4 , //<S2SV> col << 4 , 16 , //<S2SV> ( active_end - col ) << 4 ) ; //<S2SV> col = active_end ; //<S2SV> } //<S2SV> active_map += mb_cols ; //<S2SV> } //<S2SV> } else { //<S2SV> # endif //<S2SV> if ( larger_dimensions ) { //<S2SV> YV12_BUFFER_CONFIG new_img ; //<S2SV> memset ( & new_img , 0 , sizeof ( new_img ) ) ; //<S2SV> if ( vpx_alloc_frame_buffer ( & new_img , //<S2SV> width , height , subsampling_x , subsampling_y , //<S2SV> # if CONFIG_VP9_HIGHBITDEPTH //<S2SV> use_highbitdepth , //<S2SV> # endif //<S2SV> VP9_ENC_BORDER_IN_PIXELS , //<S2SV> 0 ) ) //<S2SV> return 1 ; //<S2SV> vpx_free_frame_buffer ( & buf -> img ) ; //<S2SV> buf -> img = new_img ; //<S2SV> } else if ( new_dimensions ) { //<S2SV> buf -> img . y_crop_width = src -> y_crop_width ; //<S2SV> buf -> img . y_crop_height = src -> y_crop_height ; //<S2SV> buf -> img . uv_crop_width = src -> uv_crop_width ; //<S2SV> buf -> img . uv_crop_height = src -> uv_crop_height ; //<S2SV> buf -> img . subsampling_x = src -> subsampling_x ; //<S2SV> buf -> img . subsampling_y = src -> subsampling_y ; //<S2SV> } //<S2SV> vp9_copy_and_extend_frame ( src , & buf -> img ) ; //<S2SV> # if USE_PARTIAL_COPY //<S2SV> } //<S2SV> # endif //<S2SV> buf -> ts_start = ts_start ; //<S2SV> buf -> ts_end = ts_end ; //<S2SV> buf -> flags = flags ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 