static vpx_codec_err_t decoder_peek_si_internal ( const uint8_t * data , //<S2SV> unsigned int data_sz , //<S2SV> vpx_codec_stream_info_t * si , //<S2SV> int * is_intra_only , //<S2SV> vpx_decrypt_cb decrypt_cb , //<S2SV> void * decrypt_state ) { //<S2SV> int intra_only_flag = 0 ; //<S2SV> uint8_t clear_buffer [ 9 ] ; //<S2SV> if ( data + data_sz <= data ) //<S2SV> return VPX_CODEC_INVALID_PARAM ; //<S2SV> si -> is_kf = 0 ; //<S2SV> si -> w = si -> h = 0 ; //<S2SV> if ( decrypt_cb ) { //<S2SV> data_sz = VPXMIN ( sizeof ( clear_buffer ) , data_sz ) ; //<S2SV> decrypt_cb ( decrypt_state , data , clear_buffer , data_sz ) ; //<S2SV> data = clear_buffer ; //<S2SV> } //<S2SV> { //<S2SV> int show_frame ; //<S2SV> int error_resilient ; //<S2SV> struct vpx_read_bit_buffer rb = { data , data + data_sz , 0 , NULL , NULL } ; //<S2SV> const int frame_marker = vpx_rb_read_literal ( & rb , 2 ) ; //<S2SV> const BITSTREAM_PROFILE profile = vp9_read_profile ( & rb ) ; //<S2SV> if ( frame_marker != VP9_FRAME_MARKER ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( profile >= MAX_PROFILES ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( ( profile >= 2 && data_sz <= 1 ) || data_sz < 1 ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( vpx_rb_read_bit ( & rb ) ) { //<S2SV> vpx_rb_read_literal ( & rb , 3 ) ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> if ( data_sz <= 8 ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> si -> is_kf = ! vpx_rb_read_bit ( & rb ) ; //<S2SV> show_frame = vpx_rb_read_bit ( & rb ) ; //<S2SV> error_resilient = vpx_rb_read_bit ( & rb ) ; //<S2SV> if ( si -> is_kf ) { //<S2SV> if ( ! vp9_read_sync_code ( & rb ) ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; //<S2SV> } else { //<S2SV> intra_only_flag = show_frame ? 0 : vpx_rb_read_bit ( & rb ) ; //<S2SV> rb . bit_offset += error_resilient ? 0 : 2 ; //<S2SV> if ( intra_only_flag ) { //<S2SV> if ( ! vp9_read_sync_code ( & rb ) ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> if ( profile > PROFILE_0 ) { //<S2SV> if ( ! parse_bitdepth_colorspace_sampling ( profile , & rb ) ) //<S2SV> return VPX_CODEC_UNSUP_BITSTREAM ; //<S2SV> } //<S2SV> rb . bit_offset += REF_FRAMES ; //<S2SV> vp9_read_frame_size ( & rb , ( int * ) & si -> w , ( int * ) & si -> h ) ; //<S2SV> } //<S2SV> } //<S2SV> } //<S2SV> if ( is_intra_only != NULL ) //<S2SV> * is_intra_only = intra_only_flag ; //<S2SV> return VPX_CODEC_OK ; //<S2SV> } //<S2SV> 