static int sysMapBlockFile ( FILE * mapf , MemMapping * pMap ) //<S2SV> { //<S2SV> char block_dev [ PATH_MAX + 1 ] ; //<S2SV> size_t size ; //<S2SV> unsigned int blksize ; //<S2SV> size_t blocks ; //<S2SV> unsigned int range_count ; //<S2SV> unsigned int i ; //<S2SV> if ( fgets ( block_dev , sizeof ( block_dev ) , mapf ) == NULL ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>block<S2SV_blank>device<S2SV_blank>from<S2SV_blank>header\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> for ( i = 0 ; i < sizeof ( block_dev ) ; ++ i ) { //<S2SV> if ( block_dev [ i ] == '\\n' ) { //<S2SV> block_dev [ i ] = 0 ; //<S2SV> break ; //<S2SV> } //<S2SV> } //<S2SV> if ( fscanf ( mapf , "%zu<S2SV_blank>%u\\n%u\\n" , & size , & blksize , & range_count ) != 3 ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>block<S2SV_blank>map<S2SV_blank>header\\n" ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> if ( blksize != 0 ) { //<S2SV> blocks = ( ( size - 1 ) / blksize ) + 1 ; //<S2SV> } //<S2SV> if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { //<S2SV> LOGE ( "invalid<S2SV_blank>data<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%zu,<S2SV_blank>blksize<S2SV_blank>%u,<S2SV_blank>range_count<S2SV_blank>%u\\n" , //<S2SV> size , blksize , range_count ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> pMap -> range_count = range_count ; //<S2SV> pMap -> ranges = calloc ( range_count , sizeof ( MappedRange ) ) ; //<S2SV> if ( pMap -> ranges == NULL ) { //<S2SV> LOGE ( "calloc(%u,<S2SV_blank>%zu)<S2SV_blank>failed:<S2SV_blank>%s\\n" , range_count , sizeof ( MappedRange ) , strerror ( errno ) ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> unsigned char * reserve ; //<S2SV> reserve = mmap64 ( NULL , blocks * blksize , PROT_NONE , MAP_PRIVATE | MAP_ANON , - 1 , 0 ) ; //<S2SV> if ( reserve == MAP_FAILED ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>reserve<S2SV_blank>address<S2SV_blank>space:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; //<S2SV> free ( pMap -> ranges ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> int fd = open ( block_dev , O_RDONLY ) ; //<S2SV> if ( fd < 0 ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>block<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%s\\n" , block_dev , strerror ( errno ) ) ; //<S2SV> munmap ( reserve , blocks * blksize ) ; //<S2SV> free ( pMap -> ranges ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> unsigned char * next = reserve ; //<S2SV> size_t remaining_size = blocks * blksize ; //<S2SV> bool success = true ; //<S2SV> for ( i = 0 ; i < range_count ; ++ i ) { //<S2SV> size_t start , end ; //<S2SV> if ( fscanf ( mapf , "%zu<S2SV_blank>%zu\\n" , & start , & end ) != 2 ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>range<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map\\n" , i ) ; //<S2SV> success = false ; //<S2SV> break ; //<S2SV> } //<S2SV> size_t length = ( end - start ) * blksize ; //<S2SV> if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { //<S2SV> LOGE ( "unexpected<S2SV_blank>range<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map:<S2SV_blank>%zu<S2SV_blank>%zu\\n" , start , end ) ; //<S2SV> success = false ; //<S2SV> break ; //<S2SV> } //<S2SV> void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; //<S2SV> if ( addr == MAP_FAILED ) { //<S2SV> LOGW ( "failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>block<S2SV_blank>%d:<S2SV_blank>%s\\n" , i , strerror ( errno ) ) ; //<S2SV> success = false ; //<S2SV> break ; //<S2SV> } //<S2SV> pMap -> ranges [ i ] . addr = addr ; //<S2SV> pMap -> ranges [ i ] . length = length ; //<S2SV> next += length ; //<S2SV> remaining_size -= length ; //<S2SV> } //<S2SV> if ( success && remaining_size != 0 ) { //<S2SV> LOGE ( "ranges<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>are<S2SV_blank>invalid:<S2SV_blank>remaining_size<S2SV_blank>=<S2SV_blank>%zu\\n" , remaining_size ) ; //<S2SV> success = false ; //<S2SV> } //<S2SV> if ( ! success ) { //<S2SV> close ( fd ) ; //<S2SV> munmap ( reserve , blocks * blksize ) ; //<S2SV> free ( pMap -> ranges ) ; //<S2SV> return - 1 ; //<S2SV> } //<S2SV> close ( fd ) ; //<S2SV> pMap -> addr = reserve ; //<S2SV> pMap -> length = size ; //<S2SV> LOGI ( "mmapped<S2SV_blank>%d<S2SV_blank>ranges\\n" , range_count ) ; //<S2SV> return 0 ; //<S2SV> } //<S2SV> 