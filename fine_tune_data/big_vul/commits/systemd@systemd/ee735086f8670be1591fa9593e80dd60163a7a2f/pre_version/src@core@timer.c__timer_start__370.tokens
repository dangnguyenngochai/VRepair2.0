static int timer_start ( Unit * u ) { //<S2SV> Timer * t = TIMER ( u ) ; //<S2SV> TimerValue * v ; //<S2SV> assert ( t ) ; //<S2SV> assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; //<S2SV> if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) //<S2SV> return - ENOENT ; //<S2SV> t -> last_trigger = DUAL_TIMESTAMP_NULL ; //<S2SV> LIST_FOREACH ( value , v , t -> values ) //<S2SV> if ( v -> base == TIMER_ACTIVE ) //<S2SV> v -> disabled = false ; //<S2SV> if ( t -> stamp_path ) { //<S2SV> struct stat st ; //<S2SV> if ( stat ( t -> stamp_path , & st ) >= 0 ) //<S2SV> t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; //<S2SV> else if ( errno == ENOENT ) //<S2SV> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; //<S2SV> } //<S2SV> t -> result = TIMER_SUCCESS ; //<S2SV> timer_enter_waiting ( t , true ) ; //<S2SV> return 1 ; //<S2SV> } //<S2SV> 