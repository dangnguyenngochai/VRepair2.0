<S2SV_ModStart> e_value & ( 1UL <S2SV_ModEnd> << i )
<S2SV_ModStart> goto out_free_interp ; if ( file_permission ( interpreter , MAY_READ ) < 0 ) bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP ;
<S2SV_ModStart> error ; } if ( file_permission ( interpreter , MAY_READ ) < 0 ) bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP ;
<S2SV_ModStart> cardno >= MAX_BOARDS || dltmp . len < 0
<S2SV_ModStart> ; if ( len < 0 ||
<S2SV_ModStart> ; int i ; if ( len < 0 || len > sizeof ( moxaBuff ) ) return - EINVAL
<S2SV_ModStart> ; if ( len < 0 || len > sizeof ( moxaBuff ) ) return - EINVAL ; if (
<S2SV_ModStart> ops ) { void * table ; <S2SV_ModStart> ( & appldata_ops_lock <S2SV_ModEnd> ) ; list_del <S2SV_ModStart> list ) ; table = <S2SV_ModEnd> ops -> ctl_table <S2SV_ModStart> ops -> ctl_table <S2SV_ModEnd> ; ops -> <S2SV_ModStart> appldata_ops_lock ) ; unregister_sysctl_table ( ops -> sysctl_header ) ; kfree ( table ) ;
<S2SV_ModStart> * nodes ; if ( nodes_weight ( * nodes ) == 0 ) { kmem_cache_free ( policy_cache , policy ) ; return ERR_PTR ( - EINVAL ) ; }
<S2SV_ModStart> ; pmsg -> prefix_pad1 = 0 ; pmsg -> prefix_pad2 = 0 ; pmsg -> <S2SV_ModStart> pinfo -> type ; pmsg -> prefix_pad3 = 0
<S2SV_ModStart> -> tunnelhdr ; pinfo . pad = 0 ;
<S2SV_ModStart> priority2 + 1 ; opt . pad = 0
<S2SV_ModStart> = AF_UNSPEC ; t -> tca__pad1 = 0 ; t -> tca__pad2 = 0 ;
<S2SV_ModStart> = AF_UNSPEC ; t -> tca__pad1 = 0 ; t -> tca__pad2 = 0 ;
<S2SV_ModStart> = AF_UNSPEC ; t -> tca__pad1 = 0 ; t -> tca__pad2 = 0 ;
<S2SV_ModStart> = AF_UNSPEC ; t -> tca__pad1 = 0 ; t -> tca__pad2 = 0 ;
<S2SV_ModStart> ; r -> __ifi_pad = 0 ; r ->
<S2SV_ModStart> ; tcm -> tcm__pad1 = 0 ; tcm -> tcm__pad1 = 0 ; tcm ->
<S2SV_ModStart> * skb ; struct nlmsgerr * e ; <S2SV_ModStart> nlmsg_len ) ; e = <S2SV_ModEnd> NLMSG_DATA ( nlh <S2SV_ModStart> ( nlh ) ; e <S2SV_ModEnd> -> error = <S2SV_ModStart> - EMSGSIZE ; memset ( & e -> msg , 0 , sizeof ( e -> msg ) ) ;
<S2SV_ModStart> sk_buff * skb ; struct nlmsgerr * e <S2SV_ModStart> nlmsg_len ) ; e = <S2SV_ModEnd> NLMSG_DATA ( nlh <S2SV_ModStart> ( nlh ) ; e <S2SV_ModEnd> -> error = <S2SV_ModStart> = - ETIMEDOUT ; memset ( & e -> msg , 0 , sizeof ( e -> msg ) )
<S2SV_ModStart> ; ndm -> ndm_pad1 = 0 ; ndm -> ndm_pad2 = 0 ; ndm ->
<S2SV_ModStart> -> family ; ndtmsg -> ndtm_pad1 = 0 ; ndtmsg -> ndtm_pad2 = 0 ;
<S2SV_ModStart> -> family ; ndtmsg -> ndtm_pad1 = 0 ; ndtmsg -> ndtm_pad2 = 0 ;
<S2SV_ModStart> ifi_family = AF_UNSPEC ; r -> __ifi_pad = 0
<S2SV_ModStart> ; tcm -> tcm__pad1 = 0 ; tcm -> tcm__pad2 = 0 ; tcm ->
<S2SV_ModStart> ; r -> __ifi_pad = 0 ; r ->
<S2SV_ModStart> attrlen ) ; memset ( RTA_DATA ( rta ) + attrlen , 0 , RTA_ALIGN ( size ) - size ) ;
<S2SV_ModStart> u8 * nexthdrp <S2SV_ModEnd> ) { u8 <S2SV_ModStart> ; if ( nexthdr == NEXTHDR_NONE <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; hp = skb_header_pointer ( skb , start , sizeof ( _hdr ) , & _hdr ) ; if ( hp == NULL <S2SV_ModEnd> ) return - <S2SV_ModStart> return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> nexthdr ; <S2SV_ModEnd> start += hdrlen
<S2SV_ModStart> , & nexthdr <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , & nexthdr <S2SV_ModEnd> ) ; if
<S2SV_ModStart> -> number != tmp . <S2SV_ModEnd> num_counters ) {
<S2SV_ModStart> -> number != tmp . <S2SV_ModEnd> num_counters ) {
<S2SV_ModStart> ; # endif clear_fpu_state ( & tsk -> thread . i387 . fxsave <S2SV_ModEnd> ) ; }
<S2SV_ModStart> . ip ; memset ( sin . sin_zero , 0 , sizeof ( sin . sin_zero ) ) ;
<S2SV_ModStart> . ip ; memset ( sin . sin_zero , 0 , sizeof ( sin . sin_zero ) ) ;
<S2SV_ModStart> ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_2
<S2SV_ModStart> EINVAL ; } if ( ( vma -> vm_flags & ( VM_SHARED | VM_WRITE ) ) != ( VM_SHARED | VM_WRITE ) ) return - EACCES ;
<S2SV_ModStart> sch == NULL || sch -> length == 0
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> count != 0 ) || ! sch -> length
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> != 0 ) || ! sch -> length )
<S2SV_ModStart> goto out ; error = - EINVAL ; if ( memchr ( dentry -> d_name . name , '\\\\' , dentry -> d_name . len ) ) goto out ;
<S2SV_ModStart> int ispipe ; bool need_nonrelative = false ; <S2SV_ModStart> = GLOBAL_ROOT_UID ; need_nonrelative = true ; <S2SV_ModStart> goto fail_unlock ; if ( need_nonrelative && cn . corename [ 0 ] != '/' ) { printk ( KERN_WARNING "Pid<S2SV_blank>%d(%s)<S2SV_blank>can<S2SV_blank>only<S2SV_blank>dump<S2SV_blank>core<S2SV_blank>" "to<S2SV_blank>fully<S2SV_blank>qualified<S2SV_blank>path!\\n" , task_tgid_vnr ( current ) , current -> comm ) ; printk ( KERN_WARNING "Skipping<S2SV_blank>core<S2SV_blank>dump\\n" ) ; goto fail_unlock ; }
<S2SV_ModStart> || arg2 > 1 <S2SV_ModEnd> ) { error
<S2SV_ModStart> - 1 ; ret = 0 ;
<S2SV_ModStart> int check_result ; if ( BN_num_bits ( dh -> p ) > OPENSSL_DH_MAX_MODULUS_BITS ) { DHerr ( DH_F_COMPUTE_KEY , DH_R_MODULUS_TOO_LARGE ) ; goto err ; }
<S2SV_ModStart> 1 ; } if ( BN_num_bits ( dsa -> q ) != 160 ) { DSAerr ( DSA_F_DSA_DO_VERIFY , DSA_R_BAD_Q_VALUE ) ; return - 1 ; } if ( BN_num_bits ( dsa -> p ) > OPENSSL_DSA_MAX_MODULUS_BITS ) { DSAerr ( DSA_F_DSA_DO_VERIFY , DSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; }
<S2SV_ModStart> = NULL ; long field_bits ; <S2SV_ModStart> . char_two ; field_bits = char_two -> m ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_FIELD_TOO_LARGE ) ; goto err ; } <S2SV_ModStart> if ( ! ( char_two -> m > tmp_long && tmp_long > 0 ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_TRINOMIAL_BASIS ) ; goto err ; } if ( ! <S2SV_ModStart> if ( ! ( char_two -> m > penta -> k3 && penta -> k3 > penta -> k2 && penta -> k2 > penta -> k1 && penta -> k1 > 0 ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_PENTANOMIAL_BASIS ) ; goto err ; } if ( ! <S2SV_ModStart> EC_F_EC_ASN1_PARAMETERS2GROUP , ERR_R_ASN1_LIB ) ; goto err ; } if ( BN_is_negative ( p ) || BN_is_zero ( p ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_FIELD ) ; goto err ; } field_bits = BN_num_bits ( p ) ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_FIELD_TOO_LARGE <S2SV_ModStart> } if ( BN_is_negative ( a ) || BN_is_zero ( a ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if ( BN_num_bits ( a ) > ( int ) field_bits + 1 ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if (
<S2SV_ModStart> = NULL ; if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_MAX_MODULUS_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; } if ( BN_ucmp ( rsa -> n , rsa -> e ) <= 0 ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_SMALL_MODULUS_BITS ) { if ( BN_num_bits ( rsa -> e ) > OPENSSL_RSA_MAX_PUBEXP_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } }
<S2SV_ModStart> = NULL ; if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_MAX_MODULUS_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; } if ( BN_ucmp ( rsa -> n , rsa -> e ) <= 0 ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_SMALL_MODULUS_BITS ) { if ( BN_num_bits ( rsa -> e ) > OPENSSL_RSA_MAX_PUBEXP_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } }
<S2SV_ModStart> int check_result ; if ( BN_num_bits ( dh -> p ) > OPENSSL_DH_MAX_MODULUS_BITS ) { DHerr ( DH_F_COMPUTE_KEY , DH_R_MODULUS_TOO_LARGE ) ; goto err ; }
<S2SV_ModStart> 1 ; } if ( BN_num_bits ( dsa -> q ) != 160 ) { DSAerr ( DSA_F_DSA_DO_VERIFY , DSA_R_BAD_Q_VALUE ) ; return - 1 ; } if ( BN_num_bits ( dsa -> p ) > OPENSSL_DSA_MAX_MODULUS_BITS ) { DSAerr ( DSA_F_DSA_DO_VERIFY , DSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; }
<S2SV_ModStart> = NULL ; long field_bits ; <S2SV_ModStart> . char_two ; field_bits = char_two -> m ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_FIELD_TOO_LARGE ) ; goto err ; } <S2SV_ModStart> if ( ! ( char_two -> m > tmp_long && tmp_long > 0 ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_TRINOMIAL_BASIS ) ; goto err ; } if ( ! <S2SV_ModStart> if ( ! ( char_two -> m > penta -> k3 && penta -> k3 > penta -> k2 && penta -> k2 > penta -> k1 && penta -> k1 > 0 ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_PENTANOMIAL_BASIS ) ; goto err ; } if ( ! <S2SV_ModStart> EC_F_EC_ASN1_PARAMETERS2GROUP , ERR_R_ASN1_LIB ) ; goto err ; } if ( BN_is_negative ( p ) || BN_is_zero ( p ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_FIELD ) ; goto err ; } field_bits = BN_num_bits ( p ) ; if ( field_bits > OPENSSL_ECC_MAX_FIELD_BITS ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_FIELD_TOO_LARGE <S2SV_ModStart> } if ( BN_is_negative ( a ) || BN_is_zero ( a ) ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if ( BN_num_bits ( a ) > ( int ) field_bits + 1 ) { ECerr ( EC_F_EC_ASN1_PARAMETERS2GROUP , EC_R_INVALID_GROUP_ORDER ) ; goto err ; } if (
<S2SV_ModStart> = NULL ; if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_MAX_MODULUS_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; } if ( BN_ucmp ( rsa -> n , rsa -> e ) <= 0 ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_SMALL_MODULUS_BITS ) { if ( BN_num_bits ( rsa -> e ) > OPENSSL_RSA_MAX_PUBEXP_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } }
<S2SV_ModStart> = NULL ; if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_MAX_MODULUS_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_MODULUS_TOO_LARGE ) ; return - 1 ; } if ( BN_ucmp ( rsa -> n , rsa -> e ) <= 0 ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } if ( BN_num_bits ( rsa -> n ) > OPENSSL_RSA_SMALL_MODULUS_BITS ) { if ( BN_num_bits ( rsa -> e ) > OPENSSL_RSA_MAX_PUBEXP_BITS ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_ENCRYPT , RSA_R_BAD_E_VALUE ) ; return - 1 ; } }
<S2SV_ModStart> -> session -> sess_cert == NULL || s -> session ->
<S2SV_ModStart> client_princ ) { size_t <S2SV_ModEnd> len = strlen
<S2SV_ModStart> ( len -- <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> - 1 ; ret = 0 ;
<S2SV_ModStart> -> session -> sess_cert == NULL || s -> session ->
<S2SV_ModStart> client_princ ) { size_t <S2SV_ModEnd> len = strlen
<S2SV_ModStart> ( len -- <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> - 1 ; ret = 0 ;
<S2SV_ModStart> -> session -> sess_cert == NULL || s -> session ->
<S2SV_ModStart> client_princ ) { size_t <S2SV_ModEnd> len = strlen
<S2SV_ModStart> ( len -- <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> , const struct <S2SV_ModEnd> msghdr * msg <S2SV_ModStart> msghdr * msg , size_t paylen <S2SV_ModStart> payload = NULL ; int err ; <S2SV_ModEnd> retval = sctp_make_abort <S2SV_ModStart> ( asoc , NULL <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( paylen , GFP_KERNEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto err_payload ; err = memcpy_fromiovec ( payload , msg -> msg_iov , paylen ) ; if ( err < 0 <S2SV_ModEnd> ) goto err_copy <S2SV_ModStart> goto err_copy ; <S2SV_ModEnd> } sctp_init_cause (
<S2SV_ModStart> ) { struct <S2SV_ModEnd> sctp_chunk * abort <S2SV_ModStart> sctp_chunk * abort = arg <S2SV_ModStart> = SCTP_DISPOSITION_CONSUME ; <S2SV_ModEnd> sctp_add_cmd_sf ( commands
<S2SV_ModStart> ) { struct <S2SV_ModEnd> sctp_chunk * abort <S2SV_ModStart> sctp_chunk * abort = arg <S2SV_ModStart> = SCTP_DISPOSITION_CONSUME ; <S2SV_ModEnd> sctp_add_cmd_sf ( commands
<S2SV_ModStart> SCTP_ABORT ) { struct sctp_chunk * chunk ; chunk = sctp_make_abort_user ( asoc , msg , msg_len ) ; if ( ! chunk ) { err = - ENOMEM ; goto out_unlock ; } <S2SV_ModStart> ( asoc , chunk <S2SV_ModEnd> ) ; err
<S2SV_ModStart> -> s_maxbytes = 1 << 30 <S2SV_ModEnd> ; return 0
<S2SV_ModStart> offset ) { if ( ( ! bh && extoffset == udf_file_entry_alloc_offset ( inode ) ) || ( bh && extoffset == sizeof ( struct allocExtDesc ) ) ) { memset ( & eloc , 0x00 , sizeof ( kernel_lb_addr ) ) ; elen = EXT_NOT_RECORDED_NOT_ALLOCATED | offset ; udf_add_aext ( inode , & bloc , & extoffset , eloc , elen , & bh , 1 ) ; } else { <S2SV_ModStart> } } } }
<S2SV_ModStart> num ) ; if ( r > 42 && 3 * 8 * r >= BN_num_bits ( rsa -> n ) ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_PKCS1_PADDING_TOO_SHORT ) ; goto err ; }
<S2SV_ModStart> goto err ; if ( p != s + i ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; } if ( sig -> algor -> parameter && ASN1_TYPE_get ( sig -> algor -> parameter ) != V_ASN1_NULL ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; }
<S2SV_ModStart> num ) ; if ( r > 42 && 3 * 8 * r >= BN_num_bits ( rsa -> n ) ) { RSAerr ( RSA_F_RSA_EAY_PUBLIC_DECRYPT , RSA_R_PKCS1_PADDING_TOO_SHORT ) ; goto err ; }
<S2SV_ModStart> goto err ; if ( p != s + i ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; } if ( sig -> algor -> parameter && ASN1_TYPE_get ( sig -> algor -> parameter ) != V_ASN1_NULL ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; }
<S2SV_ModStart> goto err ; if ( p != s + i ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; } if ( sig -> algor -> parameter && ASN1_TYPE_get ( sig -> algor -> parameter ) != V_ASN1_NULL ) { RSAerr ( RSA_F_RSA_VERIFY , RSA_R_BAD_SIGNATURE ) ; goto err ; }
<S2SV_ModStart> = 0 ; char b [ BDEVNAME_SIZE ] ; <S2SV_ModStart> { printk ( "MINIX-fs:<S2SV_blank>block_to_path:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank><<S2SV_blank>0<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s\\n" , block , bdevname ( inode -> i_sb -> s_bdev , b ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ) { if ( printk_ratelimit ( ) ) printk ( "MINIX-fs:<S2SV_blank>block_to_path:<S2SV_blank>" "block<S2SV_blank>%ld<S2SV_blank>too<S2SV_blank>big<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s\\n" , block , bdevname ( inode -> i_sb -> s_bdev , b ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = 0 ; char b [ BDEVNAME_SIZE ] ; <S2SV_ModStart> { printk ( "MINIX-fs:<S2SV_blank>block_to_path:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank><<S2SV_blank>0<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s\\n" , block , bdevname ( sb -> s_bdev , b ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ) { if ( printk_ratelimit ( ) ) printk ( "MINIX-fs:<S2SV_blank>block_to_path:<S2SV_blank>" "block<S2SV_blank>%ld<S2SV_blank>too<S2SV_blank>big<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>%s\\n" , block , bdevname ( sb -> s_bdev , b ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if ( type_page && data_page
<S2SV_ModStart> 5 ) ; min_bytes_to_read = min_t ( size_t , min_bytes_to_read , READ_WRITE_BUFFER_SIZE ) ;
<S2SV_ModStart> } if ( ( <S2SV_ModStart> count < 5 ) || ( count > READ_WRITE_BUFFER_SIZE )
<S2SV_ModStart> ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> ( result , 0 ) ; if ( __udp_lib_port_inuse ( hash , result , 0 , udptable ) ) continue ; if ( ! inet_sk ( sk ) -> rcv_saddr ) break ; hash = hash_port_and_addr ( result , <S2SV_ModStart> ( snum , 0 <S2SV_ModEnd> ) ; head <S2SV_ModStart> goto fail ; if ( inet_sk ( sk ) -> rcv_saddr ) { hash = hash_port_and_addr ( snum , inet_sk ( sk ) -> rcv_saddr ) ; head = & udptable [ hash & ( UDP_HTABLE_SIZE - 1 ) ] ; sk_for_each ( sk2 , node , head ) if ( sk2 -> sk_hash == hash && sk2 != sk && inet_sk ( sk2 ) -> num == snum && ( ! sk2 -> sk_reuse || ! sk -> sk_reuse ) && ( ! sk2 -> sk_bound_dev_if || ! sk -> sk_bound_dev_if || sk2 -> sk_bound_dev_if == sk -> sk_bound_dev_if ) && ( * saddr_comp ) ( sk , sk2 ) ) goto fail ; }
<S2SV_ModStart> ( newconntrack == SCTP_CONNTRACK_NONE || newconntrack ==
<S2SV_ModStart> ) { int <S2SV_ModEnd> rsvd = r <S2SV_ModStart> random_read_wakeup_thresh / 4 ; int bytes = nbytes ; bytes = max_t ( int , bytes , random_read_wakeup_thresh / 8 ) ; bytes = min_t ( int , bytes , sizeof ( tmp ) )
<S2SV_ModStart> sz ) ; if ( type >= f -> lb ) return H323_ERROR_RANGE ;
<S2SV_ModStart> ( ! base || ! ( son -> attr & DECODE )
<S2SV_ModStart> long base ; seg &= ~ 7UL ; <S2SV_ModStart> sem ) ; if ( unlikely ( ( seg >> 3 ) >= child -> mm -> context . size ) ) addr = - 1L ; else { <S2SV_ModStart> . ldt + seg <S2SV_ModEnd> ; base = <S2SV_ModStart> ; base = ( <S2SV_ModStart> ] & 0xff000000 ) <S2SV_ModStart> += base ; }
<S2SV_ModStart> _PAGE_NO_CACHE ) ) demote_segment_4k ( mm , ea ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> skb ) ; struct net * net = ipv6_skb_net ( skb ) ; u32 pkt_len <S2SV_ModEnd> ; if (
<S2SV_ModStart> ; IP6_INC_STATS_BH ( ipv6_skb_idev ( skb <S2SV_ModEnd> ) , IPSTATS_MIB_INHDRERRORS <S2SV_ModStart> { IP6_INC_STATS_BH ( ipv6_skb_idev ( skb <S2SV_ModEnd> ) , IPSTATS_MIB_INHDRERRORS <S2SV_ModStart> { IP6_INC_STATS_BH ( ipv6_skb_idev ( skb <S2SV_ModEnd> ) , IPSTATS_MIB_INHDRERRORS <S2SV_ModStart> { IP6_INC_STATS_BH ( ipv6_skb_idev ( skb <S2SV_ModEnd> ) , IPSTATS_MIB_INTRUNCATEDPKTS
<S2SV_ModStart> unsigned long tmp <S2SV_ModEnd> ; switch (
<S2SV_ModStart> fc ) ; if ( skb -> len < hdrlen ) { printk ( KERN_INFO "%s:<S2SV_blank>invalid<S2SV_blank>SKB<S2SV_blank>length<S2SV_blank>%d\\n" , dev -> name , skb -> len ) ; goto rx_dropped ; }
<S2SV_ModStart> ) return 0 ; if ( ! tp -> packets_out ) goto out <S2SV_ModStart> 0 ) ; out :
<S2SV_ModStart> pSMB = NULL <S2SV_ModEnd> ; cFYI ( <S2SV_ModStart> return rc ; <S2SV_ModEnd> pSMB -> FileID <S2SV_ModStart> ; rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> * ) pSMB <S2SV_ModEnd> , 0 ) <S2SV_ModStart> num_fclose ) ; <S2SV_ModEnd> if ( rc
<S2SV_ModStart> pSMB = NULL <S2SV_ModEnd> ; cFYI ( <S2SV_ModStart> return rc ; <S2SV_ModEnd> pSMB -> FileID <S2SV_ModStart> ; rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> * ) pSMB <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; } } <S2SV_ModEnd> if ( rc
<S2SV_ModStart> 1 , ( "CIFSSMBLock<S2SV_blank>timeout<S2SV_blank>%d<S2SV_blank>numLock<S2SV_blank>%d" <S2SV_ModEnd> , waitFlag , <S2SV_ModStart> { timeout = CIFS_ASYNC_OP <S2SV_ModEnd> ; pSMB -> <S2SV_ModStart> { timeout = CIFS_BLOCKING_OP <S2SV_ModEnd> ; pSMB -> <S2SV_ModStart> bytes_returned ) ; cifs_small_buf_release ( pSMB ) ; <S2SV_ModStart> { rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> ) pSMB , <S2SV_ModEnd> timeout ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> return rc ;
<S2SV_ModStart> ses ) { <S2SV_ModEnd> LOGOFF_ANDX_REQ * pSMB <S2SV_ModStart> rc = 0 <S2SV_ModEnd> ; cFYI ( <S2SV_ModStart> rc ; } <S2SV_ModEnd> if ( ses <S2SV_ModStart> ; rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> ) pSMB , <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ses -> sesSem <S2SV_ModEnd> ) ; if
<S2SV_ModStart> & bytes_returned , CIFS_ASYNC_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> & bytes_returned , CIFS_LONG_OP <S2SV_ModEnd> ) ; cifs_stats_inc
<S2SV_ModStart> = 0 ; int resp_buf_type = 0 ; <S2SV_ModStart> byte_count , count ; struct kvec iov [ 1 ] <S2SV_ModStart> { timeout = CIFS_BLOCKING_OP <S2SV_ModEnd> ; parm_data -> <S2SV_ModStart> } else { iov [ 0 ] . iov_base = ( char * ) pSMB ; iov [ 0 ] . iov_len = pSMB -> hdr . smb_buf_length + 4 ; rc = SendReceive2 <S2SV_ModEnd> ( xid , <S2SV_ModStart> -> ses , iov , 1 , & resp_buf_type , timeout ) ; pSMB = NULL ; pSMBr = ( struct smb_com_transaction2_sfi_rsp * ) iov [ 0 ] . iov_base <S2SV_ModEnd> ; } if <S2SV_ModStart> pSMB ) ; if ( resp_buf_type == CIFS_SMALL_BUFFER ) cifs_small_buf_release ( iov [ 0 ] . iov_base ) ; else if ( resp_buf_type == CIFS_LARGE_BUFFER ) cifs_buf_release ( iov [ 0 ] . iov_base ) ;
<S2SV_ModStart> & resp_buf_type , CIFS_STD_OP | CIFS_LOG_ERROR <S2SV_ModEnd> ) ; cifs_stats_inc
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> char * data_offset <S2SV_ModStart> ; int rc <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ) return rc <S2SV_ModEnd> ; pSMB -> <S2SV_ModStart> ; rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> ) pSMB , <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> return rc ;
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> char * data_offset <S2SV_ModStart> ; int rc <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ) return rc <S2SV_ModEnd> ; params = <S2SV_ModStart> ; rc = SendReceiveNoRsp <S2SV_ModEnd> ( xid , <S2SV_ModStart> ) pSMB , <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> return rc ;
<S2SV_ModStart> * smb_buffer ; <S2SV_ModEnd> int rc = <S2SV_ModStart> = 0 ; <S2SV_ModEnd> cFYI ( 1 <S2SV_ModStart> rc ; } rc = SendReceiveNoRsp ( xid , tcon -> ses , smb_buffer <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> up ( &
<S2SV_ModStart> resp_buf_type , long_op <S2SV_ModEnd> ) ; cifs_stats_inc
<S2SV_ModStart> & bytes_returned , CIFS_LONG_OP <S2SV_ModEnd> ) ; cifs_stats_inc
<S2SV_ModStart> & bytes_returned , CIFS_LONG_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> & bytes_returned , CIFS_LONG_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> & bytes_returned , CIFS_LONG_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> & length , CIFS_STD_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) long_op = CIFS_VLONG_OP <S2SV_ModEnd> ; else long_op <S2SV_ModStart> else long_op = CIFS_LONG_OP <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; long_op = CIFS_STD_OP <S2SV_ModEnd> ; } cifs_stats_bytes_written
<S2SV_ModStart> ) long_op = CIFS_VLONG_OP <S2SV_ModEnd> ; else long_op <S2SV_ModStart> else long_op = CIFS_LONG_OP <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; long_op = CIFS_STD_OP <S2SV_ModEnd> ; } cifs_stats_bytes_written
<S2SV_ModStart> , n_iov , CIFS_LONG_OP <S2SV_ModEnd> ) ; atomic_dec
<S2SV_ModStart> & resp_buf_type , CIFS_STD_OP | CIFS_LOG_ERROR <S2SV_ModEnd> ) ; cFYI
<S2SV_ModStart> , const int flags ) { int rc = 0 ; int long_op <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> . iov_base ; long_op = flags & CIFS_TIMEOUT_MASK ; <S2SV_ModStart> ( long_op == CIFS_STD_OP ) timeout = 15 * HZ ; else if ( long_op == CIFS_VLONG_OP ) timeout = 180 * HZ ; else if ( long_op == CIFS_LONG_OP ) timeout = 45 * HZ ; else if ( long_op == CIFS_ASYNC_OP <S2SV_ModEnd> ) goto out <S2SV_ModStart> ( long_op == CIFS_BLOCKING_OP <S2SV_ModEnd> ) timeout = <S2SV_ModStart> ) timeout = 0x7FFFFFFF ; else { cERROR ( 1 , ( "unknown<S2SV_blank>timeout<S2SV_blank>flag<S2SV_blank>%d" , long_op ) ) ; rc = - EIO ; goto out ; } <S2SV_ModEnd> if ( signal_pending <S2SV_ModStart> -> resp_buf , flags & CIFS_LOG_ERROR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) ; if ( ( flags & CIFS_NO_RESP ) == 0 )
<S2SV_ModStart> ( ses , CIFS_BLOCKING_OP <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( long_op == CIFS_STD_OP ) timeout = 15 * HZ ; else if ( long_op == CIFS_ASYNC_OP <S2SV_ModEnd> ) goto out <S2SV_ModStart> ( long_op == CIFS_VLONG_OP <S2SV_ModEnd> ) timeout = <S2SV_ModStart> ( long_op == CIFS_LONG_OP ) timeout = 45 * HZ ; else if ( long_op == CIFS_BLOCKING_OP ) timeout = 0x7FFFFFFF ; else { cERROR ( 1 , ( "unknown<S2SV_blank>timeout<S2SV_blank>flag<S2SV_blank>%d" , long_op ) ) ; rc = - EIO ; goto out ; } <S2SV_ModEnd> if ( signal_pending
<S2SV_ModStart> & bytes_returned , CIFS_STD_OP <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( long_op == CIFS_ASYNC_OP <S2SV_ModEnd> ) { atomic_inc <S2SV_ModStart> if ( long_op != CIFS_BLOCKING_OP <S2SV_ModEnd> ) atomic_inc (
<S2SV_ModStart> - EFAULT ; iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0 ; <S2SV_ModStart> - EFAULT ; iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0 ; <S2SV_ModStart> ++ ) { snprintf ( bname , sizeof ( bname ) <S2SV_ModEnd> , "%s%s" , <S2SV_ModStart> - EFAULT ; iocts . drvid [ sizeof ( iocts . drvid ) - 1 ] = 0 ;
<S2SV_ModStart> ; if ( inode -> i_uid != current -> fsuid ) goto close_fail ; if (
<S2SV_ModStart> interval ) ; if ( timer -> expires . tv64 < 0 ) timer -> expires = ktime_set ( KTIME_SEC_MAX , 0 ) ;
<S2SV_ModStart> } dio = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; dio -> <S2SV_ModEnd> inode = inode <S2SV_ModStart> i_blkbits - blkbits <S2SV_ModEnd> ; dio -> <S2SV_ModStart> ; dio -> <S2SV_ModEnd> get_block = get_block <S2SV_ModStart> ; dio -> <S2SV_ModEnd> final_block_in_bio = - <S2SV_ModStart> ; dio -> <S2SV_ModEnd> iocb = iocb <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> pages_in_io = 2 <S2SV_ModEnd> ; for (
<S2SV_ModStart> tlsext_hostname ) ; s -> session -> tlsext_hostname = NULL ;
<S2SV_ModStart> tlsext_hostname ) ; s -> session -> tlsext_hostname = NULL ;
<S2SV_ModStart> return retval ; if ( resource == RLIMIT_CPU && new_rlim . rlim_cur == 0 ) { new_rlim . rlim_cur = 1 ; } <S2SV_ModStart> cputime_t cputime ; <S2SV_ModEnd> cputime = secs_to_cputime
<S2SV_ModStart> ( addr_t ) & dummy -> regs . fp_regs ) { tmp = 0 ; } else if ( addr < ( addr_t )
<S2SV_ModStart> ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t )
<S2SV_ModStart> ; if ( * con == ASN1_PRI && ! def ) return 0 ; if (
<S2SV_ModStart> } } } if ( * len > ctx -> end - ctx -> pointer ) return 0 ;
<S2SV_ModStart> pointer + 1 ; if ( size < 2 || size > ULONG_MAX / sizeof ( unsigned long ) ) return 0
<S2SV_ModStart> ; if ( * con == ASN1_PRI && ! def ) return 0 ; if (
<S2SV_ModStart> } } } if ( * len > ctx -> end - ctx -> pointer ) return 0 ;
<S2SV_ModStart> pointer + 1 ; if ( size < 2 || size > ULONG_MAX / sizeof ( unsigned long ) ) return 0
<S2SV_ModStart> mm ) { __ptrace_detach ( p , 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> child ) { BUG_ON <S2SV_ModEnd> ( ! child <S2SV_ModStart> child -> ptrace <S2SV_ModEnd> ) ; child
<S2SV_ModStart> child ) ; <S2SV_ModEnd> write_lock_irq ( & <S2SV_ModStart> tasklist_lock ) ; <S2SV_ModEnd> if ( child <S2SV_ModStart> ( child -> ptrace ) __ptrace_detach ( child , data <S2SV_ModEnd> ) ; write_unlock_irq
<S2SV_ModStart> goto out ; repeat : task_lock ( task ) ; local_irq_disable ( ) ; if ( ! write_trylock <S2SV_ModEnd> ( & tasklist_lock <S2SV_ModStart> & tasklist_lock ) ) { local_irq_enable ( ) ; task_unlock ( task ) ; do { cpu_relax ( ) ; } while ( ! write_can_lock ( & tasklist_lock ) ) ; goto repeat ; } <S2SV_ModEnd> if ( task
<S2SV_ModStart> { int retval <S2SV_ModEnd> ; retval = <S2SV_ModStart> 1 ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> tgid ) goto out ; write_lock_irq ( & tasklist_lock ) ; task_lock ( task ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> |= PT_PTRACE_CAP ; <S2SV_ModEnd> __ptrace_link ( task <S2SV_ModStart> task , current <S2SV_ModEnd> ) ; force_sig_specific <S2SV_ModStart> task ) ; bad : write_unlock_irq ( & tasklist_lock ) ; <S2SV_ModEnd> task_unlock ( task <S2SV_ModStart> task ) ; out :
<S2SV_ModStart> { int ret = - EPERM ; task_lock ( current ) ; if ( ! <S2SV_ModEnd> ( current -> <S2SV_ModStart> & PT_PTRACED ) ) { <S2SV_ModEnd> ret = security_ptrace <S2SV_ModStart> ; if ( ! ret ) <S2SV_ModEnd> current -> ptrace <S2SV_ModStart> |= PT_PTRACED ; } task_unlock ( current ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ptl ) ; <S2SV_ModEnd> pte = * <S2SV_ModStart> ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! pte_write ( pte ) ) goto unlock ; <S2SV_ModEnd> page = vm_normal_page <S2SV_ModStart> ) ) goto bad_page <S2SV_ModEnd> ; if ( <S2SV_ModStart> return page ; bad_page : pte_unmap_unlock ( ptep , ptl ) ; return ERR_PTR ( - EFAULT ) ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return page ;
<S2SV_ModStart> } if ( IS_ERR ( page ) ) return i ? i : PTR_ERR ( page ) ; if (
<S2SV_ModStart> ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , <S2SV_ModEnd> msg -> msg_iov <S2SV_ModStart> -> msg_iov , <S2SV_ModEnd> len ) ; <S2SV_ModStart> ; if ( likely ( err == 0 ) ) err = len ; <S2SV_ModEnd> kfree_skb ( skb
<S2SV_ModStart> addr_num <= 0 || getaddrs . addr_num >= ( INT_MAX / sizeof ( union sctp_addr ) ) ) <S2SV_ModEnd> return - EINVAL
<S2SV_ModStart> & ~ MS_REC ; if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM
<S2SV_ModStart> dentry * new ; dentry = ERR_PTR ( - ENOENT ) ; if ( IS_DEADDIR ( inode ) ) goto out ; new
<S2SV_ModStart> struct dentry * dentry ; result = ERR_PTR ( - ENOENT ) ; if ( IS_DEADDIR ( dir ) ) goto out_unlock ; <S2SV_ModStart> dentry ; } out_unlock :
<S2SV_ModStart> return - EFAULT ; if ( opt . dccpsf_len < 1 ) return - EINVAL
<S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return - <S2SV_ModStart> : if ( ! capable ( CAP_NET_ADMIN ) <S2SV_ModEnd> ) return -
<S2SV_ModStart> sctp_auth_bytes * key ; if ( ( INT_MAX - key_len ) < sizeof ( struct sctp_auth_bytes ) ) return NULL
<S2SV_ModStart> out ; } if ( authkey -> sca_keylength > optlen ) { ret = - EINVAL ; goto out ; }
<S2SV_ModStart> exstack ) { <S2SV_ModEnd> struct mm_struct * <S2SV_ModStart> up_fail ; } ret = install_special_mapping ( mm , addr , PAGE_SIZE , VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC | VM_ALWAYSDUMP , syscall_pages <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ret ) <S2SV_ModEnd> goto up_fail ; <S2SV_ModStart> goto up_fail ; <S2SV_ModEnd> current -> mm <S2SV_ModStart> SYSENTER_RETURN ) ; <S2SV_ModEnd> up_fail : up_write
<S2SV_ModStart> ; int ret = 0 ; int dir_has_error <S2SV_ModStart> bh ) { if ( ! dir_has_error ) { <S2SV_ModStart> ( sb , __func__ , "directory<S2SV_blank>#%lu<S2SV_blank>" "contains<S2SV_blank>a<S2SV_blank>hole<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%Lu" <S2SV_ModEnd> , inode -> <S2SV_ModStart> ( unsigned long long ) filp -> f_pos ) ; dir_has_error = 1 ; } <S2SV_ModEnd> if ( filp
<S2SV_ModStart> i_blocks = 0 <S2SV_ModEnd> ; inode -> <S2SV_ModStart> : inode -> i_mapping -> a_ops = & shmem_aops ; inode ->
<S2SV_ModStart> ) { struct inet6_dev * idev = ip6_dst_idev ( & rt -> u . dst ) ; struct <S2SV_ModStart> ( ipv6_dev_get_saddr ( idev ? idev -> dev : NULL <S2SV_ModEnd> , dst ,
<S2SV_ModStart> type = SCTP_PARAM_CHUNKS ; auth_chunks -> param_hdr . length = htons ( sizeof ( sctp_paramhdr_t ) ) <S2SV_ModStart> param_hdr . length += htons ( <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> sctp_association * asoc ; if ( ! sctp_auth_enable ) return - EACCES <S2SV_ModStart> -> active_key_id ; len = sizeof ( struct sctp_authkeyid ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ;
<S2SV_ModStart> ) { struct sctp_hmacalgo __user * p = ( void __user * ) optval ; struct <S2SV_ModStart> hmacs ; __u16 data_len = 0 ; u32 num_idents ; if ( ! sctp_auth_enable ) return - EACCES <S2SV_ModEnd> ; hmacs = <S2SV_ModStart> -> auth_hmacs_list ; data_len <S2SV_ModEnd> = ntohs ( <S2SV_ModStart> . length ) - sizeof ( sctp_paramhdr_t ) <S2SV_ModStart> ( len < sizeof ( struct sctp_hmacalgo ) + data_len <S2SV_ModEnd> ) return - <S2SV_ModStart> return - EINVAL ; len = sizeof ( struct sctp_hmacalgo ) + data_len ; num_idents = data_len / sizeof ( u16 ) <S2SV_ModStart> ; if ( put_user ( num_idents , & p -> shmac_num_idents ) ) return - EFAULT ; if ( copy_to_user ( p -> shmac_idents <S2SV_ModEnd> , hmacs -> <S2SV_ModStart> -> hmac_ids , data_len <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; u32 num_chunks = 0 <S2SV_ModStart> ; if ( ! sctp_auth_enable ) return - EACCES ; if ( len < <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> & val , optval <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> -> auth_chunk_list ; if ( ! ch ) goto num ; <S2SV_ModStart> ( len < sizeof ( struct sctp_authchunks ) + <S2SV_ModStart> - EINVAL ; if ( copy_to_user ( to , ch -> chunks , num_chunks ) ) return - EFAULT ; num : len = sizeof ( struct sctp_authchunks ) + <S2SV_ModEnd> num_chunks ; if <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ; u32 num_chunks = 0 <S2SV_ModStart> ; if ( ! sctp_auth_enable ) return - EACCES ; if ( len < <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> & val , optval <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> . peer_chunks ; if ( ! ch ) goto num ; <S2SV_ModStart> - EINVAL ; if ( copy_to_user ( to , ch -> chunks , num_chunks ) ) return - EFAULT ; num : len = sizeof ( struct sctp_authchunks ) + <S2SV_ModEnd> num_chunks ; if <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> sctp_association * asoc ; if ( ! sctp_auth_enable ) return - EACCES
<S2SV_ModStart> struct sctp_authchunk val ; if ( ! sctp_auth_enable ) return - EACCES
<S2SV_ModStart> ; int ret ; if ( ! sctp_auth_enable ) return - EACCES
<S2SV_ModStart> sctp_association * asoc ; if ( ! sctp_auth_enable ) return - EACCES
<S2SV_ModStart> ; int err ; if ( ! sctp_auth_enable ) return - EACCES
<S2SV_ModStart> -> f_mapping ; struct inode * inode = mapping -> host ; <S2SV_ModStart> ssize_t ret ; int err ; err = should_remove_suid ( out -> f_dentry ) ; if ( unlikely ( err ) ) { mutex_lock ( & inode -> i_mutex ) ; err = __remove_suid ( out -> f_dentry , err ) ; mutex_unlock ( & inode -> i_mutex ) ; if ( err ) return err ; } <S2SV_ModStart> 0 ) { <S2SV_ModEnd> * ppos += <S2SV_ModStart> ) ) { <S2SV_ModEnd> mutex_lock ( &
<S2SV_ModStart> ret ; int err ; err = remove_suid ( out -> f_dentry ) ; if ( unlikely ( err ) ) return
<S2SV_ModStart> sizeof ( struct posix_user_ace_state <S2SV_ModEnd> ) ; state
<S2SV_ModStart> [ i ] ; if ( id > SCTP_AUTH_HMAC_ID_MAX ) return - EOPNOTSUPP
<S2SV_ModStart> sctp_hmacalgo * hmacs ; u32 idents <S2SV_ModStart> out ; } idents = <S2SV_ModEnd> hmacs -> shmac_num_idents <S2SV_ModStart> hmacs -> shmac_num_idents ; if ( idents <S2SV_ModStart> == 0 || idents > SCTP_AUTH_NUM_HMACS || ( idents * sizeof ( u16 ) ) > ( optlen - sizeof ( struct sctp_hmacalgo ) ) <S2SV_ModEnd> ) { err
<S2SV_ModStart> ATTR_FILE ; } newattrs . ia_valid |= should_remove_suid ( dentry ) ;
<S2SV_ModStart> ) ) goto out_release <S2SV_ModEnd> ; } ret <S2SV_ModStart> ; out : unlock_page ( page ) ; out_release : page_cache_release <S2SV_ModEnd> ( page )
<S2SV_ModStart> NFS_MOUNT_NONLM ) ) <S2SV_ModEnd> status = NFS_PROTO <S2SV_ModStart> fl ) ; <S2SV_ModEnd> else status =
<S2SV_ModStart> ; vmi_ops . write_ldt_entry <S2SV_ModEnd> ( dt ,
<S2SV_ModStart> [ i ] ; if ( id > SCTP_AUTH_HMAC_ID_MAX ) return - EOPNOTSUPP
<S2SV_ModStart> sctp_hmacalgo * hmacs ; u32 idents <S2SV_ModStart> out ; } idents = <S2SV_ModEnd> hmacs -> shmac_num_idents <S2SV_ModStart> hmacs -> shmac_num_idents ; if ( idents <S2SV_ModStart> == 0 || idents > SCTP_AUTH_NUM_HMACS || ( idents * sizeof ( u16 ) ) > ( optlen - sizeof ( struct sctp_hmacalgo ) ) <S2SV_ModEnd> ) { err
<S2SV_ModStart> - EBADF ; if ( unlikely ( out -> f_flags & O_APPEND ) ) return - EINVAL ;
<S2SV_ModStart> errp ) { <S2SV_ModEnd> if ( * <S2SV_ModStart> * errp = sctp_make_violation_paramlen <S2SV_ModEnd> ( asoc , <S2SV_ModStart> , chunk , <S2SV_ModEnd> param ) ; <S2SV_ModStart> param ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> , type , arg , <S2SV_ModStart> , type , arg , <S2SV_ModStart> void * ) <S2SV_ModEnd> err_param , commands
<S2SV_ModStart> , type , arg , <S2SV_ModStart> void * ) <S2SV_ModEnd> err_param , commands
<S2SV_ModStart> * arg , void * ext , <S2SV_ModStart> commands ) { struct sctp_chunk * chunk = arg ; struct sctp_paramhdr * param = ext ; struct sctp_chunk * abort = NULL ; if ( sctp_auth_recv_cid ( SCTP_CID_ABORT , asoc ) ) goto discard ; abort = sctp_make_violation_paramlen ( asoc , chunk , param ) ; if ( ! abort ) goto nomem ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; SCTP_INC_STATS ( SCTP_MIB_OUTCTRLCHUNKS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_PROTO_VIOLATION ) ) ; SCTP_DEC_STATS ( SCTP_MIB_CURRESTAB ) ; discard : sctp_sf_pdiscard <S2SV_ModEnd> ( ep , <S2SV_ModStart> , asoc , SCTP_ST_CHUNK ( 0 ) , <S2SV_ModStart> arg , commands ) ; SCTP_INC_STATS ( SCTP_MIB_ABORTEDS ) ; return SCTP_DISPOSITION_ABORT ; nomem : return SCTP_DISPOSITION_NOMEM <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> EIO ; } if ( be16_to_cpu ( tmp . thread . nodeName . length ) > 255 ) { printk ( KERN_ERR "hfs:<S2SV_blank>catalog<S2SV_blank>name<S2SV_blank>length<S2SV_blank>corrupted\\n" ) ; return - EIO ; }
<S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; } <S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; } <S2SV_ModStart> NULL ) ; if ( IS_ERR ( page ) ) { start = size ; goto out ; }
<S2SV_ModStart> . len ; if ( len > HFS_NAMELEN ) { printk ( KERN_ERR "hfs:<S2SV_blank>bad<S2SV_blank>catalog<S2SV_blank>namelength\\n" ) ; return - EIO ; }
<S2SV_ModStart> : if ( ! ( <S2SV_ModStart> & CHIP_HAS_BASSTREBLE ) )
<S2SV_ModStart> : if ( ! ( <S2SV_ModStart> & CHIP_HAS_BASSTREBLE ) ) <S2SV_ModStart> : if ( ! ( <S2SV_ModStart> & CHIP_HAS_BASSTREBLE ) ) break ; ctrl -> value = chip -> treble ; return 0 ; } <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( ! ( <S2SV_ModStart> & CHIP_HAS_BASSTREBLE ) ) <S2SV_ModStart> : if ( ! ( <S2SV_ModStart> & CHIP_HAS_BASSTREBLE ) ) break ; chip -> treble = ctrl -> value ; chip_write ( chip , desc -> treblereg , desc -> treblefunc ( chip -> treble ) ) ; return 0 ; } <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> desc -> checkmode && desc -> setmode
<S2SV_ModStart> ; if ( r <= 0 <S2SV_ModEnd> ) CMSerr (
<S2SV_ModStart> ) && ( i <= 0 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> if ( i > 0 <S2SV_ModStart> if ( i > 0
<S2SV_ModStart> ; if ( <S2SV_ModEnd> EVP_VerifyFinal ( & <S2SV_ModStart> , pkey ) <= 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> EVP_VerifyFinal ( & <S2SV_ModStart> , pkey ) <= 0
<S2SV_ModStart> ) && ( i <= 0 <S2SV_ModEnd> ) # ifndef
<S2SV_ModStart> ; if ( i <= 0 <S2SV_ModEnd> ) { al
<S2SV_ModStart> if ( ret <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> if ( i > 0
<S2SV_ModStart> if ( i > 0
<S2SV_ModStart> ! reqfile && <S2SV_ModEnd> X509_verify_cert ( & <S2SV_ModStart> & xsc ) <= 0
<S2SV_ModStart> out ; } if ( test_bit ( ATM_VF_LISTEN , & vcc -> flags ) ) { error = - EADDRINUSE ; goto out ; } <S2SV_ModEnd> set_bit ( ATM_VF_WAITING <S2SV_ModStart> vcc -> flags ) ; vcc_insert_socket ( sk
<S2SV_ModStart> -> ssid_len = min_t ( int , 32 , elem -> len ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> -> data , bss -> ssid_len <S2SV_ModEnd> ) ; lbs_deb_scan
<S2SV_ModStart> { printk ( KERN_CRIT "<S2SV_blank>[<" RFMT ">]<S2SV_blank>%pS\\n" , info -> ip , ( void * ) <S2SV_ModEnd> info -> ip <S2SV_ModStart> ip ) ; <S2SV_ModEnd> i ++ ; <S2SV_ModStart> } printk ( KERN_CRIT
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> { int i , user <S2SV_ModStart> , cr31 ; user <S2SV_ModEnd> = user_mode ( <S2SV_ModStart> ( regs ) ; level = user <S2SV_ModStart> ; if ( user <S2SV_ModEnd> ) print_fr ( <S2SV_ModStart> orig_r28 ) ; if ( user ) { printk ( "%s<S2SV_blank>IAOQ[0]:<S2SV_blank>" RFMT "\\n" , level , regs -> iaoq [ 0 ] ) ; printk ( "%s<S2SV_blank>IAOQ[1]:<S2SV_blank>" RFMT "\\n" , level <S2SV_ModEnd> , regs -> <S2SV_ModStart> ; printk ( "%s<S2SV_blank>RP(r2):<S2SV_blank>" RFMT "\\n" , level <S2SV_ModEnd> , regs -> <S2SV_ModStart> ] ) ; } else { printk ( "%s<S2SV_blank>IAOQ[0]:<S2SV_blank>%pS\\n" , level , ( void * ) regs -> iaoq [ 0 ] ) ; printk ( "%s<S2SV_blank>IAOQ[1]:<S2SV_blank>%pS\\n" , level , ( void * ) regs -> iaoq [ 1 ] ) ; printk ( "%s<S2SV_blank>RP(r2):<S2SV_blank>%pS\\n" , level , ( void * ) regs -> gr [ 2 ] ) ; <S2SV_ModStart> regs ) ; }
<S2SV_ModStart> = BLK_DEFAULT_SG_TIMEOUT ; if ( rq -> timeout < BLK_MIN_SG_TIMEOUT ) rq -> timeout = BLK_MIN_SG_TIMEOUT ;
<S2SV_ModStart> = BLK_DEFAULT_SG_TIMEOUT ; if ( rq -> timeout < BLK_MIN_SG_TIMEOUT ) rq -> timeout = BLK_MIN_SG_TIMEOUT ;
<S2SV_ModStart> [ i ] >= <S2SV_ModEnd> t ) break
<S2SV_ModStart> dev ) { unsigned long start_time = jiffies ; while ( qdisc_restart ( dev ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( netif_queue_stopped <S2SV_ModEnd> ( dev ) <S2SV_ModStart> ) break ; if ( need_resched ( ) || jiffies != start_time ) { netif_schedule <S2SV_ModEnd> ( dev ) <S2SV_ModStart> ( dev ) ; break ; } } <S2SV_ModEnd> clear_bit ( __LINK_STATE_QDISC_RUNNING
<S2SV_ModStart> pages ) { WARN_ON ( current -> mm == NULL ) ;
<S2SV_ModStart> pages ) { WARN_ON ( mm == NULL ) ;
<S2SV_ModStart> while ( bytes || ! iov -> iov_len
<S2SV_ModStart> ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied
<S2SV_ModStart> long addr ; struct file * file = vma -> vm_file ; <S2SV_ModStart> &= MAP_NONBLOCK ; get_file ( file ) ; <S2SV_ModStart> = mmap_region ( file <S2SV_ModEnd> , start , <S2SV_ModStart> pgoff , 1 ) ; fput ( file
<S2SV_ModStart> <S2SV_null> <S2SV_null> asmlinkage long <S2SV_ModEnd> sys_exit_group ( int <S2SV_ModStart> 8 ) ; return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> asmlinkage <S2SV_ModEnd> long sys_brk (
<S2SV_ModStart> <S2SV_null> <S2SV_null> asmlinkage <S2SV_ModEnd> long sys_mremap (
<S2SV_ModStart> <S2SV_null> <S2SV_null> asmlinkage <S2SV_ModEnd> long sys_brk (
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE6 ( 32_pread <S2SV_ModEnd> , unsigned long <S2SV_ModStart> , fd , char __user * , buf , size_t , count , <S2SV_ModStart> unsigned long , unused , unsigned long , a4 , unsigned long , a5 ) { return ksys_pread64 ( fd , buf , count , merge_64 ( a4 , a5 <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE6 ( 32_pwrite , unsigned int <S2SV_ModEnd> , fd , <S2SV_ModStart> , fd , const <S2SV_ModStart> , count , u32 <S2SV_ModEnd> , unused , <S2SV_ModStart> , unused , u64 <S2SV_ModEnd> , a4 , <S2SV_ModStart> , a4 , u64 <S2SV_ModEnd> , a5 ) <S2SV_ModStart> ) { return ksys_pwrite64 <S2SV_ModEnd> ( fd ,
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( rmdir <S2SV_ModEnd> , const char <S2SV_ModStart> ) { return do_rmdir <S2SV_ModEnd> ( AT_FDCWD ,
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( mkdir <S2SV_ModEnd> , const char <S2SV_ModStart> __user * , pathname , int , mode <S2SV_ModEnd> ) { return <S2SV_ModStart> ) { return sys_mkdirat ( AT_FDCWD , pathname , mode <S2SV_ModEnd> ) ; }
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( symlink <S2SV_ModEnd> , const char <S2SV_ModStart> ) { return sys_symlinkat ( <S2SV_ModEnd> oldname , AT_FDCWD <S2SV_ModStart> AT_FDCWD , newname <S2SV_ModEnd> ) ; }
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( link <S2SV_ModEnd> , const char <S2SV_ModStart> ) { return sys_linkat <S2SV_ModEnd> ( AT_FDCWD , <S2SV_ModStart> AT_FDCWD , newname , 0
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( chdir <S2SV_ModEnd> , const char <S2SV_ModStart> goto dput_and_out ; set_fs_pwd <S2SV_ModEnd> ( current -> <S2SV_ModStart> & path ) <S2SV_ModEnd> ; dput_and_out :
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( fchdir <S2SV_ModEnd> , unsigned int <S2SV_ModStart> struct file * file ; struct inode * inode ; int error ; error = - EBADF ; file = fget ( fd <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! file ) goto out ; inode = file -> f_path . dentry -> d_inode ; error = - ENOTDIR <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! S_ISDIR ( inode -> i_mode ) ) goto out_putf ; error = inode_permission ( inode , MAY_EXEC | MAY_ACCESS <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! error ) set_fs_pwd ( current -> fs , & file -> f_path ) ; out_putf : fput ( file ) ; out : return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( listen <S2SV_ModEnd> , int , <S2SV_ModStart> , int , backlog ) { struct socket * sock ; <S2SV_ModEnd> int err , <S2SV_ModStart> , fput_needed ; int somaxconn <S2SV_ModEnd> ; sock = <S2SV_ModStart> if ( sock ) { somaxconn = sock_net ( sock -> sk ) -> core . sysctl_somaxconn ; if ( ( unsigned ) backlog > somaxconn ) backlog = somaxconn ; err = security_socket_listen <S2SV_ModEnd> ( sock , <S2SV_ModStart> ( sock , backlog <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> ops -> listen <S2SV_ModEnd> ( sock , <S2SV_ModStart> ( sock , backlog <S2SV_ModEnd> ) ; fput_light
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( connect <S2SV_ModEnd> , int , <S2SV_ModStart> __user * , uservaddr , int , addrlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> address ; int <S2SV_ModEnd> err , fput_needed <S2SV_ModStart> ; err = move_addr_to_kernel ( uservaddr , addrlen , ( struct sockaddr * ) & address ) ; if ( err < 0 ) goto out_put ; err = security_socket_connect ( sock , ( struct sockaddr * ) & address , addrlen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> ops -> connect <S2SV_ModEnd> ( sock , <S2SV_ModStart> & address , addrlen , sock -> file -> f_flags <S2SV_ModEnd> ) ; out_put
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( getsockname <S2SV_ModEnd> , int , <S2SV_ModStart> ; if ( ! sock ) goto out ; err = security_socket_getsockname <S2SV_ModEnd> ( sock ) <S2SV_ModStart> ( err ) goto out_put ; <S2SV_ModEnd> err = sock <S2SV_ModStart> & len , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( err ) goto out_put ; <S2SV_ModEnd> err = move_addr_to_user <S2SV_ModStart> usockaddr_len ) ; out_put : <S2SV_ModStart> fput_needed ) ; out : <S2SV_ModEnd> return err ;
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( socket <S2SV_ModEnd> , int , <S2SV_ModStart> , int , family <S2SV_ModEnd> , int , <S2SV_ModStart> , int , type , int , protocol ) { int retval ; <S2SV_ModEnd> struct socket * <S2SV_ModStart> * sock ; int flags ; BUILD_BUG_ON ( SOCK_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( ( SOCK_MAX | SOCK_TYPE_MASK ) != SOCK_TYPE_MASK ) ; BUILD_BUG_ON ( SOCK_CLOEXEC & SOCK_TYPE_MASK ) ; BUILD_BUG_ON ( SOCK_NONBLOCK & SOCK_TYPE_MASK ) ; flags = type & ~ SOCK_TYPE_MASK ; if ( flags & ~ ( SOCK_CLOEXEC | SOCK_NONBLOCK ) ) return - EINVAL ; type &= SOCK_TYPE_MASK ; if ( SOCK_NONBLOCK != O_NONBLOCK && ( flags & SOCK_NONBLOCK ) ) flags = ( flags & ~ SOCK_NONBLOCK ) | O_NONBLOCK ; retval = sock_create ( family , type , protocol , & sock <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( retval < 0 ) goto out ; retval = sock_map_fd ( sock , flags & ( O_CLOEXEC | O_NONBLOCK ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( retval < 0 ) goto out_release ; out : return retval ; out_release : sock_release ( sock ) ; return retval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( bind <S2SV_ModEnd> , int , <S2SV_ModStart> __user * , umyaddr , int , addrlen ) { struct socket * sock ; struct sockaddr_storage address ; int err , fput_needed ; sock = sockfd_lookup_light <S2SV_ModEnd> ( fd , <S2SV_ModStart> ( fd , & err , & fput_needed ) ; if ( sock ) { err = move_addr_to_kernel ( umyaddr , addrlen , ( struct sockaddr * ) & address ) ; if ( err >= 0 ) { err = security_socket_bind ( sock , ( struct sockaddr * ) & address , addrlen ) ; if ( ! err ) err = sock -> ops -> bind ( sock , ( struct sockaddr * ) & address , addrlen <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } fput_light ( sock -> file , fput_needed ) ; } return err ; }
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( accept <S2SV_ModEnd> , int , <S2SV_ModStart> __user * , upeer_sockaddr , int __user * , upeer_addrlen ) { return sys_accept4 <S2SV_ModEnd> ( fd , <S2SV_ModStart> ( fd , upeer_sockaddr , upeer_addrlen , 0 ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE4 ( socketpair , int , family , int , type , int , protocol , int <S2SV_ModEnd> __user * , <S2SV_ModStart> __user * , usockvec <S2SV_ModEnd> ) { struct <S2SV_ModStart> struct socket * sock1 , * sock2 ; int fd1 , fd2 , err <S2SV_ModEnd> ; struct file <S2SV_ModStart> struct file * newfile1 , * newfile2 ; int flags ; flags = type & ~ SOCK_TYPE_MASK <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EINVAL ; type &= SOCK_TYPE_MASK <S2SV_ModStart> | O_NONBLOCK ; err = sock_create ( family , type , protocol , & sock1 ) ; if ( err < 0 <S2SV_ModEnd> ) goto out <S2SV_ModStart> ; err = sock_create ( family , type , protocol , & sock2 ) ; if ( err < 0 ) goto out_release_1 ; err = sock1 <S2SV_ModEnd> -> ops -> <S2SV_ModStart> -> ops -> socketpair ( sock1 , sock2 ) ; if ( err < 0 ) goto out_release_both ; fd1 <S2SV_ModEnd> = sock_alloc_fd ( <S2SV_ModStart> sock_alloc_fd ( & newfile1 <S2SV_ModEnd> , flags & <S2SV_ModStart> ( unlikely ( fd1 <S2SV_ModEnd> < 0 ) <S2SV_ModStart> { err = fd1 ; goto out_release_both ; } fd2 = sock_alloc_fd ( & newfile2 , flags & O_CLOEXEC ) ; if ( unlikely ( fd2 < 0 ) ) { err = fd2 ; put_filp ( newfile1 ) ; put_unused_fd ( fd1 ) ; goto out_release_both ; } err = sock_attach_fd ( sock1 , newfile1 , flags & O_NONBLOCK ) ; if ( unlikely ( err < 0 ) ) { goto out_fd2 ; } err = sock_attach_fd ( sock2 , newfile2 , flags & O_NONBLOCK ) ; if ( unlikely ( err < 0 ) ) { fput ( newfile1 ) ; goto out_fd1 ; } audit_fd_pair ( fd1 , fd2 ) ; fd_install ( fd1 , newfile1 ) ; fd_install ( fd2 , newfile2 ) ; err = put_user ( fd1 , & usockvec [ 0 ] ) ; if ( ! err ) err = put_user ( fd2 , & usockvec [ 1 ] ) ; if ( ! err ) return 0 ; sys_close ( fd2 ) ; sys_close ( fd1 ) ; return err ; out_release_both : sock_release ( sock2 ) ; out_release_1 : sock_release ( sock1 <S2SV_ModEnd> ) ; out <S2SV_ModStart> return err ; out_fd2 : put_filp ( newfile1 ) ; sock_release ( sock1 ) ; out_fd1 : put_filp ( newfile2 ) ; sock_release ( sock2 <S2SV_ModEnd> ) ; put_unused_fd <S2SV_ModStart> ; put_unused_fd ( fd1 <S2SV_ModEnd> ) ; put_unused_fd <S2SV_ModStart> ; put_unused_fd ( fd2 ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( faccessat , int , dfd <S2SV_ModEnd> , const char <S2SV_ModStart> , filename , int , mode ) { const struct cred * old_cred ; struct cred * override_cred ; struct path path ; struct inode * inode ; int res ; if ( mode & ~ S_IRWXO ) return - EINVAL ; override_cred = prepare_creds ( ) ; if ( ! override_cred ) return - ENOMEM ; override_cred -> fsuid = override_cred -> uid ; override_cred -> fsgid = override_cred -> gid ; if ( ! issecure ( SECURE_NO_SETUID_FIXUP ) ) { if ( override_cred -> uid ) cap_clear ( override_cred -> cap_effective ) ; else override_cred -> cap_effective = override_cred -> cap_permitted ; } old_cred = override_creds ( override_cred ) ; res = user_path_at ( dfd , filename , LOOKUP_FOLLOW , & path ) ; if ( res <S2SV_ModEnd> ) goto out <S2SV_ModStart> goto out ; inode = path . dentry -> d_inode ; if ( ( mode & MAY_EXEC ) && S_ISREG ( inode -> i_mode ) ) { res = - EACCES ; if <S2SV_ModEnd> ( path . <S2SV_ModStart> path . mnt -> mnt_flags & MNT_NOEXEC ) goto out_path_release ; } res = inode_permission ( inode , mode | MAY_ACCESS ) ; if ( res || ! ( mode & S_IWOTH ) || special_file ( inode -> i_mode ) ) goto out_path_release ; if ( __mnt_is_readonly <S2SV_ModEnd> ( path . <S2SV_ModStart> . mnt ) ) res = - EROFS ; out_path_release <S2SV_ModEnd> : path_put ( <S2SV_ModStart> ; out : revert_creds ( old_cred ) ; put_cred ( override_cred ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( fchmodat , int , dfd <S2SV_ModEnd> , const char <S2SV_ModStart> , filename , mode_t , mode <S2SV_ModEnd> ) { struct <S2SV_ModStart> path path ; struct inode * inode ; <S2SV_ModStart> int error ; struct iattr newattrs ; error = user_path_at ( dfd , filename , LOOKUP_FOLLOW <S2SV_ModEnd> , & path <S2SV_ModStart> ) goto out ; inode = path . dentry -> d_inode <S2SV_ModStart> error ) goto dput_and_out ; mutex_lock ( & inode -> i_mutex ) ; if ( mode == ( mode_t ) - 1 ) mode = inode -> i_mode ; newattrs . ia_mode = ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ; newattrs . ia_valid = ATTR_MODE | ATTR_CTIME <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = notify_change <S2SV_ModEnd> ( path . <S2SV_ModStart> . dentry , & newattrs ) ; mutex_unlock ( & inode -> i_mutex <S2SV_ModEnd> ) ; mnt_drop_write <S2SV_ModStart> mnt ) ; dput_and_out <S2SV_ModEnd> : path_put (
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( chown , const char __user * , filename <S2SV_ModEnd> , uid_t , <S2SV_ModStart> ) { struct path path <S2SV_ModEnd> ; int error <S2SV_ModStart> ; int error ; error = user_path ( filename , & path <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( error <S2SV_ModEnd> ) goto out <S2SV_ModStart> = mnt_want_write ( path <S2SV_ModEnd> . mnt ) <S2SV_ModStart> error ) goto out_release <S2SV_ModEnd> ; error = <S2SV_ModStart> = chown_common ( path . <S2SV_ModStart> ; mnt_drop_write ( path <S2SV_ModEnd> . mnt ) <S2SV_ModStart> mnt ) ; out_release : path_put ( & path <S2SV_ModEnd> ) ; out
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( lchown <S2SV_ModEnd> , const char <S2SV_ModStart> , filename , uid_t , user , gid_t , group ) { struct path path ; int error ; error = user_lpath ( filename , & path ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( error ) goto out ; error = mnt_want_write ( path . mnt ) ; if ( error ) goto out_release ; error = chown_common ( path . dentry , user , group ) ; mnt_drop_write ( path . mnt ) ; out_release : path_put ( & path ) ; out : return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( getpriority , int , which , int , who ) { struct task_struct * g , * p ; struct user_struct * user ; <S2SV_ModEnd> const struct cred <S2SV_ModStart> struct cred * cred = current_cred ( ) ; long niceval , retval = - ESRCH ; struct pid * pgrp ; if ( which > PRIO_USER || which < PRIO_PROCESS ) return - EINVAL ; read_lock ( & tasklist_lock ) ; switch ( which ) { case PRIO_PROCESS : if ( who ) p = find_task_by_vpid ( who ) ; else p = current ; if ( p ) { niceval = 20 - task_nice ( p ) ; if ( niceval > retval ) retval = niceval ; } break ; case PRIO_PGRP : if ( who ) pgrp = find_vpid ( who ) ; else pgrp = task_pgrp ( current ) ; do_each_pid_thread ( pgrp , PIDTYPE_PGID , p ) { niceval = 20 - task_nice ( p ) ; if ( niceval > retval ) retval = niceval ; } while_each_pid_thread ( pgrp , PIDTYPE_PGID , p ) ; break ; case PRIO_USER : user = ( struct user_struct * ) cred -> user <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! who ) who = cred -> uid ; else if ( ( who != cred -> uid ) && ! ( user = find_user ( who ) ) ) goto out_unlock ; do_each_thread ( g , p ) if ( __task_cred ( p ) -> uid == who ) { niceval = 20 - task_nice ( p ) ; if ( niceval > retval ) retval = niceval ; } while_each_thread ( g , p ) ; if ( who != cred -> uid ) free_uid ( user ) ; break ; } out_unlock : read_unlock ( & tasklist_lock ) ; return <S2SV_ModEnd> retval ; }
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( setregid , gid_t , rgid , gid_t , egid <S2SV_ModEnd> ) { const <S2SV_ModStart> ; retval = security_task_setgid ( rgid , egid , ( gid_t <S2SV_ModEnd> ) - 1 <S2SV_ModStart> ; if ( rgid != ( gid_t <S2SV_ModEnd> ) - 1 <S2SV_ModStart> 1 ) { if ( old -> gid == rgid || old -> egid == rgid || capable ( CAP_SETGID ) ) new -> gid = rgid ; else goto error ; } if ( egid != ( gid_t ) - 1 ) { if ( old -> gid == egid || old -> egid == egid || old -> sgid == egid || capable ( CAP_SETGID ) ) new -> egid = egid ; else goto error ; } if ( rgid != ( gid_t ) - 1 || ( egid != ( gid_t ) - 1 && egid != old -> gid ) ) new -> sgid = new -> egid ; new -> fsgid = new -> egid <S2SV_ModEnd> ; return commit_creds
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( setreuid , uid_t , ruid , uid_t , euid ) { const struct cred * old ; struct cred * new ; int retval ; new = prepare_creds ( ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! new ) return - ENOMEM ; old = current_cred ( ) ; retval = security_task_setuid ( ruid , euid , ( uid_t ) - 1 , LSM_SETID_RE ) ; if ( retval ) goto error ; retval = - EPERM ; if ( ruid != ( uid_t ) - 1 ) { new -> uid = ruid ; if ( old -> uid != ruid && old -> euid != ruid && ! capable ( CAP_SETUID ) ) goto error ; } if ( euid != ( uid_t ) - 1 ) { new -> euid = euid ; if ( old -> uid != euid && old -> euid != euid && old -> suid != euid && ! capable ( CAP_SETUID ) ) goto error ; } retval = - EAGAIN ; if ( new -> uid != old -> uid && set_user ( new ) <S2SV_ModEnd> < 0 ) <S2SV_ModStart> < 0 ) goto error ; if ( ruid != ( uid_t ) - 1 || ( euid != ( uid_t ) - 1 && euid != old -> uid ) ) new -> suid = new -> euid ; new -> fsuid = new -> euid ; retval = security_task_fix_setuid ( new , old , LSM_SETID_RE ) ; if ( retval < 0 ) goto error ; return commit_creds ( new ) ; error : abort_creds ( new <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return retval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( setpgid , pid_t , pid , pid_t , pgid ) { struct task_struct * p ; struct task_struct * group_leader = current -> group_leader ; struct pid * pgrp ; int err ; if ( ! pid ) pid = task_pid_vnr ( group_leader ) ; if ( ! pgid ) pgid = pid ; if ( pgid <S2SV_ModEnd> < 0 ) <S2SV_ModStart> - EINVAL ; write_lock_irq ( & tasklist_lock ) ; err = - ESRCH ; p = find_task_by_vpid ( pid ) ; if ( ! p ) goto out ; err <S2SV_ModEnd> = - EINVAL <S2SV_ModStart> - EINVAL ; if ( ! thread_group_leader ( p ) ) goto out ; if ( same_thread_group ( p -> real_parent , group_leader ) ) { err = - EPERM ; if ( task_session ( p ) != task_session ( group_leader ) ) goto out ; err = - EACCES ; if ( p -> did_exec ) goto out ; } else { err = - ESRCH ; if ( p != group_leader ) goto out ; } err = - EPERM ; if ( p -> signal -> leader ) goto out ; pgrp = task_pid ( p ) ; if ( pgid != pid ) { struct task_struct * g ; pgrp = find_vpid ( pgid ) ; g = pid_task ( pgrp , PIDTYPE_PGID ) ; if ( ! g || task_session ( g ) != task_session ( group_leader ) ) goto out ; } err = security_task_setpgid ( p , pgid ) ; if ( err ) goto out ; if ( task_pgrp ( p ) != pgrp ) { change_pid ( p , PIDTYPE_PGID , pgrp ) ; set_task_pgrp ( p , pid_nr ( pgrp ) ) ; } err = 0 ; out : write_unlock_irq ( & tasklist_lock ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( getgroups <S2SV_ModEnd> , int , <S2SV_ModStart> grouplist ) { const struct cred * cred = current_cred ( ) ; int i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( gidsetsize < 0 <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; i = cred -> group_info -> ngroups <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( gidsetsize ) { if ( i > gidsetsize ) { i = - EINVAL ; goto out ; } if ( groups_to_user ( grouplist , cred -> group_info ) ) { i = - EFAULT ; goto out ; } } out : return i <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( setpriority , int , which , int , who , int , niceval ) { struct task_struct * g , * p ; struct user_struct * user ; <S2SV_ModEnd> const struct cred <S2SV_ModStart> struct cred * cred = current_cred ( ) ; int error = - EINVAL ; struct pid * pgrp ; if ( which > PRIO_USER || which < PRIO_PROCESS ) goto out ; error = - ESRCH ; if ( niceval < - 20 ) niceval = - 20 ; if ( niceval > 19 ) niceval = 19 ; read_lock ( & tasklist_lock ) ; switch ( which ) { case PRIO_PROCESS : if ( who ) p = find_task_by_vpid ( who ) ; else p = current ; if ( p ) error = set_one_prio ( p , niceval , error ) ; break ; case PRIO_PGRP : if ( who ) pgrp = find_vpid ( who ) ; else pgrp = task_pgrp ( current ) ; do_each_pid_thread ( pgrp , PIDTYPE_PGID , p ) { error = set_one_prio ( p , niceval , error ) ; } while_each_pid_thread ( pgrp , PIDTYPE_PGID , p ) ; break ; case PRIO_USER : user = ( struct user_struct * ) cred -> user <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! who ) who = cred -> uid ; else if ( ( who != cred -> uid ) && ! ( user = find_user ( who ) ) ) goto out_unlock ; do_each_thread ( g , p ) if ( __task_cred ( p ) -> uid == who ) error = set_one_prio ( p , niceval , error ) ; while_each_thread ( g , p ) ; if ( who != cred -> uid ) free_uid ( user ) ; break ; } out_unlock : read_unlock ( & tasklist_lock ) ; out : return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( setresuid , uid_t , ruid , uid_t , euid , uid_t <S2SV_ModEnd> , suid ) <S2SV_ModStart> struct cred * old ; struct cred * new ; int retval ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; retval = security_task_setuid ( ruid , euid , suid , LSM_SETID_RES ) ; if ( retval ) goto error ; old <S2SV_ModEnd> = current_cred ( <S2SV_ModStart> ( ) ; retval = - EPERM <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! capable ( CAP_SETUID ) ) { if ( ruid != ( uid_t ) - 1 && ruid != old -> uid && ruid != old -> euid && ruid != old -> suid ) goto error ; if ( euid != ( uid_t ) - 1 && euid != old -> uid && euid != old -> euid && euid != old -> suid ) goto error ; if ( suid != ( uid_t ) - 1 && suid != old -> uid && suid != old -> euid && suid != old -> suid ) goto error ; } retval = - EAGAIN ; if ( ruid != ( uid_t ) - 1 ) { new -> uid = ruid ; if ( ruid != old -> uid && set_user ( new ) < 0 ) goto error ; } if ( euid != ( uid_t ) - 1 ) new -> euid = euid ; if ( suid != ( uid_t ) - 1 ) new -> suid = suid ; new -> fsuid = new -> euid ; retval = security_task_fix_setuid ( new , old , LSM_SETID_RES ) ; if ( retval < 0 ) goto error ; return commit_creds ( new ) ; error : abort_creds ( new <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( getresuid , uid_t __user * , ruid , uid_t __user * , euid , uid_t __user * , suid <S2SV_ModEnd> ) { const <S2SV_ModStart> struct cred * cred = current_cred ( ) <S2SV_ModEnd> ; int retval <S2SV_ModStart> int retval ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! ( retval = put_user ( cred -> uid , ruid ) ) && ! ( retval = put_user ( cred -> euid , euid ) ) ) retval = put_user ( cred -> suid , suid <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( setresgid , gid_t , rgid , gid_t , egid , gid_t <S2SV_ModEnd> , sgid ) <S2SV_ModStart> struct cred * old ; struct cred * new ; int retval ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; old <S2SV_ModEnd> = current_cred ( <S2SV_ModStart> ( ) ; retval = security_task_setgid ( rgid , egid , sgid , LSM_SETID_RES ) ; if ( retval ) goto error ; retval = - EPERM <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! capable ( CAP_SETGID ) ) { if ( rgid != ( gid_t ) - 1 && rgid != old -> gid && rgid != old -> egid && rgid != old -> sgid ) goto error ; if ( egid != ( gid_t ) - 1 && egid != old -> gid && egid != old -> egid && egid != old -> sgid ) goto error ; if ( sgid != ( gid_t ) - 1 && sgid != old -> gid && sgid != old -> egid && sgid != old -> sgid ) goto error ; } if ( rgid != ( gid_t ) - 1 ) new -> gid = rgid ; if ( egid != ( gid_t ) - 1 ) new -> egid = egid ; if ( sgid != ( gid_t ) - 1 ) new -> sgid = sgid ; new -> fsgid = new -> egid ; return commit_creds ( new ) ; error : abort_creds ( new <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( setgid , gid_t , gid ) { const struct cred * old ; struct cred * new ; int retval ; new = prepare_creds ( <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! new <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; old = current_cred <S2SV_ModEnd> ( ) ; <S2SV_ModStart> ( ) ; retval = security_task_setgid ( gid , ( gid_t ) - 1 , ( gid_t ) - 1 , LSM_SETID_ID ) ; if ( retval ) goto error ; retval = - EPERM ; if ( capable ( CAP_SETGID ) ) new -> gid = new -> egid = new -> sgid = new -> fsgid = gid ; else if ( gid == old -> gid || gid == old -> sgid ) new -> egid = new -> fsgid = gid ; else goto error ; return commit_creds ( new ) ; error : abort_creds ( new ) ; return retval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( setuid , uid_t , uid ) { const struct cred * old ; struct cred * new <S2SV_ModEnd> ; int retval <S2SV_ModStart> int retval ; new = prepare_creds <S2SV_ModEnd> ( ) ; <S2SV_ModStart> if ( ! new ) return - ENOMEM ; old = current_cred ( ) ; retval = security_task_setuid ( uid , ( uid_t ) - 1 , ( uid_t ) - 1 , LSM_SETID_ID ) ; if ( retval ) goto error ; retval = - EPERM ; if ( capable ( CAP_SETUID ) ) { new -> suid = new -> uid = uid ; if ( uid != old -> uid && set_user ( new ) < 0 ) { retval = - EAGAIN ; goto error ; } } else if ( uid != old -> uid && uid != new -> suid ) { goto error ; } new -> fsuid = new -> euid = uid ; retval = security_task_fix_setuid ( new , old , LSM_SETID_ID ) ; if ( retval < 0 ) goto error ; return commit_creds ( new ) ; error : abort_creds ( new <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( setfsuid , uid_t , uid ) { const struct cred * old ; struct cred * new ; uid_t old_fsuid ; new = prepare_creds <S2SV_ModEnd> ( ) ; <S2SV_ModStart> if ( ! new ) return current_fsuid ( ) ; old = current_cred ( ) ; old_fsuid = old -> fsuid <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( security_task_setuid ( uid , ( uid_t ) - 1 , ( uid_t ) - 1 , LSM_SETID_FS ) < 0 ) goto error <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( uid == old -> uid || uid == old -> euid || uid == old -> suid || uid == old -> fsuid || capable ( CAP_SETUID ) ) { if ( uid != old_fsuid ) { new -> fsuid = uid <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( security_task_fix_setuid ( new , old , LSM_SETID_FS ) == 0 ) goto change_okay ; } } error : abort_creds ( new <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return old_fsuid ; change_okay : commit_creds ( new ) ; return old_fsuid <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( setresuid , uid_t , ruid , uid_t , euid , uid_t <S2SV_ModEnd> , suid ) <S2SV_ModStart> struct cred * old ; struct cred * new ; int retval ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; retval = security_task_setuid ( ruid , euid , suid , LSM_SETID_RES ) ; if ( retval ) goto error ; old <S2SV_ModEnd> = current_cred ( <S2SV_ModStart> ( ) ; retval = - EPERM <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! capable ( CAP_SETUID ) ) { if ( ruid != ( uid_t ) - 1 && ruid != old -> uid && ruid != old -> euid && ruid != old -> suid ) goto error ; if ( euid != ( uid_t ) - 1 && euid != old -> uid && euid != old -> euid && euid != old -> suid ) goto error ; if ( suid != ( uid_t ) - 1 && suid != old -> uid && suid != old -> euid && suid != old -> suid ) goto error ; } retval = - EAGAIN ; if ( ruid != ( uid_t ) - 1 ) { new -> uid = ruid ; if ( ruid != old -> uid && set_user ( new ) < 0 ) goto error ; } if ( euid != ( uid_t ) - 1 ) new -> euid = euid ; if ( suid != ( uid_t ) - 1 ) new -> suid = suid ; new -> fsuid = new -> euid ; retval = security_task_fix_setuid ( new , old , LSM_SETID_RES ) ; if ( retval < 0 ) goto error ; return commit_creds ( new ) ; error : abort_creds ( new <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE3 ( getresuid , uid_t <S2SV_ModEnd> __user * , <S2SV_ModStart> __user * , ruid , uid_t <S2SV_ModEnd> __user * , <S2SV_ModStart> __user * , euid , uid_t <S2SV_ModEnd> __user * , <S2SV_ModStart> __user * , suid <S2SV_ModEnd> ) { const <S2SV_ModStart> ( cred -> uid , ruid <S2SV_ModEnd> ) ) && <S2SV_ModStart> ( cred -> euid , euid <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ( cred -> suid , suid <S2SV_ModEnd> ) ; return
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( setpgid , pid_t , pid , pid_t , pgid ) { struct task_struct * p ; struct task_struct * group_leader = current -> group_leader ; struct pid * pgrp ; int err ; if ( ! pid ) pid = task_pid_vnr ( group_leader ) ; if ( ! pgid ) pgid = pid ; if ( pgid <S2SV_ModEnd> < 0 ) <S2SV_ModStart> - EINVAL ; write_lock_irq ( & tasklist_lock ) ; err = - ESRCH ; p = find_task_by_vpid ( pid ) ; if ( ! p ) goto out ; err <S2SV_ModEnd> = - EINVAL <S2SV_ModStart> - EINVAL ; if ( ! thread_group_leader ( p ) ) goto out ; if ( same_thread_group ( p -> real_parent , group_leader ) ) { err = - EPERM ; if ( task_session ( p ) != task_session ( group_leader ) ) goto out ; err = - EACCES ; if ( p -> did_exec ) goto out ; } else { err = - ESRCH ; if ( p != group_leader ) goto out ; } err = - EPERM ; if ( p -> signal -> leader ) goto out ; pgrp = task_pid ( p ) ; if ( pgid != pid ) { struct task_struct * g ; pgrp = find_vpid ( pgid ) ; g = pid_task ( pgrp , PIDTYPE_PGID ) ; if ( ! g || task_session ( g ) != task_session ( group_leader ) ) goto out ; } err = security_task_setpgid ( p , pgid ) ; if ( err ) goto out ; if ( task_pgrp ( p ) != pgrp ) { change_pid ( p , PIDTYPE_PGID , pgrp ) ; set_task_pgrp ( p , pid_nr ( pgrp ) ) ; } err = 0 ; out : write_unlock_irq ( & tasklist_lock ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( access , const char __user * , filename , int <S2SV_ModEnd> , mode ) <S2SV_ModStart> mode ) { return sys_faccessat ( AT_FDCWD , filename , mode ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( fchmod , unsigned int , fd , mode_t , mode ) { struct inode * inode ; struct dentry * dentry ; struct file * file ; int err = - EBADF ; struct iattr newattrs ; file = fget ( fd ) ; if ( ! file ) goto out ; dentry = file -> f_path . dentry ; inode = dentry -> d_inode ; audit_inode ( NULL , dentry ) ; err = mnt_want_write ( file -> f_path . mnt ) ; if ( err ) goto out_putf ; mutex_lock ( & inode -> i_mutex ) ; if ( mode == ( mode_t ) - 1 ) mode = inode -> i_mode ; newattrs . ia_mode = ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ; newattrs . ia_valid = ATTR_MODE | ATTR_CTIME ; err = notify_change ( dentry , & newattrs ) ; mutex_unlock ( & inode -> i_mutex ) ; mnt_drop_write ( file -> f_path . mnt ) ; out_putf : fput ( file ) ; out : return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE2 ( chmod <S2SV_ModEnd> , const char <S2SV_ModStart> __user * , filename , mode_t <S2SV_ModEnd> , mode ) <S2SV_ModStart> ) { return sys_fchmodat ( AT_FDCWD , filename <S2SV_ModEnd> , mode )
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE0 ( getppid ) { int pid ; rcu_read_lock ( ) ; pid = task_tgid_vnr ( current -> real_parent ) ; rcu_read_unlock ( ) ; return pid <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * fwdtsn_hdr ; struct sctp_fwdtsn_skip * skip ; <S2SV_ModStart> goto discard_noforce ; sctp_walk_fwdtsn ( skip , chunk ) { if ( ntohs ( skip -> stream ) >= asoc -> c . sinit_max_instreams ) goto discard_noforce ; }
<S2SV_ModStart> * fwdtsn_hdr ; struct sctp_fwdtsn_skip * skip ; <S2SV_ModStart> goto gen_shutdown ; sctp_walk_fwdtsn ( skip , chunk ) { if ( ntohs ( skip -> stream ) >= asoc -> c . sinit_max_instreams ) goto gen_shutdown ; }
<S2SV_ModStart> len ) ; <S2SV_ModEnd> set_fs ( old_fs <S2SV_ModStart> ) goto out_free ; else buf [ rc ] = '\\0'
<S2SV_ModStart> ) size = scnprintf ( buffer , count <S2SV_ModEnd> , "%s\\n" ,
<S2SV_ModStart> ; size = scnprintf ( buffer , count <S2SV_ModEnd> , "%lu\\n" ,
<S2SV_ModStart> - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) <S2SV_ModEnd> ; switch (
<S2SV_ModStart> return - EINVAL ; v . val = 0
<S2SV_ModStart> ) ) ; memset ( gdp , 0 , EXT4_DESC_SIZE ( sb ) ) ; <S2SV_ModStart> gdp -> bg_flags = <S2SV_ModEnd> cpu_to_le16 ( EXT4_BG_INODE_ZEROED
<S2SV_ModStart> printk ( KERN_DEBUG "Creating<S2SV_blank>index:<S2SV_blank>inode<S2SV_blank>%lu\\n" , dir -> i_ino <S2SV_ModEnd> ) ) ; <S2SV_ModStart> bh -> b_data ; fde = & root -> dotdot ; de = ( struct ext4_dir_entry_2 * ) ( ( char * ) fde + ext4_rec_len_from_disk ( fde -> rec_len ) ) ; if ( ( char * ) de >= ( ( ( char * ) root ) + blocksize ) ) { ext4_error ( dir -> i_sb , __func__ , "invalid<S2SV_blank>rec_len<S2SV_blank>for<S2SV_blank>\'..\'<S2SV_blank>in<S2SV_blank>inode<S2SV_blank>%lu" , dir -> i_ino ) ; brelse ( bh ) ; return - EIO ; } len = ( ( char * ) root ) + blocksize - ( char * ) de <S2SV_ModStart> bh2 -> b_data <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> , "ext4_block_to_path" , "block<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>max<S2SV_blank>in<S2SV_blank>inode<S2SV_blank>%lu" <S2SV_ModEnd> , i_block + <S2SV_ModStart> indirect_blocks + double_blocks , inode -> i_ino
<S2SV_ModStart> ) ) goto ende <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) goto ende <S2SV_ModEnd> ; odst = <S2SV_ModStart> err ) goto ende <S2SV_ModEnd> ; err =
<S2SV_ModStart> -> crypt_stat ; unsigned int order ; <S2SV_ModStart> virt ; size_t virt_len ; size_t <S2SV_ModStart> out ; } virt_len = crypt_stat -> num_header_bytes_at_front ; order = get_order ( virt_len ) ; <S2SV_ModStart> char * ) ecryptfs_get_zeroed_pages ( GFP_KERNEL , order <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( virt , virt_len <S2SV_ModEnd> , & size <S2SV_ModStart> & size , crypt_stat , <S2SV_ModEnd> ecryptfs_dentry ) ; <S2SV_ModStart> ( ecryptfs_dentry , virt , <S2SV_ModEnd> size ) ; <S2SV_ModStart> = ecryptfs_write_metadata_to_contents ( ecryptfs_dentry , virt , virt_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> } out_free : free_pages <S2SV_ModEnd> ( ( unsigned <S2SV_ModStart> long ) virt , order
<S2SV_ModStart> int ecryptfs_write_metadata_to_contents ( <S2SV_ModEnd> struct dentry * <S2SV_ModStart> char * virt , size_t virt_len <S2SV_ModStart> , 0 , virt_len <S2SV_ModEnd> ) ; if
<S2SV_ModStart> dentry * ecryptfs_dentry <S2SV_ModEnd> , char *
<S2SV_ModStart> } else { # ifdef CONFIG_SHMEM <S2SV_ModStart> lock ) ; # else * rss += inode -> i_mapping -> nrpages ; # endif
<S2SV_ModStart> GFP_KERNEL | GFP_DMA32 | __GFP_ZERO
<S2SV_ModStart> GFP_KERNEL | GFP_DMA32 | __GFP_ZERO
<S2SV_ModStart> msr_index ) { case MSR_EFER : vmx_load_host_state ( vmx ) ; ret = kvm_set_msr_common ( vcpu , msr_index , data ) ; break ; <S2SV_ModStart> # ifdef CONFIG_X86_64 <S2SV_ModEnd> case MSR_FS_BASE :
<S2SV_ModStart> "NET/ROM:<S2SV_blank>sendto:<S2SV_blank>Addresses<S2SV_blank>built.\\n" ) ; if ( len > 65536 ) return - EMSGSIZE ;
<S2SV_ModStart> , "ROSE:<S2SV_blank>sendto:<S2SV_blank>building<S2SV_blank>packet.\\n" ) ; if ( len > 65535 ) return - EMSGSIZE
<S2SV_ModStart> dest_addr ; } if ( len > 65535 ) { rc = - EMSGSIZE ; goto out ; }
<S2SV_ModStart> : IP_INC_STATS_BH ( net <S2SV_ModEnd> , IPSTATS_MIB_REASMFAILS )
<S2SV_ModStart> goto out_free_server ; if ( server -> namelen == 0 || server -> namelen > NFS4_MAXNAMLEN ) server -> namelen = NFS4_MAXNAMLEN ;
<S2SV_ModStart> ; if ( server -> nfs_client -> rpc_ops -> version == 3 ) { if ( server -> namelen == 0 || server -> namelen > NFS3_MAXNAMLEN ) server -> namelen = NFS3_MAXNAMLEN ; if ( ! ( data -> flags & NFS_MOUNT_NORDIRPLUS ) ) server -> caps |= NFS_CAP_READDIRPLUS ; } else { if ( server -> namelen == 0 || server -> namelen > NFS2_MAXNAMLEN ) server -> namelen = NFS2_MAXNAMLEN ; } if (
<S2SV_ModStart> server ) ; <S2SV_ModEnd> dprintk ( "<--<S2SV_blank>nfs_init_server()<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[new<S2SV_blank>%p]\\n"
<S2SV_ModStart> return NULL ; if ( name . len > NFS_SERVER ( dir ) -> namelen ) return NULL ;
<S2SV_ModStart> tsk -> parent_exec_id <S2SV_ModEnd> ) ) tsk
<S2SV_ModStart> { if ( task_pid_vnr ( p ) <S2SV_ModEnd> > 1 &&
<S2SV_ModStart> ; NET_INC_STATS_BH ( net <S2SV_ModEnd> , LINUX_MIB_TIMEWAITRECYCLED ) <S2SV_ModStart> ; NET_INC_STATS_BH ( net <S2SV_ModEnd> , LINUX_MIB_TIMEWAITRECYCLED )
<S2SV_ModStart> status & E1000_RXD_STAT_EOP ) || ( length <= 4
<S2SV_ModStart> rtl_set_rx_max_size ( ioaddr , tp -> rx_buf_sz
<S2SV_ModStart> rtl_set_rx_max_size ( ioaddr , tp -> rx_buf_sz
<S2SV_ModStart> = kzalloc ( 2 * ( length + 1 ) <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> mutex_lock_interruptible ( & task <S2SV_ModEnd> -> cred_exec_mutex ) <S2SV_ModStart> mutex_unlock ( & task <S2SV_ModEnd> -> cred_exec_mutex )
<S2SV_ModStart> & SMBFLG2_UNICODE ) { if ( ( ( unsigned long ) bcc_ptr - ( unsigned long ) smb_buf ) % 2 ) { ++ bcc_ptr ; -- bytes_remaining ; } <S2SV_ModStart> nls_cp ) ; } else { <S2SV_ModEnd> rc = decode_ascii_ssetup <S2SV_ModStart> nls_cp ) ; }
<S2SV_ModStart> ) ) ; if ( bleft % 2 ) { data [ bleft ] = 0 ; ++ bleft ; } <S2SV_ModEnd> words_left = bleft <S2SV_ModStart> = kzalloc ( ( 4 * len ) + 2 <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> != NULL ) <S2SV_ModEnd> cifs_strfromUCS_le ( ses <S2SV_ModStart> nls_cp ) ; <S2SV_ModEnd> data += 2
<S2SV_ModStart> kmalloc ( ( 4 * NAME_MAX ) + 2 <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> ; rc = cifs_strlcpy_to_host <S2SV_ModEnd> ( & ( <S2SV_ModStart> ; rc = cifs_strlcpy_to_host <S2SV_ModEnd> ( & (
<S2SV_ModStart> sock * sk <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ) return POLLERR ; sk = tun -> sk
<S2SV_ModStart> * rp = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> name ) ; mutex_lock_nested ( & inode -> i_mutex , I_MUTEX_PARENT <S2SV_ModEnd> ) ; ret <S2SV_ModStart> out_unlock ; } if ( pipe -> inode ) mutex_lock_nested ( & pipe -> inode -> i_mutex , I_MUTEX_CHILD ) ; <S2SV_ModStart> len , flags ) ; if ( pipe -> inode ) mutex_unlock ( & pipe -> inode -> i_mutex <S2SV_ModStart> ; out : mutex_unlock ( & inode -> i_mutex <S2SV_ModEnd> ) ; mlog_exit
<S2SV_ModStart> ssize_t ret ; WARN_ON ( S_ISFIFO ( inode -> i_mode ) ) ; mutex_lock_nested ( & inode -> i_mutex , I_MUTEX_PARENT <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ret ) ) { if ( pipe -> inode ) mutex_lock_nested ( & pipe -> inode -> i_mutex , I_MUTEX_CHILD ) ; <S2SV_ModStart> pipe_to_file ) ; if ( pipe -> inode ) mutex_unlock ( & pipe -> inode -> i_mutex ) ; } mutex_unlock ( & inode -> i_mutex <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , } ; WARN_ON ( S_ISFIFO ( inode -> i_mode ) ) ; mutex_lock_nested ( & inode -> i_mutex , I_MUTEX_PARENT ) ; if ( <S2SV_ModEnd> pipe -> inode <S2SV_ModStart> pipe -> inode ) mutex_lock_nested ( & pipe -> inode -> i_mutex , I_MUTEX_CHILD <S2SV_ModStart> actor ) ; if ( <S2SV_ModEnd> pipe -> inode <S2SV_ModStart> pipe -> inode ) mutex_unlock ( & pipe -> inode -> i_mutex ) ; mutex_unlock ( & inode -> i_mutex
<S2SV_ModStart> -> cr3 ; down_read ( & vcpu -> kvm -> slots_lock ) ; if ( gfn_to_memslot ( vcpu -> kvm , sregs -> cr3 >> PAGE_SHIFT ) ) vcpu -> arch . cr3 = sregs -> cr3 ; else set_bit ( KVM_REQ_TRIPLE_FAULT , & vcpu -> requests ) ; up_read ( & vcpu -> kvm -> slots_lock ) <S2SV_ModEnd> ; kvm_set_cr8 (
<S2SV_ModStart> } if ( unlikely ( ( * tag_11_contents_size ) > max_contents_bytes ) ) { printk ( KERN_ERR "Literal<S2SV_blank>data<S2SV_blank>section<S2SV_blank>in<S2SV_blank>tag<S2SV_blank>11<S2SV_blank>packet<S2SV_blank>exceeds<S2SV_blank>" "expected<S2SV_blank>size\\n" ) ; rc = - EINVAL ; goto out ; } if (
<S2SV_ModStart> ; if ( ( * new_auth_tok ) -> session_key . encrypted_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES ) { printk ( KERN_WARNING "Tag<S2SV_blank>3<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>key<S2SV_blank>larger<S2SV_blank>" "than<S2SV_blank>ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n" ) ; rc = - EINVAL ; goto out_free ; } if (
<S2SV_ModStart> ; if ( mm && <S2SV_ModEnd> mm != current <S2SV_ModStart> mm ) ; mm = <S2SV_ModEnd> NULL ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> return mm ;
<S2SV_ModStart> ) return NULL ; down_read ( & mm -> mmap_sem )
<S2SV_ModStart> NULL ; } down_read ( & mm -> mmap_sem ) ;
<S2SV_ModStart> return NULL ; if ( <S2SV_ModEnd> mm != current <S2SV_ModStart> current -> mm ) { if ( ! ptrace_may_access <S2SV_ModEnd> ( task , <S2SV_ModStart> , PTRACE_MODE_READ ) || mm != task -> mm ) { <S2SV_ModEnd> mmput ( mm <S2SV_ModStart> NULL ; } } down_read ( & mm -> mmap_sem ) ; return mm ; }
<S2SV_ModStart> mm_struct * mm ; if ( mutex_lock_killable ( & task -> cred_guard_mutex ) ) return NULL ; mm <S2SV_ModStart> current -> mm && <S2SV_ModEnd> ! ptrace_may_access ( <S2SV_ModStart> , PTRACE_MODE_READ ) <S2SV_ModEnd> ) { mmput <S2SV_ModStart> NULL ; } mutex_unlock ( & task -> cred_guard_mutex ) ; <S2SV_ModEnd> return mm ;
<S2SV_ModStart> MSG_MORE ; return kernel_sendpage <S2SV_ModEnd> ( sock ,
<S2SV_ModStart> ( addr < dac_mmap_min_addr <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ( addr < CONFIG_LSM_MMAP_MIN_ADDR <S2SV_ModEnd> ) { rc
<S2SV_ModStart> addr_only ) { return cap_file_mmap ( file , reqprot , prot , flags , addr , addr_only ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> < mmap_min_addr ) { <S2SV_ModStart> MEMPROTECT__MMAP_ZERO , NULL ) ; if ( rc ) return rc ; } rc = cap_file_mmap ( file , reqprot , prot , flags , addr , addr_only
<S2SV_ModStart> < mmap_min_addr ) { <S2SV_ModStart> MEMPROTECT__MMAP_ZERO , NULL ) ; if ( rc ) return rc ; } rc = cap_file_mmap ( file , reqprot , prot , flags , addr , addr_only
<S2SV_ModStart> addr_only ) { return cap_file_mmap ( file , reqprot , prot , flags , addr , addr_only ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( addr < dac_mmap_min_addr <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ( addr < CONFIG_LSM_MMAP_MIN_ADDR <S2SV_ModEnd> ) { rc
<S2SV_ModStart> { if ( ( <S2SV_ModStart> addr < mmap_min_addr ) && ! capable ( CAP_SYS_RAWIO )
<S2SV_ModStart> , up ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0
<S2SV_ModStart> = no_timer_create , . nsleep = no_nsleep ,
<S2SV_ModStart> ( ! ie1 || ! ie2
<S2SV_ModStart> ; if ( ! ie ) return false ; if (
<S2SV_ModStart> ; if ( * ppos < 0 ||
<S2SV_ModStart> int error ; <S2SV_ModEnd> oss . ss_sp <S2SV_ModStart> sp ) ; <S2SV_ModEnd> if ( uss <S2SV_ModStart> ss_size ; } error = 0 ; <S2SV_ModStart> ; if ( ! access_ok ( VERIFY_WRITE , uoss <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( * uoss ) ) ) goto out ; error = __put_user ( oss . ss_sp , & uoss -> ss_sp ) | __put_user ( oss . ss_size , & uoss -> ss_size ) | __put_user ( oss . ss_flags , & uoss -> ss_flags ) ; } <S2SV_ModEnd> out : return
<S2SV_ModStart> != ARPHRD_ETHER ) goto free_it <S2SV_ModEnd> ; skb -> <S2SV_ModStart> aarp_lock ) ; goto free_it <S2SV_ModEnd> ; } skb_queue_tail <S2SV_ModStart> aarp_lock ) ; goto sent <S2SV_ModEnd> ; sendit : <S2SV_ModStart> -> sk_priority ; if ( <S2SV_ModStart> ( skb ) ) goto drop <S2SV_ModStart> sent : return NET_XMIT_SUCCESS ; free_it : kfree_skb ( skb ) ; drop : return NET_XMIT_DROP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> atif ) { return <S2SV_ModStart> , origlen ) <S2SV_ModEnd> ; } if
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> atalk_route_packet ( struct <S2SV_ModStart> skb ) ; <S2SV_ModEnd> skb = nskb <S2SV_ModStart> if ( skb == NULL ) goto drop ; if ( <S2SV_ModEnd> aarp_send_ddp ( rt <S2SV_ModStart> NULL ) == NET_XMIT_DROP ) return NET_RX_DROP ; return NET_XMIT_SUCCESS <S2SV_ModEnd> ; free_it : <S2SV_ModStart> skb ) ; drop : return NET_RX_DROP ;
<S2SV_ModStart> sk ) ; <S2SV_ModEnd> aarp_send_ddp ( dev <S2SV_ModStart> sat_addr , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> gsat ; } <S2SV_ModEnd> aarp_send_ddp ( dev <S2SV_ModStart> , NULL ) <S2SV_ModEnd> ; } SOCK_DEBUG
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned <S2SV_ModStart> __user * , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * opt , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * ov , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> * optval , unsigned
<S2SV_ModStart> = 0 ; memset ( & sllc , 0 , sizeof ( sllc ) ) ;
<S2SV_ModStart> irda_sk ( sk ) ; memset ( & saddr , 0 , sizeof ( saddr )
<S2SV_ModStart> ; int n ; memset ( srose , 0 , sizeof ( * srose ) )
<S2SV_ModStart> sockaddr_at ) ; memset ( & sat . sat_zero , 0 , sizeof ( sat . sat_zero ) ) ;
<S2SV_ModStart> return - EOPNOTSUPP ; memset ( sec , 0 , sizeof ( * sec ) )
<S2SV_ModStart> - EOPNOTSUPP ; memset ( addr , 0 , sizeof ( * addr ) ) ;
<S2SV_ModStart> -> user_addr ; memset ( sax -> fsa_digipeater , 0 , sizeof ( sax -> fsa_digipeater ) ) ;
<S2SV_ModStart> TTY_DRIVER_RESET_TERMIOS ) { tty_ldisc_halt ( tty ) ; flush_scheduled_work ( ) ; <S2SV_ModStart> ldisc ) { <S2SV_ModEnd> tty_ldisc_reinit ( tty
<S2SV_ModStart> ; tcm -> tcm__pad1 = 0 ; tcm -> tcm__pad2 = 0 ; tcm ->
<S2SV_ModStart> void ) { struct keydata * keyptr ; __u32 * hash = get_cpu_var ( get_random_int_hash ) ; int ret ; keyptr = get_keyptr ( ) ; hash [ 0 ] += <S2SV_ModEnd> current -> pid <S2SV_ModStart> pid + jiffies + get_cycles ( ) + ( int ) ( long ) & ret ; ret = half_md4_transform ( hash , keyptr -> secret ) ; put_cpu_var ( get_random_int_hash ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> b ; } if ( <S2SV_ModStart> -> top ) == NULL ) return 0
<S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err <S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err
<S2SV_ModStart> 5 ] ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0 ; if ( <S2SV_ModEnd> bn_wexpand ( & <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0
<S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err <S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err
<S2SV_ModStart> b ; } if ( <S2SV_ModStart> -> top ) == NULL ) return 0
<S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err <S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err
<S2SV_ModStart> 4 ] ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0 ; if ( <S2SV_ModEnd> bn_wexpand ( & <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0
<S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err <S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err
<S2SV_ModStart> b ; } if ( <S2SV_ModStart> -> top ) == NULL ) return 0
<S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err <S2SV_ModStart> p ) ; if ( <S2SV_ModStart> -> top ) == NULL ) goto err
<S2SV_ModStart> 5 ] ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0 ; if ( <S2SV_ModEnd> bn_wexpand ( & <S2SV_ModStart> / BN_BITS2 ) == NULL ) return 0
<S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err <S2SV_ModStart> goto err ; if ( <S2SV_ModStart> / BN_BITS2 ) == NULL ) goto err
<S2SV_ModStart> * ies , int <S2SV_ModEnd> len ) {
<S2SV_ModStart> verf , NULL , NULL
<S2SV_ModStart> __be32 status ; int created = 0 ; <S2SV_ModStart> open -> op_truncate , & created <S2SV_ModStart> fh_size ) ; if ( ! created )
<S2SV_ModStart> 0xFFFFFFFF ; } if ( kvm_x86_ops -> get_cpl ( vcpu ) != 0 ) { ret = - KVM_EPERM ; goto out ; } <S2SV_ModStart> break ; } out :
<S2SV_ModStart> filp ) { int ret = - ENOENT ; <S2SV_ModStart> -> i_mutex ) ; if ( inode -> i_pipe ) { ret = 0 <S2SV_ModStart> writers ++ ; } <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> filp ) { int ret = - ENOENT ; <S2SV_ModStart> i_mutex ) ; if ( inode -> i_pipe ) { ret = 0 ; <S2SV_ModStart> readers ++ ; } <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> filp ) { int ret = - ENOENT ; <S2SV_ModStart> i_mutex ) ; if ( inode -> i_pipe ) { ret = 0 ; <S2SV_ModStart> writers ++ ; } <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; tcm -> tcm__pad2 <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> -> len ; <S2SV_ModEnd> opts1 |= FirstFrag <S2SV_ModStart> = NETDEV_TX_BUSY ; <S2SV_ModEnd> dev -> stats
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ;
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModEnd> r128_do_cce_reset ( dev_priv
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ;
<S2SV_ModStart> dev , file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv
<S2SV_ModStart> "\\n" ) ; if ( dev -> dev_private ) { DRM_DEBUG ( "called<S2SV_blank>when<S2SV_blank>already<S2SV_blank>initialized\\n" ) ; return - EINVAL ; }
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev -> dev_private ) ;
<S2SV_ModStart> dev , file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv
<S2SV_ModStart> drm_r128_sarea_t * sarea_priv <S2SV_ModEnd> ; drm_r128_clear_t * <S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModStart> ( dev_priv ) ; sarea_priv = dev_priv -> sarea_priv
<S2SV_ModStart> dev , file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ;
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModEnd> DRM_DEBUG ( "pid=%d<S2SV_blank>buf=%d<S2SV_blank>s=%d<S2SV_blank>e=%d<S2SV_blank>d=%d\\n"
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModEnd> DRM_DEBUG ( "idx=%d<S2SV_blank>s=%d<S2SV_blank>e=%d<S2SV_blank>d=%d\\n"
<S2SV_ModStart> dev , file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv
<S2SV_ModStart> dev , file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv
<S2SV_ModStart> file_priv ) ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModEnd> DRM_DEBUG ( "pid=%d<S2SV_blank>index=%d<S2SV_blank>count=%d<S2SV_blank>discard=%d\\n"
<S2SV_ModStart> int value ; DEV_INIT_TEST_WITH_RETURN ( dev_priv ) ; <S2SV_ModEnd> DRM_DEBUG ( "pid=%d\\n"
<S2SV_ModStart> ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if (
<S2SV_ModStart> = clp , . rpc_cred = callback_cred } <S2SV_ModEnd> ; int status <S2SV_ModStart> ; int status <S2SV_ModEnd> ; status = <S2SV_ModStart> clp ) ; <S2SV_ModEnd> if ( status
<S2SV_ModStart> . rpc_cred = callback_cred <S2SV_ModEnd> } ; int
<S2SV_ModStart> ) ; return set_callback_cred ( ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 1 } ; struct rpc_auth * auth = <S2SV_ModEnd> cb -> cb_client <S2SV_ModStart> cb_client -> cl_auth ; return auth -> au_ops -> lookup_cred ( auth
<S2SV_ModStart> * _dest_keyring = key_get ( <S2SV_ModStart> rka -> dest_keyring )
<S2SV_ModStart> goto out ; if ( cpuid -> nent > KVM_MAX_CPUID_ENTRIES ) cpuid -> nent = KVM_MAX_CPUID_ENTRIES ;
<S2SV_ModStart> kvm_x86_ops -> update_cr8_intercept ) return ; if ( ! vcpu -> arch . apic
<S2SV_ModStart> dr , reg ; if ( ! kvm_require_cpl ( vcpu , 0 ) ) return 1
<S2SV_ModStart> cmd ) ) { if ( state != NULL ) <S2SV_ModStart> request ) ; return 0 ; } <S2SV_ModStart> == F_UNLCK ) { if ( state != NULL ) <S2SV_ModStart> , request ) ; return 0 ; } if ( state == NULL ) return - ENOLCK
<S2SV_ModStart> ; error : if ( region -> vm_file ) <S2SV_ModStart> region ) ; if ( vma -> vm_file )
<S2SV_ModStart> ( ! bank_num || bank_num >= KVM_MAX_MCE_BANKS
<S2SV_ModStart> { if ( fifo -> skbuff -> len > 3 && <S2SV_ModEnd> ! fifo -> <S2SV_ModStart> 1 ] ) <S2SV_ModEnd> { if (
<S2SV_ModStart> ; } } if ( ! IS_ERR ( req ) )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ___ieee80211_stop_tx_ba_session ( <S2SV_ModStart> * state ; # ifdef CONFIG_MAC80211_HT_DEBUG printk ( KERN_DEBUG "Tx<S2SV_blank>BA<S2SV_blank>session<S2SV_blank>stop<S2SV_blank>requested<S2SV_blank>for<S2SV_blank>%pM<S2SV_blank>tid<S2SV_blank>%u\\n" , sta -> sta . addr , tid ) ; # endif <S2SV_ModStart> ) ) { <S2SV_ModEnd> } return ret
<S2SV_ModStart> unlock ; } <S2SV_ModEnd> ret = ___ieee80211_stop_tx_ba_session
<S2SV_ModStart> len ) { <S2SV_ModEnd> u16 tid , <S2SV_ModStart> lock ) ; if ( <S2SV_ModStart> [ tid ] & HT_ADDBA_REQUESTED_MSK ) ___ieee80211_stop_tx_ba_session ( sta , tid , WLAN_BACK_RECIPIENT ) <S2SV_ModEnd> ; spin_unlock_bh ( <S2SV_ModStart> sta -> lock <S2SV_ModEnd> ) ; }
<S2SV_ModStart> agg . state == IWL_EMPTYING_HW_QUEUE_ADDBA ) { IWL_DEBUG_HT ( priv , "AGG<S2SV_blank>stop<S2SV_blank>before<S2SV_blank>setup<S2SV_blank>done\\n" ) ; ieee80211_stop_tx_ba_cb_irqsafe ( priv -> hw , ra , tid ) ; priv -> stations [ sta_id ] . tid [ tid ] . agg . state = IWL_AGG_OFF ; return 0 ; } if ( priv -> stations [ sta_id ] . tid [ tid ] . agg . state <S2SV_ModStart> ( priv , "Stopping<S2SV_blank>AGG<S2SV_blank>while<S2SV_blank>state<S2SV_blank>not<S2SV_blank>ON<S2SV_blank>or<S2SV_blank>starting\\n" <S2SV_ModEnd> ) ; tid_data
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ___ieee80211_stop_tx_ba_session ( <S2SV_ModStart> * state ; # ifdef CONFIG_MAC80211_HT_DEBUG printk ( KERN_DEBUG "Tx<S2SV_blank>BA<S2SV_blank>session<S2SV_blank>stop<S2SV_blank>requested<S2SV_blank>for<S2SV_blank>%pM<S2SV_blank>tid<S2SV_blank>%u\\n" , sta -> sta . addr , tid ) ; # endif <S2SV_ModStart> ) ) { <S2SV_ModEnd> } return ret
<S2SV_ModStart> unlock ; } <S2SV_ModEnd> ret = ___ieee80211_stop_tx_ba_session
<S2SV_ModStart> len ) { <S2SV_ModEnd> u16 tid , <S2SV_ModStart> lock ) ; if ( <S2SV_ModStart> [ tid ] & HT_ADDBA_REQUESTED_MSK ) ___ieee80211_stop_tx_ba_session ( sta , tid , WLAN_BACK_RECIPIENT ) <S2SV_ModEnd> ; spin_unlock_bh ( <S2SV_ModStart> sta -> lock <S2SV_ModEnd> ) ; }
<S2SV_ModStart> agg . state == IWL_EMPTYING_HW_QUEUE_ADDBA ) { IWL_DEBUG_HT ( priv , "AGG<S2SV_blank>stop<S2SV_blank>before<S2SV_blank>setup<S2SV_blank>done\\n" ) ; ieee80211_stop_tx_ba_cb_irqsafe ( priv -> hw , ra , tid ) ; priv -> stations [ sta_id ] . tid [ tid ] . agg . state = IWL_AGG_OFF ; return 0 ; } if ( priv -> stations [ sta_id ] . tid [ tid ] . agg . state <S2SV_ModStart> ( priv , "Stopping<S2SV_blank>AGG<S2SV_blank>while<S2SV_blank>state<S2SV_blank>not<S2SV_blank>ON<S2SV_blank>or<S2SV_blank>starting\\n" <S2SV_ModEnd> ) ; tid_data
<S2SV_ModStart> ; if ( ! ( filp -> f_mode & FMODE_READ ) || ! ( filp -> f_mode & FMODE_WRITE ) ) return - EBADF ; if ( <S2SV_ModStart> - EFAULT ; me . moved_len = 0 ; <S2SV_ModStart> if ( ! <S2SV_ModEnd> ( donor_filp -> <S2SV_ModStart> ( donor_filp -> f_mode & FMODE_WRITE ) ) { err = - EBADF ; goto mext_out ; } err = mnt_want_write ( filp -> f_path . mnt ) ; if ( err ) goto mext_out ; err = ext4_move_extents ( filp , donor_filp , me . orig_start , me . donor_start , me . len , & me . moved_len ) ; mnt_drop_write ( filp -> f_path . mnt ) ; if ( me . moved_len > 0 ) file_remove_suid <S2SV_ModEnd> ( donor_filp ) <S2SV_ModStart> ) ) ) err = - EFAULT ; mext_out : fput ( donor_filp ) <S2SV_ModEnd> ; return err
<S2SV_ModStart> } if ( donor_inode -> i_mode & ( S_ISUID | S_ISGID ) ) { ext4_debug ( "ext4<S2SV_blank>move<S2SV_blank>extent:<S2SV_blank>suid<S2SV_blank>or<S2SV_blank>sgid<S2SV_blank>is<S2SV_blank>set" "<S2SV_blank>to<S2SV_blank>donor<S2SV_blank>file<S2SV_blank>[ino:orig<S2SV_blank>%lu,<S2SV_blank>donor<S2SV_blank>%lu]\\n" , orig_inode -> i_ino , donor_inode -> i_ino ) ; return - EINVAL ; } if (
<S2SV_ModStart> -> payload_length ; if ( rest == 0 ) return - EINVAL ;
<S2SV_ModStart> descriptor * d , * pd <S2SV_ModEnd> ; struct fw_iso_packet <S2SV_ModStart> = payload_per_buffer ; pd = d ; <S2SV_ModStart> ) { pd ++ <S2SV_ModEnd> ; pd ->
<S2SV_ModStart> fapp ) { if ( ! on ) return fasync_remove_entry ( filp , fapp ) ; return fasync_add_entry ( fd , filp , fapp <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) { goto report_and_exit <S2SV_ModEnd> ; } rthp <S2SV_ModStart> ) ) ; report_and_exit :
<S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( rt <S2SV_ModStart> err ) { if ( net_ratelimit ( ) ) printk ( KERN_WARNING "Neighbour<S2SV_blank>table<S2SV_blank>failure<S2SV_blank>&<S2SV_blank>not<S2SV_blank>caching<S2SV_blank>routes.\\n" ) ; rt_drop ( rt ) ; return err ; } } rt_free ( rt ) ; goto skip_hashing ; } rthp = & rt_hash_table [ hash ] . chain ; spin_lock_bh ( rt_hash_lock_addr ( hash ) ) ; while ( ( rth = * rthp ) != NULL ) { if ( rt_is_expired ( rth ) ) { * rthp = rth -> u . dst . rt_next ; rt_free ( rth ) ; continue ; } if ( compare_keys ( & rth -> fl , & rt -> fl ) && compare_netns ( rth , rt ) ) { * rthp = rth -> u . dst . rt_next ; rcu_assign_pointer ( rth -> u . dst . rt_next , rt_hash_table [ hash ] . chain ) ; rcu_assign_pointer ( rt_hash_table [ hash ] . chain , rth ) ; dst_use ( & rth -> u . dst , now ) ; spin_unlock_bh ( rt_hash_lock_addr ( hash ) ) ; rt_drop ( rt ) ; if ( rp ) * rp = rth ; else skb_dst_set ( skb , & rth -> u . dst ) ; return 0 ; } if ( ! atomic_read ( & rth -> u . dst . __refcnt ) ) { u32 score = rt_score ( rth ) ; if ( score <= min_score ) { cand = rth ; candp = rthp ; min_score = score ; } } chain_length ++ ; rthp = & rth -> u . dst . rt_next ; } if ( cand ) { if ( chain_length > ip_rt_gc_elasticity ) { * candp = cand -> u . dst . rt_next ; rt_free ( cand ) ; } } else { if ( chain_length > rt_chain_length_max ) { struct net * net = dev_net ( rt -> u . dst . dev ) ; int num = ++ net -> ipv4 . current_rt_cache_rebuild_count ; if ( ! rt_caching ( dev_net ( rt -> u . dst . dev ) ) ) { printk ( KERN_WARNING "%s:<S2SV_blank>%d<S2SV_blank>rebuilds<S2SV_blank>is<S2SV_blank>over<S2SV_blank>limit,<S2SV_blank>route<S2SV_blank>caching<S2SV_blank>disabled\\n" , rt -> u . dst . dev -> name , num ) ; } rt_emergency_hash_rebuild ( dev_net ( rt -> u . dst . dev ) ) ; } } if ( rt -> rt_type == RTN_UNICAST || rt -> fl . iif == 0 ) { int err = arp_bind_neighbour ( & rt -> u . dst ) ; if ( err ) { <S2SV_ModStart> ) ) ; skip_hashing <S2SV_ModEnd> : if (
<S2SV_ModStart> int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; if ( groups_per_flex < 2 ) { sbi -> s_log_groups_per_flex <S2SV_ModEnd> = 0 ; <S2SV_ModStart> 1 ; } <S2SV_ModEnd> flex_group_count = (
<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
<S2SV_ModStart> ! sb || ( EXT4_SB ( sb ) -> s_journal && <S2SV_ModStart> j_flags & JBD2_ABORT )
<S2SV_ModStart> tp , dev -> mtu
<S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> & E1000_RXD_STAT_EOP ) ) ) adapter -> flags2 |= FLAG2_IS_DISCARDING ; if ( adapter -> flags2 & FLAG2_IS_DISCARDING <S2SV_ModEnd> ) { e_dbg <S2SV_ModStart> skb = skb ; if ( status & E1000_RXD_STAT_EOP ) adapter -> flags2 &= ~ FLAG2_IS_DISCARDING
<S2SV_ModStart> E1000_RXD_STAT_EOP ) ) adapter -> flags2 |= FLAG2_IS_DISCARDING ; if ( adapter -> flags2 & FLAG2_IS_DISCARDING ) <S2SV_ModStart> ( skb ) ; if ( staterr & E1000_RXD_STAT_EOP ) adapter -> flags2 &= ~ FLAG2_IS_DISCARDING
<S2SV_ModStart> = 0 ; adapter -> flags2 &= ~ FLAG2_IS_DISCARDING ;
<S2SV_ModStart> PIDTYPE_PID ; } retval = __f_setown ( filp , pid , type , 0 ) ; <S2SV_ModStart> ctrl_lock , flags <S2SV_ModEnd> ) ; if
<S2SV_ModStart> skb ) ; struct net * net = ipv6_skb_net ( skb ) ; u32 pkt_len <S2SV_ModEnd> ; if (
<S2SV_ModStart> ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if (
<S2SV_ModStart> { int ret ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM
<S2SV_ModStart> ( const struct sctp_endpoint * ep , const struct <S2SV_ModStart> ) { struct sctp_packet * packet = NULL ; struct <S2SV_ModStart> goto nomem ; if ( asoc ) { <S2SV_ModStart> ) ; } } else { packet = sctp_ootb_pkt_new ( asoc , chunk ) ; if ( ! packet ) goto nomem_pkt ; if ( sctp_test_T_bit ( abort ) ) packet -> vtag = ntohl ( chunk -> sctp_hdr -> vtag ) ; abort -> skb -> sk = ep -> base . sk ; sctp_packet_append_chunk ( packet , abort ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_PKT , SCTP_PACKET ( packet ) ) ; SCTP_INC_STATS ( SCTP_MIB_OUTCTRLCHUNKS ) ; } sctp_sf_pdiscard ( ep , asoc , SCTP_ST_CHUNK ( 0 ) , arg , commands <S2SV_ModEnd> ) ; SCTP_INC_STATS <S2SV_ModStart> return SCTP_DISPOSITION_ABORT ; nomem_pkt : sctp_chunk_free ( abort ) ;
<S2SV_ModStart> commands ) { struct sctp_chunk * chunk = arg ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , commands ) ;
<S2SV_ModStart> if ( ! sctp_vtag_verify_either ( chunk , asoc ) ) return sctp_sf_pdiscard ( ep , asoc , type , arg , commands ) ; if ( ! <S2SV_ModStart> singleton ) return sctp_sf_violation_chunk ( ep , asoc , type , arg , commands ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , <S2SV_ModEnd> commands ) ;
<S2SV_ModStart> if ( ! chunk -> singleton ) return sctp_sf_violation_chunk ( ep , asoc , type , arg , commands ) ; if ( ! <S2SV_ModStart> , commands ) <S2SV_ModEnd> ; chunk ->
<S2SV_ModStart> ep ) return sctp_sf_tabort_8_4_8 <S2SV_ModEnd> ( ep ,
<S2SV_ModStart> commands ) { struct sctp_chunk * chunk = arg ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , commands ) ;
<S2SV_ModStart> sctp_chunk * reply ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , commands )
<S2SV_ModStart> sctp_chunkhdr_t ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , commands ) ; if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( ep , asoc , type , arg , commands ) <S2SV_ModEnd> ; ch_end = <S2SV_ModStart> skb ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , <S2SV_ModEnd> commands ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> commands ) { struct sctp_chunk * chunk = arg ; if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_violation_chunklen ( ep , asoc , type , arg , commands ) ;
<S2SV_ModStart> return sctp_sf_abort_violation ( ep ,
<S2SV_ModStart> return sctp_sf_abort_violation ( ep ,
<S2SV_ModStart> prot ) ; if ( flags & MAP_HUGETLB ) return - ENOMEM ;
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( sparc_pipe_real , struct pt_regs * , regs ) { int fd [ 2 ] ; int error ; error = do_pipe_flags ( fd , 0 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( error ) goto out ; regs -> u_regs [ UREG_I1 ] = fd [ 1 ] ; error = fd [ 0 ] ; out : return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( sparc64_newuname , struct new_utsname __user * , name <S2SV_ModEnd> ) { int <S2SV_ModStart> ) { int ret = sys_newuname ( name <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( current -> personality == PER_LINUX32 && ! ret ) { ret = ( copy_to_user ( name -> machine , "sparc\\0\\0" , 8 ) ? - EFAULT : 0 ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> SYSCALL_DEFINE1 ( sparc64_personality , unsigned long , personality <S2SV_ModEnd> ) { int <S2SV_ModStart> { int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> == PER_LINUX32 && personality == PER_LINUX ) personality = PER_LINUX32 ; ret = sys_personality ( personality ) ; if ( ret == PER_LINUX32 ) ret = PER_LINUX ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> = 0 ; unsigned long map_flags ; <S2SV_ModStart> out ; } map_flags = MAP_FIXED ; if ( vma -> vm_flags & VM_MAYSHARE ) map_flags |= MAP_SHARED ; ret = arch_mmap_check ( new_addr , new_len , map_flags ) ; if ( ret ) goto out1 ; ret = get_unmapped_area ( vma -> vm_file , new_addr , new_len , vma -> vm_pgoff + ( ( addr - vma -> vm_start ) >> PAGE_SHIFT ) , map_flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ~ PAGE_MASK ) goto out1 ; ret = move_vma ( vma , addr , old_len , new_len , new_addr ) ; if ( ! ( ret & ~ PAGE_MASK ) ) goto out ; out1 :
<S2SV_ModStart> goto out ; <S2SV_ModEnd> down_write ( &
<S2SV_ModStart> addr ) { if ( vma_expandable ( vma , new_len - old_len ) <S2SV_ModEnd> ) { int
<S2SV_ModStart> return addr ; <S2SV_ModEnd> error = security_file_mmap <S2SV_ModStart> ; error = get_unmapped_area ( NULL , addr , len , 0 , MAP_FIXED ) ; if ( error & ~ PAGE_MASK <S2SV_ModEnd> ) return error
<S2SV_ModStart> | MAP_DENYWRITE ) <S2SV_ModEnd> ; error =
<S2SV_ModStart> new_len ; } vma = vma_to_resize ( addr , old_len , new_len , & charged ) ; if ( IS_ERR ( vma ) ) { ret = PTR_ERR ( vma ) ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> charged ) ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> | MAP_DENYWRITE ) <S2SV_ModEnd> ; error =
<S2SV_ModStart> pgoff ) ; <S2SV_ModEnd> up_write ( &
<S2SV_ModStart> - ENOMEM ; <S2SV_ModEnd> addr = get_unmapped_area
<S2SV_ModStart> ) ) { if ( unlikely ( flags & MAP_HUGETLB ) ) return - EINVAL ; <S2SV_ModStart> ) goto out ; } else if ( flags & MAP_HUGETLB ) { struct user_struct * user = NULL ; len = ALIGN ( len , huge_page_size ( & default_hstate ) ) ; file = hugetlb_file_setup ( HUGETLB_ANON_FILE , len , VM_NORESERVE , & user , HUGETLB_ANONHUGE_INODE ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file )
<S2SV_ModStart> addr ) ; <S2SV_ModEnd> len = PAGE_ALIGN <S2SV_ModStart> ( ! len <S2SV_ModEnd> ) return -
<S2SV_ModStart> unsigned long ) ; unsigned long error = arch_mmap_check ( addr , len , flags ) ; if ( error ) return error ; if ( len > TASK_SIZE ) return - ENOMEM
<S2SV_ModStart> ; ret = <S2SV_ModEnd> get_unmapped_area ( vma
<S2SV_ModStart> + delta ; if ( <S2SV_ModEnd> end < vma <S2SV_ModStart> ; if ( vma -> vm_next && vma -> vm_next -> vm_start < end <S2SV_ModEnd> ) return 0
<S2SV_ModStart> vma -> vm_pgoff + ( ( addr - vma -> vm_start ) >> PAGE_SHIFT ) , <S2SV_ModEnd> map_flags ) ;
<S2SV_ModStart> fd , off_t offset ) { if ( unlikely ( offset & ~ PAGE_MASK ) ) return - EINVAL ; <S2SV_ModEnd> return sys_mmap_pgoff ( <S2SV_ModStart> , fd , offset <S2SV_ModEnd> >> PAGE_SHIFT )
<S2SV_ModStart> { unsigned long retval = sys_brk ( brk <S2SV_ModEnd> ) ; force_successful_syscall_return
<S2SV_ModStart> , f_mode , is_file_hugepages ( shp -> shm_file ) ? & shm_file_operations_huge :
<S2SV_ModStart> - ENOMEM ; unsigned long ( * get_area ) ( struct file * , unsigned long , unsigned long , unsigned long , unsigned long ) ; get_area = current -> mm -> get_unmapped_area ; <S2SV_ModStart> ) { return get_area <S2SV_ModEnd> ( NULL , <S2SV_ModStart> { addr = get_area <S2SV_ModEnd> ( NULL , <S2SV_ModStart> ) addr = get_area <S2SV_ModEnd> ( NULL ,
<S2SV_ModStart> MAP_SHARED ) && ( ( addr - ( pgoff << PAGE_SHIFT ) ) <S2SV_ModEnd> & ( SHMLBA
<S2SV_ModStart> MAP_SHARED ) && ( ( addr - ( pgoff << PAGE_SHIFT ) ) <S2SV_ModEnd> & shm_align_mask )
<S2SV_ModStart> { if ( <S2SV_ModEnd> flags & MREMAP_MAYMOVE <S2SV_ModStart> & MREMAP_MAYMOVE ) ret = mremap_to ( addr , old_len , new_addr , new_len ) ; goto out ; } if ( old_len >= new_len ) { ret = do_munmap ( mm , addr + new_len , old_len <S2SV_ModEnd> - new_len ) <S2SV_ModStart> - new_len ) ; if ( ret && <S2SV_ModEnd> old_len != new_len <S2SV_ModStart> = addr ; goto out <S2SV_ModEnd> ; } vma <S2SV_ModStart> vm_end - addr <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> MREMAP_MAYMOVE ) { <S2SV_ModEnd> unsigned long map_flags <S2SV_ModStart> goto out ; <S2SV_ModEnd> ret = move_vma
<S2SV_ModStart> delta ) { unsigned long end = vma -> vm_end + delta ; <S2SV_ModStart> if ( max_addr < end || end < vma -> vm_end ) return 0 ; if ( arch_mmap_check ( vma -> vm_start , end <S2SV_ModStart> - vma -> vm_start , MAP_FIXED ) ) return 0 ; if ( get_unmapped_area ( NULL , vma -> vm_start , end - vma -> vm_start , 0 , MAP_FIXED ) & ~ PAGE_MASK <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> pgoff ) { <S2SV_ModEnd> unsigned long error <S2SV_ModStart> goto out ; error = sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , pgoff >> ( PAGE_SHIFT - 12 ) <S2SV_ModEnd> ) ; out
<S2SV_ModStart> off ) { <S2SV_ModEnd> unsigned long ret <S2SV_ModStart> ret = - EINVAL <S2SV_ModEnd> ; # if <S2SV_ModStart> endif if ( ( off + PAGE_ALIGN ( len ) ) < off <S2SV_ModEnd> ) goto out <S2SV_ModStart> goto out ; if ( off & ~ PAGE_MASK ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> ; ret = sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , off >> PAGE_SHIFT <S2SV_ModEnd> ) ; out
<S2SV_ModStart> ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> ; err = sys_mmap_pgoff <S2SV_ModEnd> ( buffer [
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> pgoff ) { <S2SV_ModEnd> if ( pgoff <S2SV_ModStart> - EINVAL ; return sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , pgoff >> ( PAGE_SHIFT - 12 ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> goto out ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> ; err = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> { addr = sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ; addr = sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> goto out ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> pgoff ) { <S2SV_ModEnd> if ( pgoff <S2SV_ModStart> ~ PAGE_MASK ) return - EINVAL ; return sys_mmap_pgoff <S2SV_ModEnd> ( addr , <S2SV_ModStart> PAGE_SHIFT ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> EINVAL ; return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> ; error = sys_mmap_pgoff <S2SV_ModEnd> ( a .
<S2SV_ModStart> pgoff ) { return sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , <S2SV_ModStart> pgoff ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> EINVAL ; return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> 12 ; return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> ) { return sys_mmap_pgoff <S2SV_ModEnd> ( addr ,
<S2SV_ModStart> off ) { <S2SV_ModEnd> unsigned long retval <S2SV_ModStart> retval = - EINVAL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( off + PAGE_ALIGN ( len ) ) < off <S2SV_ModEnd> ) goto out <S2SV_ModStart> goto out ; if ( off & ~ PAGE_MASK ) goto out <S2SV_ModEnd> ; retval = <S2SV_ModStart> ; retval = sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , off >> PAGE_SHIFT <S2SV_ModEnd> ) ; out
<S2SV_ModStart> long error ; <S2SV_ModEnd> error = - <S2SV_ModStart> ; error = sys_mmap_pgoff ( <S2SV_ModEnd> addr , len <S2SV_ModStart> , flags , fd , <S2SV_ModStart> off >> PAGE_SHIFT <S2SV_ModEnd> ) ; out
<S2SV_ModStart> goto out_free_interp ; <S2SV_ModEnd> interpreter = open_exec <S2SV_ModStart> ) goto out_free_dentry <S2SV_ModEnd> ; } retval <S2SV_ModStart> |= PF_RANDOMIZE ; setup_new_exec ( bprm <S2SV_ModEnd> ) ; current
<S2SV_ModStart> |= READ_IMPLIES_EXEC ; setup_new_exec ( bprm ) ;
<S2SV_ModStart> PER_LINUX_32BIT ) ; setup_new_exec ( bprm ) ;
<S2SV_ModStart> = PER_HPUX ; setup_new_exec ( bprm ) ;
<S2SV_ModStart> bprm ) { int retval <S2SV_ModEnd> ; retval = <S2SV_ModStart> = NULL ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> princ ) ; if ( krb5rc ) goto exit ;
<S2SV_ModStart> princ ) ; if ( krb5rc ) goto exit ;
<S2SV_ModStart> princ ) ; if ( krb5rc ) goto exit ;
<S2SV_ModStart> CONFIG_IPV6_OPTIMISTIC_DAD if ( ( * dst ) -> neighbour &&
<S2SV_ModStart> - EINVAL ; if ( pi_state -> owner != current ) return - EINVAL ;
<S2SV_ModStart> ) ; goto out_put_key <S2SV_ModEnd> ; out_unlock_put_key :
<S2SV_ModStart> SSL_R_WRONG_VERSION_NUMBER ) ; if ( ( <S2SV_ModStart> s -> version & 0xFF00 ) == ( version & 0xFF00 ) ) s -> version = ( unsigned short ) <S2SV_ModEnd> version ; al
<S2SV_ModStart> SSL_R_WRONG_VERSION_NUMBER ) ; if ( ( <S2SV_ModStart> s -> version & 0xFF00 ) == ( version & 0xFF00 ) ) s -> version = ( unsigned short ) <S2SV_ModEnd> version ; al
<S2SV_ModStart> SSL_R_WRONG_VERSION_NUMBER ) ; if ( ( <S2SV_ModStart> s -> version & 0xFF00 ) == ( version & 0xFF00 ) ) s -> version = ( unsigned short ) <S2SV_ModEnd> version ; al
<S2SV_ModStart> rsa ) ; if ( ret <= 0 ) return 0 ;
<S2SV_ModStart> = buf ; int size = PAGE_SIZE ; <S2SV_ModStart> list ) ; int len ; len = snprintf ( str , size , "%s<S2SV_blank>%s<S2SV_blank>%ld<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n" , batostr ( & bt_sk ( sk ) -> src ) , batostr ( & bt_sk ( sk ) -> dst ) , d -> state , d -> dlci , d -> mtu , d -> rx_credits , d -> tx_credits ) ; size -= len ; if ( size <= 0 ) break ; str += len ; } if ( size <= 0 ) break ; <S2SV_ModEnd> } rfcomm_unlock (
<S2SV_ModStart> = buf ; int size = PAGE_SIZE ; <S2SV_ModStart> sk ) ; int len ; len = snprintf ( str , size <S2SV_ModEnd> , "%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>0x%4.4x<S2SV_blank>0x%4.4x<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d\\n" , <S2SV_ModStart> sec_level ) ; size -= len ; if ( size <= 0 ) break ; str += len ;
<S2SV_ModStart> = buf ; int size = PAGE_SIZE ; <S2SV_ModStart> head ) { int len ; len = snprintf ( str , size <S2SV_ModEnd> , "%s<S2SV_blank>%s<S2SV_blank>%d\\n" , <S2SV_ModStart> sk_state ) ; size -= len ; if ( size <= 0 ) break ; str += len ;
<S2SV_ModStart> = buf ; int size = PAGE_SIZE ; <S2SV_ModStart> head ) { int len ; len = snprintf ( str , size <S2SV_ModEnd> , "%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d\\n" , <S2SV_ModStart> channel ) ; size -= len ; if ( size <= 0 ) break ; str += len ;
<S2SV_ModStart> need_pusi = 1 ; ts += TS_SZ
<S2SV_ModStart> req ) { return wait_on_bit <S2SV_ModEnd> ( & req <S2SV_ModStart> , PG_BUSY , nfs_wait_bit_uninterruptible , TASK_UNINTERRUPTIBLE ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; if ( follow_on_final ( inode , lookup_flags ) <S2SV_ModEnd> ) { err
<S2SV_ModStart> ( ) ; put_pid ( tty -> pgrp ) ; put_pid ( tty -> session ) ;
<S2SV_ModStart> -> skb ) >= <S2SV_ModEnd> len ) return
<S2SV_ModStart> -> skb ) < <S2SV_ModEnd> len ) return
<S2SV_ModStart> * errp = sctp_make_op_error_fixed <S2SV_ModEnd> ( asoc , <S2SV_ModStart> asoc , chunk <S2SV_ModEnd> ) ; if <S2SV_ModStart> errp ) { sctp_init_cause_fixed <S2SV_ModEnd> ( * errp <S2SV_ModStart> ) ) ; sctp_addto_chunk_fixed <S2SV_ModEnd> ( * errp
<S2SV_ModStart> { u32 z_num <S2SV_ModEnd> ; for ( <S2SV_ModStart> z_num ++ ) <S2SV_ModEnd> tipc_zone_delete ( tipc_net <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ( res =
<S2SV_ModStart> >> 32 ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> ) ; } <S2SV_ModEnd> tlbcam_addrs [ index
<S2SV_ModStart> unsigned long points = 0 <S2SV_ModStart> tasklist_lock ) ; if ( pid_alive ( task ) ) <S2SV_ModStart> badness ( task <S2SV_ModEnd> , uptime .
<S2SV_ModStart> rsa ) ; if ( ret <= 0 ) return 0 ;
<S2SV_ModStart> goto out_fput ; if ( ! ( src_file -> f_mode & FMODE_READ ) ) goto out_fput ;
<S2SV_ModStart> goto out_drop_write ; error = - EACCES ; if ( ! is_owner_or_cap ( inode ) ) goto out ; error = 0 ;
<S2SV_ModStart> += total_swap_pages ; if ( mm )
<S2SV_ModStart> += total_swap_pages ; if ( mm ) allowed -= <S2SV_ModEnd> mm -> total_vm
<S2SV_ModStart> ? 0 : security_vm_enough_memory_kern <S2SV_ModEnd> ( VM_ACCT (
<S2SV_ModStart> VM_ACCOUNT ) ? security_vm_enough_memory_kern <S2SV_ModEnd> ( VM_ACCT (
<S2SV_ModStart> } if ( IS_IMMUTABLE ( donor_inode ) || IS_APPEND ( donor_inode ) ) return - EPERM ; if (
<S2SV_ModStart> FMODE_WRITE ) || ! ( file -> f_mode & FMODE_READ ) || <S2SV_ModStart> f_mode & FMODE_WRITE ) || ! ( tmp_file -> f_mode & FMODE_READ
<S2SV_ModStart> ; pte_t entry ; if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGBUS
<S2SV_ModStart> Count ) ; if ( * nbytes > count ) * nbytes &= 0xFFFF ;
<S2SV_ModStart> Count ) ; if ( * nbytes > count ) * nbytes &= 0xFFFF ;
<S2SV_ModStart> 0 ) { if ( info . rule_cnt <= KMALLOC_MAX_SIZE / sizeof ( u32 ) )
<S2SV_ModStart> ecryptfs_daemon_hash_mux ) ; ecryptfs_hash_bits <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ( ecryptfs_number_of_users >> ecryptfs_hash_bits ) ecryptfs_hash_bits <S2SV_ModEnd> ++ ; ecryptfs_daemon_hash <S2SV_ModStart> hlist_head ) * ( 1 << ecryptfs_hash_bits ) ) , <S2SV_ModEnd> GFP_KERNEL ) ; <S2SV_ModStart> ; i < ( 1 << ecryptfs_hash_bits ) <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ; i < ( 1 << ecryptfs_hash_bits ) <S2SV_ModEnd> ; i ++
<S2SV_ModStart> else if ( ( skb_dst ( skb ) && skb_dst ( skb ) -> dev ) && ( <S2SV_ModStart> features & NETIF_F_V4_CSUM )
<S2SV_ModStart> -> end = argp -> <S2SV_ModStart> -> end = argp ->
<S2SV_ModStart> -> end = argp -> <S2SV_ModStart> -> end = argp ->
<S2SV_ModStart> & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) <S2SV_ModStart> if ( off + len > <S2SV_ModEnd> src -> i_size <S2SV_ModStart> off + len < off <S2SV_ModEnd> ) goto out_unlock
<S2SV_ModStart> & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) <S2SV_ModStart> if ( off + len > <S2SV_ModEnd> src -> i_size <S2SV_ModStart> off + len < off <S2SV_ModEnd> ) goto out_unlock
<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( -- <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) actual = 0 <S2SV_ModEnd> ; if (
<S2SV_ModStart> = NULL ; unsigned int usize , asize ; <S2SV_ModStart> num_ioctls ) ) { u32 drv_size ; <S2SV_ModStart> DRM_COMMAND_BASE ] ; drv_size = _IOC_SIZE ( ioctl -> cmd_drv ) ; usize = asize = _IOC_SIZE ( cmd ) ; if ( drv_size > asize ) asize = drv_size ; } <S2SV_ModStart> ioctl -> cmd ; usize = asize = _IOC_SIZE ( cmd ) <S2SV_ModStart> { if ( asize <S2SV_ModEnd> <= sizeof ( <S2SV_ModStart> = kmalloc ( asize <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ) arg , usize <S2SV_ModEnd> ) != 0 <S2SV_ModStart> , 0 , usize <S2SV_ModEnd> ) ; if <S2SV_ModStart> , kdata , usize <S2SV_ModEnd> ) != 0
<S2SV_ModStart> ; } } else memset ( kdata , 0 , _IOC_SIZE ( cmd ) ) ;
<S2SV_ModStart> bn_ctx ) ; bn_ctx = NULL ;
<S2SV_ModStart> bn_ctx ) ; bn_ctx = NULL ;
<S2SV_ModStart> bn_ctx ) ; bn_ctx = NULL ;
<S2SV_ModStart> bn_ctx ) ; bn_ctx = NULL ;
<S2SV_ModStart> ) ; struct tcf_gact * gact = a -> priv ; struct tc_gact opt = { . index = gact -> tcf_index , . refcnt = gact -> tcf_refcnt - ref , . bindcnt = gact -> tcf_bindcnt - bind , . action = gact -> tcf_action , } <S2SV_ModEnd> ; struct tcf_t <S2SV_ModStart> struct tcf_t t <S2SV_ModEnd> ; NLA_PUT ( <S2SV_ModStart> struct tc_gact_p p_opt = { <S2SV_ModEnd> . paction = <S2SV_ModStart> gact -> tcfg_paction , <S2SV_ModEnd> . pval = <S2SV_ModStart> gact -> tcfg_pval , <S2SV_ModEnd> . ptype = <S2SV_ModStart> gact -> tcfg_ptype , }
<S2SV_ModStart> struct tc_mirred opt = { . index = m -> tcf_index , . action = m -> tcf_action , . refcnt = m -> tcf_refcnt - ref , . bindcnt = m -> tcf_bindcnt - bind , . eaction = m -> tcfm_eaction , . ifindex = m -> tcfm_ifindex , } <S2SV_ModStart> struct tcf_t t <S2SV_ModEnd> ; NLA_PUT (
<S2SV_ModStart> struct tc_nat opt = { . old_addr = p -> old_addr , . new_addr = p -> new_addr , . mask = p -> mask , . flags = p -> flags , . index = p -> tcf_index , . action = p -> tcf_action , . refcnt = p -> tcf_refcnt - ref , . bindcnt = p -> tcf_bindcnt - bind , } <S2SV_ModStart> struct tcf_t t <S2SV_ModEnd> ; NLA_PUT (
<S2SV_ModStart> struct tc_defact opt = { . index = d -> tcf_index , . refcnt = d -> tcf_refcnt - ref , . bindcnt = d -> tcf_bindcnt - bind , . action = d -> tcf_action , } <S2SV_ModStart> struct tcf_t t <S2SV_ModEnd> ; NLA_PUT (
<S2SV_ModStart> struct tc_skbedit opt = { . index = d -> tcf_index , . refcnt = d -> tcf_refcnt - ref , . bindcnt = d -> tcf_bindcnt - bind , . action = d -> tcf_action , } <S2SV_ModStart> struct tcf_t t <S2SV_ModEnd> ; NLA_PUT (
<S2SV_ModStart> , ino , XFS_IGET_UNTRUSTED <S2SV_ModEnd> , XFS_ILOCK_SHARED ,
<S2SV_ModStart> , ino , XFS_IGET_UNTRUSTED <S2SV_ModEnd> , XFS_ILOCK_SHARED ,
<S2SV_ModStart> , & ip <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , int ubsize <S2SV_ModEnd> , int * <S2SV_ModStart> , xfs_bulkstat_one_fmt_compat , <S2SV_ModEnd> ubused , stat
<S2SV_ModStart> , 0 , <S2SV_ModEnd> & res )
<S2SV_ModStart> , & rip <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , int ubsize <S2SV_ModEnd> , int * <S2SV_ModStart> , & ip <S2SV_ModEnd> ) ) )
<S2SV_ModStart> , & uip <S2SV_ModEnd> ) ) ) <S2SV_ModStart> , & gip <S2SV_ModEnd> ) ) )
<S2SV_ModStart> , & uip <S2SV_ModEnd> ) == 0 <S2SV_ModStart> , & gip <S2SV_ModEnd> ) == 0
<S2SV_ModStart> , & qip <S2SV_ModEnd> ) ; if <S2SV_ModStart> , & qip <S2SV_ModEnd> ) ; if
<S2SV_ModStart> mp -> m_rbmip <S2SV_ModEnd> ) ; if <S2SV_ModStart> mp -> m_rsumip <S2SV_ModEnd> ) ; if
<S2SV_ModStart> lock_flags , ipp <S2SV_ModEnd> ) ; if
<S2SV_ModStart> 0 , ipp <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; char * value ; down_read ( & JFS_IP ( inode ) -> xattr_sem ) ; xattr_size = ea_get ( inode , & ea_buf , 0 ) ; if ( xattr_size < 0 ) { size = xattr_size ; goto out ; } if ( xattr_size == 0 ) goto not_found ; ealist = ( struct jfs_ea_list * ) ea_buf . xattr ; for ( ea = FIRST_EA ( ealist ) ; ea < END_EALIST ( ealist ) ; ea = NEXT_EA ( ea ) ) if ( ( namelen == ea -> namelen ) && memcmp ( name , ea -> name , namelen ) == 0 ) { size = le16_to_cpu ( ea -> valuelen ) ; if ( ! data ) goto release ; else if ( size > buf_size ) { size = - ERANGE ; goto release ; } value = ( ( char * ) & ea -> name ) + ea -> namelen + 1 <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> xattr_sem ) ; <S2SV_ModEnd> return size ;
<S2SV_ModStart> ; if ( ! strncmp ( name , XATTR_OS2_PREFIX , XATTR_OS2_PREFIX_LEN ) ) { if ( is_known_namespace ( name + XATTR_OS2_PREFIX_LEN ) ) return - EOPNOTSUPP ; return 0 ; } if ( <S2SV_ModStart> , XATTR_USER_PREFIX_LEN ) <S2SV_ModEnd> ) return -
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int is_os2_xattr ( <S2SV_ModStart> ea ) { return ! is_known_namespace <S2SV_ModEnd> ( ea -> <S2SV_ModStart> ea -> name ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int err ; if ( strncmp ( name , XATTR_OS2_PREFIX , XATTR_OS2_PREFIX_LEN ) == 0 ) { name += XATTR_OS2_PREFIX_LEN ; if ( is_known_namespace ( name ) ) return - EOPNOTSUPP ; }
<S2SV_ModStart> 0 ) { irias_delete_object ( self -> ias_obj ) ; self -> ias_obj = NULL <S2SV_ModEnd> ; goto out
<S2SV_ModStart> dev -> ieee80211_ptr ; data -> flags = 0 ; data -> length = 0
<S2SV_ModStart> ; } } if ( IW_IS_GET ( cmd ) && ! ( descr -> flags & IW_DESCR_FLAG_NOMAX ) ) { iwp -> length = descr -> max_tokens ; }
<S2SV_ModStart> ( m , "[%u]%c<S2SV_blank>" <S2SV_ModEnd> , op -> <S2SV_ModStart> ( m , "tx_op:<S2SV_blank>%03X<S2SV_blank>%s<S2SV_blank>[%u]<S2SV_blank>" <S2SV_ModEnd> , op ->
<S2SV_ModStart> * op , unsigned
<S2SV_ModStart> int update , unsigned
<S2SV_ModStart> -> data ; unsigned
<S2SV_ModStart> 0 ; } if ( msg_head -> nframes > MAX_NFRAMES + 1 ) return - EINVAL ;
<S2SV_ModStart> 1 ) { unsigned
<S2SV_ModStart> -> sk ; unsigned
<S2SV_ModStart> * op ; unsigned int i ; int <S2SV_ModEnd> err ; if <S2SV_ModStart> nframes < 1 || msg_head -> nframes > MAX_NFRAMES
<S2SV_ModStart> ; if ( ( pcred -> tgcred -> session_keyring && <S2SV_ModStart> mycred -> euid )
<S2SV_ModStart> args -> size <S2SV_ModEnd> ; mutex_lock (
<S2SV_ModStart> size ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto err ; } if ( ! access_ok ( VERIFY_WRITE , ( char __user * ) ( uintptr_t ) args -> data_ptr , args -> size ) ) { ret = - EFAULT ; goto err ; <S2SV_ModStart> ) ; } err :
<S2SV_ModStart> size ) { ret = - EINVAL ; goto err ; } if ( ! access_ok ( VERIFY_READ , ( char __user * ) ( uintptr_t ) args -> data_ptr , args -> size ) ) { ret = - EFAULT ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ; # endif err :
<S2SV_ModStart> ; if ( in_range ( iblock , ee_block , ee_len ) <S2SV_ModEnd> ) { newblock
<S2SV_ModStart> ; if ( in_range ( block , <S2SV_ModEnd> cex -> ec_block <S2SV_ModStart> cex -> ec_block , <S2SV_ModEnd> cex -> ec_len <S2SV_ModStart> cex -> ec_len )
<S2SV_ModStart> ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely (
<S2SV_ModStart> fsxattr fa ; memset ( & fa , 0 , sizeof ( struct fsxattr ) ) ;
<S2SV_ModStart> , cnt ; <S2SV_ModEnd> unsigned long flags <S2SV_ModStart> unsigned long flags ; int ret = 0 <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; for ( <S2SV_ModStart> ) continue ; if ( cnt == nfc -> rule_cnt ) { ret = - EMSGSIZE ; break ; } <S2SV_ModStart> flags ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ch_reg edata ; memset ( & edata , 0 , sizeof ( struct ch_reg ) ) ;
<S2SV_ModStart> ; master_config_t mc ; memset ( & mc , 0 , sizeof ( master_config_t ) )
<S2SV_ModStart> serial -> tiocmget ; memset ( & icount , 0 , sizeof ( struct serial_icounter_struct ) )
<S2SV_ModStart> ; if ( ( unsigned int )
<S2SV_ModStart> ; if ( ( unsigned int )
<S2SV_ModStart> packet , vtag <S2SV_ModEnd> ) ; packet
<S2SV_ModStart> * pkt_find_dev_from_minor ( unsigned
<S2SV_ModStart> -> count ) ) return NULL ; if ( control -> count > MAX_CONTROL_COUNT
<S2SV_ModStart> struct tc_police opt = { <S2SV_ModEnd> . index = <S2SV_ModStart> police -> tcf_index , <S2SV_ModEnd> . action = <S2SV_ModStart> police -> tcf_action , <S2SV_ModEnd> . mtu = <S2SV_ModStart> police -> tcfp_mtu , <S2SV_ModEnd> . burst = <S2SV_ModStart> police -> tcfp_burst , <S2SV_ModEnd> . refcnt = <S2SV_ModStart> tcf_refcnt - ref , <S2SV_ModEnd> . bindcnt = <S2SV_ModStart> tcf_bindcnt - bind , } <S2SV_ModStart> -> rate ; if ( police -> tcfp_P_tab ) opt . peakrate = police -> tcfp_P_tab -> rate <S2SV_ModEnd> ; NLA_PUT (
<S2SV_ModStart> vcpu ) ; savesegment ( fs , fs_selector ) ; savesegment ( gs , gs_selector <S2SV_ModEnd> ) ; ldt_selector <S2SV_ModStart> . rip ; load_host_msrs ( vcpu ) ; loadsegment ( fs , <S2SV_ModEnd> fs_selector ) ; <S2SV_ModStart> fs_selector ) ; # ifdef CONFIG_X86_64 load_gs_index <S2SV_ModEnd> ( gs_selector ) <S2SV_ModStart> gs_selector ) ; wrmsrl ( MSR_KERNEL_GS_BASE , current -> thread . gs ) ; # else loadsegment ( gs , gs_selector ) ; # endif <S2SV_ModStart> kvm_load_ldt ( ldt_selector <S2SV_ModEnd> ) ; reload_tss
<S2SV_ModStart> vmx ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> . fs_reload_needed ) loadsegment ( fs , <S2SV_ModEnd> vmx -> host_state <S2SV_ModStart> host_state . ldt_sel <S2SV_ModEnd> ) ; # <S2SV_ModStart> # ifdef CONFIG_X86_64 load_gs_index ( vmx -> host_state . gs_sel ) ; wrmsrl ( MSR_KERNEL_GS_BASE , current -> thread . gs ) ; # else loadsegment ( gs , vmx -> host_state . gs_sel <S2SV_ModEnd> ) ; # <S2SV_ModStart> ; # endif <S2SV_ModEnd> } reload_tss (
<S2SV_ModStart> . ldt_sel ; savesegment ( fs , <S2SV_ModStart> host_state . fs_sel <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ; } savesegment ( gs , <S2SV_ModStart> host_state . gs_sel <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( HOST_FS_SELECTOR , 0 <S2SV_ModEnd> ) ; vmcs_write16 <S2SV_ModStart> ( HOST_GS_SELECTOR , 0 <S2SV_ModEnd> ) ; vmcs_write16
<S2SV_ModStart> > SCTP_AUTH_HMAC_ID_MAX ) { id = 0 ; continue ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> . hmac_name ) { id = 0 ; continue ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> iovec iov [ 2 <S2SV_ModEnd> ] ; struct <S2SV_ModStart> __kernel_size_t size ; mm_segment_t oldfs ; char * userbuf <S2SV_ModEnd> ; # endif <S2SV_ModStart> } if ( dev -> type == ARPHRD_ECONET ) { # ifdef CONFIG_ECONET_NATIVE unsigned short proto = 0 ; int res ; if ( <S2SV_ModStart> EMSGSIZE ; } <S2SV_ModEnd> dev_hold ( dev <S2SV_ModStart> ENETDOWN ; } if ( len > 32768 ) { err = - E2BIG ; goto error ; } <S2SV_ModStart> = size ; userbuf = vmalloc ( len ) ; if ( userbuf == NULL ) { err = - ENOMEM ; goto error <S2SV_ModEnd> ; } iov <S2SV_ModStart> } iov [ <S2SV_ModEnd> 1 ] . <S2SV_ModStart> . iov_base = userbuf <S2SV_ModEnd> ; iov [ <S2SV_ModStart> ; iov [ <S2SV_ModEnd> 1 ] . <S2SV_ModStart> . iov_len = len ; err = memcpy_fromiovec ( userbuf , msg -> msg_iov , len ) ; if ( err ) goto error_free_buf ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> == NULL ) goto error_free_buf ; <S2SV_ModEnd> eb = ( <S2SV_ModStart> . msg_iovlen = 2 <S2SV_ModEnd> ; udpmsg . <S2SV_ModStart> set_fs ( oldfs ) ; error_free_buf : vfree ( userbuf <S2SV_ModStart> ; # endif error :
<S2SV_ModStart> saddr == NULL || <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> -> cb ; <S2SV_ModEnd> dev = net2dev_map
<S2SV_ModStart> case SIOCSIFADDR : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ;
<S2SV_ModStart> ; int fput_needed ; if ( len > INT_MAX ) len = INT_MAX
<S2SV_ModStart> ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX
<S2SV_ModStart> iov_base ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; if ( len > INT_MAX - tot_len ) len = INT_MAX - tot_len ; <S2SV_ModEnd> tot_len += len
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> verify_iovec ( struct <S2SV_ModStart> size , ct , <S2SV_ModEnd> err ; if <S2SV_ModStart> ++ ) { size_t len = <S2SV_ModEnd> iov [ ct <S2SV_ModStart> ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return <S2SV_ModEnd> err ; }
<S2SV_ModStart> ) rule_buf = kzalloc <S2SV_ModEnd> ( info .
<S2SV_ModStart> : if ( ! s -> hit ) { if ( <S2SV_ModStart> session -> tlsext_hostname ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( len > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ( s -> session -> tlsext_hostname = OPENSSL_malloc ( len + 1 ) ) <S2SV_ModStart> NULL ) { * al = TLS1_AD_INTERNAL_ERROR <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> servername_done = s -> session -> tlsext_hostname &&
<S2SV_ModStart> : if ( ! s -> hit ) { if ( <S2SV_ModStart> session -> tlsext_hostname ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModEnd> if ( len <S2SV_ModStart> len > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if <S2SV_ModEnd> ( ( s <S2SV_ModStart> == NULL ) { * al = TLS1_AD_INTERNAL_ERROR <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> servername_done = s -> session -> tlsext_hostname && <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ecpointformatlist ) { OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ) ; s -> session -> tlsext_ecpointformatlist = NULL ; } <S2SV_ModStart> tlsext_ecpointformatlist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ecpointformatlist_length ) ; } <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ellipticcurvelist ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModStart> tlsext_ellipticcurvelist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ellipticcurvelist_length ) ; }
<S2SV_ModStart> : if ( ! s -> hit ) { if ( <S2SV_ModStart> session -> tlsext_hostname ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModEnd> if ( len <S2SV_ModStart> len > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if <S2SV_ModEnd> ( ( s <S2SV_ModStart> == NULL ) { * al = TLS1_AD_INTERNAL_ERROR <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> servername_done = s -> session -> tlsext_hostname && <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ecpointformatlist ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModStart> tlsext_ecpointformatlist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ecpointformatlist_length ) ; } <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ellipticcurvelist ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModStart> tlsext_ellipticcurvelist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ellipticcurvelist_length ) ; }
<S2SV_ModStart> : if ( ! s -> hit ) { if ( <S2SV_ModStart> session -> tlsext_hostname ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModEnd> if ( len <S2SV_ModStart> len > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if <S2SV_ModEnd> ( ( s <S2SV_ModStart> == NULL ) { * al = TLS1_AD_INTERNAL_ERROR <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> servername_done = s -> session -> tlsext_hostname && <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ecpointformatlist ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModStart> tlsext_ecpointformatlist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ecpointformatlist_length ) ; } <S2SV_ModStart> 0 ; } if ( ! s -> hit ) { if ( s -> session -> tlsext_ellipticcurvelist ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } <S2SV_ModStart> tlsext_ellipticcurvelist_length = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ellipticcurvelist_length ) ; }
<S2SV_ModStart> ] > X25_MAX_DTE_FACIL_LEN || p [ 1 ] <= 1 ) return 0 <S2SV_ModEnd> ; dte_facs -> <S2SV_ModStart> ] > X25_MAX_DTE_FACIL_LEN || p [ 1 ] <= 1 ) return 0 <S2SV_ModEnd> ; dte_facs ->
<S2SV_ModStart> len ) ; else return - 1 ;
<S2SV_ModStart> -> num ; sll -> sll_pkttype = 0 ;
<S2SV_ModStart> ( dev ) strncpy <S2SV_ModEnd> ( uaddr -> <S2SV_ModStart> -> name , 14 <S2SV_ModEnd> ) ; else
<S2SV_ModStart> sk ) ; memset ( addr , 0 , sizeof ( * addr ) ) ;
<S2SV_ModStart> ; if ( nlmsg_attrlen ( cb -> nlh , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> inet_diag_entry entry ; const struct nlattr <S2SV_ModEnd> * bc = <S2SV_ModStart> * bc = nlmsg_find_attr ( cb -> nlh , sizeof ( * r ) , INET_DIAG_REQ_BYTECODE <S2SV_ModEnd> ) ; struct <S2SV_ModStart> ! inet_diag_bc_run ( nla_data <S2SV_ModEnd> ( bc ) <S2SV_ModStart> bc ) , nla_len <S2SV_ModEnd> ( bc )
<S2SV_ModStart> * lopt ; const struct nlattr <S2SV_ModEnd> * bc = <S2SV_ModStart> ; if ( nlmsg_attrlen ( <S2SV_ModStart> cb -> nlh , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> { bc = nlmsg_find_attr ( cb -> nlh , sizeof ( * r ) , INET_DIAG_REQ_BYTECODE <S2SV_ModEnd> ) ; entry <S2SV_ModStart> ! inet_diag_bc_run ( nla_data <S2SV_ModEnd> ( bc ) <S2SV_ModStart> bc ) , nla_len <S2SV_ModEnd> ( bc )
<S2SV_ModStart> ; if ( nlmsg_attrlen ( cb -> nlh , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> inet_diag_entry entry ; const struct nlattr <S2SV_ModEnd> * bc = <S2SV_ModStart> * bc = nlmsg_find_attr ( cb -> nlh , sizeof ( * r ) , INET_DIAG_REQ_BYTECODE <S2SV_ModEnd> ) ; entry <S2SV_ModStart> ! inet_diag_bc_run ( nla_data <S2SV_ModEnd> ( bc ) <S2SV_ModStart> bc ) , nla_len <S2SV_ModEnd> ( bc )
<S2SV_ModStart> = 0 ; memset ( & user_ns . pad , 0 , sizeof ( user_ns . pad ) ) ;
<S2SV_ModStart> = 0 ; memset ( & dbgregs -> reserved , 0 , sizeof ( dbgregs -> reserved ) ) ;
<S2SV_ModStart> -> exception . pad = 0 ; events -> exception . <S2SV_ModStart> ; events -> nmi . pad = 0 ; events -> <S2SV_ModStart> KVM_VCPUEVENT_VALID_SHADOW ) ; memset ( & events -> reserved , 0 , sizeof ( events -> reserved ) ) ;
<S2SV_ModStart> lock ) ; memset ( & ps -> reserved , 0 , sizeof ( ps -> reserved ) ) ;
<S2SV_ModStart> * addr ; <S2SV_ModEnd> addr = kmap <S2SV_ModStart> ( to_user ) { rds_stats_add ( s_copy_to_user , bytes ) ; <S2SV_ModStart> bytes ) ; } else { rds_stats_add ( s_copy_from_user , bytes ) ; <S2SV_ModEnd> ret = copy_from_user <S2SV_ModStart> bytes ) ; } <S2SV_ModStart> page ) ; return ret ? - EFAULT : <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> struct shmid_ds out ; memset ( & out , 0 , sizeof ( out ) )
<S2SV_ModStart> * p ; memset ( & m64 , 0 , sizeof ( m64 ) ) ;
<S2SV_ModStart> third ) ; memset ( & s64 , 0 , sizeof ( s64 ) ) ;
<S2SV_ModStart> second ) ; memset ( & s64 , 0 , sizeof ( s64 ) ) ;
<S2SV_ModStart> struct mq_attr attr ; memset ( & attr , 0 , sizeof ( attr ) )
<S2SV_ModStart> -> icount ; memset ( & icount , 0 , sizeof ( struct serial_icounter_struct ) ) ;
<S2SV_ModStart> ( ) ; memset ( & icount , 0 , sizeof ( struct serial_icounter_struct ) ) ;
<S2SV_ModStart> ; break ; <S2SV_ModEnd> } if (
<S2SV_ModStart> ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case
<S2SV_ModStart> ; break ; <S2SV_ModEnd> } if (
<S2SV_ModStart> ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case
<S2SV_ModStart> ; break ; <S2SV_ModEnd> } if (
<S2SV_ModStart> ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case
<S2SV_ModStart> u32 trace ; memset ( & vblank , 0 , sizeof ( struct fb_vblank ) ) ;
<S2SV_ModStart> ) return err ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO : memset ( & info , 0 , sizeof ( info ) ) ;
<S2SV_ModStart> ) return err ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> case SNDRV_HDSPM_IOCTL_GET_CONFIG_INFO : memset ( & info , 0 , sizeof ( info ) ) ;
<S2SV_ModStart> struct viafb_ioctl_info viainfo ; memset ( & viainfo , 0 , sizeof ( struct viafb_ioctl_info ) )
<S2SV_ModStart> flen ) { <S2SV_ModEnd> void * ptr <S2SV_ModStart> BPF_MEMWORDS ] ; unsigned long memvalid = 0 ; <S2SV_ModStart> ; int pc ; BUILD_BUG_ON ( BPF_MEMWORDS > BITS_PER_LONG ) <S2SV_ModStart> ++ ) { const struct sock_filter * <S2SV_ModStart> pc ] ; u32 f_k = fentry -> k ; <S2SV_ModStart> : A += f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A -= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A *= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A /= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A &= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A |= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A <<= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A >>= f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : pc += f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> ( A > f_k <S2SV_ModEnd> ) ? fentry <S2SV_ModStart> ( A >= f_k <S2SV_ModEnd> ) ? fentry <S2SV_ModStart> ( A == f_k <S2SV_ModEnd> ) ? fentry <S2SV_ModStart> ( A & f_k <S2SV_ModEnd> ) ? fentry <S2SV_ModStart> : k = f_k <S2SV_ModEnd> ; load_w : <S2SV_ModStart> : k = f_k <S2SV_ModEnd> ; load_h : <S2SV_ModStart> : k = f_k <S2SV_ModEnd> ; load_b : <S2SV_ModStart> = X + f_k <S2SV_ModEnd> ; goto load_w <S2SV_ModStart> = X + f_k <S2SV_ModEnd> ; goto load_h <S2SV_ModStart> = X + f_k <S2SV_ModEnd> ; goto load_b <S2SV_ModStart> ( skb , f_k <S2SV_ModEnd> , 1 , <S2SV_ModStart> : A = f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : X = f_k <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : A = ( memvalid & ( 1UL << f_k ) ) ? mem [ f_k ] : 0 <S2SV_ModEnd> ; continue ; <S2SV_ModStart> : X = ( memvalid & ( 1UL << f_k ) ) ? mem [ f_k ] : 0 <S2SV_ModEnd> ; continue ; <S2SV_ModStart> BPF_S_RET_K : return f_k <S2SV_ModEnd> ; case BPF_S_RET_A <S2SV_ModStart> case BPF_S_ST : memvalid |= 1UL << f_k ; mem [ f_k <S2SV_ModEnd> ] = A <S2SV_ModStart> case BPF_S_STX : memvalid |= 1UL << f_k ; mem [ f_k <S2SV_ModEnd> ] = X
<S2SV_ModStart> ; int fput_needed ; if ( len > INT_MAX ) len = INT_MAX
<S2SV_ModStart> ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX
<S2SV_ModStart> iov_base ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; if ( len > INT_MAX - tot_len ) len = INT_MAX - tot_len ; <S2SV_ModEnd> tot_len += len
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> verify_iovec ( struct <S2SV_ModStart> size , ct , <S2SV_ModEnd> err ; if <S2SV_ModStart> ++ ) { size_t len = <S2SV_ModEnd> iov [ ct <S2SV_ModStart> ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return <S2SV_ModEnd> err ; }
<S2SV_ModStart> uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL )
<S2SV_ModStart> >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ;
<S2SV_ModStart> break ; } if ( ! iov [ i ] . iov_len ) return - EINVAL ;
<S2SV_ModStart> case X25_FAC_CLASS_A : if ( len < 2 ) return 0 ; <S2SV_ModStart> case X25_FAC_CLASS_B : if ( len < 3 ) return 0 ; <S2SV_ModStart> case X25_FAC_CLASS_C : if ( len < 4 ) return 0 ; <S2SV_ModStart> case X25_FAC_CLASS_D : if ( len < p [ 1 ] + 2 ) return 0 ; <S2SV_ModStart> ( KERN_DEBUG "X.25:<S2SV_blank>unknown<S2SV_blank>facility<S2SV_blank>%02X," "length<S2SV_blank>%d\\n" , p [ 0 ] , p [ 1 <S2SV_ModEnd> ] ) ;
<S2SV_ModStart> ( val < 64 <S2SV_ModEnd> || val >
<S2SV_ModStart> goto out ; <S2SV_ModEnd> nstart = tmp
<S2SV_ModStart> nrpages ) ; perf_event_mmap ( vma ) ;
<S2SV_ModStart> ) ) { # if 0 <S2SV_ModStart> SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) ) # endif
<S2SV_ModStart> ; } } # if 0 <S2SV_ModStart> ; } } # endif
<S2SV_ModStart> ) ) { # if 0 <S2SV_ModStart> SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) ) # endif
<S2SV_ModStart> ; } } # if 0 <S2SV_ModStart> ; } } # endif
<S2SV_ModStart> ) ) { # if 0 <S2SV_ModStart> SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) ) # endif
<S2SV_ModStart> ; } } # if 0 <S2SV_ModStart> ; } } # endif
<S2SV_ModStart> ) ) { # if 0 <S2SV_ModStart> SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) ) # endif
<S2SV_ModStart> ; } } # if 0 <S2SV_ModStart> ; } } # endif
<S2SV_ModStart> -> mm ) { acct_arg_size ( bprm , 0 ) ; <S2SV_ModStart> mm ) ; }
<S2SV_ModStart> bprm -> file ) ; acct_arg_size ( bprm , 0
<S2SV_ModStart> } else { if ( unlikely ( has_group_leader_pid ( tsk ) ) ) posix_cpu_timers_exit_group ( tsk ) ;
<S2SV_ModStart> void ) { if ( unix_tot_inflight > UNIX_INFLIGHT_TRIGGER_GC && ! gc_in_progress ) unix_gc ( ) ;
<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
<S2SV_ModStart> NULL ) ; sk -> sk_backlog . len = 0 ;
<S2SV_ModStart> = NULL ; newsk -> sk_backlog . len = 0 ;
<S2SV_ModStart> ; } else if ( sk_add_backlog_limited <S2SV_ModEnd> ( sk , <S2SV_ModStart> , skb ) ) { bh_unlock_sock ( sk ) ; atomic_inc ( & sk -> sk_drops ) ; goto discard_and_relse ; } <S2SV_ModEnd> bh_unlock_sock ( sk
<S2SV_ModStart> ; sk -> sk_backlog . limit = sk -> sk_rcvbuf << 1 ; sk ->
<S2SV_ModStart> ; pipe = get_pipe_info ( file ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> if ( vlan_tag && adapter -> vlgrp
<S2SV_ModStart> pcidev ) ; bfa_com_port_attach ( bfa , meminfo ) ;
<S2SV_ModStart> dm_len ) ; dm_len += bfa_port_meminfo ( ) ;
<S2SV_ModStart> pages ) { int ret ; <S2SV_ModStart> = pages ; ret = security_file_mmap ( NULL , 0 , 0 , 0 , vma -> vm_start , 1 ) ; if ( ret ) goto out ; ret = <S2SV_ModEnd> insert_vm_struct ( mm <S2SV_ModStart> , vma ) ; if ( ret ) goto out ; <S2SV_ModEnd> mm -> total_vm <S2SV_ModStart> return 0 ; out : kmem_cache_free ( vm_area_cachep , vma ) ; return ret ;
<S2SV_ModStart> "%s\\n" , __func__ ) ; if ( sock_owned_by_user ( sk ) ) { if ( timer_pending ( & t -> proto_unreach_timer ) ) return ; else { if ( ! mod_timer ( & t -> proto_unreach_timer , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; } } else { if ( timer_pending ( & t -> proto_unreach_timer ) && del_timer ( & t -> proto_unreach_timer ) ) sctp_association_put ( asoc <S2SV_ModStart> ) ; } }
<S2SV_ModStart> peer ) ; setup_timer ( & peer -> proto_unreach_timer , sctp_generate_proto_unreach_event , ( unsigned long ) peer ) ;
<S2SV_ModStart> { if ( strncmp ( name , mixer_vols [ i ] . name , 32 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> num_mixer_volumes ++ ; strncpy ( mixer_vols [ n ] . name , name , 32 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> case IRLMP_ENUMDEVICES : offset = sizeof ( struct irda_device_list ) - sizeof ( struct irda_device_info ) ; if ( len < offset ) { err = - EINVAL ; goto out ; } <S2SV_ModStart> & list , offset <S2SV_ModEnd> ) ) err <S2SV_ModStart> = - EFAULT <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> procname , "%lu" , sock_i_ino ( sk ) <S2SV_ModEnd> ) ; bo
<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
<S2SV_ModStart> ; struct ib_uverbs_poll_cq_resp resp ; u8 __user * header_ptr ; u8 __user * data_ptr <S2SV_ModEnd> ; struct ib_cq <S2SV_ModStart> ; struct ib_wc <S2SV_ModEnd> wc ; int <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> cq = idr_read_cq <S2SV_ModStart> ! cq ) return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; header_ptr = <S2SV_ModEnd> ( void __user <S2SV_ModStart> cmd . response ; data_ptr = header_ptr + sizeof resp ; memset ( & resp , 0 , sizeof resp ) ; while ( resp . count < cmd . ne ) { ret = ib_poll_cq ( cq , 1 , & wc ) ; if ( ret < 0 ) goto out_put ; if ( ! ret ) break ; ret = copy_wc_to_user ( data_ptr , & wc ) ; if ( ret ) goto out_put ; data_ptr += sizeof ( struct ib_uverbs_wc ) ; ++ resp . count ; } if ( copy_to_user ( header_ptr , & resp , sizeof resp ) ) { <S2SV_ModEnd> ret = - <S2SV_ModStart> - EFAULT ; goto out_put ; } ret = in_len ; out_put : put_cq_read ( cq <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
<S2SV_ModStart> ; regbuf = kzalloc <S2SV_ModEnd> ( reglen ,
<S2SV_ModStart> ; data = kzalloc <S2SV_ModEnd> ( gstrings .
<S2SV_ModStart> ; indir = kzalloc <S2SV_ModEnd> ( full_size ,
<S2SV_ModStart> = kmalloc ( count <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> ; if ( ! iov [ i ] . iov_len ) return - EINVAL ; if ( <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> ; if ( sk_rcvqueues_full ( sk , skb ) ) { atomic_inc ( & sk -> sk_drops ) ; goto discard_and_relse ; } if (
<S2SV_ModStart> ; sk -> <S2SV_ModEnd> sk_state = TCP_CLOSE
<S2SV_ModStart> sctp_sockets_allocated ) ; <S2SV_ModEnd> local_bh_disable ( )
<S2SV_ModStart> ; return 0 ; } if ( sk_rcvqueues_full ( sk , skb ) ) { sock_put ( sk ) ; goto discard
<S2SV_ModStart> skb1 ) { if ( sk_rcvqueues_full ( sk , skb ) ) { kfree_skb ( skb1 ) ; goto drop ; }
<S2SV_ModStart> vcpu ) { int r = EMULATE_DONE ; <S2SV_ModStart> vcpu ) ; if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> = 0 ; r = EMULATE_FAIL ; } <S2SV_ModStart> ) ; return r <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
<S2SV_ModStart> cluster_end ) ; new = new | ( ( i_size_read ( inode ) <= page_offset ( page ) ) && ( page_offset ( page ) <= user_pos ) ) ;
<S2SV_ModStart> info -> num < 0 || info -> num
<S2SV_ModStart> ; if ( <S2SV_ModEnd> br -> multicast_disabled
<S2SV_ModStart> ) ; return br_mdb_ip_get <S2SV_ModEnd> ( mdb , <S2SV_ModStart> , & br_dst <S2SV_ModEnd> ) ; }
<S2SV_ModStart> dst ) { if ( ! mdb ) return NULL ;
<S2SV_ModStart> task ) ; <S2SV_ModEnd> task_context_switch_counts ( m
<S2SV_ModStart> new_version ) { memset ( geo , 0 , sizeof ( * geo ) ) ;
<S2SV_ModStart> = dev ; strlcpy <S2SV_ModEnd> ( dev -> <S2SV_ModStart> dev -> product_name , sizeof ( dev -> pcm -> name )
<S2SV_ModStart> return ret ; strlcpy <S2SV_ModEnd> ( rmidi -> <S2SV_ModStart> device -> product_name , sizeof ( rmidi -> name )
<S2SV_ModStart> port ) { if ( hlist_unhashed ( & mp -> mglist ) )
<S2SV_ModStart> ( m , "%d<S2SV_blank>(%s)<S2SV_blank>%c<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%u<S2SV_blank>%lu<S2SV_blank>\\\n%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%ld<S2SV_blank>%ld<S2SV_blank>%ld<S2SV_blank>%ld<S2SV_blank>%d<S2SV_blank>0<S2SV_blank>%llu<S2SV_blank>%lu<S2SV_blank>%ld<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>\\\n%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%lu<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%u<S2SV_blank>%u<S2SV_blank>%llu<S2SV_blank>%lu<S2SV_blank>%ld\\n" <S2SV_ModEnd> , pid_nr_ns ( <S2SV_ModStart> , mm ? ( permitted ? <S2SV_ModStart> -> start_code : 1 ) : <S2SV_ModStart> , mm ? ( permitted ? <S2SV_ModStart> mm -> end_code : 1 )
<S2SV_ModStart> state ) { <S2SV_ModEnd> Sector sect ; <S2SV_ModStart> data ; int slot <S2SV_ModEnd> , blocks_in_map ; <S2SV_ModStart> 0 ; } blocks_in_map = be32_to_cpu ( part -> map_count ) ; if ( blocks_in_map < 0 || blocks_in_map >= DISK_MAX_PARTS ) { put_dev_sector ( sect ) ; return 0 ; } <S2SV_ModStart> PAGE_SIZE ) ; for ( slot <S2SV_ModEnd> = 1 ; <S2SV_ModStart> = 1 ; slot <S2SV_ModEnd> <= blocks_in_map ; <S2SV_ModStart> blocks_in_map ; ++ slot <S2SV_ModEnd> ) { int <S2SV_ModStart> int pos = slot <S2SV_ModEnd> * secsize ; <S2SV_ModStart> { found_root = slot <S2SV_ModEnd> ; found_root_goodness = <S2SV_ModStart> } # endif <S2SV_ModEnd> } # ifdef
<S2SV_ModStart> 0x08 ) ; if ( vm -> vblk_size == 0 ) { ldm_error ( "Illegal<S2SV_blank>VBLK<S2SV_blank>size" ) ; return false ; }
<S2SV_ModStart> data ; int <S2SV_ModEnd> ret = 0 <S2SV_ModStart> ret = 0 ; unsigned int crtc
<S2SV_ModStart> = false ; if ( track -> aa_dirty && track -> aaresolve ) { if ( track -> aa . robj == NULL ) { DRM_ERROR ( "[drm]<S2SV_blank>No<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>AA<S2SV_blank>resolve<S2SV_blank>buffer<S2SV_blank>%d<S2SV_blank>!\\n" , i ) ; return - EINVAL ; } size = track -> aa . pitch * track -> cb [ 0 ] . cpp * track -> maxy ; size += track -> aa . offset ; if ( size > radeon_bo_size ( track -> aa . robj ) ) { DRM_ERROR ( "[drm]<S2SV_blank>Buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>AA<S2SV_blank>resolve<S2SV_blank>buffer<S2SV_blank>%d<S2SV_blank>" "(need<S2SV_blank>%lu<S2SV_blank>have<S2SV_blank>%lu)<S2SV_blank>!\\n" , i , size , radeon_bo_size ( track -> aa . robj ) ) ; DRM_ERROR ( "[drm]<S2SV_blank>AA<S2SV_blank>resolve<S2SV_blank>buffer<S2SV_blank>%d<S2SV_blank>(%u<S2SV_blank>%u<S2SV_blank>%u<S2SV_blank>%u)\\n" , i , track -> aa . pitch , track -> cb [ 0 ] . cpp , track -> aa . offset , track -> maxy ) ; return - EINVAL ; } } track -> aa_dirty = false ;
<S2SV_ModStart> = true ; track -> aa_dirty = true ; <S2SV_ModStart> = 0 ; track -> aaresolve = true ; track -> aa . robj = NULL ;
<S2SV_ModStart> : if ( rec >= f -> num ) { ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , f -> num ) ; return false ; } if (
<S2SV_ModStart> * dev ; int no_module ; <S2SV_ModStart> ( ) ; no_module = ! dev ; if ( no_module <S2SV_ModEnd> && capable ( <S2SV_ModStart> CAP_NET_ADMIN ) ) no_module = request_module ( "netdev-%s" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> , name ) ) pr_err ( "Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>" "with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>" "instead\\n" , name ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ) ; scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ) + RDS_CONG_MAP_BYTES ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret
<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; struct ib_uverbs_poll_cq_resp resp ; u8 __user * header_ptr ; u8 __user * data_ptr <S2SV_ModEnd> ; struct ib_cq <S2SV_ModStart> ; struct ib_wc <S2SV_ModEnd> wc ; int <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> cq = idr_read_cq <S2SV_ModStart> ! cq ) return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; header_ptr = <S2SV_ModEnd> ( void __user <S2SV_ModStart> cmd . response ; data_ptr = header_ptr + sizeof resp ; memset ( & resp , 0 , sizeof resp ) ; while ( resp . count < cmd . ne ) { ret = ib_poll_cq ( cq , 1 , & wc ) ; if ( ret < 0 ) goto out_put ; if ( ! ret ) break ; ret = copy_wc_to_user ( data_ptr , & wc ) ; if ( ret ) goto out_put ; data_ptr += sizeof ( struct ib_uverbs_wc ) ; ++ resp . count ; } if ( copy_to_user ( header_ptr , & resp , sizeof resp ) ) { <S2SV_ModEnd> ret = - <S2SV_ModStart> - EFAULT ; goto out_put ; } ret = in_len ; out_put : put_cq_read ( cq <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; kenter ( "%%%d,%s,\'%*.*s\',%zu" <S2SV_ModEnd> , key -> <S2SV_ModStart> key -> description , ( int ) datalen , ( int ) datalen
<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> int error ; int did_lock_epmutex = 0 ; <S2SV_ModStart> -> private_data ; if ( unlikely ( is_file_epoll ( tfile ) && op == EPOLL_CTL_ADD ) ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; error = - ELOOP ; if ( ep_loop_check ( ep , tfile ) != 0 ) goto error_tgt_fput ; } <S2SV_ModStart> ; error_tgt_fput : if ( unlikely ( did_lock_epmutex ) ) mutex_unlock ( & epmutex ) ;
<S2SV_ModStart> ; int ret , i <S2SV_ModStart> - EOPNOTSUPP ; i = buf_to_pages_noslab ( buf , buflen , arg . acl_pages , & arg . acl_pgbase ) ; if ( i < 0 ) return i ; <S2SV_ModStart> inode ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> res , 1 ) ; for ( ; i > 0 ; i -- ) put_page ( pages [ i - 1 ]
<S2SV_ModStart> 1 ; } else if ( sk -> sk_state == DCCP_CLOSED ) { dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } <S2SV_ModStart> ) { case <S2SV_ModEnd> DCCP_REQUESTING : queued
<S2SV_ModStart> -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> ; ssize_t ret_size ; int rc <S2SV_ModStart> buffer_mutex ) ; rc = <S2SV_ModEnd> copy_to_user ( buf <S2SV_ModStart> , ret_size ) ; memset ( chip -> data_buffer , 0 , ret_size ) ; if ( rc
<S2SV_ModStart> slot = 1 ; unsigned int npartitions <S2SV_ModStart> } d_partitions [ MAX_OSF_PARTITIONS <S2SV_ModEnd> ] ; } <S2SV_ModStart> 0 ; } npartitions = le16_to_cpu ( label -> d_npartitions ) ; if ( npartitions > MAX_OSF_PARTITIONS ) { put_dev_sector ( sect ) ; return 0 ; } <S2SV_ModStart> ; i < npartitions <S2SV_ModEnd> ; i ++
<S2SV_ModStart> = - EFAULT ; goto out ; } if ( hm -> h . adapter_index >= HPI_MAX_ADAPTERS ) { err = - EINVAL
<S2SV_ModStart> break ; } rev . name [ sizeof ( rev . name ) - 1 ] = 0 ;
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> break ; } rev . name [ sizeof ( rev . name ) - 1 ] = 0 ;
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> break ; } rev . name [ sizeof ( rev . name ) - 1 ] = 0 ;
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> ) ; } memset ( & ah , 0 , sizeof ( ah ) ) ; ah <S2SV_ModEnd> . port = <S2SV_ModStart> code = 2 <S2SV_ModEnd> ; size =
<S2SV_ModStart> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )
<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> copy_from_user ( & ins , addr <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( ins ) <S2SV_ModEnd> ) ) return
<S2SV_ModStart> fmt , buf + p <S2SV_ModEnd> , c ,
<S2SV_ModStart> value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
<S2SV_ModStart> channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
<S2SV_ModStart> = 0 ; skb -> dev = napi -> dev ;
<S2SV_ModStart> -> dev ; skb -> skb_iif = 0 ;
<S2SV_ModStart> idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
<S2SV_ModStart> fsnotify_group * group <S2SV_ModEnd> ; int ret <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> group = inotify_new_group <S2SV_ModStart> = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; <S2SV_ModStart> group ) ) return <S2SV_ModEnd> PTR_ERR ( group <S2SV_ModStart> PTR_ERR ( group <S2SV_ModEnd> ) ; ret <S2SV_ModStart> if ( ret < 0 ) <S2SV_ModEnd> fsnotify_put_group ( group <S2SV_ModStart> fsnotify_put_group ( group <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events <S2SV_ModStart> -> inotify_data . fa = NULL <S2SV_ModEnd> ; group -> <S2SV_ModStart> -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ;
<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>group=%p\\n" <S2SV_ModStart> group ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ; if ( l < 10 || l > 20 ) return - 1 ; if (
<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;
<S2SV_ModStart> & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> AX25_ADDR_LEN ) ; }
<S2SV_ModStart> ) + addrs_len ; chunksize += WORD_ROUND ( <S2SV_ModEnd> SCTP_SAT_LEN ( num_types <S2SV_ModStart> SCTP_SAT_LEN ( num_types ) <S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> -> length ) ) <S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> auth_chunks -> length ) <S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> sctp_supported_ext_param_t ) + num_ext ) <S2SV_ModEnd> ; retval =
<S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> -> length ) ) <S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> auth_chunks -> length ) <S2SV_ModStart> ) chunksize += WORD_ROUND ( <S2SV_ModStart> sctp_supported_ext_param_t ) + num_ext ) <S2SV_ModEnd> ; retval =
<S2SV_ModStart> skb ) { u16 txq = skb_rx_queue_recorded ( skb ) ? skb_get_rx_queue ( skb ) : 0 ; if ( unlikely ( txq >= dev -> real_num_tx_queues ) ) { do txq -= dev -> real_num_tx_queues ; while ( txq >= dev -> real_num_tx_queues ) ; } return txq <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }
<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * pid_ns , unsigned <S2SV_ModStart> , * end ; if ( last >= PID_MAX_LIMIT ) return - 1
<S2SV_ModStart> unsigned int nr ; struct task_struct * reaper ; struct tgid_iter iter ; struct pid_namespace * ns ; if ( filp -> f_pos >= PID_MAX_LIMIT + TGID_OFFSET ) goto out_no_task ; nr <S2SV_ModStart> - FIRST_PROCESS_ENTRY ; <S2SV_ModEnd> reaper = get_proc_task <S2SV_ModStart> -> d_inode ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> bcm_sock * bo ; struct bcm_op * op , * next ; if ( sk == NULL ) return 0 ; bo <S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; unregister_netdevice_notifier (
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) > num_entries ) || ( ( pg_start + mem -> page_count ) < pg_start )
<S2SV_ModStart> ; int mask_type , num_entries <S2SV_ModStart> mem -> type ) return - EINVAL ; num_entries = agp_num_entries ( ) ; if ( ( ( pg_start + mem -> page_count ) > num_entries ) || ( ( pg_start + mem -> page_count ) < pg_start )
<S2SV_ModStart> size_t i ; int cur_memory ; <S2SV_ModStart> return NULL ; cur_memory = <S2SV_ModEnd> atomic_read ( & <S2SV_ModStart> -> current_memory_agp ) ; if ( ( cur_memory + page_count <S2SV_ModEnd> > bridge -> <S2SV_ModStart> bridge -> max_memory_agp ) || ( cur_memory + page_count < page_count )
<S2SV_ModStart> page * ) ; if ( INT_MAX / sizeof ( struct page * ) < num_agp_pages ) return NULL
<S2SV_ModStart> size_t i ; int cur_memory ; <S2SV_ModStart> return NULL ; cur_memory = <S2SV_ModEnd> atomic_read ( & <S2SV_ModStart> -> current_memory_agp ) ; if ( ( cur_memory + page_count <S2SV_ModEnd> > bridge -> <S2SV_ModStart> bridge -> max_memory_agp ) || ( cur_memory + page_count < page_count )
<S2SV_ModStart> page * ) ; if ( INT_MAX / sizeof ( struct page * ) < num_agp_pages ) return NULL
<S2SV_ModStart> raw_sock * ro ; if ( ! sk ) return 0 ; ro
<S2SV_ModStart> nsops < 1 || nsops > SEMOPM
<S2SV_ModStart> * file ) { if ( file -> private_data != NULL ) <S2SV_ModStart> = NULL ; }
<S2SV_ModStart> } if ( le32_to_cpu ( ( * gpt ) -> sizeof_partition_entry ) != sizeof ( gpt_entry ) ) { pr_debug ( "GUID<S2SV_blank>Partitition<S2SV_blank>Entry<S2SV_blank>Size<S2SV_blank>check<S2SV_blank>failed.\\n" ) ; goto fail ; } if (
<S2SV_ModStart> path path ; uid_t check_ruid ; <S2SV_ModStart> sbi , raw_data , & check_ruid <S2SV_ModStart> out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }
<S2SV_ModStart> char * options , uid_t * check_ruid <S2SV_ModStart> * fn_cipher_key_bytes_src ; * check_ruid = 0 ; <S2SV_ModStart> break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case
<S2SV_ModStart> . fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) > num_entries ) || ( ( pg_start + mem -> page_count ) < pg_start )
<S2SV_ModStart> ; int mask_type , num_entries <S2SV_ModStart> mem -> type ) return - EINVAL ; num_entries = agp_num_entries ( ) ; if ( ( ( pg_start + mem -> page_count ) > num_entries ) || ( ( pg_start + mem -> page_count ) < pg_start )
<S2SV_ModStart> : if ( rec >= f -> num ) { ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , f -> num ) ; return false ; } if (
<S2SV_ModStart> ; new -> user_ns = new -> user -> user_ns ; new ->
<S2SV_ModStart> net ) ; if ( & ops -> list == first_device ) { LIST_HEAD ( dev_kill_list ) ; rtnl_lock ( ) ; unregister_netdevices ( net , & dev_kill_list ) ; unregister_netdevice_many ( & dev_kill_list ) ; rtnl_unlock ( ) ; }
<S2SV_ModStart> ops ) { int error ; <S2SV_ModStart> ( ops -> id ) { again : error = ida_get_new_above ( & net_generic_ids , 1 , ops -> id ) ; if ( error < 0 ) { if ( error == - EAGAIN ) { ida_pre_get ( & net_generic_ids , GFP_KERNEL ) ; goto again ; } return error ; } } error = __register_pernet_operations ( list , ops ) ; if ( error && ops -> id ) ida_remove ( & net_generic_ids , * ops -> id ) ; return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> net ) { const <S2SV_ModStart> pernet_operations * ops , * saved_ops <S2SV_ModStart> list ) { error = ops_init ( ops , <S2SV_ModEnd> net ) ; <S2SV_ModStart> out_undo ; } <S2SV_ModEnd> out : return <S2SV_ModStart> ; out_undo : saved_ops = ops ; <S2SV_ModStart> ; } } ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free ( ops , net ) ;
<S2SV_ModStart> ops ) { __unregister_pernet_operations ( ops ) ; <S2SV_ModStart> ( ops -> id ) ida_remove ( & net_generic_ids , * ops -> id <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; if ( HFS_I ( tree -> inode ) -> alloc_blocks > HFS_I ( tree -> inode ) -> first_blocks ) { printk ( KERN_ERR "hfs:<S2SV_blank>invalid<S2SV_blank>btree<S2SV_blank>extent<S2SV_blank>records\\n" ) ; unlock_new_inode ( tree -> inode ) ; goto free_inode ; } <S2SV_ModStart> ) ) ; if ( ! HFS_I ( tree -> inode ) -> first_blocks ) { printk ( KERN_ERR "hfs:<S2SV_blank>invalid<S2SV_blank>btree<S2SV_blank>extent<S2SV_blank>records<S2SV_blank>" "(0<S2SV_blank>size).\\n" ) ; unlock_new_inode ( tree -> inode ) ; goto free_inode ; } <S2SV_ModStart> inode ) ; <S2SV_ModEnd> mapping = tree
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> ) { const void <S2SV_ModEnd> * bc = <S2SV_ModStart> 0 ) { const <S2SV_ModStart> * op = <S2SV_ModEnd> bc ; switch <S2SV_ModStart> case INET_DIAG_BC_D_LE : case INET_DIAG_BC_JMP : <S2SV_ModStart> ( op -> no <S2SV_ModEnd> < 4 || <S2SV_ModStart> || op -> no <S2SV_ModEnd> > len + <S2SV_ModStart> len + 4 || op -> no & 3 <S2SV_ModEnd> ) return - <S2SV_ModStart> case INET_DIAG_BC_NOP : break ; default : return - EINVAL ; } <S2SV_ModStart> len + 4 || op -> yes & 3 ) return - EINVAL ; <S2SV_ModEnd> bc += op
<S2SV_ModStart> yes < 4 || op -> yes & 3
<S2SV_ModStart> ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return
<S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk
<S2SV_ModStart> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;
<S2SV_ModStart> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> goto retry_rebind ; }
<S2SV_ModStart> ; task -> tk_rebind_retry = 2 ; task ->
<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> -> sk ; memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> ; if ( new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> VM_PFNMAP ) ) goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> ; } if
<S2SV_ModStart> ; if ( len < 0 ||
<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
<S2SV_ModStart> { if ( ! dev_name ||
<S2SV_ModStart> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED )
<S2SV_ModStart> ( old && ! tc_qdisc_dump_ignore ( old ) <S2SV_ModEnd> ) { if <S2SV_ModStart> if ( new && ! tc_qdisc_dump_ignore ( new )
<S2SV_ModStart> error ; loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ; loff_t <S2SV_ModStart> EOPNOTSUPP ; offset &= bsize_mask <S2SV_ModEnd> ; len = <S2SV_ModStart> bytes = UINT_MAX ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize <S2SV_ModStart> bytes >>= 1 ; bytes &= bsize_mask ; if ( bytes == 0 ) bytes = sdp -> sd_sb . sb_bsize
<S2SV_ModStart> ( b2 == EXT_MAX_BLOCKS <S2SV_ModEnd> ) goto out <S2SV_ModStart> { len1 = EXT_MAX_BLOCKS <S2SV_ModEnd> - b1 ;
<S2SV_ModStart> && next != EXT_MAX_BLOCKS <S2SV_ModEnd> ) { ext_debug
<S2SV_ModStart> NULL ) return EXT_MAX_BLOCKS <S2SV_ModEnd> ; while ( <S2SV_ModStart> ; } return EXT_MAX_BLOCKS <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 0 ) return EXT_MAX_BLOCKS <S2SV_ModEnd> ; depth -- <S2SV_ModStart> ; } return EXT_MAX_BLOCKS <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; len = EXT_MAX_BLOCKS <S2SV_ModEnd> ; ext_debug (
<S2SV_ModStart> ( end == EXT_MAX_BLOCKS - 1 <S2SV_ModEnd> ) { ext_debug <S2SV_ModStart> ( end == EXT_MAX_BLOCKS - 1 <S2SV_ModEnd> ) { ext_debug <S2SV_ModStart> ( end != EXT_MAX_BLOCKS - 1 <S2SV_ModEnd> ) { memmove
<S2SV_ModStart> , last_block , EXT_MAX_BLOCKS - 1 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> && block != EXT_MAX_BLOCKS <S2SV_ModEnd> ) { num
<S2SV_ModStart> ( last_blk >= EXT_MAX_BLOCKS <S2SV_ModEnd> ) last_blk = <S2SV_ModStart> ) last_blk = EXT_MAX_BLOCKS <S2SV_ModEnd> - 1 ;
<S2SV_ModStart> ( ( orig_start >= EXT_MAX_BLOCKS ) || ( donor_start >= EXT_MAX_BLOCKS ) || ( * len > EXT_MAX_BLOCKS <S2SV_ModEnd> ) || ( <S2SV_ModStart> ) || ( <S2SV_ModEnd> orig_start + * <S2SV_ModStart> + * len >= EXT_MAX_BLOCKS <S2SV_ModEnd> ) ) { <S2SV_ModStart> "ext4<S2SV_blank>move<S2SV_blank>extent:<S2SV_blank>Can\'t<S2SV_blank>handle<S2SV_blank>over<S2SV_blank>[%u]<S2SV_blank>blocks<S2SV_blank>" "[ino:orig<S2SV_blank>%lu,<S2SV_blank>donor<S2SV_blank>%lu]\\n" , EXT_MAX_BLOCKS <S2SV_ModEnd> , orig_inode ->
<S2SV_ModStart> } res = ( <S2SV_ModStart> 1LL << 32 ) - 1 <S2SV_ModStart> res <<= blkbits <S2SV_ModEnd> ; if (
<S2SV_ModStart> mtu , flags , rt
<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )
<S2SV_ModStart> if ( len < 0 || len <S2SV_ModStart> if ( len < 0 || len
<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
<S2SV_ModStart> 0 ; } aux . tp_padding = 0 ;
<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found
<S2SV_ModStart> out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
<S2SV_ModStart> -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . <S2SV_ModStart> COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo .
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , int throttle <S2SV_ModStart> = POLL_HUP ; <S2SV_ModEnd> event -> pending_disable <S2SV_ModStart> ) ; } if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ; else <S2SV_ModEnd> perf_event_output ( event <S2SV_ModStart> perf_event_output ( event <S2SV_ModEnd> , data , <S2SV_ModStart> pending_kill ) { <S2SV_ModEnd> event -> pending_wakeup <S2SV_ModStart> event -> pending <S2SV_ModEnd> ) ; }
<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct pt_regs * <S2SV_ModStart> , nr , <S2SV_ModEnd> & data ,
<S2SV_ModStart> , u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs
<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> . size , <S2SV_ModEnd> 1 ) )
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> ( event , <S2SV_ModEnd> 1 , data
<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> . size , <S2SV_ModEnd> 0 ) ;
<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct perf_sample_data * <S2SV_ModStart> , 1 , <S2SV_ModEnd> data , regs <S2SV_ModStart> , 0 , <S2SV_ModEnd> data , regs
<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> u64 overflow , <S2SV_ModEnd> struct perf_sample_data * <S2SV_ModStart> ( event , <S2SV_ModEnd> throttle , data
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample
<S2SV_ModStart> POLL_IN ) ; <S2SV_ModEnd> handle -> event <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> -> size ; if ( len == 0 ) { befs_error ( sb , "Long<S2SV_blank>symlink<S2SV_blank>with<S2SV_blank>illegal<S2SV_blank>length" ) ; link = ERR_PTR ( - EIO ) ; } else { <S2SV_ModStart> = '\\0' ; }
<S2SV_ModStart> <S2SV_null> static inline __u64 <S2SV_ModEnd> dccp_v6_init_sequence ( struct
<S2SV_ModStart> ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16
<S2SV_ModStart> current_issuer = NULL ; ctx -> current_crl = NULL ; ctx -> current_crl_score = 0 ; ctx -> current_reasons = 0
<S2SV_ModStart> ; ctx -> current_crl_score = 0 ; ctx ->
<S2SV_ModStart> current_issuer = NULL ; ctx -> current_crl = NULL ; ctx -> current_crl_score = 0 ; ctx -> current_reasons = 0
<S2SV_ModStart> ; ctx -> current_crl_score = 0 ; ctx ->
<S2SV_ModStart> current_issuer = NULL ; ctx -> current_crl = NULL ; ctx -> current_crl_score = 0 ; ctx -> current_reasons = 0
<S2SV_ModStart> ; ctx -> current_crl_score = 0 ; ctx ->
<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> u64 nsec ; u32 <S2SV_ModEnd> rem ; nsec <S2SV_ModStart> -> tv_sec - div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
<S2SV_ModStart> mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj <S2SV_ModStart> ; time_offset = div_s64 <S2SV_ModEnd> ( time_offset , <S2SV_ModStart> time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset
<S2SV_ModStart> == CPUCLOCK_SCHED ) * tp = ns_to_timespec <S2SV_ModEnd> ( cpu . <S2SV_ModStart> cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> struct timespec ts ; s32 rem <S2SV_ModStart> . tv_sec = div_s64_rem <S2SV_ModEnd> ( nsec , <S2SV_ModStart> NSEC_PER_SEC , & rem <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( rem <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> ts . tv_sec <S2SV_ModStart> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> ts . tv_nsec <S2SV_ModStart> ts . tv_nsec = rem <S2SV_ModEnd> ; return ts
<S2SV_ModStart> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> outarg . namelen <S2SV_ModStart> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )
<S2SV_ModStart> page * ipage ; get_node_info ( sbi , ino , & old_ni ) ; if ( unlikely ( old_ni . blk_addr != NULL_ADDR ) ) return - EINVAL <S2SV_ModStart> ino ) ; <S2SV_ModEnd> SetPageUptodate ( ipage
<S2SV_ModStart> ( ! rc <S2SV_ModEnd> && tcon )
<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = v ; if ( ! IS_ERR ( vma ) )
<S2SV_ModStart> ) { struct ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> ; struct ext4_extent <S2SV_ModStart> struct ext4_extent * ex <S2SV_ModEnd> ; ext4_lblk_t ee_block <S2SV_ModStart> , depth ; <S2SV_ModEnd> int err = <S2SV_ModStart> 0 ; int split_flag = 0 <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> inode ) ; ex <S2SV_ModEnd> = path [ <S2SV_ModStart> depth ] . <S2SV_ModEnd> p_ext ; ee_block <S2SV_ModStart> ee_block ) ; WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> ) { err <S2SV_ModStart> ( inode , ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> ext4_ext_dirty ( handle <S2SV_ModStart> depth ) ; goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> if ( allocated <S2SV_ModStart> <= EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> ee_len = cpu_to_le16 <S2SV_ModStart> = cpu_to_le16 ( allocated - map -> m_len <S2SV_ModEnd> ) ; ext4_ext_store_pblock <S2SV_ModStart> ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> err = ext4_ext_zeroout <S2SV_ModStart> inode , & zero_ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> allocated ; } <S2SV_ModStart> else if ( ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> ; err = <S2SV_ModStart> ( inode , & zero_ex ) ; if ( err ) <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; if ( allocated < 0 ) err = allocated <S2SV_ModEnd> ; out : <S2SV_ModStart> ; out : <S2SV_ModEnd> return err ? <S2SV_ModStart> err : allocated <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart> ext4_extent * ex <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ; unsigned int ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> ex ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> ( handle , <S2SV_ModStart> inode , path , map , split_flag <S2SV_ModEnd> , flags ) <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , "Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n" ) ; clear_buffer_zeronew ( bh_map ) ; } }
<S2SV_ModStart> int error ; unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> = offset >> <S2SV_ModStart> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> ( offset + <S2SV_ModStart> offset + len <S2SV_ModEnd> > inode -> <S2SV_ModStart> FALLOC_FL_KEEP_SIZE ) ) <S2SV_ModEnd> i_size_write ( inode <S2SV_ModStart> , offset + len ) ; <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> mark_inode_dirty ( inode <S2SV_ModEnd> ) ; out <S2SV_ModStart> ; out : brelse ( dibh ) ;
<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,
<S2SV_ModStart> = 0 ; unsigned char * mac = NULL ; <S2SV_ModStart> rr -> length >= <S2SV_ModEnd> mac_size ) { <S2SV_ModStart> mac_size ) { <S2SV_ModEnd> rr -> length <S2SV_ModStart> -= mac_size ; mac = & <S2SV_ModEnd> rr -> data <S2SV_ModStart> -> length ] ; } else rr -> length = 0 ; s -> method -> ssl3_enc -> mac ( s , md , 0 ) ; if ( mac == NULL || memcmp ( md , mac <S2SV_ModEnd> , mac_size )
<S2SV_ModStart> ref = NULL ; ASN1_OBJECT * subjectDomainPolicyRef <S2SV_ModStart> goto bad_mapping ; subjectDomainPolicyRef = map -> subjectDomainPolicy ; map -> subjectDomainPolicy = NULL ; <S2SV_ModStart> -> subjectDomainPolicy = subjectDomainPolicyRef <S2SV_ModEnd> ; ref ->
<S2SV_ModStart> map ) { <S2SV_ModEnd> OPENSSL_free ( map
<S2SV_ModStart> 1 ; case - 1 : return - 1 ; case
<S2SV_ModStart> = 0 ; unsigned char * mac = NULL ; <S2SV_ModStart> rr -> length >= <S2SV_ModEnd> mac_size ) { <S2SV_ModStart> mac_size ) { <S2SV_ModEnd> rr -> length <S2SV_ModStart> -= mac_size ; mac = & rr -> data [ rr -> length ] ; } else rr -> length = 0 ; <S2SV_ModStart> < 0 || mac == NULL || <S2SV_ModStart> ( md , mac <S2SV_ModEnd> , mac_size )
<S2SV_ModStart> = 0 ; unsigned char * mac = NULL ; <S2SV_ModStart> rr -> length >= <S2SV_ModEnd> mac_size ) { <S2SV_ModStart> mac_size ) { <S2SV_ModEnd> rr -> length <S2SV_ModStart> -= mac_size ; mac = & rr -> data [ rr -> length ] ; } else rr -> length = 0 ; <S2SV_ModStart> < 0 || mac == NULL || <S2SV_ModStart> ( md , mac <S2SV_ModEnd> , mac_size )
<S2SV_ModStart> # endif # if 1 <S2SV_ModEnd> { int sock
<S2SV_ModStart> = 0 ; unsigned char * mac = NULL ; <S2SV_ModStart> rr -> length >= <S2SV_ModEnd> mac_size ) { <S2SV_ModStart> mac_size ) { <S2SV_ModEnd> rr -> length <S2SV_ModStart> -= mac_size ; mac = & rr -> data [ rr -> length ] ; } else rr -> length = 0 ; <S2SV_ModStart> < 0 || mac == NULL || <S2SV_ModStart> ( md , mac <S2SV_ModEnd> , mac_size )
<S2SV_ModStart> = port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; random_ether_addr (
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;
<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( lc -> <S2SV_ModStart> ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
<S2SV_ModStart> [ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( "NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
<S2SV_ModStart> , rqstp , res <S2SV_ModEnd> ) ; out
<S2SV_ModStart> + op_decode_hdr_maxsz + <S2SV_ModEnd> 1 ; encode_getattr_two <S2SV_ModStart> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void _copy_from_pages (
<S2SV_ModStart> out ; } if ( be32_to_cpu ( sb -> s_first ) == 0 || be32_to_cpu ( sb -> s_first ) >= journal -> j_maxlen ) { printk ( KERN_WARNING "JBD2:<S2SV_blank>Invalid<S2SV_blank>start<S2SV_blank>block<S2SV_blank>of<S2SV_blank>journal:<S2SV_blank>%u\\n" , be32_to_cpu ( sb -> s_first ) ) ; goto out ; }
<S2SV_ModStart> * cred , fmode_t <S2SV_ModEnd> mode ) {
<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
<S2SV_ModStart> * path , fmode_t fmode , <S2SV_ModStart> -> d_inode , fmode <S2SV_ModEnd> ) ; status <S2SV_ModStart> path , sp , fmode
<S2SV_ModStart> * opendata ; fmode_t <S2SV_ModEnd> delegation_type = 0
<S2SV_ModStart> * state , fmode_t mode , int open_mode <S2SV_ModEnd> ) { int <S2SV_ModStart> = 0 ; if ( open_mode & O_EXCL ) goto out ; <S2SV_ModStart> FMODE_READ | FMODE_WRITE <S2SV_ModEnd> ) ) { <S2SV_ModStart> 0 ; } out :
<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) return 0
<S2SV_ModStart> dentry * res ; fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) <S2SV_ModStart> & path , fmode , <S2SV_ModStart> path , state , fmode
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> == 0 )
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = FMODE_READ ; <S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = FMODE_WRITE ;
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> path * path , fmode_t fmode <S2SV_ModStart> dir , path , fmode
<S2SV_ModStart> nfs4_state * state , fmode_t fmode <S2SV_ModStart> ; if ( fmode <S2SV_ModEnd> & FMODE_EXEC ) <S2SV_ModStart> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
<S2SV_ModStart> -> o_arg . fmode , data -> o_arg . open_flags <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> * opendata , fmode_t fmode <S2SV_ModEnd> , struct nfs4_state <S2SV_ModStart> . open_flags = 0 ; opendata -> o_arg . fmode = fmode <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , newstate , fmode <S2SV_ModEnd> ) ; *
<S2SV_ModStart> state -> owner , 0
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
<S2SV_ModStart> * state ; fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , & path , fmode <S2SV_ModStart> path , state , fmode <S2SV_ModStart> , state , fmode <S2SV_ModEnd> ) ; out_drop
<S2SV_ModStart> nfs4_state_owner * sp , fmode_t fmode <S2SV_ModStart> open_flags = flags ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModEnd> p -> o_arg
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; iput
<S2SV_ModStart> * cred ; fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , & path , fmode <S2SV_ModStart> path , state , fmode <S2SV_ModStart> , state , fmode <S2SV_ModEnd> ) ; out_putcred
<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
<S2SV_ModStart> . open_flags & O_EXCL ; fmode_t fmode = opendata -> o_arg . fmode <S2SV_ModEnd> ; nfs4_stateid stateid <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> ( delegation , fmode <S2SV_ModEnd> ) ) { <S2SV_ModStart> & stateid , fmode <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock
<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> ) { case
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( fmode <S2SV_ModEnd> ) { case <S2SV_ModStart> -> state | fmode <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> = 0 ; fmode <S2SV_ModEnd> &= ( FMODE_READ <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) goto no_delegation_unlock <S2SV_ModStart> -> stateid , fmode <S2SV_ModEnd> ) ; ret <S2SV_ModStart> , NULL , fmode <S2SV_ModEnd> ) ; ret
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> , int wait <S2SV_ModStart> = 0 ; fmode_t <S2SV_ModEnd> newstate ; atomic_inc <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 0 )
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 1 )
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> state == fmode <S2SV_ModEnd> ) return ; <S2SV_ModStart> if ( ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> { if ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> -> state = fmode <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; return
<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; RESERVE_SPACE
<S2SV_ModStart> * xdr , fmode_t fmode <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ <S2SV_ModStart> ; default : WRITE32 ( 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> npages ) ; nfs_writedata_free <S2SV_ModEnd> ( data )
<S2SV_ModStart> dreq ) ; nfs_readdata_free ( data <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 0 ) { nfs_readdata_free <S2SV_ModEnd> ( data ) <S2SV_ModStart> result ) ; nfs_readdata_free <S2SV_ModEnd> ( data ) <S2SV_ModStart> . context = ctx <S2SV_ModEnd> ; data ->
<S2SV_ModStart> 0 ) { nfs_writedata_free <S2SV_ModEnd> ( data ) <S2SV_ModStart> result ) ; nfs_writedata_free <S2SV_ModEnd> ( data ) <S2SV_ModStart> . context = ctx <S2SV_ModEnd> ; data ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void nfs_readdata_free (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> void nfs_readdata_release ( <S2SV_ModEnd> struct nfs_read_data * <S2SV_ModStart> nfs_read_data * rdata ) { <S2SV_ModEnd> put_nfs_open_context ( rdata
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void nfs_writedata_free (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> void nfs_writedata_release ( <S2SV_ModEnd> struct nfs_write_data * <S2SV_ModStart> nfs_write_data * wdata ) { <S2SV_ModEnd> put_nfs_open_context ( wdata
<S2SV_ModStart> if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +
<S2SV_ModStart> in -> len ; if ( srclen > HFS_NAMELEN ) srclen = HFS_NAMELEN
<S2SV_ModStart> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
<S2SV_ModStart> += i ; memset ( & rec -> input [ rec -> length ] , 0 , i ) ;
<S2SV_ModStart> += i ; memset ( & rec -> input [ rec -> length ] , 0 , i ) ;
<S2SV_ModStart> += i ; memset ( & rec -> input [ rec -> length ] , 0 , i ) ;
<S2SV_ModStart> += i ; memset ( & rec -> input [ rec -> length ] , 0 , i ) ;
<S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_a , a -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_a = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1 <S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_b , b -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_b = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1
<S2SV_ModStart> ADDR_RAW_BUF_LEN ] ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> ++ ) { if ( ! <S2SV_ModStart> , length ) ) return - 1 <S2SV_ModStart> return 0 ; if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> addr_expand ( unsigned <S2SV_ModStart> fill ) { if <S2SV_ModEnd> ( bs -> <S2SV_ModStart> bs -> length < 0 || <S2SV_ModEnd> bs -> length <S2SV_ModStart> bs -> length > length ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> length ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> extract_min_max ( IPAddressOrRange <S2SV_ModStart> length ) { if ( aor == NULL || min == NULL || max == NULL ) return 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> case IPAddressOrRange_addressPrefix : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) <S2SV_ModEnd> ; case IPAddressOrRange_addressRange <S2SV_ModStart> case IPAddressOrRange_addressRange : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 4 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; BIO_printf ( <S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 16 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; for (
<S2SV_ModStart> != IPAddressOrRange_addressRange ) || ! <S2SV_ModEnd> extract_min_max ( aor <S2SV_ModStart> , afi_length ) ) return 0
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0 <S2SV_ModStart> IPAddressOrRange_addressRange ) { if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_a , a -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_a = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1 <S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_b , b -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_b = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1
<S2SV_ModStart> ADDR_RAW_BUF_LEN ] ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> ++ ) { if ( ! <S2SV_ModStart> , length ) ) return - 1 <S2SV_ModStart> return 0 ; if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> addr_expand ( unsigned <S2SV_ModStart> fill ) { if <S2SV_ModEnd> ( bs -> <S2SV_ModStart> bs -> length < 0 || <S2SV_ModEnd> bs -> length <S2SV_ModStart> bs -> length > length ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> length ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> extract_min_max ( IPAddressOrRange <S2SV_ModStart> length ) { if ( aor == NULL || min == NULL || max == NULL ) return 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> case IPAddressOrRange_addressPrefix : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) <S2SV_ModEnd> ; case IPAddressOrRange_addressRange <S2SV_ModStart> case IPAddressOrRange_addressRange : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 4 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; BIO_printf ( <S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 16 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; for (
<S2SV_ModStart> != IPAddressOrRange_addressRange ) || ! <S2SV_ModEnd> extract_min_max ( aor <S2SV_ModStart> , afi_length ) ) return 0
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0 <S2SV_ModStart> IPAddressOrRange_addressRange ) { if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_a , a -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_a = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1 <S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_b , b -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_b = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1
<S2SV_ModStart> ADDR_RAW_BUF_LEN ] ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> ++ ) { if ( ! <S2SV_ModStart> , length ) ) return - 1 <S2SV_ModStart> return 0 ; if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> addr_expand ( unsigned <S2SV_ModStart> fill ) { if <S2SV_ModEnd> ( bs -> <S2SV_ModStart> bs -> length < 0 || <S2SV_ModEnd> bs -> length <S2SV_ModStart> bs -> length > length ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> length ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> extract_min_max ( IPAddressOrRange <S2SV_ModStart> length ) { if ( aor == NULL || min == NULL || max == NULL ) return 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> case IPAddressOrRange_addressPrefix : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) <S2SV_ModEnd> ; case IPAddressOrRange_addressRange <S2SV_ModStart> case IPAddressOrRange_addressRange : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 4 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; BIO_printf ( <S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 16 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; for (
<S2SV_ModStart> != IPAddressOrRange_addressRange ) || ! <S2SV_ModEnd> extract_min_max ( aor <S2SV_ModStart> , afi_length ) ) return 0
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0 <S2SV_ModStart> IPAddressOrRange_addressRange ) { if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_a , a -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_a = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1 <S2SV_ModStart> case IPAddressOrRange_addressPrefix : if ( ! addr_expand ( addr_b , b -> u . addressPrefix , length , 0x00 ) ) return - 1 <S2SV_ModEnd> ; prefixlen_b = <S2SV_ModStart> case IPAddressOrRange_addressRange : if ( ! <S2SV_ModStart> , 0x00 ) ) return - 1
<S2SV_ModStart> ADDR_RAW_BUF_LEN ] ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> ++ ) { if ( ! <S2SV_ModStart> , length ) ) return - 1 <S2SV_ModStart> return 0 ; if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> addr_expand ( unsigned <S2SV_ModStart> fill ) { if <S2SV_ModEnd> ( bs -> <S2SV_ModStart> bs -> length < 0 || <S2SV_ModEnd> bs -> length <S2SV_ModStart> bs -> length > length ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> length ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> extract_min_max ( IPAddressOrRange <S2SV_ModStart> length ) { if ( aor == NULL || min == NULL || max == NULL ) return 0 <S2SV_ModEnd> ; switch ( <S2SV_ModStart> case IPAddressOrRange_addressPrefix : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) <S2SV_ModEnd> ; case IPAddressOrRange_addressRange <S2SV_ModStart> case IPAddressOrRange_addressRange : return ( <S2SV_ModStart> , 0x00 ) && <S2SV_ModEnd> addr_expand ( max <S2SV_ModStart> , 0xFF ) ) ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 4 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; BIO_printf ( <S2SV_ModStart> : if ( ! addr_expand ( addr , bs , 16 , fill ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ) return 0 <S2SV_ModEnd> ; for (
<S2SV_ModStart> != IPAddressOrRange_addressRange ) || ! <S2SV_ModEnd> extract_min_max ( aor <S2SV_ModStart> , afi_length ) ) return 0
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , length ) || ! <S2SV_ModEnd> extract_min_max ( b <S2SV_ModStart> , length ) ) return 0 <S2SV_ModStart> IPAddressOrRange_addressRange ) { if ( ! <S2SV_ModStart> , length ) ) return 0
<S2SV_ModStart> ( used_address && msg_sys -> msg_name && <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name , <S2SV_ModStart> -> msg_namelen ; if ( msg_sys -> msg_name ) <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name ,
<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
<S2SV_ModStart> long n ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_A , SSL3_ST_SR_CERT_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; s -> s3 -> tmp . reuse_message = 1 ; if ( s -> s3 -> tmp . message_type == SSL3_MT_CLIENT_HELLO ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_DH
<S2SV_ModStart> = 0 ; s -> s3 -> flags &= ~ SSL3_FLAGS_SGC_RESTART_DONE ;
<S2SV_ModStart> long n ; if ( s -> s3 -> flags & SSL3_FLAGS_SGC_RESTART_DONE ) { SSLerr ( SSL_F_SSL3_CHECK_CLIENT_HELLO , SSL_R_MULTIPLE_SGC_RESTARTS ) ; return - 1 ; } <S2SV_ModStart> } # endif s -> s3 -> flags |= SSL3_FLAGS_SGC_RESTART_DONE ;
<S2SV_ModStart> long n ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_A , SSL3_ST_SR_CERT_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; s -> s3 -> tmp . reuse_message = 1 ; if ( s -> s3 -> tmp . message_type == SSL3_MT_CLIENT_HELLO ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_DH
<S2SV_ModStart> long n ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_A , SSL3_ST_SR_CERT_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; s -> s3 -> tmp . reuse_message = 1 ; if ( s -> s3 -> tmp . message_type == SSL3_MT_CLIENT_HELLO ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_DH
<S2SV_ModStart> init_num = 0 ; s -> s3 -> flags &= ~ SSL3_FLAGS_SGC_RESTART_DONE
<S2SV_ModStart> long n ; if ( s -> s3 -> flags & SSL3_FLAGS_SGC_RESTART_DONE ) { SSLerr ( SSL_F_SSL3_CHECK_CLIENT_HELLO , SSL_R_MULTIPLE_SGC_RESTARTS ) ; return - 1 ; } <S2SV_ModStart> } # endif s -> s3 -> flags |= SSL3_FLAGS_SGC_RESTART_DONE ;
<S2SV_ModStart> long n ; n = s -> method -> ssl_get_message ( s , SSL3_ST_SR_CERT_A , SSL3_ST_SR_CERT_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; s -> s3 -> tmp . reuse_message = 1 ; if ( s -> s3 -> tmp . message_type == SSL3_MT_CLIENT_HELLO ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_DH
<S2SV_ModStart> init_num = 0 ; s -> s3 -> flags &= ~ SSL3_FLAGS_SGC_RESTART_DONE
<S2SV_ModStart> long n ; if ( s -> s3 -> flags & SSL3_FLAGS_SGC_RESTART_DONE ) { SSLerr ( SSL_F_SSL3_CHECK_CLIENT_HELLO , SSL_R_MULTIPLE_SGC_RESTARTS ) ; return - 1 ; } <S2SV_ModStart> } # endif s -> s3 -> flags |= SSL3_FLAGS_SGC_RESTART_DONE ;
<S2SV_ModStart> init_num = 0 ; s -> s3 -> flags &= ~ SSL3_FLAGS_SGC_RESTART_DONE
<S2SV_ModStart> long n ; if ( s -> s3 -> flags & SSL3_FLAGS_SGC_RESTART_DONE ) { SSLerr ( SSL_F_SSL3_CHECK_CLIENT_HELLO , SSL_R_MULTIPLE_SGC_RESTARTS ) ; return - 1 ; } <S2SV_ModStart> } # endif s -> s3 -> flags |= SSL3_FLAGS_SGC_RESTART_DONE ;
<S2SV_ModStart> } if ( rq -> curr -> se . on_rq &&
<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
<S2SV_ModStart> * rq ) <S2SV_ModEnd> { int cpu <S2SV_ModStart> ; u64 irq_time ; if ( rq -> skip_clock_update ) return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( l < 10 || l > 20 ) return - 1 ; if (
<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;
<S2SV_ModStart> & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> AX25_ADDR_LEN ) ; }
<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> & facilities )
<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o
<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( len < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ;
<S2SV_ModStart> char * p , unsigned packet_len <S2SV_ModStart> facilities_len == 0 || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> while ( facilities_len >= 3 && <S2SV_ModEnd> * p == <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> 1 ) ; break ; default : printk ( KERN_DEBUG "ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> len < 0 ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> + 1 ; } return facilities_len == 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> : if ( len < 3 ) return - 1 ; if ( <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_CALL ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_ADD ) { if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_DIGIS ) { if ( l % AX25_ADDR_LEN ) return - 1 ;
<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> cipher ) ; if ( ! param ) { goto err ; }
<S2SV_ModStart> group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart> ( unlikely ( <S2SV_ModEnd> ! list_empty (
<S2SV_ModStart> -> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
<S2SV_ModStart> * ace ; unsigned
<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
<S2SV_ModStart> ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
<S2SV_ModStart> file ) { struct task_struct * task = get_proc_task ( file -> f_path . dentry -> d_inode ) ; struct mm_struct * mm ; if ( ! task ) return - ESRCH ; mm = mm_access ( task , PTRACE_MODE_ATTACH ) ; put_task_struct ( task ) ; if ( IS_ERR ( mm ) ) return PTR_ERR ( mm <S2SV_ModEnd> ) ; file <S2SV_ModStart> |= FMODE_UNSIGNED_OFFSET ; file -> private_data = mm ;
<S2SV_ModStart> ppos ) { int ret <S2SV_ModEnd> ; char * <S2SV_ModStart> * ppos ; <S2SV_ModEnd> struct mm_struct * <S2SV_ModStart> mm_struct * mm = <S2SV_ModEnd> file -> private_data <S2SV_ModStart> file -> private_data ; if ( ! mm ) return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> = src ; <S2SV_ModEnd> free_page ( ( <S2SV_ModStart> page ) ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> * page ; <S2SV_ModEnd> unsigned long dst <S2SV_ModStart> mm_struct * mm = <S2SV_ModEnd> file -> private_data <S2SV_ModStart> file -> private_data ; if ( ! mm ) return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM <S2SV_ModEnd> ; copied = <S2SV_ModStart> = dst ; <S2SV_ModEnd> free_page ( ( <S2SV_ModStart> page ) ; <S2SV_ModEnd> return copied ;
<S2SV_ModStart> task ) { return mm_access <S2SV_ModEnd> ( task , <S2SV_ModStart> , PTRACE_MODE_READ ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ioc ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) exit_io_context ( tsk
<S2SV_ModStart> ; bad_fork_cleanup_io : if <S2SV_ModEnd> ( p -> <S2SV_ModStart> p -> io_context ) exit_io_context ( p
<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { }
<S2SV_ModStart> = NULL ; unsigned char * tkey = NULL ; size_t tkeylen ; <S2SV_ModStart> } if ( ! enc || <S2SV_ModEnd> ! ec -> <S2SV_ModStart> key ) { tkeylen = EVP_CIPHER_CTX_key_length ( ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; <S2SV_ModStart> if ( ! tkey ) { CMSerr ( CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( EVP_CIPHER_CTX_rand_key ( ctx , tkey ) <= 0 ) goto err ; } if ( ! ec -> key ) { ec -> key = tkey ; <S2SV_ModStart> ec -> keylen = tkeylen ; tkey = NULL ; if ( enc ) <S2SV_ModEnd> keep_key = 1 <S2SV_ModStart> = 1 ; else ERR_clear_error ( ) ; } <S2SV_ModEnd> if ( ec <S2SV_ModStart> -> keylen != tkeylen <S2SV_ModEnd> ) { if <S2SV_ModStart> 0 ) { if ( ec -> debug ) { <S2SV_ModStart> goto err ; } else { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; ec -> key = tkey ; ec -> keylen = tkeylen ; tkey = NULL ; ERR_clear_error ( ) ; } <S2SV_ModStart> } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey ) ; } if (
<S2SV_ModStart> ; if ( flags & CMS_DEBUG_DECRYPT ) cms -> d . envelopedData -> encryptedContentInfo -> debug = 1 ; else cms -> d . envelopedData -> encryptedContentInfo -> debug = 0 ; if ( ! pk && ! cert && ! dcont && ! out ) return 1 ; if (
<S2SV_ModStart> , r ; int debug = 0 ; <S2SV_ModStart> ( cms ) ; if ( ris ) debug = cms -> d . envelopedData -> encryptedContentInfo -> debug <S2SV_ModStart> ; if ( cert ) { if ( ! debug ) { ERR_clear_error ( ) ; return 1 ; } if ( <S2SV_ModStart> return 1 ; <S2SV_ModEnd> CMSerr ( CMS_F_CMS_DECRYPT_SET1_PKEY <S2SV_ModStart> 0 ; } else if ( r > 0 && debug ) return 1 ; } } if ( ! cert && ! debug ) { <S2SV_ModStart> ( ) ; return 1 ; <S2SV_ModEnd> } CMSerr (
<S2SV_ModStart> ek = NULL , * tkey = NULL <S2SV_ModStart> ; int eklen , tkeylen <S2SV_ModStart> , pkey ) < 0 ) goto err <S2SV_ModEnd> ; ERR_clear_error ( <S2SV_ModStart> ERR_clear_error ( ) <S2SV_ModEnd> ; } } <S2SV_ModStart> , pkey ) < 0 ) goto err ; ERR_clear_error ( ) <S2SV_ModEnd> ; } evp_ctx <S2SV_ModStart> goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } <S2SV_ModStart> ) ) { OPENSSL_cleanse ( ek , eklen ) ; OPENSSL_free ( ek ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; <S2SV_ModEnd> if ( EVP_CipherInit_ex <S2SV_ModStart> OPENSSL_free ( ek ) ; } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey
<S2SV_ModStart> int ret = - 1 ; pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; if ( ! pctx ) return - 1 ; if ( EVP_PKEY_decrypt_init ( pctx ) <= 0 ) goto err ; if ( EVP_PKEY_CTX_ctrl ( pctx , - 1 <S2SV_ModEnd> , EVP_PKEY_OP_DECRYPT , <S2SV_ModStart> 0 ) { ret = 0 ; <S2SV_ModStart> = 1 ; if ( * pek ) { OPENSSL_cleanse ( * pek , * peklen ) ; OPENSSL_free ( * pek ) ; } * pek = ek ; * peklen <S2SV_ModEnd> = eklen ;
<S2SV_ModStart> = NULL ; unsigned char * tkey = NULL ; size_t tkeylen ; <S2SV_ModStart> } if ( ! enc || <S2SV_ModEnd> ! ec -> <S2SV_ModStart> key ) { tkeylen = EVP_CIPHER_CTX_key_length ( ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; <S2SV_ModStart> if ( ! tkey ) { CMSerr ( CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( EVP_CIPHER_CTX_rand_key ( ctx , tkey ) <= 0 ) goto err ; } if ( ! ec -> key ) { ec -> key = tkey ; <S2SV_ModStart> ec -> keylen = tkeylen ; tkey = NULL ; if ( enc ) <S2SV_ModEnd> keep_key = 1 <S2SV_ModStart> = 1 ; else ERR_clear_error ( ) ; } <S2SV_ModEnd> if ( ec <S2SV_ModStart> -> keylen != tkeylen <S2SV_ModEnd> ) { if <S2SV_ModStart> 0 ) { if ( ec -> debug ) { <S2SV_ModStart> goto err ; } else { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; ec -> key = tkey ; ec -> keylen = tkeylen ; tkey = NULL ; ERR_clear_error ( ) ; } <S2SV_ModStart> } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey ) ; } if (
<S2SV_ModStart> = 0 ; CMS_EncryptedContentInfo * ec ; ec = cms -> d . envelopedData -> encryptedContentInfo ; <S2SV_ModStart> = 1 ; if ( ec -> key ) { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; } ec -> key = ek ; ec <S2SV_ModEnd> -> keylen =
<S2SV_ModStart> ; if ( flags & CMS_DEBUG_DECRYPT ) cms -> d . envelopedData -> encryptedContentInfo -> debug = 1 ; else cms -> d . envelopedData -> encryptedContentInfo -> debug = 0 ; if ( ! pk && ! cert && ! dcont && ! out ) return 1 ; if (
<S2SV_ModStart> , r ; int debug = 0 ; <S2SV_ModStart> ( cms ) ; if ( ris ) debug = cms -> d . envelopedData -> encryptedContentInfo -> debug <S2SV_ModStart> ; if ( cert ) { if ( ! debug ) { ERR_clear_error ( ) ; return 1 ; } if ( <S2SV_ModStart> return 1 ; <S2SV_ModEnd> CMSerr ( CMS_F_CMS_DECRYPT_SET1_PKEY <S2SV_ModStart> 0 ; } else if ( r > 0 && debug ) return 1 ; } } if ( ! cert && ! debug ) { <S2SV_ModStart> ( ) ; return 1 ; <S2SV_ModEnd> } CMSerr (
<S2SV_ModStart> ; # endif unsigned char * tkey = NULL ; int tkeylen ; <S2SV_ModStart> NULL ) { unsigned char * tmp2 ; tmp2 = OPENSSL_malloc ( jj ) ; if ( ! tmp2 ) goto err ; jj = - 1 ; <S2SV_ModStart> ++ ) { int tret ; <S2SV_ModStart> i ) ; tret = EVP_PKEY_decrypt ( tmp2 , M_ASN1_STRING_data ( ri -> enc_key ) , M_ASN1_STRING_length ( ri -> enc_key ) , pkey ) ; if ( tret > 0 ) { memcpy ( tmp , tmp2 , tret ) ; OPENSSL_cleanse ( tmp2 , tret ) ; jj = tret ; } ERR_clear_error ( ) ; } OPENSSL_free ( tmp2 ) ; } else { jj = <S2SV_ModEnd> EVP_PKEY_decrypt ( tmp <S2SV_ModStart> pkey ) ; <S2SV_ModEnd> ERR_clear_error ( ) <S2SV_ModStart> ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) <S2SV_ModEnd> goto err ; <S2SV_ModStart> goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ) { OPENSSL_free ( tmp ) ; jj = tkeylen ; tmp = tkey ; tkey = NULL ; } <S2SV_ModEnd> if ( jj <S2SV_ModStart> ( jj != tkeylen <S2SV_ModEnd> ) { if <S2SV_ModStart> ) ) { OPENSSL_cleanse ( tmp , jj ) ; OPENSSL_free ( tmp ) ; jj = tkeylen ; tmp = tkey ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , tmp , NULL , 0 ) <= 0 ) <S2SV_ModEnd> goto err ; <S2SV_ModStart> goto err ; OPENSSL_cleanse ( tmp , jj ) ; if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey ) ; } <S2SV_ModEnd> if ( out
<S2SV_ModStart> = NULL ; unsigned char * tkey = NULL ; size_t tkeylen ; <S2SV_ModStart> } if ( ! enc || <S2SV_ModEnd> ! ec -> <S2SV_ModStart> key ) { tkeylen = EVP_CIPHER_CTX_key_length ( ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; <S2SV_ModStart> if ( ! tkey ) { CMSerr ( CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( EVP_CIPHER_CTX_rand_key ( ctx , tkey ) <= 0 ) goto err ; } if ( ! ec -> key ) { ec -> key = tkey ; <S2SV_ModStart> ec -> keylen = tkeylen ; tkey = NULL ; if ( enc ) <S2SV_ModEnd> keep_key = 1 <S2SV_ModStart> = 1 ; else ERR_clear_error ( ) ; } <S2SV_ModEnd> if ( ec <S2SV_ModStart> -> keylen != tkeylen <S2SV_ModEnd> ) { if <S2SV_ModStart> 0 ) { if ( ec -> debug ) { <S2SV_ModStart> goto err ; } else { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; ec -> key = tkey ; ec -> keylen = tkeylen ; tkey = NULL ; ERR_clear_error ( ) ; } <S2SV_ModStart> } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey ) ; } if (
<S2SV_ModStart> = 0 ; CMS_EncryptedContentInfo * ec ; ec = <S2SV_ModEnd> cms -> d <S2SV_ModStart> envelopedData -> encryptedContentInfo ; if ( ktri -> pkey == NULL ) { CMSerr ( CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT , CMS_R_NO_PRIVATE_KEY ) ; return 0 ; } pctx = EVP_PKEY_CTX_new ( ktri -> pkey , NULL ) ; if ( ! pctx ) return 0 ; if ( EVP_PKEY_decrypt_init ( pctx ) <= 0 ) goto err ; if ( EVP_PKEY_CTX_ctrl ( pctx , - 1 , EVP_PKEY_OP_DECRYPT , EVP_PKEY_CTRL_CMS_DECRYPT , 0 , ri ) <= 0 ) { CMSerr ( CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT , CMS_R_CTRL_ERROR ) ; goto err ; } if ( EVP_PKEY_decrypt ( pctx , NULL , & eklen , ktri -> encryptedKey -> data , ktri -> encryptedKey -> length ) <= 0 ) goto err ; ek = OPENSSL_malloc ( eklen ) ; if ( ek == NULL ) { CMSerr ( CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( EVP_PKEY_decrypt ( pctx , ek , & eklen , ktri -> encryptedKey -> data , ktri -> encryptedKey -> length ) <= 0 ) { CMSerr ( CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT , CMS_R_CMS_LIB ) ; goto err ; } ret = 1 ; if ( ec -> key ) { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; } ec -> key = ek ; ec <S2SV_ModEnd> -> keylen =
<S2SV_ModStart> ; if ( flags & CMS_DEBUG_DECRYPT ) cms -> d . envelopedData -> encryptedContentInfo -> debug = 1 ; else cms -> d . envelopedData -> encryptedContentInfo -> debug = 0 ; if ( ! pk && ! cert && ! dcont && ! out ) return 1 ; if (
<S2SV_ModStart> , r ; int debug = 0 ; <S2SV_ModStart> ( cms ) ; if ( ris ) debug = cms -> d . envelopedData -> encryptedContentInfo -> debug <S2SV_ModStart> ; if ( cert ) { if ( ! debug ) { ERR_clear_error ( ) ; return 1 ; } if ( <S2SV_ModStart> return 1 ; <S2SV_ModEnd> CMSerr ( CMS_F_CMS_DECRYPT_SET1_PKEY <S2SV_ModStart> 0 ; } else if ( r > 0 && debug ) return 1 ; } } if ( ! cert && ! debug ) { <S2SV_ModStart> ( ) ; return 1 ; <S2SV_ModEnd> } CMSerr (
<S2SV_ModStart> ek = NULL , * tkey = NULL <S2SV_ModStart> ; int eklen , tkeylen <S2SV_ModStart> , pkey ) < 0 ) goto err <S2SV_ModEnd> ; ERR_clear_error ( <S2SV_ModStart> ERR_clear_error ( ) <S2SV_ModEnd> ; } } <S2SV_ModStart> , pkey ) < 0 ) goto err ; ERR_clear_error ( ) <S2SV_ModEnd> ; } evp_ctx <S2SV_ModStart> goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } <S2SV_ModStart> ) ) { OPENSSL_cleanse ( ek , eklen ) ; OPENSSL_free ( ek ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; <S2SV_ModEnd> if ( EVP_CipherInit_ex <S2SV_ModStart> OPENSSL_free ( ek ) ; } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey
<S2SV_ModStart> int ret = - 1 ; pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; if ( ! pctx ) return - 1 ; if ( EVP_PKEY_decrypt_init ( pctx ) <= 0 ) goto err ; if ( EVP_PKEY_CTX_ctrl ( pctx , - 1 <S2SV_ModEnd> , EVP_PKEY_OP_DECRYPT , <S2SV_ModStart> 0 ) { ret = 0 ; <S2SV_ModStart> = 1 ; if ( * pek ) { OPENSSL_cleanse ( * pek , * peklen ) ; OPENSSL_free ( * pek ) ; } * pek = ek ; * peklen <S2SV_ModEnd> = eklen ;
<S2SV_ModStart> = NULL ; unsigned char * tkey = NULL ; size_t tkeylen ; <S2SV_ModStart> } if ( ! enc || <S2SV_ModEnd> ! ec -> <S2SV_ModStart> key ) { tkeylen = EVP_CIPHER_CTX_key_length ( ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; <S2SV_ModStart> if ( ! tkey ) { CMSerr ( CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO , ERR_R_MALLOC_FAILURE ) ; goto err ; } if ( EVP_CIPHER_CTX_rand_key ( ctx , tkey ) <= 0 ) goto err ; } if ( ! ec -> key ) { ec -> key = tkey ; <S2SV_ModStart> ec -> keylen = tkeylen ; tkey = NULL ; if ( enc ) <S2SV_ModEnd> keep_key = 1 <S2SV_ModStart> = 1 ; else ERR_clear_error ( ) ; } <S2SV_ModEnd> if ( ec <S2SV_ModStart> -> keylen != tkeylen <S2SV_ModEnd> ) { if <S2SV_ModStart> 0 ) { if ( ec -> debug ) { <S2SV_ModStart> goto err ; } else { OPENSSL_cleanse ( ec -> key , ec -> keylen ) ; OPENSSL_free ( ec -> key ) ; ec -> key = tkey ; ec -> keylen = tkeylen ; tkey = NULL ; ERR_clear_error ( ) ; } <S2SV_ModStart> } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey ) ; } if (
<S2SV_ModStart> ; if ( flags & CMS_DEBUG_DECRYPT ) cms -> d . envelopedData -> encryptedContentInfo -> debug = 1 ; else cms -> d . envelopedData -> encryptedContentInfo -> debug = 0 ; if ( ! pk && ! cert && ! dcont && ! out ) return 1 ; if (
<S2SV_ModStart> , r ; int debug = 0 ; <S2SV_ModStart> ( cms ) ; if ( ris ) debug = cms -> d . envelopedData -> encryptedContentInfo -> debug <S2SV_ModStart> ; if ( cert ) { if ( ! debug ) { ERR_clear_error ( ) ; return 1 ; } if ( <S2SV_ModStart> return 1 ; <S2SV_ModEnd> CMSerr ( CMS_F_CMS_DECRYPT_SET1_PKEY <S2SV_ModStart> 0 ; } else if ( r > 0 && debug ) return 1 ; } } if ( ! cert && ! debug ) { <S2SV_ModStart> ( ) ; return 1 ; <S2SV_ModEnd> } CMSerr (
<S2SV_ModStart> ek = NULL , * tkey = NULL <S2SV_ModStart> ; int eklen , tkeylen <S2SV_ModStart> , pkey ) < 0 ) goto err <S2SV_ModEnd> ; ERR_clear_error ( <S2SV_ModStart> ERR_clear_error ( ) <S2SV_ModEnd> ; } } <S2SV_ModStart> , pkey ) < 0 ) goto err ; ERR_clear_error ( ) <S2SV_ModEnd> ; } evp_ctx <S2SV_ModStart> goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } <S2SV_ModStart> ) ) { OPENSSL_cleanse ( ek , eklen ) ; OPENSSL_free ( ek ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; <S2SV_ModEnd> if ( EVP_CipherInit_ex <S2SV_ModStart> OPENSSL_free ( ek ) ; } if ( tkey ) { OPENSSL_cleanse ( tkey , tkeylen ) ; OPENSSL_free ( tkey
<S2SV_ModStart> int ret = - 1 ; pctx = EVP_PKEY_CTX_new ( pkey , NULL ) ; if ( ! pctx ) return - 1 ; if ( EVP_PKEY_decrypt_init ( pctx ) <= 0 ) goto err ; if ( EVP_PKEY_CTX_ctrl ( pctx , - 1 <S2SV_ModEnd> , EVP_PKEY_OP_DECRYPT , <S2SV_ModStart> 0 ) { ret = 0 ; <S2SV_ModStart> = 1 ; if ( * pek ) { OPENSSL_cleanse ( * pek , * peklen ) ; OPENSSL_free ( * pek ) ; } * pek = ek ; * peklen <S2SV_ModEnd> = eklen ;
<S2SV_ModStart> * release , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> UNAME26 ) { const <S2SV_ModStart> rest = UTS_RELEASE ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned v ; size_t copy <S2SV_ModStart> + 40 ; copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , copy <S2SV_ModEnd> , "2.6.%u%s" , <S2SV_ModStart> , buf , copy + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if ( ! regset -> set ) return - EOPNOTSUPP ; if ( !
<S2SV_ModStart> if ( ! regset -> get ) return - EOPNOTSUPP ; if ( !
<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
<S2SV_ModStart> int subdir_fd ; <S2SV_ModEnd> subdir_fd = openat <S2SV_ModStart> O_DIRECTORY | O_CLOEXEC | O_NOFOLLOW ) ; if ( subdir_fd <S2SV_ModEnd> < 0 )
<S2SV_ModStart> addr ) ) goto next <S2SV_ModEnd> ; } if <S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) <S2SV_ModStart> pmd ) ) goto next <S2SV_ModEnd> ; next = <S2SV_ModStart> details ) ; next :
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> int i ; down_write ( & mm -> mmap_sem ) ; <S2SV_ModStart> ; out : up_write ( & mm -> mmap_sem ) ;
<S2SV_ModStart> , spi ) > 0 ? : 0
<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
<S2SV_ModStart> int i ; <S2SV_ModEnd> ASN1_const_CTX c ; <S2SV_ModStart> ASN1_const_CTX c ; size_t <S2SV_ModEnd> want = HEADER_SIZE <S2SV_ModStart> = 0 ; size_t off = 0 ; size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len + want < len || <S2SV_ModStart> > 0 ) { if ( len + i < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> += i ; } <S2SV_ModStart> eos ++ ; if ( eos < 0 ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_HEADER_TOO_LONG ) ; goto err ; } <S2SV_ModStart> { want = <S2SV_ModEnd> c . slen <S2SV_ModStart> off ) ; if ( want > INT_MAX || len + want < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ; } } if ( off + c . slen < off ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } off += <S2SV_ModEnd> c . slen <S2SV_ModStart> ; } } if ( off > INT_MAX ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> num <= 0 ) return NULL ; if ( num < old_len
<S2SV_ModStart> int i ; <S2SV_ModEnd> ASN1_const_CTX c ; <S2SV_ModStart> ASN1_const_CTX c ; size_t <S2SV_ModEnd> want = HEADER_SIZE <S2SV_ModStart> = 0 ; size_t off = 0 ; size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len + want < len || <S2SV_ModStart> > 0 ) { if ( len + i < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> += i ; } <S2SV_ModStart> eos ++ ; if ( eos < 0 ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_HEADER_TOO_LONG ) ; goto err ; } <S2SV_ModStart> { want = <S2SV_ModEnd> c . slen <S2SV_ModStart> off ) ; if ( want > INT_MAX || len + want < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ; } } if ( off + c . slen < off ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } off += <S2SV_ModEnd> c . slen <S2SV_ModStart> ; } } if ( off > INT_MAX ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> num <= 0 ) return NULL ; if ( num < old_len
<S2SV_ModStart> int i ; <S2SV_ModEnd> ASN1_const_CTX c ; <S2SV_ModStart> ASN1_const_CTX c ; size_t <S2SV_ModEnd> want = HEADER_SIZE <S2SV_ModStart> = 0 ; size_t off = 0 ; size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len + want < len || <S2SV_ModStart> > 0 ) { if ( len + i < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> += i ; } <S2SV_ModStart> eos ++ ; if ( eos < 0 ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_HEADER_TOO_LONG ) ; goto err ; } <S2SV_ModStart> { want = <S2SV_ModEnd> c . slen <S2SV_ModStart> off ) ; if ( want > INT_MAX || len + want < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ; } } if ( off + c . slen < off ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } off += <S2SV_ModEnd> c . slen <S2SV_ModStart> ; } } if ( off > INT_MAX ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> num <= 0 ) return NULL ; if ( num < old_len
<S2SV_ModStart> int n ; if ( len < 0 ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0 ; }
<S2SV_ModStart> int n ; if ( len < 0 ) { BUFerr ( BUF_F_BUF_MEM_GROW_CLEAN , ERR_R_MALLOC_FAILURE ) ; return 0 ; }
<S2SV_ModStart> int i ; <S2SV_ModEnd> ASN1_const_CTX c ; <S2SV_ModStart> ASN1_const_CTX c ; size_t <S2SV_ModEnd> want = HEADER_SIZE <S2SV_ModStart> = 0 ; size_t off = 0 ; size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len + want < len || <S2SV_ModStart> > 0 ) { if ( len + i < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> += i ; } <S2SV_ModStart> eos ++ ; if ( eos < 0 ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_HEADER_TOO_LONG ) ; goto err ; } <S2SV_ModStart> { want = <S2SV_ModEnd> c . slen <S2SV_ModStart> off ) ; if ( want > INT_MAX || len + want < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ; } } if ( off + c . slen < off ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } off += <S2SV_ModEnd> c . slen <S2SV_ModStart> ; } } if ( off > INT_MAX ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> num <= 0 ) return NULL ; if ( num < old_len
<S2SV_ModStart> int i ; <S2SV_ModEnd> ASN1_const_CTX c ; <S2SV_ModStart> ASN1_const_CTX c ; size_t <S2SV_ModEnd> want = HEADER_SIZE <S2SV_ModStart> = 0 ; size_t off = 0 ; size_t <S2SV_ModEnd> len = 0 <S2SV_ModStart> ; if ( len + want < len || <S2SV_ModStart> > 0 ) { if ( len + i < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> += i ; } <S2SV_ModStart> eos ++ ; if ( eos < 0 ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_HEADER_TOO_LONG ) ; goto err ; } <S2SV_ModStart> { want = <S2SV_ModEnd> c . slen <S2SV_ModStart> off ) ; if ( want > INT_MAX || len + want < len ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ; } } if ( off + c . slen < off ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } off += <S2SV_ModEnd> c . slen <S2SV_ModStart> ; } } if ( off > INT_MAX ) { ASN1err ( ASN1_F_ASN1_D2I_READ_BIO , ASN1_R_TOO_LONG ) ; goto err ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> ( len ) ; } if ( len > LIMIT_BEFORE_EXPANSION ) { BUFerr ( BUF_F_BUF_MEM_GROW , ERR_R_MALLOC_FAILURE ) ; return 0
<S2SV_ModStart> num <= 0 ) return NULL ; if ( num < old_len
<S2SV_ModStart> ; int copylen = 0 <S2SV_ModStart> goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
<S2SV_ModStart> ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )
<S2SV_ModStart> inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )
<S2SV_ModStart> offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg
<S2SV_ModStart> reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve )
<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
<S2SV_ModStart> ; sbinfo -> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> config . nr_blocks <S2SV_ModStart> config . nr_blocks != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> config . nr_blocks <S2SV_ModStart> config . nr_blocks <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! sbinfo -> spool <S2SV_ModEnd> ) goto out_free <S2SV_ModStart> goto out_free ; } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> ; out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;
<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
<S2SV_ModStart> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->
<S2SV_ModStart> int err ; int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart> ) { int <S2SV_ModEnd> i ; if <S2SV_ModStart> data_len ) break <S2SV_ModEnd> ; skb ->
<S2SV_ModStart> || ue -> type == KVM_IRQ_ROUTING_MSI || ue ->
<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> if ( i + bs
<S2SV_ModStart> if ( i + bs
<S2SV_ModStart> if ( i + bs
<S2SV_ModStart> EVP_CIPH_CBC_MODE ) { if ( bs > ( int ) rec -> length ) return - 1 ;
<S2SV_ModStart> if ( i + bs
<S2SV_ModStart> EVP_CIPH_CBC_MODE ) { if ( bs > ( int ) rec -> length ) return - 1 ;
<S2SV_ModStart> if ( i + bs
<S2SV_ModStart> EVP_CIPH_CBC_MODE ) { if ( bs > ( int ) rec -> length ) return - 1 ;
<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
<S2SV_ModStart> DRM_DEBUG ( "clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( "execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n" , args -> num_cliprects
<S2SV_ModStart> < 0 ) { ret = chg ; goto out_err ; } <S2SV_ModEnd> if ( hugepage_subpool_get_pages <S2SV_ModStart> chg ) ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto out_err ; } <S2SV_ModStart> chg ) ; goto out_err <S2SV_ModEnd> ; } if <S2SV_ModStart> return 0 ; out_err : resv_map_put ( vma ) ; return ret ;
<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
<S2SV_ModStart> 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> ; len = recvfrom <S2SV_ModEnd> ( fd , <S2SV_ModStart> ) , 0 , addr_p , & addr_l <S2SV_ModStart> len < 0 || addr . nl_pid <S2SV_ModStart> ( LOG_ERR , "recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> ) ; close
<S2SV_ModStart> return 0 ; if ( has_explicit_iv ) { rec -> data += block_size ; rec -> input += block_size ; rec -> length -= block_size ; } <S2SV_ModStart> ; } } if ( EVP_CIPHER_flags ( s -> enc_read_ctx -> cipher ) & EVP_CIPH_FLAG_AEAD_CIPHER ) { rec -> length -= padding_length ; return 1 ; } <S2SV_ModStart> << 8 ; <S2SV_ModEnd> return ( int
<S2SV_ModStart> ; # if ! defined ( OPENSSL_NO_SHA ) && ! defined ( OPENSSL_NO_SHA1 ) EVP_add_cipher ( EVP_aes_128_cbc_hmac_sha1 ( ) ) ; EVP_add_cipher ( EVP_aes_256_cbc_hmac_sha1 ( ) ) ; # endif # endif # ifndef OPENSSL_NO_CAMELLIA EVP_add_cipher ( EVP_camellia_128_cbc ( ) ) ; EVP_add_cipher ( EVP_camellia_256_cbc ( ) ) ; # endif # ifndef OPENSSL_NO_SEED EVP_add_cipher ( EVP_seed_cbc ( ) ) ; # endif # ifndef OPENSSL_NO_MD5 EVP_add_digest ( EVP_md5 ( ) ) ; EVP_add_digest_alias ( SN_md5 , "ssl2-md5" ) ; EVP_add_digest_alias ( SN_md5 , "ssl3-md5" ) ; # endif # ifndef OPENSSL_NO_SHA EVP_add_digest ( EVP_sha1 ( ) ) ; EVP_add_digest_alias ( SN_sha1 , "ssl3-sha1" ) ; EVP_add_digest_alias ( SN_sha1WithRSAEncryption , SN_sha1WithRSA ) ; # endif # ifndef OPENSSL_NO_SHA256 EVP_add_digest ( EVP_sha224 ( ) ) ; EVP_add_digest ( EVP_sha256 ( ) ) ; # endif # ifndef OPENSSL_NO_SHA512 EVP_add_digest ( EVP_sha384 ( ) ) ; EVP_add_digest ( EVP_sha512 ( ) ) ; # endif <S2SV_ModEnd> # if ! <S2SV_ModStart> ! defined ( <S2SV_ModEnd> OPENSSL_NO_DSA ) EVP_add_digest
<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
<S2SV_ModStart> ; if ( fp &&
<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
<S2SV_ModStart> -> rats_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 20 ) <S2SV_ModStart> -> attrib_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 50 )
<S2SV_ModStart> -> nfcid1_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_NFCID1_MAXSIZE )
<S2SV_ModStart> -> sensb_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSB_RES_MAXSIZE )
<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , "error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>" "Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++
<S2SV_ModStart> = GSO_MAX_SIZE ; dev -> gso_max_segs = GSO_MAX_SEGS ;
<S2SV_ModStart> dev -> features ; if ( skb_shinfo ( skb ) -> gso_segs > skb -> dev -> gso_max_segs ) features &= ~ NETIF_F_GSO_MASK
<S2SV_ModStart> ( net_dev ) ; u32 txq_entries <S2SV_ModStart> -> rx_pending < EFX_RXQ_MIN_ENT <S2SV_ModEnd> ) { netif_err <S2SV_ModStart> -> net_dev , "RX<S2SV_blank>queues<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>%u\\n" , EFX_RXQ_MIN_ENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> EINVAL ; } txq_entries = max ( ring -> tx_pending , EFX_TXQ_MIN_ENT ( efx ) ) ; if ( txq_entries != ring -> tx_pending ) netif_warn ( efx , drv , efx -> net_dev , "increasing<S2SV_blank>TX<S2SV_blank>queue<S2SV_blank>size<S2SV_blank>to<S2SV_blank>minimum<S2SV_blank>of<S2SV_blank>%u\\n" , txq_entries ) ; <S2SV_ModStart> -> rx_pending , txq_entries <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;
<S2SV_ModStart> int error ; struct file * f ; <S2SV_ModStart> - EINVAL ; f = vma -> vm_file ; <S2SV_ModStart> if ( ! f || ! f <S2SV_ModEnd> -> f_mapping || <S2SV_ModStart> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> <S2SV_ModStart> PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | <S2SV_ModStart> end - start ) ; fput ( f
<S2SV_ModStart> siocb -> scm , true
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> scm_cookie * scm , bool forcecreds <S2SV_ModStart> ( * scm ) ) ; if ( forcecreds ) scm_set_cred ( scm , task_tgid ( current ) , current_cred (
<S2SV_ModStart> __be32 daddr ; struct ip_options_rcu * inet_opt ; <S2SV_ModStart> return 0 ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> ; rt =
<S2SV_ModStart> __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
<S2SV_ModStart> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> ) ; dst_release
<S2SV_ModStart> cipso_v4_delopt ( struct ip_options_rcu <S2SV_ModEnd> * * opt_ptr <S2SV_ModStart> 0 ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> = opt -> opt . <S2SV_ModStart> & opt -> opt . <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> srr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> rr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> ts -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> router_alert -= cipso_len <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> , opt -> opt . <S2SV_ModStart> < opt -> opt . optlen ) if ( opt -> opt . <S2SV_ModEnd> __data [ iter <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; opt -> opt . <S2SV_ModEnd> optlen = ( <S2SV_ModStart> -= opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> || opt -> opt .
<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
<S2SV_ModStart> hdr_delta ; struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> ; opt = rcu_dereference_protected ( sk_inet -> inet_opt , 1 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> & sk_inet -> inet_opt <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> * opt ; int res = - ENOMSG ; rcu_read_lock ( ) ; opt = rcu_dereference ( <S2SV_ModEnd> inet_sk ( sk <S2SV_ModStart> sk ) -> inet_opt ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( opt && opt -> opt . cipso ) res = <S2SV_ModEnd> cipso_v4_getattr ( opt <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> + opt -> opt . <S2SV_ModStart> secattr ) ; rcu_read_unlock ( ) ; return res ;
<S2SV_ModStart> opt_len ; struct ip_options_rcu * old , <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> sk ) ; old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( old <S2SV_ModEnd> ) sk_conn -> <S2SV_ModStart> -> icsk_ext_hdr_len -= old -> opt . <S2SV_ModEnd> optlen ; sk_conn <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ) ; } rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
<S2SV_ModStart> icmp_param -> replyopts . opt . opt <S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> icmp_param -> replyopts . opt ; if ( ipc . opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> icmp_param -> replyopts . opt . opt
<S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> param -> replyopts . opt . opt
<S2SV_ModStart> icmp_param . replyopts . opt . opt <S2SV_ModStart> icmp_param . replyopts . opt <S2SV_ModStart> . replyopts . opt . opt .
<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt .
<S2SV_ModStart> skb ) { const <S2SV_ModStart> == 0 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> sptr = skb_network_header
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * ip_options_get_alloc ( <S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + (
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> optp , struct ip_options_rcu <S2SV_ModEnd> * opt , <S2SV_ModStart> ) opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ( net , & opt ->
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
<S2SV_ModStart> daddr , struct ip_options_rcu <S2SV_ModEnd> * opt ) <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ( skb , & opt ->
<S2SV_ModStart> ) ; struct ip_options_rcu * inet_opt <S2SV_ModEnd> ; struct rtable <S2SV_ModStart> ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt <S2SV_ModStart> : if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> is_strictroute && rt <S2SV_ModStart> ) + ( inet_opt ? inet_opt -> opt . <S2SV_ModEnd> optlen : 0 <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> optlen ) { <S2SV_ModStart> -> ihl += inet_opt -> opt . <S2SV_ModEnd> optlen >> 2 <S2SV_ModStart> ( skb , & inet_opt ->
<S2SV_ModStart> ) ; struct ip_options_data <S2SV_ModEnd> replyopts ; struct <S2SV_ModStart> replyopts . opt . opt <S2SV_ModStart> . opt . opt . <S2SV_ModStart> ; if ( replyopts . opt . opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> daddr = replyopts . opt
<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> -> opt , & opt -> <S2SV_ModStart> + opt -> opt .
<S2SV_ModStart> ) optbuf ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> optlen ) ;
<S2SV_ModStart> : { struct ip_options_rcu * old , <S2SV_ModEnd> * opt = <S2SV_ModStart> err ) break ; old = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) <S2SV_ModStart> endif if ( old <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len -= old -> opt . <S2SV_ModEnd> optlen ; if <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> # endif } rcu_assign_pointer ( inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> != NULL && <S2SV_ModStart> != NULL && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> } if ( inet_opt <S2SV_ModEnd> == NULL || <S2SV_ModStart> NULL || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; dccp_set_state
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = ireq ->
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; struct rtable <S2SV_ModStart> NULL ) { struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
<S2SV_ModStart> int err ; struct ip_options_data opt_copy ; <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> if ( ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> if ( ! inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; tp
<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * tcp_v4_save_options ( <S2SV_ModStart> skb ) { const <S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * dopt = <S2SV_ModStart> int opt_size = sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> ; dopt = <S2SV_ModStart> ( ip_options_echo ( & dopt -> opt <S2SV_ModEnd> , skb )
<S2SV_ModStart> ; # endif struct ip_options_rcu * inet_opt ; <S2SV_ModStart> -> loc_addr ; inet_opt = ireq -> opt ; rcu_assign_pointer ( newinet -> inet_opt , inet_opt ) ; <S2SV_ModEnd> ireq -> opt <S2SV_ModStart> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( inet_opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; newinet
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
<S2SV_ModStart> sk_buff * skb ; struct ip_options_data opt_copy <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> saddr = ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
<S2SV_ModStart> 0 ) { struct completion * done = xchg ( & create -> done , NULL ) ; if ( ! done ) { kfree ( create ) ; return ; } <S2SV_ModStart> ; complete ( <S2SV_ModEnd> done ) ;
<S2SV_ModStart> data ; struct completion * done ; struct <S2SV_ModStart> . exited ; done = xchg ( & create -> done , NULL ) ; if ( ! done ) { kfree ( create ) ; do_exit ( - EINTR ) ; } __set_current_state ( TASK_UNINTERRUPTIBLE ) ; create -> result = current ; complete ( done ) ; schedule ( ) ; ret = - EINTR <S2SV_ModEnd> ; if (
<S2SV_ModStart> ... ) { DECLARE_COMPLETION_ONSTACK ( done ) ; struct task_struct * task ; struct kthread_create_info * create = kmalloc ( sizeof ( * create ) , GFP_KERNEL ) ; if ( ! create ) return ERR_PTR ( - ENOMEM ) ; create -> <S2SV_ModEnd> threadfn = threadfn <S2SV_ModStart> threadfn ; create -> data = data ; create -> <S2SV_ModEnd> node = node <S2SV_ModStart> = node ; create -> done = & done <S2SV_ModEnd> ; spin_lock ( <S2SV_ModStart> ( & create -> <S2SV_ModEnd> list , & <S2SV_ModStart> kthreadd_task ) ; if ( unlikely ( wait_for_completion_killable ( & done ) ) ) { if ( xchg ( & create -> done , NULL ) ) return ERR_PTR ( - ENOMEM ) ; <S2SV_ModStart> wait_for_completion ( & done ) ; } task = create -> result <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! IS_ERR ( task <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; vsnprintf ( task <S2SV_ModEnd> -> comm , <S2SV_ModStart> , sizeof ( task <S2SV_ModEnd> -> comm ) <S2SV_ModStart> ; sched_setscheduler_nocheck ( task <S2SV_ModEnd> , SCHED_NORMAL , <S2SV_ModStart> ; set_cpus_allowed_ptr ( task <S2SV_ModEnd> , cpu_all_mask ) <S2SV_ModStart> ) ; } kfree ( create ) ; return task <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
<S2SV_ModStart> kvm_cpuid_entry2 * best ; if ( ! static_cpu_has ( X86_FEATURE_XSAVE ) ) return 0
<S2SV_ModStart> struct desc_ptr dt ; if ( ! guest_cpuid_has_xsave ( vcpu ) && ( sregs -> cr4 & X86_CR4_OSXSAVE ) ) return - EINVAL
<S2SV_ModStart> inode , struct ext4_map_blocks * map , struct <S2SV_ModStart> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> err = ext4_ext_get_access
<S2SV_ModStart> , inode , map ,
<S2SV_ModStart> split_flag & EXT4_EXT_MAY_ZEROOUT <S2SV_ModEnd> ; flags1 = <S2SV_ModStart> | EXT4_EXT_MARK_UNINIT2 ; if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> err = 0 ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> ) ) { if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else
<S2SV_ModStart> |= EXT4_EXT_MARK_UNINIT2 ; if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;
<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file =
<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( interp , <S2SV_ModEnd> bprm ) ; <S2SV_ModStart> return retval ; file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ;
<S2SV_ModStart> ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;
<S2SV_ModStart> , } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> ( t , info . tcpv_rttcnt <S2SV_ModEnd> ) ; info <S2SV_ModStart> = t ; }
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , "Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u" , addr . nl_pid ) ; continue ; }
<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
<S2SV_ModStart> * up ; int klen , ulen ; <S2SV_ModStart> rta ) ; klen = <S2SV_ModEnd> xfrm_replay_state_esn_len ( up <S2SV_ModStart> ( up ) ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> ; pp = kzalloc ( klen <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ;
<S2SV_ModStart> * up ; int ulen ; <S2SV_ModStart> rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> xfrm_replay_state_esn_len ( replay_esn <S2SV_ModStart> replay_esn ) != ulen <S2SV_ModEnd> ) return -
<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
<S2SV_ModStart> dir ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> p ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> nla ) ; strncpy <S2SV_ModEnd> ( algo -> <S2SV_ModStart> auth -> alg_name , sizeof ( algo -> alg_name )
<S2SV_ModStart> ip_vs_timeout_user t ; memset ( & t , 0 , sizeof ( t ) ) ;
<S2SV_ModStart> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;
<S2SV_ModStart> int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> sizeof ( sllc <S2SV_ModEnd> ) ; if
<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
<S2SV_ModStart> ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
<S2SV_ModStart> -> sec_level ; sec . key_size = 0 ;
<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
<S2SV_ModStart> ) sockaddr ; memset ( addr , 0 , sizeof ( * addr ) ) ;
<S2SV_ModStart> - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;
<S2SV_ModStart> == 0x89 ) { <S2SV_ModStart> return - EFAULT ; } else memset ( & ifr , 0 , sizeof ( ifr ) )
<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
<S2SV_ModStart> -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
<S2SV_ModStart> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM
<S2SV_ModStart> ; if ( ( dst_group || dst_pid ) <S2SV_ModEnd> && ! netlink_capable
<S2SV_ModStart> ; ret = aio_setup_single_vector ( READ , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( READ <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( WRITE
<S2SV_ModStart> ssize_t aio_setup_single_vector ( int type , struct file * file , <S2SV_ModStart> kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> -> iov_len = bytes <S2SV_ModEnd> ; kiocb ->
<S2SV_ModStart> goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> void * buffer ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL
<S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> ; set_sndbuf : <S2SV_ModStart> |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> ; sk -> <S2SV_ModStart> case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> ; set_rcvbuf : <S2SV_ModStart> |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ld ) ; <S2SV_ModEnd> return i ;
<S2SV_ModStart> , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }
<S2SV_ModStart> signer ) ; if ( skey ) { <S2SV_ModStart> skey ) ; } if ( ! skey || <S2SV_ModEnd> ret <= 0
<S2SV_ModStart> , inl ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }
<S2SV_ModStart> signer ) ; if ( skey ) { <S2SV_ModStart> skey ) ; } if ( ! skey || <S2SV_ModEnd> ret <= 0
<S2SV_ModStart> , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }
<S2SV_ModStart> signer ) ; if ( skey ) { <S2SV_ModStart> skey ) ; } if ( ! skey || <S2SV_ModEnd> ret <= 0
<S2SV_ModStart> , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }
<S2SV_ModStart> signer ) ; if ( skey ) { <S2SV_ModStart> skey ) ; } if ( ! skey || <S2SV_ModEnd> ret <= 0
<S2SV_ModStart> , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; }
<S2SV_ModStart> signer ) ; if ( skey ) { <S2SV_ModStart> skey ) ; } if ( ! skey || <S2SV_ModEnd> ret <= 0
<S2SV_ModStart> vif ) { <S2SV_ModEnd> if ( netif_carrier_ok <S2SV_ModStart> ( netif_carrier_ok ( vif -> <S2SV_ModEnd> dev ) ) <S2SV_ModStart> dev ) ) xenvif_carrier_off <S2SV_ModEnd> ( vif ) <S2SV_ModStart> vif ) ; <S2SV_ModEnd> atomic_dec ( &
<S2SV_ModStart> work_to_do ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Need<S2SV_blank>more<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Too<S2SV_blank>many<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> size ) { netdev_err ( vif -> dev , "Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> txp -> size ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Missing<S2SV_blank>extra<S2SV_blank>info\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , "Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>" "req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> } ret = <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> idx += ret <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue <S2SV_ModStart> skb ) ; <S2SV_ModEnd> continue ; }
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> , u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index
<S2SV_ModStart> ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo <S2SV_ModStart> err ) ) xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( <S2SV_ModStart> , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> continue ; } xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
<S2SV_ModStart> skb -> len && skb -> len
<S2SV_ModStart> ) { return <S2SV_ModEnd> pmd_flags ( pte <S2SV_ModStart> pte ) & _PAGE_PSE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> pmd ) & ( _PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> : if ( skb == NULL ||
<S2SV_ModStart> u64 ) len - s
<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }
<S2SV_ModStart> -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf
<S2SV_ModStart> ; if ( <S2SV_ModEnd> child -> ptrace <S2SV_ModStart> child -> ptrace <S2SV_ModEnd> && child -> <S2SV_ModStart> current ) { WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ignore_state || ptrace_freeze_traced ( child <S2SV_ModEnd> ) ) ret <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; } read_unlock <S2SV_ModStart> ! ignore_state ) { if ( ! <S2SV_ModEnd> wait_task_inactive ( child <S2SV_ModStart> ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> - ESRCH ; <S2SV_ModStart> - ESRCH ; } }
<S2SV_ModStart> { int i ; int relocs_total = 0 ; int relocs_max = INT_MAX / sizeof ( struct drm_i915_gem_relocation_entry ) <S2SV_ModStart> . relocation_count > relocs_max - relocs_total <S2SV_ModEnd> ) return - <S2SV_ModStart> return - EINVAL ; relocs_total += exec [ i ] . relocation_count
<S2SV_ModStart> - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2
<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
<S2SV_ModStart> unsigned long flags ; if ( ! tty ) return
<S2SV_ModStart> user -> uid_keyring && user -> session_keyring
<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
<S2SV_ModStart> = 0x0 ; vcpu -> arch . pv_time_enabled = false ;
<S2SV_ModStart> -> arch ; <S2SV_ModEnd> s64 kernel_ns , <S2SV_ModStart> ; struct pvclock_vcpu_time_info <S2SV_ModEnd> guest_hv_clock ; u8 <S2SV_ModStart> ! vcpu -> pv_time_enabled <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 2 ; if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> ; pvclock_flags = <S2SV_ModStart> = ( guest_hv_clock . <S2SV_ModEnd> flags & PVCLOCK_GUEST_STOPPED <S2SV_ModStart> = pvclock_flags ; kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> & vcpu -> <S2SV_ModStart> ) ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
<S2SV_ModStart> MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ; <S2SV_ModStart> ) break ; gpa_offset <S2SV_ModEnd> = data & <S2SV_ModStart> ; if ( gpa_offset <S2SV_ModEnd> & ( sizeof <S2SV_ModStart> ) break ; if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> ( vcpu -> <S2SV_ModStart> -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> ; break ;
<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> u64 redir_content ; if <S2SV_ModEnd> ( redir_index < <S2SV_ModStart> < IOAPIC_NUM_PINS ) <S2SV_ModEnd> redir_content = ioapic <S2SV_ModStart> ] . bits ; else redir_content = ~ 0ULL
<S2SV_ModStart> ] . bm_bn ; xfs_daddr_t eofs <S2SV_ModStart> ) ) ; eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , "%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>" , __func__ , blkno , eofs ) ; return NULL ; }
<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> if ( ccid != NULL && ccid
<S2SV_ModStart> if ( ccid != NULL && ccid
<S2SV_ModStart> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart> -> rto_min ; <S2SV_ModEnd> if ( put_user
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
<S2SV_ModStart> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up
<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
<S2SV_ModStart> -> length ) ; if ( err ) return - EFAULT
<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , "%.*s<S2SV_blank>bc<S2SV_blank>" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( user_alloc && ( <S2SV_ModStart> PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size
<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
<S2SV_ModStart> ( unlikely ( __copy_from_user <S2SV_ModEnd> ( & pte
<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
<S2SV_ModStart> ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;
<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
<S2SV_ModStart> current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> CAP_SYS_ADMIN ) )
<S2SV_ModStart> ! new_idmap_permitted ( file ,
<S2SV_ModStart> bool new_idmap_permitted ( const struct file * file , <S2SV_ModStart> , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid )
<S2SV_ModStart> ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ? cred -> uid <S2SV_ModEnd> : INVALID_UID ; <S2SV_ModStart> ? cred -> gid <S2SV_ModEnd> : INVALID_GID ;
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
<S2SV_ModStart> & IFF_UP ) || <S2SV_ModEnd> ( skb -> <S2SV_ModStart> hard_header_len ) ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> return NET_RX_DROP ; }
<S2SV_ModStart> ; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped
<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event
<S2SV_ModStart> ) break ; <S2SV_ModEnd> tp -> copied_seq <S2SV_ModStart> = seq ; } tp -> copied_seq = seq ;
<S2SV_ModStart> long secure ; struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX "access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> secure ) ; fail_response :
<S2SV_ModStart> struct siginfo info = { }
<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
<S2SV_ModStart> - EINVAL ; memset ( & pciinfo , 0 , sizeof ( pciinfo ) ) ;
<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (
<S2SV_ModStart> rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . <S2SV_ModStart> . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . <S2SV_ModStart> . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . <S2SV_ModStart> . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; unsigned long mmio_pgoff <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - ENODEV ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <S2SV_ModEnd> vma -> vm_pgoff <S2SV_ModStart> vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <S2SV_ModEnd> ( & info <S2SV_ModStart> mm_lock ) ; <S2SV_ModEnd> vma -> vm_page_prot <S2SV_ModStart> , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> cee_pg pg ; memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> struct cee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;
<S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
<S2SV_ModStart> nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )
<S2SV_ModStart> br_mdb_entry e ; memset ( & e , 0 , sizeof ( e ) ) ;
<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
<S2SV_ModStart> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;
<S2SV_ModStart> ( ddev , "%s" ,
<S2SV_ModStart> -> class_dev , "%s" ,
<S2SV_ModStart> -> wl , "%s" ,
<S2SV_ModStart> ; j < HID_MAX_IDS <S2SV_ModEnd> ; j ++
<S2SV_ModStart> report_id == 0 || parser -> global . report_id >= HID_MAX_IDS <S2SV_ModStart> -> device , "report_id<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>invalid\\n" , parser -> global . report_id <S2SV_ModEnd> ) ; return
<S2SV_ModStart> hid_report * report ; if ( id >= HID_MAX_IDS ) return NULL
<S2SV_ModStart> ) ) ; if ( ! hid_validate_values ( hdev , HID_OUTPUT_REPORT , 0 , 0 , 7 ) ) return - ENODEV ;
<S2SV_ModStart> ) ; struct input_dev * dev = hidinput -> input ; int error ; report = hid_validate_values ( hid , HID_OUTPUT_REPORT , 0 , 0 , 7 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ! report ) <S2SV_ModEnd> return - ENODEV <S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> lg2ff = kmalloc
<S2SV_ModStart> 0 ] -> report_count <S2SV_ModEnd> ) ; switch
<S2SV_ModStart> ) ; struct <S2SV_ModEnd> input_dev * dev <S2SV_ModStart> hidinput -> input <S2SV_ModEnd> ; const signed <S2SV_ModStart> ; if ( ! hid_validate_values <S2SV_ModEnd> ( hid , <S2SV_ModStart> ( hid , HID_OUTPUT_REPORT , 0 , 0 , 35 ) ) return - ENODEV ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> ) ; struct <S2SV_ModEnd> input_dev * dev <S2SV_ModStart> hidinput -> input <S2SV_ModEnd> ; struct lg4ff_device_entry <S2SV_ModStart> ; if ( ! hid_validate_values ( hid , HID_OUTPUT_REPORT , 0 , 0 , 7 ) ) <S2SV_ModEnd> return - 1 <S2SV_ModStart> - 1 ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> ) ; struct <S2SV_ModEnd> input_dev * dev <S2SV_ModStart> hidinput -> input <S2SV_ModEnd> ; const signed <S2SV_ModStart> ; if ( ! hid_validate_values <S2SV_ModEnd> ( hid , <S2SV_ModStart> ( hid , HID_OUTPUT_REPORT , 0 , 0 , 7 ) ) return - ENODEV ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> name_micmute ; int i , ret ; for ( i = 0 ; i < 4 ; i ++ ) { if ( ! hid_validate_values ( hdev , HID_FEATURE_REPORT , 4 , i , 1 ) ) return - ENODEV ; } if ( ! hid_validate_values ( hdev , HID_OUTPUT_REPORT , 3 , 0 , 2 ) ) return - ENODEV <S2SV_ModEnd> ; if (
<S2SV_ModStart> hid_parse_fail ; } if ( ! hid_validate_values ( hdev , HID_OUTPUT_REPORT , REPORT_ID_DJ_SHORT , 0 , DJREPORT_SHORT_LENGTH - 1 ) ) { retval = - ENODEV ; goto hid_parse_fail ; }
<S2SV_ModStart> device_index ) ; unsigned <S2SV_ModStart> ; i < DJREPORT_SHORT_LENGTH - 1 <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ( ! report || report -> maxfield < 1 || report -> field [ 0 ] -> report_count < 1
<S2SV_ModStart> hdev ) ; <S2SV_ModEnd> switch ( usage <S2SV_ModStart> case HID_DG_INPUTMODE : if ( usage -> usage_index >= field -> report_count ) { dev_err ( & hdev -> dev , "HID_DG_INPUTMODE<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n" ) ; break ; } <S2SV_ModStart> -> inputmode_index = usage -> usage_index ; <S2SV_ModEnd> break ; case
<S2SV_ModStart> case HID_DG_CONTACTCOUNT : if ( field -> index >= field -> report -> maxfield || usage -> usage_index >= field -> report_count ) return 1 ;
<S2SV_ModStart> * field ; unsigned <S2SV_ModEnd> usages ; unsigned <S2SV_ModStart> unsigned offset ; unsigned <S2SV_ModEnd> i ; report <S2SV_ModStart> = max_t ( unsigned <S2SV_ModEnd> , parser -> <S2SV_ModStart> ++ ) { unsigned <S2SV_ModEnd> j = i <S2SV_ModStart> j ] ; field -> usage [ i ] . usage_index = i ;
<S2SV_ModStart> hid_field * field <S2SV_ModEnd> ; if ( <S2SV_ModStart> = report ; <S2SV_ModEnd> return field ;
<S2SV_ModStart> claimed != HID_CLAIMED_HIDRAW && report -> maxfield
<S2SV_ModStart> flags & HID_MAIN_ITEM_CONSTANT ) goto ignore ; if ( field -> report_count < 1
<S2SV_ModStart> i ++ ) { if ( rep -> field [ i ] -> report_count < 1 ) continue ; <S2SV_ModStart> ; } } }
<S2SV_ModStart> -> maxfield ) || report -> field [ field_index ] -> report_count < 1
<S2SV_ModStart> ( ! report || report -> maxfield != 1
<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
<S2SV_ModStart> tp_event ) && perf_paranoid_tracepoint_raw <S2SV_ModEnd> ( ) &&
<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0
<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0
<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> err ; } <S2SV_ModEnd> copied = skb
<S2SV_ModStart> ( d ) ; msg -> msg_namelen = 0
<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
<S2SV_ModStart> __func__ ) ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen
<S2SV_ModStart> = 0 ; lsa -> l2tp_conn_id = 0 ;
<S2SV_ModStart> ; long timeo ; msg -> msg_namelen = 0
<S2SV_ModStart> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;
<S2SV_ModStart> , sizeof ( *
<S2SV_ModStart> , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg
<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> sent = 0 <S2SV_ModEnd> ; smb_msg .
<S2SV_ModStart> val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
<S2SV_ModStart> oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> struct flowi6 * fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart> . ip6 ; <S2SV_ModEnd> if ( (
<S2SV_ModStart> maxfraglen , fragheaderlen , mtu <S2SV_ModStart> ; int hh_len <S2SV_ModEnd> ; int copy <S2SV_ModStart> skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE
<S2SV_ModStart> void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )
<S2SV_ModStart> cred * cred ; int err = - ENOMEM <S2SV_ModStart> ; if ( cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> * new_cred = <S2SV_ModStart> = cred ; } return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( store ) <S2SV_ModEnd> ; sector_t size <S2SV_ModStart> -> next_free ; <S2SV_ModEnd> ps -> next_free <S2SV_ModStart> -> next_free ++ ; skip_metadata ( ps )
<S2SV_ModStart> current_area -- ; skip_metadata ( ps ) ;
<S2SV_ModStart> || ns_capable ( task_active_pid_ns ( current ) <S2SV_ModEnd> -> user_ns ,
<S2SV_ModStart> = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart> - ENOMEM ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ] ) ; <S2SV_ModEnd> return max_level ;
<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; BUG_ON <S2SV_ModStart> unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_buffer ) * pipe_bufs <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> GFP_KERNEL ) ; } <S2SV_ModStart> -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( <S2SV_ModStart> pipe ; } free_uid ( user ) ;
<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <S2SV_ModStart> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false ) <S2SV_ModStart> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false )
<S2SV_ModStart> ; struct flowi6 * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n" <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> saddr , & <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> daddr ) ; <S2SV_ModStart> daddr ) ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 1 ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart> , skb , <S2SV_ModEnd> fl6 , np
<S2SV_ModStart> ; int slen ; if ( s -> s3 -> tmp . new_cipher == NULL ) return
<S2SV_ModStart> ; int slen ; if ( s -> s3 -> tmp . new_cipher == NULL ) return
<S2SV_ModStart> ; int slen ; if ( s -> s3 -> tmp . new_cipher == NULL ) return
<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
<S2SV_ModStart> NULL ) { struct frag_hdr fhdr ; <S2SV_ModStart> csum = 0 <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> skb ) ; } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags (
<S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> = SKB_GSO_UDP ; append : <S2SV_ModEnd> return skb_append_datato_frags (
<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> vma ) { <S2SV_ModEnd> struct au1200fb_device * <S2SV_ModStart> info -> par <S2SV_ModEnd> ; vma -> <S2SV_ModStart> _CACHE_MASK ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> vma ) ; struct uio_mem * mem ; <S2SV_ModStart> mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> -> vm_start , mem -> <S2SV_ModEnd> addr >> PAGE_SHIFT
<S2SV_ModStart> ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , buffer , size <S2SV_ModEnd> ) ) return
<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
<S2SV_ModStart> "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
<S2SV_ModStart> struct serial_icounter_struct icount = { }
<S2SV_ModStart> ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen
<S2SV_ModStart> out ; } ath9k_htc_set_mac_bssid_mask <S2SV_ModEnd> ( priv ,
<S2SV_ModStart> int i ; if ( iter_data -> hw_macaddr != NULL ) { <S2SV_ModStart> ) ; } else { iter_data -> hw_macaddr = mac ; } }
<S2SV_ModStart> priv ) ; ath9k_htc_set_mac_bssid_mask <S2SV_ModEnd> ( priv ,
<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
<S2SV_ModStart> = 0 ; unsigned int copylen ; <S2SV_ModStart> return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <S2SV_ModStart> EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <S2SV_ModStart> , user , copylen <S2SV_ModEnd> ) != 0
<S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
<S2SV_ModStart> ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> acl_len ) ; }
<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
<S2SV_ModStart> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> ) goto out_free <S2SV_ModEnd> ; r = <S2SV_ModStart> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> return 0 ; out_slots : kfree ( slots ) ;
<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
<S2SV_ModStart> srcu ) ; <S2SV_ModEnd> r = 1 <S2SV_ModStart> srcu_idx ) ; <S2SV_ModEnd> return r ;
<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
<S2SV_ModStart> -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
<S2SV_ModStart> -> cid_mask ; <S2SV_ModEnd> return cid ;
<S2SV_ModStart> } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
<S2SV_ModStart> -> msg_name ; if ( sin ) { <S2SV_ModStart> sin ) ; } <S2SV_ModStart> -> msg_name ; if ( sin6 ) { <S2SV_ModStart> sin6 ) ; }
<S2SV_ModStart> frag ) { if ( frag -> msg_header . is_ccs ) { EVP_CIPHER_CTX_free ( frag -> msg_header . saved_retransmit_state . enc_write_ctx ) ; EVP_MD_CTX_destroy ( frag -> msg_header . saved_retransmit_state . write_hash ) ; }
<S2SV_ModStart> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) <S2SV_ModStart> -> enc_write_ctx = EVP_CIPHER_CTX_new ( <S2SV_ModEnd> ) ) == <S2SV_ModStart> goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_create ( ) ; if ( ! mac_ctx ) goto err ; s -> write_hash = mac_ctx ; } else <S2SV_ModEnd> mac_ctx = ssl_replace_hash
<S2SV_ModStart> frag ) { if ( frag -> msg_header . is_ccs ) { EVP_CIPHER_CTX_free ( frag -> msg_header . saved_retransmit_state . enc_write_ctx ) ; EVP_MD_CTX_destroy ( frag -> msg_header . saved_retransmit_state . write_hash ) ; }
<S2SV_ModStart> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) <S2SV_ModStart> -> enc_write_ctx = EVP_CIPHER_CTX_new ( <S2SV_ModEnd> ) ) == <S2SV_ModStart> goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_create ( ) ; if ( ! mac_ctx ) goto err ; s -> write_hash = mac_ctx ; } else <S2SV_ModEnd> mac_ctx = ssl_replace_hash
<S2SV_ModStart> frag ) { if ( frag -> msg_header . is_ccs ) { EVP_CIPHER_CTX_free ( frag -> msg_header . saved_retransmit_state . enc_write_ctx ) ; EVP_MD_CTX_destroy ( frag -> msg_header . saved_retransmit_state . write_hash ) ; }
<S2SV_ModStart> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) <S2SV_ModStart> -> enc_write_ctx = EVP_CIPHER_CTX_new ( <S2SV_ModEnd> ) ) == <S2SV_ModStart> goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_create ( ) ; if ( ! mac_ctx ) goto err ; s -> write_hash = mac_ctx ; } else <S2SV_ModEnd> mac_ctx = ssl_replace_hash
<S2SV_ModStart> frag ) { if ( frag -> msg_header . is_ccs ) { EVP_CIPHER_CTX_free ( frag -> msg_header . saved_retransmit_state . enc_write_ctx ) ; EVP_MD_CTX_destroy ( frag -> msg_header . saved_retransmit_state . write_hash ) ; }
<S2SV_ModStart> enc_write_ctx != NULL && ! SSL_IS_DTLS ( s ) <S2SV_ModStart> -> enc_write_ctx = EVP_CIPHER_CTX_new ( <S2SV_ModEnd> ) ) == <S2SV_ModStart> goto err ; dd = s -> enc_write_ctx ; if ( SSL_IS_DTLS ( s ) ) { mac_ctx = EVP_MD_CTX_create ( ) ; if ( ! mac_ctx ) goto err ; s -> write_hash = mac_ctx ; } else <S2SV_ModEnd> mac_ctx = ssl_replace_hash
<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> vma ) { <S2SV_ModEnd> struct au1200fb_device * <S2SV_ModStart> info -> par <S2SV_ModEnd> ; vma -> <S2SV_ModStart> _CACHE_MASK ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> vma ) ; struct uio_mem * mem ; <S2SV_ModStart> mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> -> vm_start , mem -> <S2SV_ModEnd> addr >> PAGE_SHIFT
<S2SV_ModStart> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
<S2SV_ModStart> shm_perm ) ; if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; }
<S2SV_ModStart> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
<S2SV_ModStart> ( ret || ! cm_id -> device ||
<S2SV_ModStart> ; err : <S2SV_ModEnd> free_percpu ( ctx
<S2SV_ModStart> { request_module ( "crypto-%s" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( "crypto-%s-all" <S2SV_ModEnd> , name )
<S2SV_ModStart> peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;
<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> timeout == NULL <S2SV_ModStart> ; if ( compat_get_timespec <S2SV_ModEnd> ( & ktspec <S2SV_ModStart> > 0 && compat_put_timespec <S2SV_ModEnd> ( & ktspec
<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
<S2SV_ModStart> -> Y ; bn_wexpand ( x1 , group -> field . top ) ; bn_wexpand ( z1 , group -> field . top ) ; bn_wexpand ( x2 , group -> field . top ) ; bn_wexpand ( z2 , group -> field . top ) ; <S2SV_ModStart> mask ) { BN_consttime_swap ( word & mask , x1 , x2 , group -> field . top ) ; BN_consttime_swap ( word & mask , z1 , z2 , group -> field . top ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> -> X , x2 , z2 , x1 , z1 <S2SV_ModEnd> , ctx ) <S2SV_ModStart> ( group , x1 , z1 , ctx ) ) goto err ; BN_consttime_swap ( word & mask , x1 , x2 , group -> field . top ) ; BN_consttime_swap ( word & mask , z1 , z2 , group -> field . top ) ; <S2SV_ModEnd> mask >>= 1
<S2SV_ModStart> -> Y ; bn_wexpand ( x1 , group -> field . top ) ; bn_wexpand ( z1 , group -> field . top ) ; bn_wexpand ( x2 , group -> field . top ) ; bn_wexpand ( z2 , group -> field . top ) ; <S2SV_ModStart> -- ) { BN_consttime_swap <S2SV_ModEnd> ( scalar -> <S2SV_ModStart> ] & mask , x1 , x2 , group -> field . top ) ; BN_consttime_swap ( scalar -> d [ i ] & mask , z1 , z2 , group -> field . top ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> -> X , x2 , z2 , x1 , z1 <S2SV_ModEnd> , ctx ) <S2SV_ModStart> ( group , x1 , z1 , ctx ) ) goto err ; BN_consttime_swap ( scalar -> d [ i ] & mask , x1 , x2 , group -> field . top ) ; BN_consttime_swap ( scalar -> d [ i ] & mask , z1 , z2 , group -> field . top ) ; <S2SV_ModEnd> mask >>= 1
<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( "Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
<S2SV_ModStart> serial ) ; if <S2SV_ModEnd> ( key != <S2SV_ModStart> -> match_data ) return 0
<S2SV_ModStart> ( head_skb ) ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;
<S2SV_ModStart> . pending_eoi = ( ret < 0 ? 0 : ret ) <S2SV_ModEnd> ; } else
<S2SV_ModStart> ) { return ( ( nsp -> flags & NETLINK_SKB_DST ) || file_ns_capable <S2SV_ModEnd> ( nsp -> <S2SV_ModStart> nsp -> sk -> sk_socket -> file , user_ns , cap ) ) && ns_capable ( <S2SV_ModEnd> user_ns , cap
<S2SV_ModStart> scm_cookie scm ; u32 netlink_skb_flags = 0 ; <S2SV_ModStart> goto out ; netlink_skb_flags |= NETLINK_SKB_DST ; <S2SV_ModStart> -> creds ; NETLINK_CB ( skb ) . flags = netlink_skb_flags ;
<S2SV_ModStart> ; } else { <S2SV_ModStart> -> data ; if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) { item = NULL ; frag = NULL ; goto err ; } }
<S2SV_ModStart> ; } else { <S2SV_ModStart> -> data ; if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) { item = NULL ; frag = NULL ; goto err ; } }
<S2SV_ModStart> ; } else { <S2SV_ModStart> -> data ; if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) { item = NULL ; frag = NULL ; goto err ; } }
<S2SV_ModStart> ; } else { <S2SV_ModStart> -> data ; if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) { item = NULL ; frag = NULL ; goto err ; } }
<S2SV_ModStart> ; } else { <S2SV_ModStart> -> data ; if ( frag -> msg_header . msg_len != msg_hdr -> msg_len ) { item = NULL ; frag = NULL ; goto err ; } }
<S2SV_ModStart> } else { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> 0 ) { mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> b , nr ) ; mutex_unlock ( & ldata -> output_lock
<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if
<S2SV_ModStart> futex_hash_bucket * hb <S2SV_ModEnd> ; hb =
<S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
<S2SV_ModStart> iocb ) ; put_reqs_available ( ctx , 1 ) ;
<S2SV_ModStart> tail ) ; <S2SV_ModEnd> out : mutex_unlock
<S2SV_ModStart> hm_header_st msg_hdr ; redo : <S2SV_ModStart> = 0 ; goto redo <S2SV_ModEnd> ; } else
<S2SV_ModStart> hm_header_st msg_hdr ; redo : <S2SV_ModStart> = 0 ; goto redo <S2SV_ModEnd> ; } else
<S2SV_ModStart> hm_header_st msg_hdr ; redo : <S2SV_ModStart> = 0 ; goto redo <S2SV_ModEnd> ; } else
<S2SV_ModStart> hm_header_st msg_hdr ; redo : <S2SV_ModStart> = 0 ; goto redo <S2SV_ModEnd> ; } else
<S2SV_ModStart> hm_header_st msg_hdr ; redo : <S2SV_ModStart> = 0 ; goto redo <S2SV_ModEnd> ; } else
<S2SV_ModStart> session == NULL || s -> session -> master_key_length == 0
<S2SV_ModStart> j ) ; s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> session == NULL || s -> session -> master_key_length == 0
<S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; s ->
<S2SV_ModStart> f_err ; } if ( ! ( s -> s3 -> flags & SSL3_FLAGS_CCS_OK ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> case SSL3_ST_SR_CERT_VRFY_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> s , SSL3_RT_HANDSHAKE , NULL <S2SV_ModStart> s , SSL3_RT_HANDSHAKE , NULL
<S2SV_ModStart> , SSL3_RT_HANDSHAKE , NULL , <S2SV_ModStart> , SSL3_RT_HANDSHAKE , NULL ,
<S2SV_ModStart> , SSL3_RT_HANDSHAKE , NULL , <S2SV_ModStart> , SSL3_RT_HANDSHAKE , NULL ,
<S2SV_ModStart> , int type , int * recvd_type
<S2SV_ModStart> , int type , int * recvd_type <S2SV_ModStart> ( rr ) || ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && type == SSL3_RT_HANDSHAKE && recvd_type != NULL ) <S2SV_ModStart> f_err ; } if ( type == SSL3_RT_HANDSHAKE && SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && s -> rlayer . handshake_fragment_len > 0 ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } if ( recvd_type != NULL ) * recvd_type = SSL3_RECORD_get_type ( rr ) ; <S2SV_ModStart> ( n ) ; } if ( rr -> type == SSL3_RT_HANDSHAKE && type == SSL3_RT_CHANGE_CIPHER_SPEC ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err <S2SV_ModStart> SSL3_RT_CHANGE_CIPHER_SPEC ) { al = SSL_AD_UNEXPECTED_MESSAGE <S2SV_ModEnd> ; SSLerr ( <S2SV_ModStart> ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY <S2SV_ModEnd> ) ; goto <S2SV_ModStart> ; goto f_err <S2SV_ModEnd> ; } if <S2SV_ModStart> al ) ; <S2SV_ModEnd> return ( -
<S2SV_ModStart> i , al , recvd_type <S2SV_ModStart> , SSL3_RT_HANDSHAKE , & recvd_type , <S2SV_ModStart> ; return i ; } if ( s -> init_num == 0 && recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC && ( mt < 0 || mt == SSL3_MT_CHANGE_CIPHER_SPEC ) ) { if ( * p != SSL3_MT_CCS ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_MESSAGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } s -> init_num = i - 1 ; s -> init_msg = p + 1 ; s -> s3 -> tmp . message_type = SSL3_MT_CHANGE_CIPHER_SPEC ; s -> s3 -> tmp . message_size = i - 1 ; s -> state = stn ; * ok = 1 ; if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_CHANGE_CIPHER_SPEC , p , 1 , s , s -> msg_callback_arg ) ; return i - 1 ; } else if ( recvd_type != SSL3_RT_HANDSHAKE ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_MESSAGE , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err <S2SV_ModStart> , SSL3_RT_HANDSHAKE , NULL ,
<S2SV_ModStart> -> s3 -> <S2SV_ModEnd> change_cipher_spec = 0 <S2SV_ModStart> -> state = SSL3_ST_CR_CHANGE_A <S2SV_ModEnd> ; if ( <S2SV_ModStart> : ret = ssl3_check_change <S2SV_ModEnd> ( s ) <S2SV_ModStart> -> state = SSL3_ST_CR_CHANGE_A <S2SV_ModEnd> ; s -> <S2SV_ModStart> . next_state = SSL3_ST_CR_CHANGE_A ; } s -> init_num = 0 ; break ; case SSL3_ST_CR_SESSION_TICKET_A : case SSL3_ST_CR_SESSION_TICKET_B : ret = ssl3_get_new_session_ticket ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_CR_CHANGE_A ; s -> init_num = 0 ; break ; case SSL3_ST_CR_CERT_STATUS_A : case SSL3_ST_CR_CERT_STATUS_B : ret = ssl3_get_cert_status ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_CR_KEY_EXCH_A ; s -> init_num = 0 ; break ; case SSL3_ST_CR_CHANGE_A : case SSL3_ST_CR_CHANGE_B : ret = ssl3_get_change_cipher_spec ( s , SSL3_ST_CR_CHANGE_A , SSL3_ST_CR_CHANGE_B ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_CR_FINISHED_A ; <S2SV_ModEnd> s -> init_num <S2SV_ModStart> break ; case SSL3_ST_CR_FINISHED_A <S2SV_ModEnd> : case SSL3_ST_CR_FINISHED_B <S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : <S2SV_ModEnd> ret = ssl3_get_finished
<S2SV_ModStart> , SSL3_RT_APPLICATION_DATA , NULL , <S2SV_ModStart> , SSL3_RT_APPLICATION_DATA , NULL ,
<S2SV_ModStart> , NULL , NULL ,
<S2SV_ModStart> &= ~ TLS1_FLAGS_SKIP_CERT_VERIFY <S2SV_ModEnd> ; s -> <S2SV_ModStart> 2 ) { s -> state = SSL3_ST_SR_CHANGE_A ; <S2SV_ModEnd> s -> init_num <S2SV_ModStart> goto end ; s -> state = SSL3_ST_SR_CHANGE_A ; s -> init_num = 0 ; break ; # if ! defined ( OPENSSL_NO_NEXTPROTONEG ) case SSL3_ST_SR_NEXT_PROTO_A : case SSL3_ST_SR_NEXT_PROTO_B : ret = ssl3_get_next_proto ( s ) ; if ( ret <= 0 ) goto end ; s -> init_num = 0 ; s -> state = SSL3_ST_SR_FINISHED_A ; break ; # endif case SSL3_ST_SR_CHANGE_A : case SSL3_ST_SR_CHANGE_B : ret = ssl3_get_change_cipher_spec ( s , SSL3_ST_SR_CHANGE_A , SSL3_ST_SR_CHANGE_B ) ; if ( ret <= 0 ) goto end ; <S2SV_ModStart> ; break ; case SSL3_ST_SR_FINISHED_A <S2SV_ModEnd> : case SSL3_ST_SR_FINISHED_B <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : <S2SV_ModEnd> ret = ssl3_get_finished <S2SV_ModStart> hit ) { <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . next_state = SSL3_ST_SR_CHANGE_A ; <S2SV_ModEnd> } else s
<S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; s ->
<S2SV_ModStart> f_err ; } if ( ! ( s -> s3 -> flags & SSL3_FLAGS_CCS_OK ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> case SSL3_ST_SR_CERT_VRFY_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> -> next_proto_neg_seen ) { s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> = SSL3_ST_SR_NEXT_PROTO_A ; }
<S2SV_ModStart> session == NULL || s -> session -> master_key_length == 0
<S2SV_ModStart> session == NULL || s -> session -> master_key_length == 0
<S2SV_ModStart> j ) ; s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> session == NULL || s -> session -> master_key_length == 0
<S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; s ->
<S2SV_ModStart> f_err ; } if ( ! ( s -> s3 -> flags & SSL3_FLAGS_CCS_OK ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> case SSL3_ST_SR_CERT_VRFY_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> -> next_proto_neg_seen ) { s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> = SSL3_ST_SR_NEXT_PROTO_A ; }
<S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; s ->
<S2SV_ModStart> f_err ; } if ( ! ( s -> s3 -> flags & SSL3_FLAGS_CCS_OK ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> case SSL3_ST_SR_CERT_VRFY_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> -> next_proto_neg_seen ) { s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> = SSL3_ST_SR_NEXT_PROTO_A ; }
<S2SV_ModStart> case SSL3_ST_CR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; s ->
<S2SV_ModStart> f_err ; } if ( ! ( s -> s3 -> flags & SSL3_FLAGS_CCS_OK ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ; goto f_err ; } s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> case SSL3_ST_SR_CERT_VRFY_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; <S2SV_ModStart> case SSL3_ST_SR_FINISHED_B : s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> j ) ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> |= SSL3_FLAGS_CCS_OK ; } } # endif if ( j != 0 && j == s -> session -> session_id_length && memcmp ( p , s -> session -> session_id , j ) == 0 ) { if ( s -> sid_ctx_length != s -> session -> sid_ctx_length || memcmp ( s -> session -> sid_ctx , s -> sid_ctx , s -> sid_ctx_length ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_SERVER_HELLO , SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT ) ; goto f_err ; } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> j ) ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> |= SSL3_FLAGS_CCS_OK ; } } # endif if ( j != 0 && j == s -> session -> session_id_length && memcmp ( p , s -> session -> session_id , j ) == 0 ) { if ( s -> sid_ctx_length != s -> session -> sid_ctx_length || memcmp ( s -> session -> sid_ctx , s -> sid_ctx , s -> sid_ctx_length ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_SERVER_HELLO , SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT ) ; goto f_err ; } s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ;
<S2SV_ModStart> tsk ) { if ( unlikely ( static_cpu_has ( X86_FEATURE_FXSAVE_LEAK ) ) ) { asm volatile ( "fnclex\\n\\t" "emms\\n\\t" "fildl<S2SV_blank>%P[addr]" : : <S2SV_ModEnd> [ addr ] <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;
<S2SV_ModStart> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;
<S2SV_ModStart> case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;
<S2SV_ModStart> ) ] ; struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <S2SV_ModStart> unsigned int ret ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , "all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use" ) <S2SV_ModStart> NF_DROP ; } snprintf ( buffer , sizeof ( buffer ) , "%u<S2SV_blank>%u" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( "nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n" , buffer , & newaddr . ip , port ) ; <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , ctinfo , <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , "cannot<S2SV_blank>mangle<S2SV_blank>packet" )
<S2SV_ModStart> ) ) ; ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; param += <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr
<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;
<S2SV_ModStart> rc = 0 ; if ( ! scontext_len ) return - EINVAL
<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;
<S2SV_ModStart> NULL ; } g_free ( list ) ;
<S2SV_ModStart> ; frag = g_malloc0 <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> { list = g_malloc0 <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; sdu = g_malloc0 <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> fh ) ; if ( packet_size > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "mpeg:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , packet_size , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; }
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ] . jf && f_offset <S2SV_ModStart> ? 2 : 5 <S2SV_ModEnd> ; EMIT_COND_JMP (
<S2SV_ModStart> ) ; } if ( p_conv_data -> rtp_dyn_payload != rtp_dyn_payload )
<S2SV_ModStart> locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
<S2SV_ModStart> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart> -> nla_len > <S2SV_ModEnd> skb -> len <S2SV_ModStart> skb -> len - A
<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
<S2SV_ModStart> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart> -> nla_len > <S2SV_ModEnd> skb -> len <S2SV_ModStart> skb -> len - A
<S2SV_ModStart> { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n" , size ) ; return 0 ; }
<S2SV_ModStart> size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return false ; }
<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
<S2SV_ModStart> if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
<S2SV_ModStart> * rsize >= 18 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>" "report<S2SV_blank>descriptor\\n" ) ; <S2SV_ModEnd> rdesc [ 62 <S2SV_ModStart> [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> ; } break
<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 112 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1
<S2SV_ModStart> ; if ( size > 64 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n" , size ) ; return 0 ; } if (
<S2SV_ModStart> ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if (
<S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> dtls1_hm_fragment_free ( frag <S2SV_ModEnd> ) ; *
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> frag ) ; <S2SV_ModEnd> * ok =
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> dtls1_hm_fragment_free ( frag <S2SV_ModEnd> ) ; *
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> frag ) ; <S2SV_ModEnd> * ok =
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> dtls1_hm_fragment_free ( frag <S2SV_ModEnd> ) ; *
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> frag ) ; <S2SV_ModEnd> * ok =
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> dtls1_hm_fragment_free ( frag <S2SV_ModEnd> ) ; *
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> frag ) ; <S2SV_ModEnd> * ok =
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> dtls1_hm_fragment_free ( frag <S2SV_ModEnd> ) ; *
<S2SV_ModStart> frag != NULL && item == NULL <S2SV_ModStart> frag ) ; <S2SV_ModEnd> * ok =
<S2SV_ModStart> ok ) ; if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;
<S2SV_ModStart> msg_hdr -> frag_len <S2SV_ModEnd> ; if ( <S2SV_ModStart> msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) <S2SV_ModEnd> ) goto err
<S2SV_ModStart> ok ) ; if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;
<S2SV_ModStart> msg_hdr -> frag_len <S2SV_ModEnd> ; if ( <S2SV_ModStart> msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) <S2SV_ModEnd> ) goto err
<S2SV_ModStart> ok ) ; if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;
<S2SV_ModStart> msg_hdr -> frag_len <S2SV_ModEnd> ; if ( <S2SV_ModStart> msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) <S2SV_ModEnd> ) goto err
<S2SV_ModStart> ok ) ; if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;
<S2SV_ModStart> msg_hdr -> frag_len <S2SV_ModEnd> ; if ( <S2SV_ModStart> msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) <S2SV_ModEnd> ) goto err
<S2SV_ModStart> ok ) ; if ( frag_len > dtls1_max_handshake_message_len ( s ) ) goto err ;
<S2SV_ModStart> msg_hdr -> frag_len <S2SV_ModEnd> ; if ( <S2SV_ModStart> msg_hdr -> msg_len || msg_hdr -> msg_len > dtls1_max_handshake_message_len ( s ) <S2SV_ModEnd> ) goto err
<S2SV_ModStart> if ( frag_len <S2SV_ModEnd> < msg_hdr -> <S2SV_ModStart> goto err ; item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ) goto err ; if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY <S2SV_ModStart> err ; } item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> if ( frag_len <S2SV_ModEnd> < msg_hdr -> <S2SV_ModStart> goto err ; item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ) goto err ; if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY <S2SV_ModStart> err ; } item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> if ( frag_len <S2SV_ModEnd> < msg_hdr -> <S2SV_ModStart> goto err ; item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ) goto err ; if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY <S2SV_ModStart> err ; } item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> if ( frag_len <S2SV_ModEnd> < msg_hdr -> <S2SV_ModStart> goto err ; item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ) goto err ; if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY <S2SV_ModStart> err ; } item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> if ( frag_len <S2SV_ModEnd> < msg_hdr -> <S2SV_ModStart> goto err ; item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ) goto err ; if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY <S2SV_ModStart> err ; } item = <S2SV_ModStart> buffered_messages , item ) ; OPENSSL_assert ( item != NULL
<S2SV_ModStart> ; int i , length ; if ( len <= 0 || len > INT_MAX || pp == NULL || ( p = * pp ) == NULL || p [ len - 1 ] & 0x80 ) { ASN1err ( ASN1_F_C2I_ASN1_OBJECT , ASN1_R_INVALID_OBJECT_ENCODING ) ; return NULL ; } length = ( int ) len <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < length <S2SV_ModEnd> ; i ++ <S2SV_ModStart> -> length < length <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) OPENSSL_malloc ( length <S2SV_ModEnd> ) ; if <S2SV_ModStart> , p , length ) ; ret -> data = data ; ret -> length = length <S2SV_ModEnd> ; ret -> <S2SV_ModStart> ; p += length <S2SV_ModEnd> ; if (
<S2SV_ModStart> + 2 ] ; if ( buf && buf_len > 0 ) buf [ 0 ] = '\\0' <S2SV_ModStart> NULL ) ) <S2SV_ModEnd> return ( 0 <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) ) { <S2SV_ModStart> + '0' ; * buf = '\\0' ; <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) { * <S2SV_ModStart> ++ = '.' ; * buf = '\\0'
<S2SV_ModStart> ; int i , length ; if ( len <= 0 || len > INT_MAX || pp == NULL || ( p = * pp ) == NULL || p [ len - 1 ] & 0x80 ) { ASN1err ( ASN1_F_C2I_ASN1_OBJECT , ASN1_R_INVALID_OBJECT_ENCODING ) ; return NULL ; } length = ( int ) len <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < length <S2SV_ModEnd> ; i ++ <S2SV_ModStart> -> length < length <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) OPENSSL_malloc ( length <S2SV_ModEnd> ) ; if <S2SV_ModStart> , p , length ) ; ret -> data = data ; ret -> length = length <S2SV_ModEnd> ; ret -> <S2SV_ModStart> ; p += length <S2SV_ModEnd> ; if (
<S2SV_ModStart> + 2 ] ; if ( buf && buf_len > 0 ) buf [ 0 ] = '\\0' <S2SV_ModStart> NULL ) ) <S2SV_ModEnd> return ( 0 <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) ) { <S2SV_ModStart> + '0' ; * buf = '\\0' ; <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) { * <S2SV_ModStart> ++ = '.' ; * buf = '\\0'
<S2SV_ModStart> ; int i , length ; if ( len <= 0 || len > INT_MAX || pp == NULL || ( p = * pp ) == NULL || p [ len - 1 ] & 0x80 ) { ASN1err ( ASN1_F_C2I_ASN1_OBJECT , ASN1_R_INVALID_OBJECT_ENCODING ) ; return NULL ; } length = ( int ) len <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < length <S2SV_ModEnd> ; i ++ <S2SV_ModStart> -> length < length <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) OPENSSL_malloc ( length <S2SV_ModEnd> ) ; if <S2SV_ModStart> , p , length ) ; ret -> data = data ; ret -> length = length <S2SV_ModEnd> ; ret -> <S2SV_ModStart> ; p += length <S2SV_ModEnd> ; if (
<S2SV_ModStart> + 2 ] ; if ( buf && buf_len > 0 ) buf [ 0 ] = '\\0' <S2SV_ModStart> NULL ) ) <S2SV_ModEnd> return ( 0 <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) ) { <S2SV_ModStart> + '0' ; * buf = '\\0' ; <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) { * <S2SV_ModStart> ++ = '.' ; * buf = '\\0'
<S2SV_ModStart> ; int i , length ; if ( len <= 0 || len > INT_MAX || pp == NULL || ( p = * pp ) == NULL || p [ len - 1 ] & 0x80 ) { ASN1err ( ASN1_F_C2I_ASN1_OBJECT , ASN1_R_INVALID_OBJECT_ENCODING ) ; return NULL ; } length = ( int ) len <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < length <S2SV_ModEnd> ; i ++ <S2SV_ModStart> -> length < length <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) OPENSSL_malloc ( length <S2SV_ModEnd> ) ; ret <S2SV_ModStart> , p , length ) ; ret -> length = length <S2SV_ModEnd> ; ret -> <S2SV_ModStart> ; p += length <S2SV_ModEnd> ; if (
<S2SV_ModStart> + 2 ] ; if ( buf && buf_len > 0 ) buf [ 0 ] = '\\0' <S2SV_ModStart> NULL ) ) <S2SV_ModEnd> return ( 0 <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) ) { <S2SV_ModStart> + '0' ; * buf = '\\0' ; <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) { * <S2SV_ModStart> ++ = '.' ; * buf = '\\0'
<S2SV_ModStart> ; int i , length ; if ( len <= 0 || len > INT_MAX || pp == NULL || ( p = * pp ) == NULL || p [ len - 1 ] & 0x80 ) { ASN1err ( ASN1_F_C2I_ASN1_OBJECT , ASN1_R_INVALID_OBJECT_ENCODING ) ; return NULL ; } length = ( int ) len <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ; i < length <S2SV_ModEnd> ; i ++ <S2SV_ModStart> -> length < length <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) OPENSSL_malloc ( length <S2SV_ModEnd> ) ; if <S2SV_ModStart> , p , length ) ; ret -> data = data ; ret -> length = length <S2SV_ModEnd> ; ret -> <S2SV_ModStart> ; p += length <S2SV_ModEnd> ; if (
<S2SV_ModStart> + 2 ] ; if ( buf && buf_len > 0 ) buf [ 0 ] = '\\0' <S2SV_ModStart> NULL ) ) <S2SV_ModEnd> return ( 0 <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) ) { <S2SV_ModStart> + '0' ; * buf = '\\0' ; <S2SV_ModStart> ( buf_len > 1 <S2SV_ModEnd> ) { * <S2SV_ModStart> ++ = '.' ; * buf = '\\0'
<S2SV_ModStart> 0 ; } if ( ! s -> hit ) { <S2SV_ModStart> ecpointformatlist_length ) ; }
<S2SV_ModStart> 0 ; } if ( ! s -> hit ) { <S2SV_ModStart> ecpointformatlist_length ) ; }
<S2SV_ModStart> 0 ; } if ( ! s -> hit ) { <S2SV_ModStart> ecpointformatlist_length ) ; }
<S2SV_ModStart> 0 ; } if ( ! s -> hit ) { <S2SV_ModStart> ecpointformatlist_length ) ; }
<S2SV_ModStart> SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; }
<S2SV_ModStart> SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; }
<S2SV_ModStart> session -> sess_cert == NULL ) { SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( s -> session -> sess_cert <S2SV_ModStart> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if ( s -> session -> sess_cert <S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; }
<S2SV_ModStart> session -> sess_cert == NULL ) { SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( s -> session -> sess_cert <S2SV_ModStart> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if ( s -> session -> sess_cert <S2SV_ModStart> = 0 ; if ( s -> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; }
<S2SV_ModStart> SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; }
<S2SV_ModStart> SSL_MAX_MASTER_KEY_LENGTH ] ; if ( s -> session -> sess_cert == NULL ) { SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } <S2SV_ModStart> session -> sess_cert == NULL ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_UNEXPECTED_MESSAGE ) ; SSLerr ( SSL_F_DTLS1_SEND_CLIENT_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto err ; } if ( s -> session -> sess_cert
<S2SV_ModStart> session -> sess_cert == NULL ) { SSLerr ( SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( s -> session -> sess_cert
<S2SV_ModStart> 6 ) { <S2SV_ModEnd> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO <S2SV_ModStart> goto err ; } <S2SV_ModEnd> if ( p <S2SV_ModStart> SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ; goto err ; } if ( n < 9 ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH
<S2SV_ModStart> 6 ) { <S2SV_ModEnd> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO <S2SV_ModStart> goto err ; } <S2SV_ModEnd> if ( p <S2SV_ModStart> SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ; goto err ; } if ( n < 9 ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH
<S2SV_ModStart> 6 ) { <S2SV_ModEnd> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO <S2SV_ModStart> goto err ; } <S2SV_ModEnd> if ( p <S2SV_ModStart> SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ; goto err ; } if ( n < 9 ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH
<S2SV_ModStart> 6 ) { <S2SV_ModEnd> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO <S2SV_ModStart> goto err ; } <S2SV_ModEnd> if ( p <S2SV_ModStart> SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ; goto err ; } if ( n < 9 ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH
<S2SV_ModStart> 6 ) { <S2SV_ModEnd> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO <S2SV_ModStart> goto err ; } <S2SV_ModEnd> if ( p <S2SV_ModStart> SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ; goto err ; } if ( n < 9 ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH
<S2SV_ModStart> return NULL ; if ( BN_ucmp ( A , N ) >= 0 || BN_ucmp ( B , N ) >= 0 ) return NULL ;
<S2SV_ModStart> ; if ( BN_ucmp ( g , N ) >= 0 ) return NULL ; if (
<S2SV_ModStart> ) ) { if ( sk_SRTP_PROTECTION_PROFILE_find ( profiles , p ) >= 0 ) { SSLerr ( SSL_F_SSL_CTX_MAKE_PROFILES , SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ; return 1 ; } <S2SV_ModStart> SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ;
<S2SV_ModStart> { SRTP_PROTECTION_PROFILE * <S2SV_ModEnd> sprof ; STACK_OF <S2SV_ModStart> SRTP_PROTECTION_PROFILE ) * <S2SV_ModEnd> srvr ; int <S2SV_ModStart> int i , srtp_pref ; unsigned int id <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ; } srvr = SSL_get_srtp_profiles ( s ) ; s -> srtp_profile = NULL ; srtp_pref = sk_SRTP_PROTECTION_PROFILE_num ( srvr <S2SV_ModEnd> ) ; while <S2SV_ModStart> -= 2 ; for ( i = 0 ; i < srtp_pref ; i ++ ) { sprof = sk_SRTP_PROTECTION_PROFILE_value ( srvr , i ) ; if ( sprof <S2SV_ModEnd> -> id == <S2SV_ModStart> -> id == <S2SV_ModEnd> id ) { <S2SV_ModStart> = sprof ; srtp_pref = i ; break ; } } } mki_len = * d ; d ++ ; len -- ; if ( mki_len != len ) { SSLerr ( SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT , SSL_R_BAD_SRTP_MKI_VALUE ) ; * al = SSL_AD_DECODE_ERROR ; return 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> OPENSSL_NO_SRTP if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> OPENSSL_NO_SRTP if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> ^ no - srtp$ / ) { $no_srtp = 1 ; } elsif ( / ^ no -
<S2SV_ModStart> ^ no - srtp$ / ) { $no_srtp = 1 ; } elsif ( / ^ no -
<S2SV_ModStart> ) ) { if ( sk_SRTP_PROTECTION_PROFILE_find ( profiles , p ) >= 0 ) { SSLerr ( SSL_F_SSL_CTX_MAKE_PROFILES , SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ; return 1 ; } <S2SV_ModStart> SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ;
<S2SV_ModStart> { SRTP_PROTECTION_PROFILE * <S2SV_ModEnd> sprof ; STACK_OF <S2SV_ModStart> SRTP_PROTECTION_PROFILE ) * <S2SV_ModEnd> srvr ; int <S2SV_ModStart> int i , srtp_pref ; unsigned int id <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ; } srvr = SSL_get_srtp_profiles ( s ) ; s -> srtp_profile = NULL ; srtp_pref = sk_SRTP_PROTECTION_PROFILE_num ( srvr <S2SV_ModEnd> ) ; while <S2SV_ModStart> -= 2 ; for ( i = 0 ; i < srtp_pref ; i ++ ) { sprof = sk_SRTP_PROTECTION_PROFILE_value ( srvr , i ) ; if ( sprof <S2SV_ModEnd> -> id == <S2SV_ModStart> -> id == <S2SV_ModEnd> id ) { <S2SV_ModStart> = sprof ; srtp_pref = i ; break ; } } } mki_len = * d ; d ++ ; len -- ; if ( mki_len != len ) { SSLerr ( SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT , SSL_R_BAD_SRTP_MKI_VALUE ) ; * al = SSL_AD_DECODE_ERROR ; return 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> } if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> endif if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> ^ no - srtp$ / ) { $no_srtp = 1 ; } elsif ( / ^ no -
<S2SV_ModStart> ) ) { if ( sk_SRTP_PROTECTION_PROFILE_find ( profiles , p ) >= 0 ) { SSLerr ( SSL_F_SSL_CTX_MAKE_PROFILES , SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ; return 1 ; } <S2SV_ModStart> SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE ) ; sk_SRTP_PROTECTION_PROFILE_free ( profiles ) ;
<S2SV_ModStart> { SRTP_PROTECTION_PROFILE * <S2SV_ModEnd> sprof ; STACK_OF <S2SV_ModStart> SRTP_PROTECTION_PROFILE ) * <S2SV_ModEnd> srvr ; int <S2SV_ModStart> int i , srtp_pref ; unsigned int id <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ; } srvr = SSL_get_srtp_profiles ( s ) ; s -> srtp_profile = NULL ; srtp_pref = sk_SRTP_PROTECTION_PROFILE_num ( srvr <S2SV_ModEnd> ) ; while <S2SV_ModStart> -= 2 ; for ( i = 0 ; i < srtp_pref ; i ++ ) { sprof = sk_SRTP_PROTECTION_PROFILE_value ( srvr , i ) ; if ( sprof <S2SV_ModEnd> -> id == <S2SV_ModStart> -> id == <S2SV_ModEnd> id ) { <S2SV_ModStart> = sprof ; srtp_pref = i ; break ; } } } mki_len = * d ; d ++ ; len -- ; if ( mki_len != len ) { SSLerr ( SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT , SSL_R_BAD_SRTP_MKI_VALUE ) ; * al = SSL_AD_DECODE_ERROR ; return 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> } if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> endif if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) &&
<S2SV_ModStart> else if ( SSL_IS_DTLS ( s ) &&
<S2SV_ModStart> ( ( data ^ PSW_USER_BITS ) <S2SV_ModStart> ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return -
<S2SV_ModStart> mlen ) ) { EVP_CIPHER_CTX_cleanup ( & ctx ) ; <S2SV_ModStart> goto tickerr ; }
<S2SV_ModStart> mlen ) ) { EVP_CIPHER_CTX_cleanup ( & ctx ) ; return 2 ; } <S2SV_ModEnd> p = etick
<S2SV_ModStart> mlen ) ) { EVP_CIPHER_CTX_cleanup ( & ctx ) ; <S2SV_ModStart> goto tickerr ; }
<S2SV_ModStart> mlen ) ) { EVP_CIPHER_CTX_cleanup ( & ctx ) ; return 2 ; } <S2SV_ModEnd> p = etick
<S2SV_ModStart> mlen ) ) { EVP_CIPHER_CTX_cleanup ( & ctx ) ; return 2 ; } <S2SV_ModEnd> p = etick
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ; } else # endif
<S2SV_ModStart> ) ) { s -> method = ssl23_get_server_method ( s -> version ) ; if ( s -> method == NULL ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ; goto err ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> # if 0
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ; } else # endif
<S2SV_ModStart> ) ) { s -> method = ssl23_get_server_method ( s -> version ) ; if ( s -> method == NULL ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ; goto err ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> # if 0
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ; } else # endif
<S2SV_ModStart> ) ) { s -> method = ssl23_get_server_method ( s -> version ) ; if ( s -> method == NULL ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ; goto err ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> # if 0
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ; } else # endif
<S2SV_ModStart> ) ) { s -> method = ssl23_get_server_method ( s -> version ) ; if ( s -> method == NULL ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ; goto err ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> # if 0
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ; } else # endif
<S2SV_ModStart> ) ) { s -> method = ssl23_get_server_method ( s -> version ) ; if ( s -> method == NULL ) { SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ; goto err ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> # if 0
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SSL3 <S2SV_ModStart> ) ) ; # endif <S2SV_ModEnd> if ( ver
<S2SV_ModStart> ) ) { const SSL_METHOD * new_method ; new_method <S2SV_ModEnd> = ssl23_get_server_method ( <S2SV_ModStart> ; if ( new_method <S2SV_ModEnd> == NULL ) <S2SV_ModStart> err ; } s -> method = new_method ;
<S2SV_ModStart> ) ) { const SSL_METHOD * new_method ; new_method <S2SV_ModEnd> = ssl23_get_server_method ( <S2SV_ModStart> ; if ( new_method <S2SV_ModEnd> == NULL ) <S2SV_ModStart> err ; } s -> method = new_method ;
<S2SV_ModStart> ) ) { const SSL_METHOD * new_method ; new_method <S2SV_ModEnd> = ssl23_get_server_method ( <S2SV_ModStart> ; if ( new_method <S2SV_ModEnd> == NULL ) <S2SV_ModStart> err ; } s -> method = new_method ;
<S2SV_ModStart> ) ) { const SSL_METHOD * new_method ; new_method <S2SV_ModEnd> = ssl23_get_server_method ( <S2SV_ModStart> ; if ( new_method <S2SV_ModEnd> == NULL ) <S2SV_ModStart> err ; } s -> method = new_method ;
<S2SV_ModStart> ) ) { const SSL_METHOD * new_method ; new_method <S2SV_ModEnd> = ssl23_get_server_method ( <S2SV_ModStart> ; if ( new_method <S2SV_ModEnd> == NULL ) <S2SV_ModStart> err ; } s -> method = new_method ;
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> DTLS1_VERSION ) { if ( s -> s3 -> rbuf . left == 0 && extend ) return 0 ;
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al =
<S2SV_ModStart> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kEDH | SSL_kEECDH ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al =
<S2SV_ModStart> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al =
<S2SV_ModStart> n ) ; alg = s -> s3 -> tmp . new_cipher -> algorithms ; EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg & ( SSL_kEDH | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> param_len = 0 <S2SV_ModEnd> ; al =
<S2SV_ModStart> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kEDH | SSL_kEECDH ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al =
<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn
<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
<S2SV_ModStart> , unsigned long npages <S2SV_ModEnd> ) { gfn_t <S2SV_ModStart> = gfn + npages <S2SV_ModEnd> ; gfn +=
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,
<S2SV_ModStart> msr ) { switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; }
<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct <S2SV_ModStart> dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; <S2SV_ModStart> -> _eip ; rc = <S2SV_ModStart> , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc
<S2SV_ModStart> -> _eip ; rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> case 4 : rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val )
<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> == 0 ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }
<S2SV_ModStart> int rc ; unsigned long eip <S2SV_ModEnd> ; rc = <S2SV_ModStart> ctxt , & eip <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip
<S2SV_ModStart> ; u64 msr_data , rcx , rdx <S2SV_ModStart> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> -> _eip = rdx <S2SV_ModEnd> ; * reg_write <S2SV_ModStart> VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE
<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct <S2SV_ModStart> rel ) { return
<S2SV_ModStart> eflags ) ) rc = <S2SV_ModStart> case 0xeb : rc = <S2SV_ModStart> eflags ) ) rc =
<S2SV_ModStart> , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;
<S2SV_ModStart> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> , VCPU_SREG_CS ) <S2SV_ModStart> , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> 2 ) ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> ) return X86EMUL_CONTINUE <S2SV_ModStart> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModStart> return rc ; rc = assign_eip_far ( ctxt <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; unsigned long eip , cs ; u16 old_cs <S2SV_ModEnd> ; int cpl <S2SV_ModStart> ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> ctxt , & eip <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> ) return rc <S2SV_ModEnd> ; rc = <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> return rc ;
<S2SV_ModStart> cpl , false , NULL
<S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> sctp_verify_asconf ( const <S2SV_ModStart> asoc , struct sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> , struct sctp_paramhdr <S2SV_ModStart> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> ; union sctp_params <S2SV_ModStart> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> param . v <S2SV_ModStart> param . v != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * hdr ; __u32 serial <S2SV_ModEnd> ; if ( <S2SV_ModStart> serial ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( asoc , chunk , true , <S2SV_ModEnd> & err_param )
<S2SV_ModStart> ( asoc , asconf_ack , false , <S2SV_ModEnd> & err_param )
<S2SV_ModStart> { if ( sctp_chunk_pending ( ack ) ) continue ; if (
<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( "+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }
<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> inode ) { struct user_namespace * ns ; <S2SV_ModStart> return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (
<S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> , ENC_NA ) <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> , pinfo -> <S2SV_ModStart> , 0 , tvb_captured_length ( tvb ) <S2SV_ModEnd> , "Frame<S2SV_blank>%u:<S2SV_blank>%u<S2SV_blank>byte%s<S2SV_blank>on<S2SV_blank>wire" , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> , "This<S2SV_blank>frame<S2SV_blank>is<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>ignored" )
<S2SV_ModStart> rd_dev ) { struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> sg_tables , total_sg_needed <S2SV_ModStart> ) ) ; int rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> = sg_tables ; rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of"
<S2SV_ModStart> ) { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array
<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
<S2SV_ModStart> ; ue -> card = card ; ue ->
<S2SV_ModStart> -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> -> tlv_data ) { ret = <S2SV_ModEnd> - ENXIO ; <S2SV_ModStart> - ENXIO ; goto err_unlock ; } <S2SV_ModStart> -> tlv_data_size ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto err_unlock ; } <S2SV_ModStart> tlv_data_size ) ) ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;
<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> -> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
<S2SV_ModStart> snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
<S2SV_ModStart> if ( ! list_empty ( & asoc -> asocs ) <S2SV_ModEnd> ) { list_del
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
<S2SV_ModStart> } # endif # ifndef OPENSSL_NO_SRP if ( ! ( s -> srp_ctx . srp_Mask & SSL_kSRP ) ) { c -> mask_a |= SSL_aSRP ; c -> mask_k |= SSL_kSRP ; } # endif
<S2SV_ModStart> f_err ; } # ifndef OPENSSL_NO_SRP if ( ( ( c -> algorithm_mkey & SSL_kSRP ) || ( c -> algorithm_auth & SSL_aSRP ) ) && ! ( s -> srp_ctx . srp_Mask & SSL_kSRP ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_SERVER_HELLO , SSL_R_WRONG_CIPHER_RETURNED ) ; goto f_err ; } # endif
<S2SV_ModStart> ; # endif # ifndef OPENSSL_NO_SRP if ( ( ( c -> algorithm_mkey & SSL_kSRP ) || ( c -> algorithm_auth & SSL_aSRP ) ) && ! ( s -> srp_ctx . srp_Mask & SSL_kSRP ) ) continue ; # endif
<S2SV_ModStart> ; if ( * length > 0 && <S2SV_ModStart> } if ( * length > 0 &&
<S2SV_ModStart> ; length = tvb_captured_length <S2SV_ModEnd> ( tvb ) <S2SV_ModStart> ; if ( length > 0 && <S2SV_ModStart> else if ( length > 1 &&
<S2SV_ModStart> ; if ( * length > 0 && <S2SV_ModStart> } if ( * length > 0 &&
<S2SV_ModStart> ; length = tvb_captured_length <S2SV_ModEnd> ( tvb ) <S2SV_ModStart> ; if ( length > 0 && <S2SV_ModStart> else if ( length > 1 &&
<S2SV_ModStart> 0 , MAX_APN_LENGTH + 1
<S2SV_ModStart> 0 , MAX_APN_LENGTH + 1
<S2SV_ModStart> ; default : li [ num_li ] . len = li [ num_li ] . li - prev_li ; <S2SV_ModStart> 1 ; } <S2SV_ModEnd> prev_li = li
<S2SV_ModStart> ) && ( pad < 8 * len ) && (
<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
<S2SV_ModStart> ; if ( ! mnt_may_suid ( <S2SV_ModStart> f_path . mnt ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; if ( ! mnt_may_suid ( <S2SV_ModStart> f_path . mnt ) <S2SV_ModEnd> ) return ;
<S2SV_ModStart> int nosuid = ! mnt_may_suid <S2SV_ModStart> f_path . mnt <S2SV_ModEnd> ) ; int
<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
<S2SV_ModStart> mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV
<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
<S2SV_ModStart> inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = <S2SV_ModStart> , inode , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; }
<S2SV_ModStart> inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;
<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
<S2SV_ModStart> inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = <S2SV_ModStart> , inode , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; }
<S2SV_ModStart> inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;
<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , "too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy" "<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; void * preply = & reply ; void * <S2SV_ModStart> end , & preply <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; void * preply = & reply ; void * <S2SV_ModStart> end , & preply <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; void * preply = & reply ; void * <S2SV_ModStart> end , & preply <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> guint8 rtp_payload_type ; rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload ; <S2SV_ModStart> * rtp_dyn_payload ; rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; rtp_dyn_payload_used <S2SV_ModStart> ) ) { rtp_dyn_payload_insert ( rtp_dyn_payload , rtp_payload_type , mime_type , sample_rate ) ; rtp_dyn_payload_used = TRUE ; first_assigned_found = TRUE ; rtp_add_address ( pinfo , & data_p -> rtp_src_addr , data_p -> rtp_port , 0 , "IOS5" , pinfo -> fd -> num , FALSE , rtp_dyn_payload ) ; } if ( in_band_format_assigned ) { rtp_dyn_payload_insert ( rtp_dyn_payload , rtp_payload_type , "telephone-event" , sample_rate <S2SV_ModEnd> ) ; rtp_dyn_payload_used <S2SV_ModStart> FALSE ) { rtp_dyn_payload_free <S2SV_ModEnd> ( rtp_dyn_payload )
<S2SV_ModStart> * p_conv ; rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> rtp_dyn_payload = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> FALSE ; } rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert <S2SV_ModEnd> ( rtp_dyn_payload , <S2SV_ModStart> ( rtp_dyn_payload , 97 , "rtp-midi" , 10000 <S2SV_ModEnd> ) ; rtp_add_address
<S2SV_ModStart> upcoming_channel_lcl ) { rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> 0 ) { rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert ( rtp_dyn_payload , upcoming_channel_lcl -> rfc2198 , "red" , 8000 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> upcoming_channel_lcl ) { rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> 0 ) { rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert ( rtp_dyn_payload , upcoming_channel_lcl -> rfc2198 , "red" , 8000 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , # line 481 <S2SV_ModEnd> "../../asn1/h245/packet-h245-template.c" } ; <S2SV_ModStart> , # line 488 <S2SV_ModEnd> "../../asn1/h245/packet-h245-template.c" } ;
<S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; local_transport_info <S2SV_ModStart> ) ) { const gchar * payload_type_str = rtp_dyn_payload_get_name <S2SV_ModEnd> ( local_transport_info . <S2SV_ModStart> . rtp_dyn_payload , <S2SV_ModEnd> local_transport_info . media <S2SV_ModStart> ; if ( payload_type_str <S2SV_ModEnd> ) { if <S2SV_ModStart> -> summary_str , payload_type_str <S2SV_ModEnd> , 50 ) <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info ->
<S2SV_ModStart> * attribute_value ; <S2SV_ModEnd> guint8 pt ; <S2SV_ModStart> master_salt_length = 0 <S2SV_ModEnd> ; offset = <S2SV_ModStart> return ; } <S2SV_ModEnd> transport_info -> encoding_name <S2SV_ModStart> ++ ) { rtp_dyn_payload_insert <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> . rtp_dyn_payload , pt , <S2SV_ModEnd> transport_info -> encoding_name <S2SV_ModStart> [ pt ] , <S2SV_ModEnd> transport_info -> sample_rate <S2SV_ModStart> [ pt ] ) ; } return ; } rtp_dyn_payload_insert <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> . rtp_dyn_payload , pt , transport_info -> encoding_name [ pt ] , transport_info -> sample_rate [ pt ] <S2SV_ModEnd> ) ; break
<S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; transport_info <S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; } <S2SV_ModStart> DPRINT ( ( "set_rtp<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> DPRINT ( ( "media_count<S2SV_blank>==<S2SV_blank>-1,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> DPRINT ( ( "media_count<S2SV_blank>!=<S2SV_blank>-1,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info ->
<S2SV_ModStart> rtp_dyn_payload ) { const gchar * encoding_name = rtp_dyn_payload_get_name <S2SV_ModEnd> ( p_conv_data -> <S2SV_ModStart> -> rtp_dyn_payload , <S2SV_ModEnd> strinfo -> pt <S2SV_ModStart> ; if ( encoding_name <S2SV_ModEnd> ) { strinfo <S2SV_ModStart> = g_strdup ( <S2SV_ModEnd> encoding_name ) ;
<S2SV_ModStart> guint8 rtp_payload_type ; rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload ; <S2SV_ModStart> * rtp_dyn_payload ; rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; rtp_dyn_payload_used <S2SV_ModStart> ) ) { rtp_dyn_payload_insert ( rtp_dyn_payload , rtp_payload_type , mime_type , sample_rate ) ; rtp_dyn_payload_used = TRUE ; first_assigned_found = TRUE ; rtp_add_address ( pinfo , & data_p -> rtp_src_addr , data_p -> rtp_port , 0 , "IOS5" , pinfo -> fd -> num , FALSE , rtp_dyn_payload ) ; } if ( in_band_format_assigned ) { rtp_dyn_payload_insert ( rtp_dyn_payload , rtp_payload_type , "telephone-event" , sample_rate <S2SV_ModEnd> ) ; rtp_dyn_payload_used <S2SV_ModStart> FALSE ) { rtp_dyn_payload_free <S2SV_ModEnd> ( rtp_dyn_payload )
<S2SV_ModStart> * p_conv ; rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> rtp_dyn_payload = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> FALSE ; } rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert <S2SV_ModEnd> ( rtp_dyn_payload , <S2SV_ModStart> ( rtp_dyn_payload , 97 , "rtp-midi" , 10000 <S2SV_ModEnd> ) ; rtp_add_address
<S2SV_ModStart> upcoming_channel_lcl ) { rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> 0 ) { rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert ( rtp_dyn_payload , upcoming_channel_lcl -> rfc2198 , "red" , 8000 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> upcoming_channel_lcl ) { rtp_dyn_payload_t <S2SV_ModEnd> * rtp_dyn_payload = <S2SV_ModStart> 0 ) { rtp_dyn_payload = rtp_dyn_payload_new ( ) ; rtp_dyn_payload_insert ( rtp_dyn_payload , upcoming_channel_lcl -> rfc2198 , "red" , 8000 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , # line 481 <S2SV_ModEnd> "../../asn1/h245/packet-h245-template.c" } ; <S2SV_ModStart> , # line 488 <S2SV_ModEnd> "../../asn1/h245/packet-h245-template.c" } ;
<S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; local_transport_info <S2SV_ModStart> ) ) { const gchar * payload_type_str = rtp_dyn_payload_get_name <S2SV_ModEnd> ( local_transport_info . <S2SV_ModStart> . rtp_dyn_payload , <S2SV_ModEnd> local_transport_info . media <S2SV_ModStart> ; if ( payload_type_str <S2SV_ModEnd> ) { if <S2SV_ModStart> -> summary_str , payload_type_str <S2SV_ModEnd> , 50 ) <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info ->
<S2SV_ModStart> * attribute_value ; <S2SV_ModEnd> guint8 pt ; <S2SV_ModStart> master_salt_length = 0 <S2SV_ModEnd> ; offset = <S2SV_ModStart> return ; } <S2SV_ModEnd> transport_info -> encoding_name <S2SV_ModStart> ++ ) { rtp_dyn_payload_insert <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> . rtp_dyn_payload , pt , <S2SV_ModEnd> transport_info -> encoding_name <S2SV_ModStart> [ pt ] , <S2SV_ModEnd> transport_info -> sample_rate <S2SV_ModStart> [ pt ] ) ; } return ; } rtp_dyn_payload_insert <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> . rtp_dyn_payload , pt , transport_info -> encoding_name [ pt ] , transport_info -> sample_rate [ pt ] <S2SV_ModEnd> ) ; break
<S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; transport_info <S2SV_ModStart> . rtp_dyn_payload = rtp_dyn_payload_new ( <S2SV_ModEnd> ) ; } <S2SV_ModStart> DPRINT ( ( "set_rtp<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> DPRINT ( ( "media_count<S2SV_blank>==<S2SV_blank>-1,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> DPRINT ( ( "media_count<S2SV_blank>!=<S2SV_blank>-1,<S2SV_blank>calling<S2SV_blank>rtp_dyn_payload_free,<S2SV_blank>" <S2SV_ModEnd> "channel=%d,<S2SV_blank>media_port=%d" , n <S2SV_ModStart> ) ) ; rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info -> <S2SV_ModStart> set_rtp ) { rtp_dyn_payload_free <S2SV_ModEnd> ( transport_info ->
<S2SV_ModStart> rtp_dyn_payload ) { const gchar * encoding_name = rtp_dyn_payload_get_name <S2SV_ModEnd> ( p_conv_data -> <S2SV_ModStart> -> rtp_dyn_payload , <S2SV_ModEnd> strinfo -> pt <S2SV_ModStart> ; if ( encoding_name <S2SV_ModEnd> ) { strinfo <S2SV_ModStart> = g_strdup ( <S2SV_ModEnd> encoding_name ) ;
<S2SV_ModStart> tvb_lineend < tvb_len && linelen > 0
<S2SV_ModStart> , tvb , offset_e <S2SV_ModEnd> [ i ] <S2SV_ModStart> 4 , & ts_end <S2SV_ModEnd> [ i ]
<S2SV_ModStart> ; s = tvb_get_string_enc ( wmem_packet_scope ( ) , <S2SV_ModEnd> tvb , offset <S2SV_ModStart> offset , l , ENC_ASCII
<S2SV_ModStart> ; s = tvb_get_string_enc ( wmem_packet_scope ( ) , <S2SV_ModEnd> tvb , offset <S2SV_ModStart> offset , l , ENC_ASCII
<S2SV_ModStart> } if ( locator_type <= 2 <S2SV_ModEnd> ) { ti_loc
<S2SV_ModStart> ; const guchar * token , <S2SV_ModStart> 5 , & token <S2SV_ModEnd> ) ; if <S2SV_ModStart> = get_token_len ( token <S2SV_ModEnd> , line + <S2SV_ModStart> ( response_chars , token <S2SV_ModEnd> , 3 )
<S2SV_ModStart> abort_type = SESSION_NO_ABORT ; session . pres_ctx_id = 0
<S2SV_ModStart> ; while ( pin < pin_end <S2SV_ModEnd> ) { bit_mask <S2SV_ModStart> bit_mask ) { if ( pin + 2 >= pin_end ) { * err = WTAP_ERR_UNC_TRUNCATED ; return ( - 1 ) ; } <S2SV_ModStart> += 2 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) ) { if ( pout + 1 > pout_end ) { * err = WTAP_ERR_UNC_OVERFLOW ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> } return (
<S2SV_ModStart> ; while ( pin < pin_end <S2SV_ModEnd> ) { bit_mask <S2SV_ModStart> bit_mask ) { if ( pin + 2 >= pin_end ) { * err = WTAP_ERR_UNC_TRUNCATED ; return ( - 1 ) ; } <S2SV_ModStart> += 2 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) ) { if ( pout + 1 > pout_end ) { * err = WTAP_ERR_UNC_OVERFLOW ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> } return (
<S2SV_ModStart> ; while ( pin < pin_end <S2SV_ModEnd> ) { bit_mask <S2SV_ModStart> bit_mask ) { if ( pin + 2 >= pin_end ) { * err = WTAP_ERR_UNC_TRUNCATED ; return ( - 1 ) ; } <S2SV_ModStart> += 2 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) ) { if ( pout + 1 > pout_end ) { * err = WTAP_ERR_UNC_OVERFLOW ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> } return (
<S2SV_ModStart> ; while ( pin < pin_end <S2SV_ModEnd> ) { bit_mask <S2SV_ModStart> bit_mask ) { if ( pin + 2 >= pin_end ) { * err = WTAP_ERR_UNC_TRUNCATED ; return ( - 1 ) ; } <S2SV_ModStart> += 2 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) ) { if ( pout + 1 > pout_end ) { * err = WTAP_ERR_UNC_OVERFLOW ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } if ( pout - offset + length > pout ) { * err = WTAP_ERR_UNC_BAD_OFFSET ; return ( - 1 ) ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> } return (
<S2SV_ModStart> tree ) ; if ( tcon )
<S2SV_ModStart> struct static_key * once_key <S2SV_ModEnd> ) { static <S2SV_ModStart> ; __net_random_once_disable_jump ( once_key <S2SV_ModEnd> ) ; return
<S2SV_ModStart> work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
<S2SV_ModStart> ) ) ; if ( af == NULL ) break ;
<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
<S2SV_ModStart> goto out4 ; if ( ! is_path_reachable ( new_mnt , new . dentry , & root ) ) goto out4 ;
<S2SV_ModStart> ) ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ;
<S2SV_ModStart> return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL
<S2SV_ModStart> * info ; int i ; <S2SV_ModStart> = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
<S2SV_ModStart> , & attrs ) ; if ( ( PAGE_ALIGN ( addr + size ) <= size ) || ( PAGE_ALIGN ( addr + size ) <= addr ) ) return ERR_PTR ( - EINVAL
<S2SV_ModStart> ) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = current ; <S2SV_ModEnd> BUG_ON ( !
<S2SV_ModStart> task = current <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) ; } <S2SV_ModEnd> atomic_long_set ( &
<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
<S2SV_ModStart> -> i_mapping ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> f_op ) ; <S2SV_ModEnd> if ( f
<S2SV_ModStart> goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; <S2SV_ModEnd> if ( list_lru_init <S2SV_ModStart> & s -> s_inode_lru <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto fail ; <S2SV_ModEnd> INIT_LIST_HEAD ( &
<S2SV_ModStart> s_inode_lru ) ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> force ) { sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
<S2SV_ModStart> DSA_SIG * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ; <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
<S2SV_ModStart> , unsigned long npages <S2SV_ModEnd> ) { gfn_t <S2SV_ModStart> = gfn + npages <S2SV_ModEnd> ; gfn +=
<S2SV_ModStart> OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
<S2SV_ModStart> ( sha1_digest_buf , STATE_MIN_ACCESS_LEN <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ; struct_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> + 4 , amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> , 4 + amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> + 4 , amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> , 4 + amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> + 4 , amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> , 4 + amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> { arg_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> length ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> length ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> length ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> length ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> length ) ; <S2SV_ModEnd> ti = proto_tree_add_item
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> tvb , offset <S2SV_ModEnd> ) ; proto_tree_add_item <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti
<S2SV_ModStart> { struct_size = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; proto_tree_add_item ( args_tree , hf_amqp_0_10_method_execution_description , tvb , offset + 2 , size , ENC_ASCII | ENC_NA ) ; AMQP_INCREMENT ( offset , ( <S2SV_ModEnd> 2 + size <S2SV_ModStart> + size ) <S2SV_ModEnd> , length ) <S2SV_ModStart> { struct_size = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree
<S2SV_ModStart> { struct_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti
<S2SV_ModStart> value ) ; field_length = AMQP_0_10_SIZE_MAX ( field_length ) ; <S2SV_ModStart> : field_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 1 + namelen <S2SV_ModEnd> + 1 + <S2SV_ModStart> : field_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> offset ) ; ti = proto_tree_add_item ( args_tree , hf_amqp_0_10_method_message_accept_transfers , tvb , offset , size + 2 , ENC_NA ) ; AMQP_INCREMENT ( offset , 2 , length ) ; format_amqp_0_10_sequence_set ( tvb , offset , size , ti ) ; AMQP_INCREMENT ( offset , size , length ) ; } if ( flag1 & 0x02 ) { proto_tree_add_item ( args_tree , hf_amqp_0_10_method_message_transfer_reject_code , tvb , offset , 2 , ENC_BIG_ENDIAN <S2SV_ModEnd> ) ; AMQP_INCREMENT <S2SV_ModStart> length ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> tvb , offset <S2SV_ModEnd> ) ; proto_tree_add_item <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_size = amqp_0_10_get_32bit_size ( tvb , offset <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree
<S2SV_ModStart> offset ) ; ti = proto_tree_add_item ( args_tree , hf_amqp_0_10_method_session_commands , tvb , offset , size + 2 , ENC_NA ) ; AMQP_INCREMENT ( offset , 2 , length ) ; format_amqp_0_10_sequence_set ( tvb , offset , size , ti ) ; AMQP_INCREMENT ( offset , size + <S2SV_ModEnd> 2 , length <S2SV_ModStart> { array_size = amqp_0_10_get_32bit_size ( tvb , offset <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; ti = proto_tree_add_item ( args_tree , hf_amqp_0_10_method_session_commands , tvb , offset , size + 2 , ENC_NA ) ; AMQP_INCREMENT ( offset , 2 , length ) ; format_amqp_0_10_sequence_set ( tvb , offset , size , ti ) ; AMQP_INCREMENT ( offset , size + <S2SV_ModEnd> 2 , length <S2SV_ModStart> { array_size = amqp_0_10_get_32bit_size ( tvb , offset <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> offset ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> offset ) ; <S2SV_ModEnd> ti = proto_tree_add_item
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , length <S2SV_ModEnd> ) ; ti <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> ; array_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; args_tree = <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( args_tree
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; result = <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( result <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb , <S2SV_ModStart> 4 , max_length <S2SV_ModEnd> ) ; ti
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; props = <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; args_tree =
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; frag = <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; result = <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( result <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( result <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size ( tvb , offset ) ; AMQP_INCREMENT ( offset , 4 , max_length <S2SV_ModEnd> ) ; ti
<S2SV_ModStart> = offset + AMQP_0_10_SIZE_MAX ( struct_length ) <S2SV_ModEnd> ; props = <S2SV_ModStart> { map_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( xid_tree <S2SV_ModStart> offset ) ; <S2SV_ModEnd> proto_tree_add_item ( xid_tree
<S2SV_ModStart> ) string_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> ) bin_length = amqp_0_10_get_32bit_size <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> in_struct = FALSE ; buffer [ 0 ] = '\\0'
<S2SV_ModStart> ) ) , MIN ( <S2SV_ModStart> ( tree_pointer ) ) , buffer_size
<S2SV_ModStart> } else { guint32 step ; step = dissect_unknown_data ( tn5250_tree , tvb , offset , start , length ) ; if ( step == 0 ) break ; offset += step ; } } break ; default : done = 1 ; break ; } } <S2SV_ModStart> , start , <S2SV_ModEnd> sf_length ) ;
<S2SV_ModStart> ENC_BIG_ENDIAN ) ; if ( length == 0 ) break ;
<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
<S2SV_ModStart> , CAP_SETGID ) && userns_may_setgroups ( user_ns )
<S2SV_ModStart> -> f_cred -> euid <S2SV_ModEnd> ) ) return
<S2SV_ModStart> true ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> new_map ) { const struct cred * cred = file -> f_cred ; <S2SV_ModStart> count == 1 ) && uid_eq ( ns -> owner , cred -> euid <S2SV_ModStart> ( uid , cred <S2SV_ModEnd> -> euid )
<S2SV_ModStart> ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> next -> ds <S2SV_ModEnd> ) ; if
<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
<S2SV_ModStart> , size - skb_out <S2SV_ModEnd> -> len ,
<S2SV_ModStart> nikeys ) ; if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart> key -> user <S2SV_ModEnd> ) ; kfree
<S2SV_ModStart> 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
<S2SV_ModStart> name ) , "crypto-%s" <S2SV_ModEnd> , name )
<S2SV_ModStart> src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item *
<S2SV_ModStart> btrfs_dir_item * di = NULL <S2SV_ModStart> - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , <S2SV_ModEnd> di ) ; <S2SV_ModStart> out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } if ( di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_CREATE ) ) { ret = - EEXIST ; <S2SV_ModStart> goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> ; goto out <S2SV_ModStart> out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> ret = btrfs_delete_one_dir_name <S2SV_ModStart> goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out :
<S2SV_ModStart> mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
<S2SV_ModStart> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }
<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> ; int err <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> ! bh ) { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> symlink = bh <S2SV_ModStart> return 0 ; out_unlock_inode <S2SV_ModEnd> : up_read ( <S2SV_ModStart> page ) ; out_unmap :
<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct <S2SV_ModStart> char * to , int tolen <S2SV_ModStart> = 0 ; int comp_len ; <S2SV_ModStart> p = to ; tolen -- <S2SV_ModStart> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> += 3 ; tolen -= 3 ; <S2SV_ModStart> case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> += 2 ; tolen -= 2 ; <S2SV_ModStart> case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> ; * p <S2SV_ModStart> ++ = '/' ; tolen -- <S2SV_ModStart> = '\\0' ; return 0 ;
<S2SV_ModStart> b_data ; } err = <S2SV_ModStart> i_size , p , PAGE_SIZE <S2SV_ModStart> ( bh ) ; if ( err ) goto out_unlock_inode
<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,
<S2SV_ModStart> * newName , int newLen , <S2SV_ModStart> * udfName , int udfLen , <S2SV_ModEnd> uint8_t * fidName <S2SV_ModStart> ( newIndex < newLen <S2SV_ModEnd> ) newName [ <S2SV_ModStart> } maxFilenameLen = newLen - CRC_LEN <S2SV_ModEnd> - localExtIndex ; <S2SV_ModStart> ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ; newName [
<S2SV_ModStart> { if ( pte_valid_user <S2SV_ModEnd> ( pte )
<S2SV_ModStart> thread -> tp_value [ 0 ] <S2SV_ModStart> childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( )
<S2SV_ModStart> ) -> tp_value [ 0 ]
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
<S2SV_ModStart> , attr , attr -> size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
<S2SV_ModStart> inet_daddr ; struct dst_entry * dst ; struct <S2SV_ModStart> * rt ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ) { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> inet_opt = rcu_dereference <S2SV_ModStart> sk_bound_dev_if ) ; dst = <S2SV_ModEnd> ! IS_ERR ( <S2SV_ModStart> ( rt ) ? <S2SV_ModEnd> & rt -> <S2SV_ModStart> & rt -> dst : NULL ; sk_dst_set ( sk ,
<S2SV_ModStart> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( 0 <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( 0 <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( 0 <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( 0 <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( 0 <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> -> algorithms ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> ( l &
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithms ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> ( l &
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ; <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) OPENSSL_free ( rdata -> rbuf . buf ) ; <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> { int ret ; SSL_clear ( s )
<S2SV_ModStart> { int ret ; SSL_clear ( s )
<S2SV_ModStart> { int ret ; SSL_clear ( s )
<S2SV_ModStart> { int ret ; SSL_clear ( s )
<S2SV_ModStart> { int ret ; SSL_clear ( s )
<S2SV_ModStart> , pkey ) > 0 ) { <S2SV_ModEnd> return 2 ; <S2SV_ModStart> return 2 ; }
<S2SV_ModStart> , pkey ) > 0 ) { <S2SV_ModEnd> return 2 ; <S2SV_ModStart> return 2 ; }
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ERR_R_EC_LIB ) ; if ( a == NULL || * a != ret ) EC_KEY_free ( ret ) ; <S2SV_ModStart> NULL ; } if ( a ) * a = ret ;
<S2SV_ModStart> * ret ; int freeret = 0 ; <S2SV_ModStart> * pp ; if ( ! a || * a == NULL ) { freeret = 1 ; } <S2SV_ModStart> ; err : if ( freeret ) { <S2SV_ModStart> ret ) ; if ( a ) * a = NULL ; }
<S2SV_ModStart> err ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ; } } if ( a ) * a = ret ; <S2SV_ModStart> if ( ret && ( a == NULL || * a != ret )
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ERR_R_EC_LIB ) ; if ( a == NULL || * a != ret ) EC_KEY_free ( ret ) ; <S2SV_ModStart> NULL ; } if ( a ) * a = ret ;
<S2SV_ModStart> * ret ; int freeret = 0 ; <S2SV_ModStart> * pp ; if ( ! a || * a == NULL ) { freeret = 1 ; } <S2SV_ModStart> ; err : if ( freeret ) { <S2SV_ModStart> ret ) ; if ( a ) * a = NULL ; }
<S2SV_ModStart> err ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> EC_PKEY_NO_PUBKEY ; } if ( a ) * a = ret ; <S2SV_ModStart> if ( ret && ( a == NULL || * a != ret )
<S2SV_ModStart> err ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> EC_PKEY_NO_PUBKEY ; } if ( a ) * a = ret ; <S2SV_ModStart> if ( ret && ( a == NULL || * a != ret )
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ERR_R_EC_LIB ) ; if ( a == NULL || * a != ret ) EC_KEY_free ( ret ) ; <S2SV_ModStart> NULL ; } if ( a ) * a = ret ;
<S2SV_ModStart> * ret ; int freeret = 0 ; <S2SV_ModStart> * pp ; if ( ! a || * a == NULL ) { freeret = 1 ; } <S2SV_ModStart> ; err : if ( freeret ) { <S2SV_ModStart> ret ) ; if ( a ) * a = NULL ; }
<S2SV_ModStart> err ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> EC_PKEY_NO_PUBKEY ; } if ( a ) * a = ret ; <S2SV_ModStart> if ( ret && ( a == NULL || * a != ret )
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ERR_R_EC_LIB ) ; if ( a == NULL || * a != ret ) EC_KEY_free ( ret ) ; <S2SV_ModStart> NULL ; } if ( a ) * a = ret ;
<S2SV_ModStart> * ret ; int freeret = 0 ; <S2SV_ModStart> * pp ; if ( ! a || * a == NULL ) { freeret = 1 ; } <S2SV_ModStart> ; err : if ( freeret ) { <S2SV_ModStart> ret ) ; if ( a ) * a = NULL ; }
<S2SV_ModStart> err ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> EC_PKEY_NO_PUBKEY ; } if ( a ) * a = ret ; <S2SV_ModStart> if ( ret && ( a == NULL || * a != ret )
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> } else ret <S2SV_ModStart> ERR_R_EC_LIB ) ; if ( a == NULL || * a != ret ) EC_KEY_free ( ret ) ; <S2SV_ModStart> NULL ; } if ( a ) * a = ret ;
<S2SV_ModStart> * ret ; int freeret = 0 ; <S2SV_ModStart> * pp ; if ( ! a || * a == NULL ) { freeret = 1 ; } <S2SV_ModStart> ; err : if ( freeret ) { <S2SV_ModStart> ret ) ; if ( a ) * a = NULL ; }
<S2SV_ModStart> ctxt -> mode != X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) && ( <S2SV_ModStart> msr_data ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> ctxt -> eflags <S2SV_ModStart> u16 ) msr_data & <S2SV_ModEnd> ~ SELECTOR_RPL_MASK ; <S2SV_ModStart> + 8 ; if <S2SV_ModEnd> ( efer & <S2SV_ModStart> efer & EFER_LMA <S2SV_ModEnd> ) { cs <S2SV_ModStart> -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,
<S2SV_ModStart> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
<S2SV_ModStart> ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> args -> rmtblkcnt = 0 ; args -> rmtvaluelen <S2SV_ModStart> args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2
<S2SV_ModStart> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> ( name_rmt -> <S2SV_ModEnd> valueblk ) ; <S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; args . rmtvaluelen = valuelen ; args .
<S2SV_ModStart> ; int valuelen <S2SV_ModEnd> ; int nmap <S2SV_ModStart> ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
<S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; error <S2SV_ModStart> = args -> rmtvaluelen <S2SV_ModEnd> ; while (
<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
<S2SV_ModStart> if ( i && <S2SV_ModEnd> ssl_fill_hello_random ( s <S2SV_ModStart> client_random ) ) <= 0 ) goto err
<S2SV_ModStart> if ( i && <S2SV_ModEnd> ssl_fill_hello_random ( s <S2SV_ModStart> client_random ) ) <= 0 ) goto err
<S2SV_ModStart> break ; case V_ASN1_BOOLEAN : result = a -> value . boolean - b -> value . boolean ; break ; case
<S2SV_ModStart> ; if ( * pval ) { i = asn1_get_choice_selector ( pval , it ) ; if ( ( i >= 0 ) && ( i < it -> tcount ) ) { tt = it -> templates + i ; pchptr = asn1_get_field_ptr ( pval , tt ) ; ASN1_template_free ( pchptr , tt ) ; asn1_set_choice_selector ( pval , - 1 , it ) ; } } else if ( <S2SV_ModEnd> ! ASN1_item_ex_new ( <S2SV_ModStart> ++ ) { if ( tt -> flags & ASN1_TFLG_ADB_MASK ) { const ASN1_TEMPLATE * seqtt ; ASN1_VALUE * * pseqval ; seqtt = asn1_do_adb ( pval , tt , 1 ) ; pseqval = asn1_get_field_ptr ( pval , seqtt ) ; ASN1_template_free ( pseqval , seqtt ) ; } } for ( i = 0 , tt = it -> templates ; i < it -> tcount ; i ++ , tt ++ ) {
<S2SV_ModStart> ; if ( * pval ) { i = asn1_get_choice_selector ( pval , it ) ; if ( ( i >= 0 ) && ( i < it -> tcount ) ) { tt = it -> templates + i ; pchptr = asn1_get_field_ptr ( pval , tt ) ; ASN1_template_free ( pchptr , tt ) ; asn1_set_choice_selector ( pval , - 1 , it ) ; } } else if ( <S2SV_ModEnd> ! ASN1_item_ex_new ( <S2SV_ModStart> ++ ) { if ( tt -> flags & ASN1_TFLG_ADB_MASK ) { const ASN1_TEMPLATE * seqtt ; ASN1_VALUE * * pseqval ; seqtt = asn1_do_adb ( pval , tt , 1 ) ; pseqval = asn1_get_field_ptr ( pval , seqtt ) ; ASN1_template_free ( pseqval , seqtt ) ; } } for ( i = 0 , tt = it -> templates ; i < it -> tcount ; i ++ , tt ++ ) {
<S2SV_ModStart> ; if ( * pval ) { i = asn1_get_choice_selector ( pval , it ) ; if ( ( i >= 0 ) && ( i < it -> tcount ) ) { tt = it -> templates + i ; pchptr = asn1_get_field_ptr ( pval , tt ) ; ASN1_template_free ( pchptr , tt ) ; asn1_set_choice_selector ( pval , - 1 , it ) ; } } else if ( <S2SV_ModEnd> ! ASN1_item_ex_new ( <S2SV_ModStart> ++ ) { if ( tt -> flags & ASN1_TFLG_ADB_MASK ) { const ASN1_TEMPLATE * seqtt ; ASN1_VALUE * * pseqval ; seqtt = asn1_do_adb ( pval , tt , 1 ) ; pseqval = asn1_get_field_ptr ( pval , seqtt ) ; ASN1_template_free ( pseqval , seqtt ) ; } } for ( i = 0 , tt = it -> templates ; i < it -> tcount ; i ++ , tt ++ ) {
<S2SV_ModStart> ; if ( * pval ) { i = asn1_get_choice_selector ( pval , it ) ; if ( ( i >= 0 ) && ( i < it -> tcount ) ) { tt = it -> templates + i ; pchptr = asn1_get_field_ptr ( pval , tt ) ; ASN1_template_free ( pchptr , tt ) ; asn1_set_choice_selector ( pval , - 1 , it ) ; } } else if ( <S2SV_ModEnd> ! ASN1_item_ex_new ( <S2SV_ModStart> ++ ) { if ( tt -> flags & ASN1_TFLG_ADB_MASK ) { const ASN1_TEMPLATE * seqtt ; ASN1_VALUE * * pseqval ; seqtt = asn1_do_adb ( pval , tt , 1 ) ; pseqval = asn1_get_field_ptr ( pval , seqtt ) ; ASN1_template_free ( pseqval , seqtt ) ; } } for ( i = 0 , tt = it -> templates ; i < it -> tcount ; i ++ , tt ++ ) {
<S2SV_ModStart> ; if ( * pval ) { i = asn1_get_choice_selector ( pval , it ) ; if ( ( i >= 0 ) && ( i < it -> tcount ) ) { tt = it -> templates + i ; pchptr = asn1_get_field_ptr ( pval , tt ) ; ASN1_template_free ( pchptr , tt ) ; asn1_set_choice_selector ( pval , - 1 , it ) ; } } else if ( <S2SV_ModEnd> ! ASN1_item_ex_new ( <S2SV_ModStart> ++ ) { if ( tt -> flags & ASN1_TFLG_ADB_MASK ) { const ASN1_TEMPLATE * seqtt ; ASN1_VALUE * * pseqval ; seqtt = asn1_do_adb ( pval , tt , 1 ) ; pseqval = asn1_get_field_ptr ( pval , seqtt ) ; ASN1_template_free ( pseqval , seqtt ) ; } } for ( i = 0 , tt = it -> templates ; i < it -> tcount ; i ++ , tt ++ ) {
<S2SV_ModStart> x ) ; if ( pktmp == NULL ) goto err ;
<S2SV_ModStart> x ) ; if ( pktmp == NULL ) goto err ;
<S2SV_ModStart> x ) ; if ( pktmp == NULL ) goto err ;
<S2SV_ModStart> x ) ; if ( pktmp == NULL ) goto err ;
<S2SV_ModStart> x ) ; if ( pktmp == NULL ) goto err ;
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_NO_CONTENT ) ; return 0 ; } <S2SV_ModStart> os ) ; os = NULL ; <S2SV_ModStart> ( os ) ; os = NULL <S2SV_ModStart> ) ) { if ( os == NULL ) goto err ;
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> * x509 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_NO_CONTENT ) ; return 0 ; }
<S2SV_ModStart> p7 ) { if ( p7 == NULL || p7 -> d . ptr == NULL ) return NULL ;
<S2SV_ModStart> = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_NO_CONTENT ) ; return 0 ; } <S2SV_ModStart> os ) ; os = NULL ; <S2SV_ModStart> ( os ) ; os = NULL <S2SV_ModStart> ( p7 ) ) { if ( os == NULL ) goto err ; if ( <S2SV_ModEnd> ! ( os <S2SV_ModStart> ) ; } }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> * x509 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_NO_CONTENT ) ; return 0 ; }
<S2SV_ModStart> p7 ) { if ( p7 == NULL || p7 -> d . ptr == NULL ) return NULL ;
<S2SV_ModStart> = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_NO_CONTENT ) ; return 0 ; } <S2SV_ModStart> os ) ; os = NULL ; <S2SV_ModStart> ( os ) ; os = NULL <S2SV_ModStart> ( p7 ) ) { if ( os == NULL ) goto err ; if ( <S2SV_ModEnd> ! ( os <S2SV_ModStart> ) ; } }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> * x509 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_NO_CONTENT ) ; return 0 ; }
<S2SV_ModStart> p7 ) { if ( p7 == NULL || p7 -> d . ptr == NULL ) return NULL ;
<S2SV_ModStart> = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_NO_CONTENT ) ; return 0 ; } <S2SV_ModStart> os ) ; os = NULL ; <S2SV_ModStart> ( os ) ; os = NULL <S2SV_ModStart> ( p7 ) ) { if ( os == NULL ) goto err ; if ( <S2SV_ModEnd> ! ( os <S2SV_ModStart> ) ; } }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> * x509 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_NO_CONTENT ) ; return 0 ; }
<S2SV_ModStart> p7 ) { if ( p7 == NULL || p7 -> d . ptr == NULL ) return NULL ;
<S2SV_ModStart> = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAFINAL , PKCS7_R_NO_CONTENT ) ; return 0 ; } <S2SV_ModStart> os ) ; os = NULL ; <S2SV_ModStart> ( os ) ; os = NULL <S2SV_ModStart> ( p7 ) ) { if ( os == NULL ) goto err ; if ( <S2SV_ModEnd> ! ( os <S2SV_ModStart> ) ; } }
<S2SV_ModStart> = NULL ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAINIT , PKCS7_R_NO_CONTENT ) ; return NULL ; }
<S2SV_ModStart> * x509 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_INVALID_NULL_POINTER ) ; return 0 ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATAVERIFY , PKCS7_R_NO_CONTENT ) ; return 0 ; }
<S2SV_ModStart> p7 ) { if ( p7 == NULL || p7 -> d . ptr == NULL ) return NULL ;
<S2SV_ModStart> i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) )
<S2SV_ModStart> i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) )
<S2SV_ModStart> shared_sigalgs = NULL ; s -> cert -> shared_sigalgslen = 0
<S2SV_ModStart> shared_sigalgs = NULL ; c -> shared_sigalgslen = 0 <S2SV_ModStart> ; if ( nmatch ) { salgs = OPENSSL_malloc ( nmatch * sizeof ( TLS_SIGALGS ) ) ; if ( ! salgs ) return 0 ; nmatch = tls12_shared_sigalgs ( s , salgs , pref , preflen , allow , allowlen ) ; } else { salgs = NULL ; } c -> shared_sigalgs = salgs ; c -> shared_sigalgslen = nmatch ; <S2SV_ModEnd> return 1 ; <S2SV_ModStart> return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> shared_sigalgs = NULL ; s -> cert -> shared_sigalgslen = 0
<S2SV_ModStart> shared_sigalgs = NULL ; c -> shared_sigalgslen = 0 <S2SV_ModStart> ; if ( nmatch ) { salgs = OPENSSL_malloc ( nmatch * sizeof ( TLS_SIGALGS ) ) ; if ( ! salgs ) return 0 ; nmatch = tls12_do_shared_sigalgs ( salgs , pref , preflen , allow , allowlen ) ; } else { salgs = NULL ; } c -> shared_sigalgs = salgs ; c -> shared_sigalgslen = nmatch ; <S2SV_ModEnd> return 1 ; <S2SV_ModStart> return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> end ; } if ( eof > v ) { rv = - 1 ; goto end ; }
<S2SV_ModStart> session -> master_key_length <= <S2SV_ModEnd> ( int )
<S2SV_ModStart> ) ; } is_export = SSL_C_IS_EXPORT ( s -> session -> cipher ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & md , NULL , NULL , NULL ) ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS ) ; return ( 0 ) ; } if ( s -> session -> cipher -> algorithm2 & SSL2_CF_8_BYTE_ENC ) { is_export = 1 ; ek = 8 ; } else ek = 5 ; if ( ( ! is_export && s -> s2 -> tmp . clear != 0 ) || ( is_export && s -> s2 -> tmp . clear + ek != EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_BAD_LENGTH ) ; return - 1 ; } if ( ( is_export && s -> s2 -> tmp . enc < ek ) || ( ! is_export && s -> s2 -> tmp . enc < EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } <S2SV_ModStart> RSA_PKCS1_PADDING ) ; <S2SV_ModEnd> # if 1 <S2SV_ModStart> ! is_export && <S2SV_ModEnd> i != EVP_CIPHER_key_length <S2SV_ModStart> c ) ) <S2SV_ModEnd> || ( is_export <S2SV_ModStart> ( is_export && <S2SV_ModEnd> i != ek <S2SV_ModStart> != ek ) ) ) { ERR_clear_error ( ) ; if ( is_export ) i = ek ; else i = EVP_CIPHER_key_length ( c ) ; if ( RAND_pseudo_bytes ( & p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> tmp . clear ] <S2SV_ModEnd> , i ) <S2SV_ModStart> is_export ) i = EVP_CIPHER_key_length ( c ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> n , keya ; unsigned int <S2SV_ModEnd> ek ; unsigned <S2SV_ModStart> + ek != ( unsigned int ) <S2SV_ModStart> . enc < ( unsigned int ) <S2SV_ModStart> && i != ( int )
<S2SV_ModStart> n , keya ; unsigned int <S2SV_ModEnd> ek ; unsigned <S2SV_ModStart> + ek != ( unsigned int ) <S2SV_ModStart> . enc < ( unsigned int ) <S2SV_ModStart> && i != ( int )
<S2SV_ModStart> session -> master_key_length <= <S2SV_ModEnd> ( int )
<S2SV_ModStart> ) ; } is_export = SSL_C_IS_EXPORT ( s -> session -> cipher ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & md , NULL ) ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS ) ; return ( 0 ) ; } if ( s -> session -> cipher -> algorithm2 & SSL2_CF_8_BYTE_ENC ) { is_export = 1 ; ek = 8 ; } else ek = 5 ; if ( ( ! is_export && s -> s2 -> tmp . clear != 0 ) || ( is_export && s -> s2 -> tmp . clear + ek != EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_BAD_LENGTH ) ; return - 1 ; } if ( ( is_export && s -> s2 -> tmp . enc < ek ) || ( ! is_export && s -> s2 -> tmp . enc < EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } <S2SV_ModStart> RSA_PKCS1_PADDING ) ; <S2SV_ModEnd> # if 1 <S2SV_ModStart> ! is_export && <S2SV_ModEnd> i != EVP_CIPHER_key_length <S2SV_ModStart> c ) ) <S2SV_ModEnd> || ( is_export <S2SV_ModStart> ( is_export && <S2SV_ModEnd> i != ek <S2SV_ModStart> != ek ) ) ) { ERR_clear_error ( ) ; if ( is_export ) i = ek ; else i = EVP_CIPHER_key_length ( c ) ; if ( RAND_pseudo_bytes ( & p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> tmp . clear ] <S2SV_ModEnd> , i ) <S2SV_ModStart> is_export ) i = EVP_CIPHER_key_length ( c ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> session -> master_key_length <= <S2SV_ModEnd> ( int )
<S2SV_ModStart> ) ; } is_export = SSL_C_IS_EXPORT ( s -> session -> cipher ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & md , NULL , NULL , NULL ) ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS ) ; return ( 0 ) ; } if ( s -> session -> cipher -> algorithm2 & SSL2_CF_8_BYTE_ENC ) { is_export = 1 ; ek = 8 ; } else ek = 5 ; if ( ( ! is_export && s -> s2 -> tmp . clear != 0 ) || ( is_export && s -> s2 -> tmp . clear + ek != EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_BAD_LENGTH ) ; return - 1 ; } if ( ( is_export && s -> s2 -> tmp . enc < ek ) || ( ! is_export && s -> s2 -> tmp . enc < EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } <S2SV_ModStart> RSA_PKCS1_PADDING ) ; <S2SV_ModEnd> # if 1 <S2SV_ModStart> ! is_export && <S2SV_ModEnd> i != EVP_CIPHER_key_length <S2SV_ModStart> c ) ) <S2SV_ModEnd> || ( is_export <S2SV_ModStart> ( is_export && <S2SV_ModEnd> i != ek <S2SV_ModStart> != ek ) ) ) { ERR_clear_error ( ) ; if ( is_export ) i = ek ; else i = EVP_CIPHER_key_length ( c ) ; if ( RAND_pseudo_bytes ( & p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> tmp . clear ] <S2SV_ModEnd> , i ) <S2SV_ModStart> is_export ) i = EVP_CIPHER_key_length ( c ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> n , keya ; unsigned int <S2SV_ModEnd> ek ; unsigned <S2SV_ModStart> + ek != ( unsigned int ) <S2SV_ModStart> . enc < ( unsigned int ) <S2SV_ModStart> && i != ( int )
<S2SV_ModStart> n , keya ; unsigned int <S2SV_ModEnd> ek ; unsigned <S2SV_ModStart> + ek != ( unsigned int ) <S2SV_ModStart> . enc < ( unsigned int ) <S2SV_ModStart> && i != ( int )
<S2SV_ModStart> session -> master_key_length <= <S2SV_ModEnd> ( int )
<S2SV_ModStart> ) ; } is_export = SSL_C_IS_EXPORT ( s -> session -> cipher ) ; if ( ! ssl_cipher_get_evp ( s -> session , & c , & md , NULL , NULL , NULL ) ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_PROBLEMS_MAPPING_CIPHER_FUNCTIONS ) ; return ( 0 ) ; } if ( s -> session -> cipher -> algorithm2 & SSL2_CF_8_BYTE_ENC ) { is_export = 1 ; ek = 8 ; } else ek = 5 ; if ( ( ! is_export && s -> s2 -> tmp . clear != 0 ) || ( is_export && s -> s2 -> tmp . clear + ek != EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_BAD_LENGTH ) ; return - 1 ; } if ( ( is_export && s -> s2 -> tmp . enc < ek ) || ( ! is_export && s -> s2 -> tmp . enc < EVP_CIPHER_key_length ( c ) ) ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } <S2SV_ModStart> RSA_PKCS1_PADDING ) ; <S2SV_ModEnd> # if 1 <S2SV_ModStart> ! is_export && <S2SV_ModEnd> i != EVP_CIPHER_key_length <S2SV_ModStart> c ) ) <S2SV_ModEnd> || ( is_export <S2SV_ModStart> ( is_export && <S2SV_ModEnd> i != ek <S2SV_ModStart> != ek ) ) ) { ERR_clear_error ( ) ; if ( is_export ) i = ek ; else i = EVP_CIPHER_key_length ( c ) ; if ( RAND_pseudo_bytes ( & p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> tmp . clear ] <S2SV_ModEnd> , i ) <S2SV_ModStart> is_export ) i = EVP_CIPHER_key_length ( c ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) wmem_alloc ( pinfo -> pool <S2SV_ModEnd> , wccp_wccp_address_table . <S2SV_ModStart> ) wmem_alloc ( pinfo -> pool <S2SV_ModEnd> , wccp_wccp_address_table .
<S2SV_ModStart> packet_info * pinfo <S2SV_ModEnd> , proto_tree * <S2SV_ModStart> , item_length , pinfo , NULL <S2SV_ModEnd> ) ; return
<S2SV_ModStart> guint32 * ) wmem_alloc0 <S2SV_ModEnd> ( pinfo -> <S2SV_ModStart> e_in6_addr * ) wmem_alloc0 <S2SV_ModEnd> ( pinfo ->
<S2SV_ModStart> { # line 276 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" guint32 duration
<S2SV_ModStart> { # line 1249 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> ; # line 1159 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 1197 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> { # line 700 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" guint64 cnavE <S2SV_ModStart> ; # line 705 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" PROTO_ITEM_SET_HIDDEN (
<S2SV_ModStart> { # line 745 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" gint64 cnavIo <S2SV_ModStart> ; # line 750 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" PROTO_ITEM_SET_HIDDEN (
<S2SV_ModStart> { # line 686 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" gint64 cnavMo <S2SV_ModStart> ; # line 691 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" PROTO_ITEM_SET_HIDDEN (
<S2SV_ModStart> { # line 728 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" gint64 cnavOMEGA0 <S2SV_ModStart> ; # line 733 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" PROTO_ITEM_SET_HIDDEN (
<S2SV_ModStart> { # line 714 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" gint64 cnavOmega <S2SV_ModStart> ; # line 719 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" PROTO_ITEM_SET_HIDDEN (
<S2SV_ModStart> ; # line 859 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 383 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 387 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> ; # line 1153 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 464 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 467 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 1379 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> { # line 333 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 337 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> { # line 309 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 313 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> { # line 321 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 325 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> ; # line 976 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 780 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 783 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 787 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> ; # line 1156 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1138 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1135 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 853 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1144 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 856 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1129 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1042 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1036 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1045 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1039 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1033 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1126 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 1301 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> ; # line 874 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1168 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 1180 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> { # line 1087 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 1091 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> ; # line 1075 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 365 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t * <S2SV_ModStart> ; # line 369 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" if (
<S2SV_ModStart> { # line 1223 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> { # line 345 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> line 271 "../../asn1/lpp/lpp.cnf" if ( idx < 10 ) { <S2SV_ModStart> ] ) ; }
<S2SV_ModStart> { # line 1359 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> { # line 1327 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> ; # line 1132 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 297 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1117 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1069 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1111 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1057 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1120 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1072 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1114 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1066 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1063 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> ; # line 1108 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" proto_item_append_text (
<S2SV_ModStart> { # line 1278 <S2SV_ModEnd> "../../asn1/lpp/lpp.cnf" tvbuff_t *
<S2SV_ModStart> ; set_dnet_address ( pinfo , <S2SV_ModStart> ; set_dnet_address ( pinfo , <S2SV_ModStart> ; set_dnet_address ( pinfo , <S2SV_ModStart> ; set_dnet_address ( pinfo ,
<S2SV_ModStart> void set_dnet_address ( packet_info * pinfo , <S2SV_ModStart> , 1 , wmem_strdup ( pinfo -> pool , addr ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; size_t decrypt_len = 0 <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen ; <S2SV_ModStart> { if ( ( decrypt_len = <S2SV_ModStart> ( decrypt ) ) <S2SV_ModStart> , ENC_ASCII ) ; decrypt_len = linelen <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen - 10 ; <S2SV_ModStart> , ENC_ASCII ) ; decrypt_len = linelen - 10 <S2SV_ModStart> = NULL ; decrypt_len = 0 ;
<S2SV_ModStart> decrypt = NULL ; size_t decrypt_len <S2SV_ModStart> smtp_decryption_enabled ) && ( ( decrypt_len = <S2SV_ModEnd> ws_base64_decode_inplace ( decrypt <S2SV_ModStart> ws_base64_decode_inplace ( decrypt ) <S2SV_ModStart> = decrypt ; linelen = ( int ) decrypt_len ; <S2SV_ModStart> , linelen ) ; decrypt_len = linelen <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen ; <S2SV_ModStart> { if ( ( decrypt_len = <S2SV_ModStart> ( decrypt ) ) <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen ; <S2SV_ModStart> ( decrypt , decrypt_len <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen ; <S2SV_ModStart> { if ( ( decrypt_len = <S2SV_ModStart> ( decrypt ) ) <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen ; <S2SV_ModStart> ( decrypt , decrypt_len <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; if ( linelen >= 11 ) { if ( <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen - 11 ; <S2SV_ModStart> { if ( ( decrypt_len = <S2SV_ModStart> ws_base64_decode_inplace ( decrypt ) <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen - 11 ; <S2SV_ModStart> ( decrypt , decrypt_len ) ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ENC_NA ) ; if ( linelen >= 10 ) { <S2SV_ModStart> { if ( ( decrypt_len = <S2SV_ModStart> ws_base64_decode_inplace ( decrypt ) <S2SV_ModStart> ) ) ; } <S2SV_ModStart> ENC_ASCII ) ; decrypt_len = linelen - 4 ; if ( ( decrypt_len = <S2SV_ModEnd> ws_base64_decode_inplace ( decrypt <S2SV_ModStart> ws_base64_decode_inplace ( decrypt ) <S2SV_ModStart> ( decrypt , decrypt_len <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;
<S2SV_ModStart> ATTR_KILL_PRIV ) { error = security_inode_need_killpriv ( dentry ) ; if ( error < 0 ) return error ; if ( error == 0 ) ia_valid = <S2SV_ModStart> &= ~ ATTR_KILL_PRIV <S2SV_ModEnd> ; } if
<S2SV_ModStart> & ATTR_FORCE ) goto kill_priv <S2SV_ModEnd> ; if ( <S2SV_ModStart> EPERM ; } kill_priv : if ( ia_valid & ATTR_KILL_PRIV ) { int error ; error = security_inode_killpriv ( dentry ) ; if ( error ) return error ; }
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc
<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> && ! opt
<S2SV_ModStart> out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
<S2SV_ModStart> * ns ; list_for_each_entry ( chain <S2SV_ModEnd> , & ctx <S2SV_ModStart> goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> ) ; if <S2SV_ModStart> } list_for_each_entry_safe ( chain , nc <S2SV_ModEnd> , & ctx <S2SV_ModStart> -> table -> chains <S2SV_ModEnd> , list ) <S2SV_ModStart> list ) { ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> random_variable = 0 <S2SV_ModStart> { random_variable = ( unsigned long ) <S2SV_ModStart> get_random_int ( ) ; random_variable &= <S2SV_ModEnd> STACK_RND_MASK ; random_variable
<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
<S2SV_ModStart> if ( n > 1 ) { <S2SV_ModEnd> n2s ( p <S2SV_ModStart> i ) ; } else { if ( alg_k & SSL_kDHE ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE , SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG ) ; goto f_err ; } <S2SV_ModEnd> i = 0 <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> if ( n > 1 ) { <S2SV_ModEnd> n2s ( p <S2SV_ModStart> i ) ; } else { if ( alg_k & SSL_kDHE ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE , SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG ) ; goto f_err ; } <S2SV_ModEnd> i = 0 <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT <S2SV_ModStart> 1 if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT <S2SV_ModStart> 1 if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT <S2SV_ModStart> 1 if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT <S2SV_ModStart> 1 if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> -> krb5_client_princ_len = src <S2SV_ModEnd> -> krb5_client_princ_len ;
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> ) ) ; dest -> ciphers <S2SV_ModEnd> = NULL ; <S2SV_ModStart> # ifndef OPENSSL_NO_TLSEXT dest -> tlsext_hostname = NULL ; # endif dest -> tlsext_tick = NULL ; memset ( & dest -> ex_data , 0 , sizeof ( dest -> ex_data ) ) ; dest -> prev = NULL ; dest -> next = NULL ; dest -> references = 1 ; if ( src -> sess_cert != NULL ) CRYPTO_add ( & src -> sess_cert -> references , 1 , CRYPTO_LOCK_SSL_SESS_CERT ) ; if ( src -> peer != NULL ) CRYPTO_add ( & src -> peer -> references , 1 , CRYPTO_LOCK_X509 ) ; if ( src -> ciphers != NULL ) { dest -> ciphers = sk_SSL_CIPHER_dup ( src -> ciphers ) ; if ( dest -> ciphers == NULL ) goto err ; } if ( ! CRYPTO_dup_ex_data ( CRYPTO_EX_INDEX_SSL_SESSION , & dest -> ex_data , & src -> ex_data ) ) { goto err ; } # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> err ; } <S2SV_ModEnd> } # endif <S2SV_ModStart> { dest -> tlsext_tick = BUF_memdup ( src -> tlsext_tick , src -> tlsext_ticklen ) ; if ( dest -> tlsext_tick == NULL ) goto err ; } else { dest -> tlsext_tick_lifetime_hint = 0 <S2SV_ModEnd> ; dest -> <S2SV_ModStart> -> tlsext_ticklen = 0 ; <S2SV_ModEnd> } return dest
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> # ifndef OPENSSL_NO_PSK dest -> psk_identity_hint = NULL ; dest -> psk_identity = NULL ; # endif dest -> ciphers = NULL ; dest -> tlsext_hostname = NULL ; # ifndef OPENSSL_NO_EC dest -> tlsext_ecpointformatlist = NULL ; dest -> tlsext_ellipticcurvelist = NULL ; # endif dest -> tlsext_tick = NULL ; # ifndef OPENSSL_NO_SRP dest -> srp_username = NULL ; # endif memset ( & dest -> ex_data , 0 , sizeof ( dest -> ex_data ) ) ; dest -> prev = NULL ; dest -> next = NULL ; dest -> references = 1 ; <S2SV_ModEnd> if ( src <S2SV_ModStart> CRYPTO_LOCK_X509 ) ; # ifndef OPENSSL_NO_PSK if ( src -> psk_identity_hint ) { dest -> psk_identity_hint = BUF_strdup ( src -> psk_identity_hint ) ; if ( dest -> psk_identity_hint == NULL ) { goto err ; } } if ( src -> psk_identity ) { dest -> psk_identity = BUF_strdup ( src -> psk_identity ) ; if ( dest -> psk_identity == NULL ) { goto err ; } } # endif <S2SV_ModEnd> if ( src <S2SV_ModStart> err ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> err ; } <S2SV_ModEnd> if ( src <S2SV_ModStart> err ; } <S2SV_ModEnd> } # ifndef <S2SV_ModStart> goto err ; <S2SV_ModEnd> } if ( <S2SV_ModStart> goto err ; } <S2SV_ModEnd> # endif if <S2SV_ModStart> { dest -> tlsext_tick = BUF_memdup ( src -> tlsext_tick , src -> tlsext_ticklen ) ; if ( dest -> tlsext_tick == NULL ) goto err ; } else { dest -> tlsext_tick_lifetime_hint = 0 <S2SV_ModEnd> ; dest -> <S2SV_ModStart> -> tlsext_ticklen = 0 ; <S2SV_ModEnd> } # ifndef <S2SV_ModStart> # ifndef OPENSSL_NO_SRP if ( src -> srp_username ) { dest -> srp_username = BUF_strdup ( src -> srp_username ) ; if ( dest -> srp_username == NULL ) { goto err ; } <S2SV_ModEnd> } # endif
<S2SV_ModStart> -> krb5_client_princ_len = src <S2SV_ModEnd> -> krb5_client_princ_len ;
<S2SV_ModStart> ; # ifndef OPENSSL_NO_PSK dest -> psk_identity_hint = NULL ; dest -> psk_identity = NULL ; # endif dest -> ciphers = NULL ; # ifndef OPENSSL_NO_TLSEXT dest -> tlsext_hostname = NULL ; # ifndef OPENSSL_NO_EC dest -> tlsext_ecpointformatlist = NULL ; dest -> tlsext_ellipticcurvelist = NULL ; # endif # endif dest -> tlsext_tick = NULL ; # ifndef OPENSSL_NO_SRP dest -> srp_username = NULL ; # endif memset ( & dest -> ex_data , 0 , sizeof ( dest -> ex_data ) ) ; dest -> prev = NULL ; dest -> next = NULL ; dest -> references = 1 ; <S2SV_ModEnd> if ( src <S2SV_ModStart> CRYPTO_LOCK_X509 ) ; # ifndef OPENSSL_NO_PSK if ( src -> psk_identity_hint ) { dest -> psk_identity_hint = BUF_strdup ( src -> psk_identity_hint ) ; if ( dest -> psk_identity_hint == NULL ) { goto err ; } } if ( src -> psk_identity ) { dest -> psk_identity = BUF_strdup ( src -> psk_identity ) ; if ( dest -> psk_identity == NULL ) { goto err ; } } # endif <S2SV_ModEnd> if ( src <S2SV_ModStart> err ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> err ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> ; } } <S2SV_ModEnd> # ifndef OPENSSL_NO_EC <S2SV_ModStart> goto err ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) goto err <S2SV_ModEnd> ; } # <S2SV_ModStart> { dest -> tlsext_tick = BUF_memdup ( src -> tlsext_tick , src -> tlsext_ticklen ) ; if ( dest -> tlsext_tick == NULL ) goto err ; } else { dest -> tlsext_tick_lifetime_hint = 0 <S2SV_ModEnd> ; dest -> <S2SV_ModStart> -> tlsext_ticklen = 0 ; <S2SV_ModEnd> } # ifndef <S2SV_ModStart> # ifndef OPENSSL_NO_SRP if ( src -> srp_username ) { dest -> srp_username = BUF_strdup ( src -> srp_username ) ; if ( dest -> srp_username == NULL ) { goto err ; } <S2SV_ModEnd> } # endif
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> -> krb5_client_princ_len = src <S2SV_ModEnd> -> krb5_client_princ_len ;
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> ; # ifndef OPENSSL_NO_PSK dest -> psk_identity_hint = NULL ; dest -> psk_identity = NULL ; # endif dest -> ciphers = NULL ; # ifndef OPENSSL_NO_TLSEXT dest -> tlsext_hostname = NULL ; # ifndef OPENSSL_NO_EC dest -> tlsext_ecpointformatlist = NULL ; dest -> tlsext_ellipticcurvelist = NULL ; # endif # endif dest -> tlsext_tick = NULL ; # ifndef OPENSSL_NO_SRP dest -> srp_username = NULL ; # endif memset ( & dest -> ex_data , 0 , sizeof ( dest -> ex_data ) ) ; dest -> prev = NULL ; dest -> next = NULL ; dest -> references = 1 ; <S2SV_ModEnd> if ( src <S2SV_ModStart> CRYPTO_LOCK_X509 ) ; # ifndef OPENSSL_NO_PSK if ( src -> psk_identity_hint ) { dest -> psk_identity_hint = BUF_strdup ( src -> psk_identity_hint ) ; if ( dest -> psk_identity_hint == NULL ) { goto err ; } } if ( src -> psk_identity ) { dest -> psk_identity = BUF_strdup ( src -> psk_identity ) ; if ( dest -> psk_identity == NULL ) { goto err ; } } # endif <S2SV_ModEnd> if ( src <S2SV_ModStart> err ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> err ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> ; } } <S2SV_ModEnd> # ifndef OPENSSL_NO_EC <S2SV_ModStart> goto err ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) goto err <S2SV_ModEnd> ; } # <S2SV_ModStart> { dest -> tlsext_tick = BUF_memdup ( src -> tlsext_tick , src -> tlsext_ticklen ) ; if ( dest -> tlsext_tick == NULL ) goto err ; } else { dest -> tlsext_tick_lifetime_hint = 0 <S2SV_ModEnd> ; dest -> <S2SV_ModStart> -> tlsext_ticklen = 0 ; <S2SV_ModEnd> } # ifndef <S2SV_ModStart> # ifndef OPENSSL_NO_SRP if ( src -> srp_username ) { dest -> srp_username = BUF_strdup ( src -> srp_username ) ; if ( dest -> srp_username == NULL ) { goto err ; } <S2SV_ModEnd> } # endif
<S2SV_ModStart> ; # ifndef OPENSSL_NO_PSK dest -> psk_identity_hint = NULL ; dest -> psk_identity = NULL ; # endif dest -> ciphers = NULL ; # ifndef OPENSSL_NO_TLSEXT dest -> tlsext_hostname = NULL ; # ifndef OPENSSL_NO_EC dest -> tlsext_ecpointformatlist = NULL ; dest -> tlsext_ellipticcurvelist = NULL ; # endif # endif dest -> tlsext_tick = NULL ; memset ( & dest -> ex_data , 0 , sizeof ( dest -> ex_data ) ) ; dest -> prev = NULL ; dest -> next = NULL ; dest -> references = 1 ; if ( src -> sess_cert != NULL ) CRYPTO_add ( & src -> sess_cert -> references , 1 , CRYPTO_LOCK_SSL_SESS_CERT ) ; if ( src -> peer != NULL ) CRYPTO_add ( & src -> peer -> references , 1 , CRYPTO_LOCK_X509 ) ; <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK <S2SV_ModStart> ; } } <S2SV_ModEnd> if ( src <S2SV_ModStart> ; } } # endif <S2SV_ModEnd> if ( src <S2SV_ModStart> err ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> err ; } <S2SV_ModEnd> # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> ; } } <S2SV_ModEnd> # ifndef OPENSSL_NO_EC <S2SV_ModStart> goto err ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ) goto err <S2SV_ModEnd> ; } # <S2SV_ModStart> { dest -> tlsext_tick = BUF_memdup ( src -> tlsext_tick , src -> tlsext_ticklen ) ; if ( dest -> tlsext_tick == NULL ) goto err ; } else { dest -> tlsext_tick_lifetime_hint = 0 <S2SV_ModEnd> ; dest -> <S2SV_ModStart> -> tlsext_ticklen = 0 ; <S2SV_ModEnd> } return dest
<S2SV_ModStart> -> krb5_client_princ_len = src <S2SV_ModEnd> -> krb5_client_princ_len ;
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> num -- ; } <S2SV_ModStart> ctx -> last_untrusted = sk_X509_num ( ctx -> chain ) ; <S2SV_ModEnd> retry = 1
<S2SV_ModStart> num -- ; } <S2SV_ModStart> ctx -> last_untrusted = sk_X509_num ( ctx -> chain ) ; <S2SV_ModEnd> retry = 1
<S2SV_ModStart> 1 ; } if ( ctx -> chain != NULL ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED ) ; return - 1 ; } <S2SV_ModStart> ; if ( ( ( ctx -> chain = sk_X509_new_null ( ) ) <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> || ( ! <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( ctx
<S2SV_ModStart> num -- ; } <S2SV_ModStart> ctx -> last_untrusted = sk_X509_num ( ctx -> chain ) ; <S2SV_ModEnd> retry = 1
<S2SV_ModStart> 1 ; } if ( ctx -> chain != NULL ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED ) ; return - 1 ; } <S2SV_ModStart> ; if ( ( ( ctx -> chain = sk_X509_new_null ( ) ) <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> || ( ! <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( ctx
<S2SV_ModStart> 1 ; } if ( ctx -> chain != NULL ) { X509err ( X509_F_X509_VERIFY_CERT , ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED ) ; return - 1 ; } <S2SV_ModStart> ; if ( ( ( ctx -> chain = sk_X509_new_null ( ) ) <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> || ( ! <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( ctx
<S2SV_ModStart> ; if ( num <S2SV_ModEnd> == ctx ->
<S2SV_ModStart> * R ; if ( BN_is_zero ( mod ) ) return 0 ;
<S2SV_ModStart> ; if ( BN_is_zero ( dh -> p ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> ; if ( BN_is_zero ( dh -> g ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> -= param_len ; if ( BN_is_zero ( dh -> pub_key ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_VALUE ) ; goto f_err ; }
<S2SV_ModStart> * R ; if ( BN_is_zero ( mod ) ) return 0 ;
<S2SV_ModStart> ; if ( BN_is_zero ( dh -> p ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> ; if ( BN_is_zero ( dh -> g ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> -= param_len ; if ( BN_is_zero ( dh -> pub_key ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_VALUE ) ; goto f_err ; }
<S2SV_ModStart> * R ; if ( BN_is_zero ( mod ) ) return 0 ;
<S2SV_ModStart> ; if ( BN_is_zero ( dh -> p ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> ; if ( BN_is_zero ( dh -> g ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_VALUE ) ; goto f_err ; } if ( <S2SV_ModStart> -= param_len ; if ( BN_is_zero ( dh -> pub_key ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_VALUE ) ; goto f_err ; }
<S2SV_ModStart> size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> -> ops ; <S2SV_ModEnd> size_t chars = <S2SV_ModStart> buf -> len ; size_t written <S2SV_ModStart> ; int error <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ;
<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;
<S2SV_ModStart> ) { int ret = pci_read_config_word <S2SV_ModEnd> ( dev , <S2SV_ModStart> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> * value |= <S2SV_ModStart> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
<S2SV_ModStart> = TRUE ; } CATCH_ALL { is_atn_cpdlc = FALSE ; is_pm = FALSE ; } ENDTRY ; if ( is_atn_cpdlc ) { break ; } <S2SV_ModEnd> TRY { dissect_GroundPDUs_PDU <S2SV_ModStart> is_atn_cpdlc = TRUE <S2SV_ModEnd> ; } CATCH_ALL <S2SV_ModStart> = TRUE ; } CATCH_ALL { is_atn_cpdlc = FALSE ; is_pm = FALSE ; } ENDTRY ; if ( is_atn_cpdlc ) { break ; } <S2SV_ModEnd> TRY { dissect_AircraftPDUs_PDU <S2SV_ModStart> is_pm = FALSE <S2SV_ModEnd> ; } CATCH_ALL
<S2SV_ModStart> = TRUE ; } CATCH_ALL { is_atn_cpdlc = FALSE ; is_pm = FALSE ; } ENDTRY ; if ( is_atn_cpdlc ) { break ; } <S2SV_ModEnd> TRY { dissect_GroundPDUs_PDU <S2SV_ModStart> is_atn_cpdlc = TRUE <S2SV_ModEnd> ; } CATCH_ALL <S2SV_ModStart> = TRUE ; } CATCH_ALL { is_atn_cpdlc = FALSE ; is_pm = FALSE ; } ENDTRY ; if ( is_atn_cpdlc ) { break ; } <S2SV_ModEnd> TRY { dissect_AircraftPDUs_PDU <S2SV_ModStart> is_pm = FALSE <S2SV_ModEnd> ; } CATCH_ALL
<S2SV_ModStart> , # line 309 <S2SV_ModEnd> "../../asn1/atn-cpdlc/packet-atn-cpdlc-template.c" } ; <S2SV_ModStart> , # line 313 <S2SV_ModEnd> "../../asn1/atn-cpdlc/packet-atn-cpdlc-template.c" & ett_atn_cpdlc
<S2SV_ModStart> ( guint8 * dst , guint16 data_offset , guint16 data_cnt <S2SV_ModEnd> , int * <S2SV_ModStart> buf_end ) { const guint8 <S2SV_ModEnd> * src ; <S2SV_ModStart> * src ; <S2SV_ModEnd> src = (
<S2SV_ModStart> comp_flag_bits = 0 ; guint16 data_offset , data_cnt <S2SV_ModStart> if ( ! ( offset + 1 < cnt ) ) { THROW ( ReportedBoundsError ) ; } data_offset = pntoh16 ( src ) & WCP_OFFSET_MASK ; if ( ( * src & 0xf0 ) == 0x10 ) { if ( ! ( offset + 2 < cnt ) ) { THROW ( ReportedBoundsError ) ; } data_cnt = * ( src + 2 ) + 1 ; if ( tree ) { ti = proto_tree_add_item ( cd_tree , hf_wcp_long_run , src_tvb , offset , 3 , ENC_NA ) ; sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ) ; proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ) ; proto_tree_add_item ( sub_tree , hf_wcp_long_len , src_tvb , offset + 2 , 1 , ENC_BIG_ENDIAN ) ; } src += 3 ; offset += 3 ; } else { data_cnt = ( * src >> 4 ) + 1 ; if ( tree ) { ti = proto_tree_add_item ( cd_tree , hf_wcp_short_run , src_tvb , offset , 2 , ENC_NA ) ; sub_tree = proto_item_add_subtree ( ti , ett_wcp_field ) ; proto_tree_add_uint ( sub_tree , hf_wcp_short_len , src_tvb , offset , 1 , * src ) ; proto_tree_add_uint ( sub_tree , hf_wcp_offset , src_tvb , offset , 2 , data_offset ) ; } src += 2 ; offset += 2 ; } if ( ! <S2SV_ModStart> = decompressed_entry ( dst , data_offset , data_cnt , <S2SV_ModEnd> & len , <S2SV_ModStart> NULL ; } <S2SV_ModEnd> } } else
<S2SV_ModStart> interface_data -> len <= <S2SV_ModEnd> wblock . data <S2SV_ModStart> { pcapng_debug1 ( "pcapng_read:<S2SV_blank>BLOCK_TYPE_ISB<S2SV_blank>wblock.if_stats.interface_id<S2SV_blank>%u<S2SV_blank>>=<S2SV_blank>number_of_interfaces" <S2SV_ModEnd> , wblock . <S2SV_ModStart> , * data_offset <S2SV_ModEnd> ) ; return
<S2SV_ModStart> is_signed ) { header_field_info * hfinfo = fi -> hfinfo ; guint64 value ; char buf [ 32 ] ; const char * out ; if ( is_signed ) value = fvalue_get_sinteger64 ( & fi -> value ) ; else value = fvalue_get_uinteger64 ( & fi -> value ) ; if ( hfinfo -> display == BASE_CUSTOM ) { gchar <S2SV_ModEnd> tmp [ ITEM_LABEL_LENGTH <S2SV_ModStart> tmp [ ITEM_LABEL_LENGTH ] ; const custom_fmt_func_64_t fmtfunc64 = ( const custom_fmt_func_64_t ) hfinfo -> strings ; DISSECTOR_ASSERT ( fmtfunc64 ) ; fmtfunc64 <S2SV_ModEnd> ( tmp , <S2SV_ModStart> ( tmp , value ) ; label_fill ( label_str , 0 , hfinfo , tmp ) ; } else <S2SV_ModEnd> if ( hfinfo <S2SV_ModStart> "Unknown" ) ; out = hfinfo_number_vals_format64 ( hfinfo , buf , value ) ; if ( out == NULL ) <S2SV_ModEnd> label_fill ( label_str <S2SV_ModStart> val_str ) ; else <S2SV_ModEnd> label_fill_descr ( label_str <S2SV_ModStart> , val_str , out ) ; } else { out = hfinfo_number_value_format64 ( hfinfo , buf , value ) ; <S2SV_ModEnd> label_fill ( label_str <S2SV_ModStart> , hfinfo , out <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; default : g_assert_not_reached ( ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; default : g_assert_not_reached ( ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; } } if ( offset + length > ( guint32 ) offset ) { <S2SV_ModStart> += length ; }
<S2SV_ModStart> return ; } if ( offset + <S2SV_ModEnd> length + padlen <S2SV_ModStart> length + padlen > offset ) { offset += length + padlen ; } <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> "1:<S2SV_blank>" XRSTOR , <S2SV_ModEnd> XRSTORS , X86_FEATURE_XSAVES
<S2SV_ModStart> XRSTORS "\\n\\t" "2:\\n\\t" xstate_fault <S2SV_ModEnd> : "D" ( <S2SV_ModStart> XRSTOR "\\n\\t" "2:\\n\\t" xstate_fault <S2SV_ModEnd> : "D" ( <S2SV_ModStart> "memory" ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> "1:" XSAVE , <S2SV_ModEnd> XSAVEOPT , X86_FEATURE_XSAVEOPT <S2SV_ModStart> , X86_FEATURE_XSAVEOPT , <S2SV_ModEnd> XSAVES , X86_FEATURE_XSAVES
<S2SV_ModStart> XSAVES "\\n\\t" "2:\\n\\t" xstate_fault <S2SV_ModEnd> : "D" ( <S2SV_ModStart> XSAVE "\\n\\t" "2:\\n\\t" xstate_fault <S2SV_ModEnd> : "D" ( <S2SV_ModStart> "memory" ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
<S2SV_ModStart> icmp6_hop_limit ) { if ( <S2SV_ModStart> cnf . hop_limit < <S2SV_ModEnd> ra_msg -> icmph <S2SV_ModStart> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n" ) ; } <S2SV_ModEnd> if ( rt
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> follow_dotdot ( struct <S2SV_ModStart> old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> -> d_inode ; return 0 ;
<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
<S2SV_ModStart> ; } else return
<S2SV_ModStart> mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }
<S2SV_ModStart> if ( alg == NULL || alg -> parameter
<S2SV_ModStart> NID_mgf1 && param && param
<S2SV_ModStart> * ptmpval ; int combine = aclass & ASN1_TFLG_COMBINE ; aclass &= ~ ASN1_TFLG_COMBINE ; <S2SV_ModStart> ; err : if ( combine == 0 )
<S2SV_ModStart> - 1 , tt -> flags & ASN1_TFLG_COMBINE <S2SV_ModEnd> , opt ,
<S2SV_ModStart> * ptmpval ; int combine = aclass & ASN1_TFLG_COMBINE ; aclass &= ~ ASN1_TFLG_COMBINE ; <S2SV_ModStart> ; err : if ( combine == 0 )
<S2SV_ModStart> - 1 , tt -> flags & ASN1_TFLG_COMBINE <S2SV_ModEnd> , opt ,
<S2SV_ModStart> * ptmpval ; int combine = aclass & ASN1_TFLG_COMBINE ; aclass &= ~ ASN1_TFLG_COMBINE ; <S2SV_ModStart> ; err : if ( combine == 0 )
<S2SV_ModStart> - 1 , tt -> flags & ASN1_TFLG_COMBINE <S2SV_ModEnd> , opt ,
<S2SV_ModStart> * ptmpval ; int combine = aclass & ASN1_TFLG_COMBINE ; aclass &= ~ ASN1_TFLG_COMBINE ; <S2SV_ModStart> ; err : if ( combine == 0 )
<S2SV_ModStart> - 1 , tt -> flags & ASN1_TFLG_COMBINE <S2SV_ModEnd> , opt ,
<S2SV_ModStart> SSL_kPSK ) { <S2SV_ModEnd> param_len = 2 <S2SV_ModStart> += i ; s -> session -> psk_identity_hint = BUF_strndup ( ( char * ) p , i ) ; if ( s -> session <S2SV_ModEnd> -> psk_identity_hint ==
<S2SV_ModStart> , s -> session <S2SV_ModEnd> -> psk_identity_hint ,
<S2SV_ModStart> -> psk_identity = BUF_strndup <S2SV_ModEnd> ( ( char <S2SV_ModStart> * ) p , i
<S2SV_ModStart> ++ ) { const SSL_CIPHER * cp = sk_SSL_CIPHER_value ( prio , z ) ; if ( ( cp -> algorithm_ssl & SSL_SSLV2 ) == 0 || <S2SV_ModEnd> sk_SSL_CIPHER_find ( allow <S2SV_ModStart> ( allow , cp <S2SV_ModEnd> ) < 0 <S2SV_ModStart> prio ; } if ( sk_SSL_CIPHER_num ( s -> session -> ciphers ) == 0 ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_HELLO , SSL_R_NO_CIPHER_MATCH ) ; return - 1 ; }
<S2SV_ModStart> cp == NULL || sk_SSL_CIPHER_find ( s -> session -> ciphers , cp ) < 0
<S2SV_ModStart> ++ ) { const SSL_CIPHER * cp = sk_SSL_CIPHER_value ( prio , z ) ; if ( ( cp -> algorithm_ssl & SSL_SSLV2 ) == 0 || <S2SV_ModEnd> sk_SSL_CIPHER_find ( allow <S2SV_ModStart> ( allow , cp <S2SV_ModEnd> ) < 0 <S2SV_ModStart> prio ; } if ( sk_SSL_CIPHER_num ( s -> session -> ciphers ) == 0 ) { ssl2_return_error ( s , SSL2_PE_NO_CIPHER ) ; SSLerr ( SSL_F_GET_CLIENT_HELLO , SSL_R_NO_CIPHER_MATCH ) ; return - 1 ; }
<S2SV_ModStart> cp == NULL || sk_SSL_CIPHER_find ( s -> session -> ciphers , cp ) < 0
<S2SV_ModStart> sk ) ; spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; bh_lock_sock <S2SV_ModStart> sk ) ; spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; sock_put
<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;
<S2SV_ModStart> * head ; <S2SV_ModEnd> newsk -> sk_sndbuf <S2SV_ModStart> -> sk_rcvbuf ; sctp_copy_descendant <S2SV_ModEnd> ( newsk ,
<S2SV_ModStart> &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
<S2SV_ModStart> ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
<S2SV_ModStart> -> vm_ops ) <S2SV_ModEnd> return do_fault ( <S2SV_ModStart> , pte , pmd , flags , entry ) ; <S2SV_ModEnd> return do_anonymous_page ( <S2SV_ModStart> , address , pte , pmd , <S2SV_ModEnd> flags ) ;
<S2SV_ModStart> bprm ) { <S2SV_ModEnd> int retval ; <S2SV_ModStart> int retval ; bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> retval = security_bprm_set_creds
<S2SV_ModStart> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;
<S2SV_ModStart> ( tvb , curr_offset + <S2SV_ModStart> , tvb , curr_offset <S2SV_ModEnd> , L_LBMR_PSER_OPT_CTXINST_T , <S2SV_ModStart> opt_type ) ; if ( option_len == 0 ) { return ( len ) ; }
<S2SV_ModStart> ( tvb , curr_offset + <S2SV_ModStart> , tvb , curr_offset <S2SV_ModEnd> , L_LBMR_PSER_OPT_CTXINST_T , <S2SV_ModStart> opt_type ) ; if ( option_len == 0 ) { return ( len ) ; }
<S2SV_ModStart> startframe ) { if ( pinfo -> can_desegment > 0 ) pinfo -> can_desegment ++ ;
<S2SV_ModStart> void * data ) { tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , 2 , get_websocket_frame_length , dissect_websocket_frame , data ) ; return tvb_captured_length <S2SV_ModEnd> ( tvb ) <S2SV_ModStart> tvb ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> guint payload_length , gboolean <S2SV_ModEnd> mask , const
<S2SV_ModStart> * len , wcp_window_t * buf_ptr <S2SV_ModEnd> ) { const <S2SV_ModStart> guint8 * src ; guint8 * buf_start , * buf_end ; buf_start = buf_ptr -> buffer ; buf_end = buf_ptr -> buffer + MAX_WIN_BUF_LEN <S2SV_ModStart> = * src ; if ( buf_ptr -> initialized < MAX_WIN_BUF_LEN ) buf_ptr -> initialized ++
<S2SV_ModStart> ; wcp_circuit_data -> recv . initialized = 0 ; wcp_circuit_data -> <S2SV_ModStart> send . buffer ; wcp_circuit_data -> send . initialized = 0
<S2SV_ModStart> } } , { & ei_wcp_invalid_window_offset , { "wcp.off.invalid" , PI_MALFORMED , PI_ERROR , "Offset<S2SV_blank>points<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>visible<S2SV_blank>window" , EXPFILL } } , { & ei_wcp_invalid_match_length , { "wcp.len.invalid" , PI_MALFORMED , PI_ERROR , "Length<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>offset" , EXPFILL } } ,
<S2SV_ModStart> } if ( data_offset + 1 > buf_ptr -> initialized ) { expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data<S2SV_blank>offset<S2SV_blank>exceeds<S2SV_blank>valid<S2SV_blank>window<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%d)" , data_offset + 1 , buf_ptr -> initialized ) ; return NULL ; } if ( data_offset + 1 < data_cnt ) { expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Data<S2SV_blank>count<S2SV_blank>exceeds<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%d)" , data_cnt , data_offset + 1 ) ; return NULL ; } if ( <S2SV_ModStart> & len , buf_ptr <S2SV_ModEnd> ) ; if <S2SV_ModStart> = buf_start ; if ( buf_ptr -> initialized < MAX_WIN_BUF_LEN ) buf_ptr -> initialized ++ ;
<S2SV_ModStart> x11_conv_data_t * last ; g_hash_table_destroy ( state -> eventcode_funcs ) ; g_hash_table_destroy ( state -> reply_funcs )
<S2SV_ModStart> TRUE ; } if ( ! tvb_bytes_exist ( tvb , offset , fd -> len ) ) { g_slice_free ( fragment_item , fd ) ; THROW ( BoundsError ) ; }
<S2SV_ModStart> ftype ) ; if ( tlen == 0 ) break ;
<S2SV_ModStart> ftype ) ; if ( tlen == 0 ) break ;
<S2SV_ModStart> payload_length ; guint16 hdr_size ; guint16 read_sofar ; guint16 entry_len ; gint version ; struct logger_entry * log_entry ; struct logger_entry_v2 * log_entry_v2 <S2SV_ModEnd> ; guint8 * <S2SV_ModStart> guint8 * buffer <S2SV_ModEnd> ; guint16 tmp <S2SV_ModStart> guint16 tmp ; guint8 * msg_payload , * msg_part , * msg_end ; guint16 msg_len <S2SV_ModEnd> ; bytes_read = <S2SV_ModStart> 1 ; } hdr_size <S2SV_ModEnd> = pletoh16 ( <S2SV_ModStart> tmp ) ; read_sofar = 4 ; if ( payload_length < 3 ) return - 1 ; if ( payload_length > LOGGER_ENTRY_MAX_PAYLOAD ) return - 1 ; <S2SV_ModStart> ) g_malloc ( sizeof ( * log_entry_v2 ) <S2SV_ModEnd> + payload_length ) <S2SV_ModStart> payload_length ) ; log_entry_v2 = ( struct logger_entry_v2 * ) buffer ; log_entry = ( struct logger_entry * ) buffer ; for ( version = 1 ; version <= 2 ; ++ version ) { if ( version == 1 ) { msg_payload = log_entry -> msg ; entry_len = sizeof ( * log_entry ) + payload_length ; } else if ( version == 2 ) { msg_payload = log_entry_v2 -> msg ; entry_len = sizeof ( * log_entry_v2 ) + payload_length ; if ( hdr_size != sizeof ( * log_entry_v2 ) ) continue ; } <S2SV_ModStart> file_read ( buffer + read_sofar , entry_len - read_sofar , <S2SV_ModEnd> wth -> fh <S2SV_ModStart> ( bytes_read != entry_len - read_sofar ) { * err = file_error ( wth -> fh , err_info ) ; if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ; version = - 1 ; break ; } read_sofar += bytes_read ; if ( get_priority ( msg_payload [ 0 ] ) == '?' ) continue ; msg_part = ( guint8 * ) memchr ( msg_payload , '\\0' , payload_length - 1 ) ; if ( msg_part == NULL ) continue ; ++ msg_part ; msg_len = payload_length - ( msg_part - msg_payload ) ; msg_end = ( guint8 * ) memchr ( msg_part , '\\0' , msg_len ) ; if ( msg_end && ( msg_payload + payload_length - 1 != msg_end ) ) continue <S2SV_ModEnd> ; g_free ( <S2SV_ModStart> ) ; return version ; } <S2SV_ModEnd> g_free ( buffer <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( const guint8 <S2SV_ModEnd> priority ) { <S2SV_ModStart> ; if ( <S2SV_ModEnd> priority >= ( <S2SV_ModStart> return priorities [ <S2SV_ModEnd> priority ] ;
<S2SV_ModStart> priority ; const struct logger_entry * log_entry = ( struct logger_entry * ) pd ; const struct logger_entry_v2 * log_entry_v2 = ( struct logger_entry_v2 * ) pd ; gint payload_length ; const <S2SV_ModStart> * tag ; gint32 pid ; gint32 tid ; gint32 seconds ; gint32 milliseconds ; const gchar * msg_begin ; gint msg_pre_skip ; <S2SV_ModEnd> gchar * log <S2SV_ModStart> * log_part ; gchar * log_next <S2SV_ModEnd> ; const union <S2SV_ModStart> FALSE ; } payload_length = GINT32_FROM_LE ( log_entry -> len ) ; pid = GINT32_FROM_LE ( log_entry -> pid ) ; tid = GINT32_FROM_LE ( log_entry -> tid ) ; seconds = GINT32_FROM_LE ( log_entry -> sec ) ; milliseconds = GINT32_FROM_LE ( log_entry -> nsec ) / 1000000 ; <S2SV_ModStart> 1 ) { <S2SV_ModEnd> priority = get_priority <S2SV_ModStart> = get_priority ( log_entry -> msg [ 0 ] <S2SV_ModEnd> ) ; tag <S2SV_ModStart> ; tag = log_entry -> msg + 1 ; msg_pre_skip = 1 + strlen ( tag ) + 1 ; msg_begin = log_entry -> msg + msg_pre_skip <S2SV_ModEnd> ; } else <S2SV_ModStart> 2 ) { <S2SV_ModEnd> priority = get_priority <S2SV_ModStart> = get_priority ( log_entry_v2 -> msg [ 0 ] <S2SV_ModEnd> ) ; tag <S2SV_ModStart> ; tag = log_entry_v2 -> msg + 1 ; msg_pre_skip = 1 + strlen ( tag ) + 1 ; msg_begin = log_entry_v2 -> msg + msg_pre_skip <S2SV_ModEnd> ; } else <S2SV_ModStart> FALSE ; } log = g_strndup ( msg_begin , payload_length - msg_pre_skip ) ; log_next = log ; do { log_part = log_next ; if <S2SV_ModEnd> ( dumper -> <S2SV_ModStart> dumper -> type == DUMP_LONG ) { log_next = NULL ; } else { log_next = strchr ( log_part , '\\n' ) ; if ( log_next != NULL ) { * log_next = '\\0' ; ++ log_next ; if ( * log_next == '\\0' ) { log_next = NULL ; } } } <S2SV_ModEnd> buf = logcat_log <S2SV_ModStart> ( dumper , seconds , milliseconds , pid , <S2SV_ModEnd> tid , priority <S2SV_ModStart> { g_free ( log <S2SV_ModEnd> ) ; return <S2SV_ModStart> FALSE ; } <S2SV_ModEnd> length = ( <S2SV_ModStart> { g_free ( log <S2SV_ModEnd> ) ; return <S2SV_ModStart> += length ; } while ( log_next != NULL ) ; g_free ( log ) ; <S2SV_ModEnd> return TRUE ;
<S2SV_ModStart> seconds , gint milliseconds <S2SV_ModEnd> , gint pid <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , priority , <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , pid , <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , pid ,
<S2SV_ModStart> * pd ; struct logger_entry * log_entry ; <S2SV_ModStart> { packet_size = sizeof ( struct logger_entry ) <S2SV_ModEnd> + payload_length ; <S2SV_ModStart> { packet_size = sizeof ( struct logger_entry_v2 ) <S2SV_ModEnd> + payload_length ; <S2SV_ModStart> ( buf ) ; log_entry = ( struct logger_entry * ) pd <S2SV_ModStart> ( time_t ) GINT32_FROM_LE ( log_entry -> sec <S2SV_ModEnd> ) ; phdr <S2SV_ModStart> . nsecs = GINT32_FROM_LE ( log_entry -> nsec <S2SV_ModEnd> ) ; phdr
<S2SV_ModStart> payload_length ; guint16 hdr_size ; guint16 read_sofar ; guint16 entry_len ; gint version ; struct logger_entry * log_entry ; struct logger_entry_v2 * log_entry_v2 <S2SV_ModEnd> ; guint8 * <S2SV_ModStart> guint8 * buffer <S2SV_ModEnd> ; guint16 tmp <S2SV_ModStart> guint16 tmp ; guint8 * msg_payload , * msg_part , * msg_end ; guint16 msg_len <S2SV_ModEnd> ; bytes_read = <S2SV_ModStart> 1 ; } hdr_size <S2SV_ModEnd> = pletoh16 ( <S2SV_ModStart> tmp ) ; read_sofar = 4 ; if ( payload_length < 3 ) return - 1 ; if ( payload_length > LOGGER_ENTRY_MAX_PAYLOAD ) return - 1 ; <S2SV_ModStart> ) g_malloc ( sizeof ( * log_entry_v2 ) <S2SV_ModEnd> + payload_length ) <S2SV_ModStart> payload_length ) ; log_entry_v2 = ( struct logger_entry_v2 * ) buffer ; log_entry = ( struct logger_entry * ) buffer ; for ( version = 1 ; version <= 2 ; ++ version ) { if ( version == 1 ) { msg_payload = log_entry -> msg ; entry_len = sizeof ( * log_entry ) + payload_length ; } else if ( version == 2 ) { msg_payload = log_entry_v2 -> msg ; entry_len = sizeof ( * log_entry_v2 ) + payload_length ; if ( hdr_size != sizeof ( * log_entry_v2 ) ) continue ; } <S2SV_ModStart> file_read ( buffer + read_sofar , entry_len - read_sofar , <S2SV_ModEnd> wth -> fh <S2SV_ModStart> ( bytes_read != entry_len - read_sofar ) { * err = file_error ( wth -> fh , err_info ) ; if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ; version = - 1 ; break ; } read_sofar += bytes_read ; if ( get_priority ( msg_payload [ 0 ] ) == '?' ) continue ; msg_part = ( guint8 * ) memchr ( msg_payload , '\\0' , payload_length - 1 ) ; if ( msg_part == NULL ) continue ; ++ msg_part ; msg_len = payload_length - ( msg_part - msg_payload ) ; msg_end = ( guint8 * ) memchr ( msg_part , '\\0' , msg_len ) ; if ( msg_end && ( msg_payload + payload_length - 1 != msg_end ) ) continue <S2SV_ModEnd> ; g_free ( <S2SV_ModStart> ) ; return version ; } <S2SV_ModEnd> g_free ( buffer <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( const guint8 <S2SV_ModEnd> priority ) { <S2SV_ModStart> ; if ( <S2SV_ModEnd> priority >= ( <S2SV_ModStart> return priorities [ <S2SV_ModEnd> priority ] ;
<S2SV_ModStart> priority ; const struct logger_entry * log_entry = ( struct logger_entry * ) pd ; const struct logger_entry_v2 * log_entry_v2 = ( struct logger_entry_v2 * ) pd ; gint payload_length ; const <S2SV_ModStart> * tag ; gint32 pid ; gint32 tid ; gint32 seconds ; gint32 milliseconds ; const gchar * msg_begin ; gint msg_pre_skip ; <S2SV_ModEnd> gchar * log <S2SV_ModStart> * log_part ; gchar * log_next <S2SV_ModEnd> ; const union <S2SV_ModStart> FALSE ; } payload_length = GINT32_FROM_LE ( log_entry -> len ) ; pid = GINT32_FROM_LE ( log_entry -> pid ) ; tid = GINT32_FROM_LE ( log_entry -> tid ) ; seconds = GINT32_FROM_LE ( log_entry -> sec ) ; milliseconds = GINT32_FROM_LE ( log_entry -> nsec ) / 1000000 ; <S2SV_ModStart> 1 ) { <S2SV_ModEnd> priority = get_priority <S2SV_ModStart> = get_priority ( log_entry -> msg [ 0 ] <S2SV_ModEnd> ) ; tag <S2SV_ModStart> ; tag = log_entry -> msg + 1 ; msg_pre_skip = 1 + strlen ( tag ) + 1 ; msg_begin = log_entry -> msg + msg_pre_skip <S2SV_ModEnd> ; } else <S2SV_ModStart> 2 ) { <S2SV_ModEnd> priority = get_priority <S2SV_ModStart> = get_priority ( log_entry_v2 -> msg [ 0 ] <S2SV_ModEnd> ) ; tag <S2SV_ModStart> ; tag = log_entry_v2 -> msg + 1 ; msg_pre_skip = 1 + strlen ( tag ) + 1 ; msg_begin = log_entry_v2 -> msg + msg_pre_skip <S2SV_ModEnd> ; } else <S2SV_ModStart> FALSE ; } log = g_strndup ( msg_begin , payload_length - msg_pre_skip ) ; log_next = log ; do { log_part = log_next ; if <S2SV_ModEnd> ( dumper -> <S2SV_ModStart> dumper -> type == DUMP_LONG ) { log_next = NULL ; } else { log_next = strchr ( log_part , '\\n' ) ; if ( log_next != NULL ) { * log_next = '\\0' ; ++ log_next ; if ( * log_next == '\\0' ) { log_next = NULL ; } } } <S2SV_ModEnd> buf = logcat_log <S2SV_ModStart> ( dumper , seconds , milliseconds , pid , <S2SV_ModEnd> tid , priority <S2SV_ModStart> { g_free ( log <S2SV_ModEnd> ) ; return <S2SV_ModStart> FALSE ; } <S2SV_ModEnd> length = ( <S2SV_ModStart> { g_free ( log <S2SV_ModEnd> ) ; return <S2SV_ModStart> += length ; } while ( log_next != NULL ) ; g_free ( log ) ; <S2SV_ModEnd> return TRUE ;
<S2SV_ModStart> seconds , gint milliseconds <S2SV_ModEnd> , gint pid <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , priority , <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , pid , <S2SV_ModStart> , time_buffer , milliseconds <S2SV_ModEnd> , pid ,
<S2SV_ModStart> * pd ; struct logger_entry * log_entry ; <S2SV_ModStart> { packet_size = sizeof ( struct logger_entry ) <S2SV_ModEnd> + payload_length ; <S2SV_ModStart> { packet_size = sizeof ( struct logger_entry_v2 ) <S2SV_ModEnd> + payload_length ; <S2SV_ModStart> ( buf ) ; log_entry = ( struct logger_entry * ) pd <S2SV_ModStart> ( time_t ) GINT32_FROM_LE ( log_entry -> sec <S2SV_ModEnd> ) ; phdr <S2SV_ModStart> . nsecs = GINT32_FROM_LE ( log_entry -> nsec <S2SV_ModEnd> ) ; phdr
<S2SV_ModStart> u8 req_id , u8 <S2SV_ModEnd> status , const <S2SV_ModStart> * desc , u8 length , u16 offset , u16 <S2SV_ModEnd> total_size ) { <S2SV_ModStart> 0 ) { unsigned <S2SV_ModStart> int copy_len ; unsigned
<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , "USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; int n ; if ( ! body -> unit_size ) break ; n
<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo ->
<S2SV_ModStart> long tmp = <S2SV_ModEnd> atomic_long_cmpxchg ( & <S2SV_ModStart> new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }
<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
<S2SV_ModStart> ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> wait ) ; INIT_HLIST_NODE ( & p -> s_list ) ; INIT_HLIST_NODE ( & p -> m_list ) ;
<S2SV_ModStart> guint32 i ; gint16 family ; guint16 table_length ; <S2SV_ModStart> proto_tree * element_tree <S2SV_ModEnd> ; proto_item * <S2SV_ModStart> proto_item * tf <S2SV_ModEnd> ; if ( <S2SV_ModStart> * 4 ; <S2SV_ModEnd> family = tvb_get_ntohs <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> table_length = tvb_get_ntohl <S2SV_ModStart> ( 4 ) ; if ( wccp_wccp_address_table . in_use == FALSE ) { wccp_wccp_address_table . in_use = TRUE ; wccp_wccp_address_table . family = family ; wccp_wccp_address_table . table_length = table_length <S2SV_ModStart> & ei_wccp_length_bad , "The<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>must<S2SV_blank>be<S2SV_blank>4,<S2SV_blank>but<S2SV_blank>I<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>IPv4<S2SV_blank>addresses.<S2SV_blank>Correcting<S2SV_blank>this." <S2SV_ModEnd> , address_length ) <S2SV_ModStart> & ei_wccp_length_bad , "The<S2SV_blank>Address<S2SV_blank>length<S2SV_blank>must<S2SV_blank>be<S2SV_blank>16,<S2SV_blank>but<S2SV_blank>I<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>IPv6<S2SV_blank>addresses.<S2SV_blank>Correcting<S2SV_blank>this." <S2SV_ModEnd> , address_length ) <S2SV_ModStart> ; } ; } <S2SV_ModStart> ; i < <S2SV_ModEnd> table_length ; i <S2SV_ModStart> * addr ; switch ( <S2SV_ModEnd> family ) { <S2SV_ModStart> ; if ( ( <S2SV_ModStart> != NULL ) && ( ( address_length * i ) < wccp_wccp_address_table . table_length ) ) <S2SV_ModStart> ) ; if ( <S2SV_ModStart> != NULL ) && ( ( address_length * i ) < wccp_wccp_address_table . table_length ) ) <S2SV_ModStart> ( ) , "unknown<S2SV_blank>family<S2SV_blank>%d" , wccp_wccp_address_table . family <S2SV_ModEnd> ) ; } <S2SV_ModStart> element_tree ) { proto_item * pi ; pi = <S2SV_ModStart> addr ) ; if ( ( address_length * i ) > wccp_wccp_address_table . table_length ) expert_add_info_format ( pinfo , pi , & ei_wccp_length_bad , "Ran<S2SV_blank>out<S2SV_blank>of<S2SV_blank>space<S2SV_blank>to<S2SV_blank>store<S2SV_blank>address" ) ;
<S2SV_ModStart> ; guint8 extension <S2SV_ModEnd> ; guint32 curr_offset <S2SV_ModStart> guint32 curr_offset , <S2SV_ModEnd> num_string_len ; proto_item <S2SV_ModStart> * item ; const char * digit_str <S2SV_ModEnd> ; * address_extracted <S2SV_ModStart> Dgt_mbcd ) ; digit_str = tvb_bcd_dig_to_wmem_packet_str ( tvb , curr_offset , num_string_len , NULL , FALSE ) ; item = proto_tree_add_string ( tree , header_field , tvb , curr_offset , num_string_len , digit_str ) ; item = <S2SV_ModEnd> proto_tree_add_string_format ( tree <S2SV_ModStart> a_bigbuf ) ; if ( strchr ( digit_str , '?' ) ) { <S2SV_ModEnd> expert_add_info ( pinfo <S2SV_ModStart> ei_gsm_a_dtap_end_mark_unexpected ) ; }
<S2SV_ModStart> ; guint8 en_len <S2SV_ModEnd> ; guint8 count <S2SV_ModStart> guint8 count ; <S2SV_ModEnd> proto_tree * subtree <S2SV_ModStart> * item ; const char * digit_str <S2SV_ModEnd> ; curr_offset = <S2SV_ModStart> en_len -- ; digit_str = tvb_bcd_dig_to_wmem_packet_str ( tvb , curr_offset , en_len , NULL , FALSE ) ; item = proto_tree_add_string <S2SV_ModEnd> ( subtree , <S2SV_ModStart> , hf_gsm_a_dtap_emergency_bcd_num , tvb , curr_offset , en_len , digit_str ) ; if ( strchr ( digit_str , '?' ) ) { <S2SV_ModEnd> expert_add_info ( pinfo <S2SV_ModStart> ei_gsm_a_dtap_end_mark_unexpected ) ; }
<S2SV_ModStart> ) { return kvm_vcpu_has_lapic ( vcpu ) &&
<S2SV_ModStart> pass < 10 || image
<S2SV_ModStart> NETIF_F_HW_CSUM | NETIF_F_SG <S2SV_ModEnd> ; if ( <S2SV_ModStart> NETIF_F_HW_CSUM | NETIF_F_SG <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( ) ; load_mm_ldt ( & init_mm <S2SV_ModEnd> ) ; t
<S2SV_ModStart> ( ) ; load_mm_ldt ( <S2SV_ModEnd> current -> active_mm <S2SV_ModStart> current -> active_mm <S2SV_ModEnd> ) ; fpu__resume_cpu
<S2SV_ModStart> mm ) { free_ldt_struct <S2SV_ModEnd> ( mm -> <S2SV_ModStart> ldt ) ; <S2SV_ModEnd> mm -> context <S2SV_ModStart> context . ldt = NULL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { struct ldt_struct * new_ldt ; struct <S2SV_ModStart> lock ) ; old_mm = current -> mm ; if ( ! old_mm ) { mm -> context . ldt = NULL ; return 0 ; } mutex_lock ( & old_mm -> context . lock ) ; if ( ! old_mm -> context . ldt ) { mm -> context . ldt = NULL ; goto out_unlock ; } new_ldt = alloc_ldt_struct ( old_mm -> context . ldt -> size ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ! new_ldt ) { retval = - ENOMEM ; goto out_unlock ; } memcpy ( new_ldt -> entries , old_mm -> context . ldt -> entries , new_ldt -> size * LDT_ENTRY_SIZE ) ; finalize_ldt_struct ( new_ldt ) ; mm -> context . ldt = new_ldt ; out_unlock : mutex_unlock <S2SV_ModEnd> ( & old_mm <S2SV_ModStart> lock ) ; <S2SV_ModEnd> return retval ;
<S2SV_ModStart> ) { int retval <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> -> mm ; mutex_lock ( & mm -> context . lock ) ; <S2SV_ModStart> -> context . ldt ) { retval = 0 ; goto out_unlock ; } <S2SV_ModEnd> if ( bytecount <S2SV_ModStart> * LDT_ENTRIES ; size = mm -> context . ldt -> <S2SV_ModEnd> size * LDT_ENTRY_SIZE <S2SV_ModStart> = bytecount ; <S2SV_ModEnd> if ( copy_to_user <S2SV_ModStart> context . ldt -> entries , size ) ) { retval <S2SV_ModEnd> = - EFAULT <S2SV_ModStart> - EFAULT ; goto out_unlock ; } <S2SV_ModEnd> if ( size <S2SV_ModStart> - size ) ) { retval <S2SV_ModEnd> = - EFAULT <S2SV_ModStart> EFAULT ; goto out_unlock ; } } retval = bytecount ; out_unlock : mutex_unlock ( & mm -> context . lock ) ; return retval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> user_desc ldt_info ; int oldsize , newsize ; struct ldt_struct * new_ldt , * old_ldt ; <S2SV_ModStart> out ; } if ( ( oldmode && ! ldt_info . base_addr && ! ldt_info . limit ) || LDT_empty ( & ldt_info ) ) { memset ( & ldt , 0 , sizeof ( ldt ) ) ; } else { if ( ! IS_ENABLED ( CONFIG_X86_16BIT ) && ! ldt_info . seg_32bit ) { error = - EINVAL ; goto out ; } fill_ldt ( & ldt , & ldt_info ) ; if ( oldmode ) ldt . avl = 0 ; } <S2SV_ModStart> lock ) ; old_ldt = <S2SV_ModEnd> mm -> context <S2SV_ModStart> -> context . ldt ; oldsize = old_ldt ? old_ldt -> size : 0 ; newsize = max ( ( int ) ( <S2SV_ModEnd> ldt_info . entry_number <S2SV_ModStart> entry_number + 1 ) , oldsize ) ; error = - ENOMEM ; new_ldt = alloc_ldt_struct ( newsize ) ; if ( ! new_ldt <S2SV_ModEnd> ) goto out_unlock <S2SV_ModStart> goto out_unlock ; if ( old_ldt ) memcpy ( new_ldt -> entries , old_ldt -> entries , oldsize * LDT_ENTRY_SIZE ) ; new_ldt -> entries [ <S2SV_ModEnd> ldt_info . entry_number <S2SV_ModStart> ldt_info . entry_number ] = ldt ; finalize_ldt_struct ( new_ldt ) ; install_ldt ( mm , new_ldt ) ; free_ldt_struct ( old_ldt <S2SV_ModEnd> ) ; error
<S2SV_ModStart> ldt ) ) load_mm_ldt ( next <S2SV_ModEnd> ) ; } <S2SV_ModStart> next ) ; load_mm_ldt ( next <S2SV_ModEnd> ) ; }
<S2SV_ModStart> SEGMENT_LDT ) { struct ldt_struct * ldt ; <S2SV_ModStart> return 0 ; ldt = lockless_dereference ( <S2SV_ModEnd> current -> active_mm <S2SV_ModStart> -> context . ldt ) ; if ( ! ldt || idx > ldt -> <S2SV_ModStart> ; desc = & ldt -> entries [ idx ] <S2SV_ModEnd> ; } else <S2SV_ModStart> . gdt ) + idx <S2SV_ModStart> get_desc_base ( desc <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> context . ldt <S2SV_ModEnd> ) { pr_warn <S2SV_ModStart> -> context . ldt ->
<S2SV_ModStart> ( unlikely ( ! child -> mm -> context . ldt || <S2SV_ModStart> -> context . ldt -> <S2SV_ModStart> { desc = & <S2SV_ModStart> context . ldt -> entries [ seg ] <S2SV_ModEnd> ; base =
<S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops <S2SV_ModEnd> ) ; sctp_v6_protosw_exit <S2SV_ModStart> ; sctp_v4_protosw_exit ( ) ; unregister_pernet_subsys ( & sctp_defaults_ops
<S2SV_ModStart> ; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
<S2SV_ModStart> svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
<S2SV_ModStart> ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
<S2SV_ModStart> 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
<S2SV_ModStart> goto unsupported_time ; if ( year < 1970 || mon < 1 || mon > 12 ) goto invalid_time ; <S2SV_ModStart> month_lengths [ mon - 1 <S2SV_ModStart> } if ( <S2SV_ModEnd> day < 1
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> ; file = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
<S2SV_ModStart> bytes ) ; else proto_tree_set_bytes ( new_fi , NULL , 0 ) ;
<S2SV_ModStart> ; } else if ( WMEM_CHUNK_DATA_LEN ( chunk ) >= sizeof ( wmem_block_free_t ) )
<S2SV_ModStart> ) { dissector_table_t sub_dissectors ; if ( ! string ) return 0 ;
<S2SV_ModStart> dtbl_entry_t * dtbl_entry ; if ( ! string ) return 0
<S2SV_ModStart> mic_len ; gint payload_reported_len <S2SV_ModEnd> ; tvbuff_t * <S2SV_ModStart> # ifdef HAVE_LIBGCRYPT gint payload_captured_len ; <S2SV_ModStart> ; } } payload_reported_len = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb , <S2SV_ModStart> ; if ( payload_reported_len <S2SV_ModEnd> == 0 ) <S2SV_ModStart> , offset , payload_reported_len <S2SV_ModEnd> ) ; } <S2SV_ModStart> # ifdef HAVE_LIBGCRYPT payload_captured_len = tvb_captured_length_remaining ( tvb , offset + mic_len ) ; <S2SV_ModStart> ) g_malloc ( payload_captured_len <S2SV_ModEnd> ) ; decrypted <S2SV_ModStart> , dec_buffer , payload_captured_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_captured_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_captured_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_captured_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_captured_len , payload_reported_len <S2SV_ModEnd> ) ; tvb_set_free_cb <S2SV_ModStart> ; payload_tvb = tvb_new_subset_length ( tvb , offset , payload_reported_len <S2SV_ModEnd> ) ; call_dissector
<S2SV_ModStart> mic_len ; gint payload_len <S2SV_ModEnd> ; tvbuff_t * <S2SV_ModStart> # ifdef HAVE_LIBGCRYPT <S2SV_ModEnd> proto_item * ti <S2SV_ModStart> ; } } payload_len <S2SV_ModEnd> = tvb_reported_length_remaining ( <S2SV_ModStart> ; if ( payload_len <S2SV_ModEnd> == 0 ) <S2SV_ModStart> , offset , payload_len <S2SV_ModEnd> ) ; } <S2SV_ModStart> # ifdef HAVE_LIBGCRYPT if ( <S2SV_ModEnd> tvb_captured_length_remaining ( tvb <S2SV_ModStart> + mic_len ) < payload_len ) { expert_add_info ( pinfo , sec_tree , & ei_zbee_sec_encrypted_payload_sliced ) ; payload_tvb = tvb_new_subset_length ( tvb , offset , payload_len ) ; call_dissector ( data_handle , payload_tvb , pinfo , tree ) ; return NULL ; } <S2SV_ModEnd> dec_buffer = ( <S2SV_ModStart> ) g_malloc ( payload_len <S2SV_ModEnd> ) ; decrypted <S2SV_ModStart> , dec_buffer , payload_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_len <S2SV_ModEnd> , mic_len , <S2SV_ModStart> , dec_buffer , payload_len , payload_len <S2SV_ModEnd> ) ; tvb_set_free_cb <S2SV_ModStart> , offset , payload_len <S2SV_ModEnd> ) ; call_dissector
<S2SV_ModStart> , { & ei_zbee_sec_encrypted_payload_sliced , { "zbee_sec.encrypted_payload_sliced" , PI_UNDECODED , PI_WARN , "Encrypted<S2SV_blank>payload,<S2SV_blank>cut<S2SV_blank>short<S2SV_blank>when<S2SV_blank>capturing<S2SV_blank>-<S2SV_blank>can\'t<S2SV_blank>decrypt" , EXPFILL } } , { &
<S2SV_ModStart> ; } } payload_len = tvb_captured_length_remaining <S2SV_ModEnd> ( tvb , <S2SV_ModStart> + mic_len ) ; if ( payload_len == 0 ) <S2SV_ModEnd> return NULL ; <S2SV_ModStart> return NULL ; <S2SV_ModEnd> if ( (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_egprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint <S2SV_ModEnd> offset = initial_offset <S2SV_ModStart> offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = * <S2SV_ModStart> 0 ) { <S2SV_ModEnd> item = proto_tree_add_bits_item
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_gprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = *
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * 8 ; gint <S2SV_ModEnd> bit_offset = 0
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> guint32 isr ; <S2SV_ModStart> guint32 isr ; guint8 isr_value <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { isr_value = tvb_get_guint8 ( tvb , offset + 36 + isr ) ; if ( isr_value <S2SV_ModEnd> == 0xFF ) <S2SV_ModStart> "%2.1f%s<S2SV_blank>" , ( isr_value <S2SV_ModEnd> & 0x7F ) <S2SV_ModStart> 0.5 , ( isr_value <S2SV_ModEnd> & 0x80 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_egprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint <S2SV_ModEnd> offset = initial_offset <S2SV_ModStart> offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = * <S2SV_ModStart> 0 ) { <S2SV_ModEnd> item = proto_tree_add_bits_item
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_gprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = *
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * 8 ; gint <S2SV_ModEnd> bit_offset = 0
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> guint32 isr ; <S2SV_ModStart> guint32 isr ; guint8 isr_value <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { isr_value = tvb_get_guint8 ( tvb , offset + 36 + isr ) ; if ( isr_value <S2SV_ModEnd> == 0xFF ) <S2SV_ModStart> "%2.1f%s<S2SV_blank>" , ( isr_value <S2SV_ModEnd> & 0x7F ) <S2SV_ModStart> 0.5 , ( isr_value <S2SV_ModEnd> & 0x80 )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_egprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint <S2SV_ModEnd> offset = initial_offset <S2SV_ModStart> offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = * <S2SV_ModStart> 0 ) { <S2SV_ModEnd> item = proto_tree_add_bits_item
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_gprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = *
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * 8 ; gint <S2SV_ModEnd> bit_offset = 0
<S2SV_ModStart> * conf_tree ; int save_offset ; <S2SV_ModStart> length ) { save_offset = offset ; <S2SV_ModStart> length ) ; if ( offset <= save_offset ) { break ; }
<S2SV_ModStart> -> tvb , <S2SV_ModEnd> offset , item_length
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> guint32 isr ; <S2SV_ModStart> guint32 isr ; guint8 isr_value <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { isr_value = tvb_get_guint8 ( tvb , offset + 36 + isr ) ; if ( isr_value <S2SV_ModEnd> == 0xFF ) <S2SV_ModStart> "%2.1f%s<S2SV_blank>" , ( isr_value <S2SV_ModEnd> & 0x7F ) <S2SV_ModStart> 0.5 , ( isr_value <S2SV_ModEnd> & 0x80 )
<S2SV_ModStart> n ; } test_length ( hfinfo , ptvc -> tvb , ptvc -> offset , item_length ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_egprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint <S2SV_ModEnd> offset = initial_offset <S2SV_ModStart> offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = * <S2SV_ModStart> 0 ) { <S2SV_ModEnd> item = proto_tree_add_bits_item
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_gprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = *
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * 8 ; gint <S2SV_ModEnd> bit_offset = 0
<S2SV_ModStart> * conf_tree ; int save_offset ; <S2SV_ModStart> length ) { save_offset = offset ; <S2SV_ModStart> length ) ; if ( offset <= save_offset ) { break ; }
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> guint32 isr ; <S2SV_ModStart> guint32 isr ; guint8 isr_value <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { isr_value = tvb_get_guint8 ( tvb , offset + 36 + isr ) ; if ( isr_value <S2SV_ModEnd> == 0xFF ) <S2SV_ModStart> "%2.1f%s<S2SV_blank>" , ( isr_value <S2SV_ModEnd> & 0x7F ) <S2SV_ModStart> 0.5 , ( isr_value <S2SV_ModEnd> & 0x80 )
<S2SV_ModStart> n ; } test_length ( hfinfo , ptvc -> tvb , ptvc -> offset , item_length ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_egprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint <S2SV_ModEnd> offset = initial_offset <S2SV_ModStart> offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = * <S2SV_ModStart> 0 ) { <S2SV_ModEnd> item = proto_tree_add_bits_item
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gint <S2SV_ModEnd> construct_gprs_data_segment_li_array ( tvbuff_t <S2SV_ModStart> e ) { gint offset = initial_offset ; guint8 <S2SV_ModEnd> li_array_size = *
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * data_tree ; gint <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * 8 ; gint <S2SV_ModEnd> bit_offset = 0
<S2SV_ModStart> * conf_tree ; int save_offset ; <S2SV_ModStart> length ) { save_offset = offset ; <S2SV_ModStart> length ) ; if ( offset <= save_offset ) { break ; }
<S2SV_ModStart> { wccp_wccp_address_table . <S2SV_ModEnd> family = family <S2SV_ModStart> ( wccp_wccp_address_table . in_use == FALSE ) && ( wccp_wccp_address_table . <S2SV_ModStart> ; if ( ( wccp_wccp_address_table . in_use == FALSE ) && <S2SV_ModStart> NULL ) && ( i <S2SV_ModEnd> < wccp_wccp_address_table . <S2SV_ModStart> ; if ( i <S2SV_ModEnd> > wccp_wccp_address_table . <S2SV_ModStart> ) ; } wccp_wccp_address_table . in_use = TRUE ;
<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
<S2SV_ModStart> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }
<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
<S2SV_ModStart> ) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;
<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> ! handle )
<S2SV_ModStart> goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> ps ) { int i ; <S2SV_ModStart> ) ) ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , ps -> <S2SV_ModStart> -> channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , "interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; err = - EINVAL ;
<S2SV_ModStart> : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> == 0 ) ret = <S2SV_ModEnd> key -> type <S2SV_ModStart> type -> read ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> ( & key <S2SV_ModStart> sem ) ; <S2SV_ModEnd> } error2 :
<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
<S2SV_ModStart> retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &
<S2SV_ModStart> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart> no_id ; } <S2SV_ModEnd> list_add ( &
<S2SV_ModStart> lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart> in_use ++ ; <S2SV_ModEnd> if ( next_id
<S2SV_ModStart> ; if ( IS_ERR ( sltmp ) ) return PTR_ERR ( sltmp ) ; <S2SV_ModEnd> if ( is
<S2SV_ModStart> ; if ( IS_ERR ( <S2SV_ModEnd> is -> slcomp <S2SV_ModStart> -> slcomp ) ) <S2SV_ModStart> ) ; return PTR_ERR ( is -> slcomp ) <S2SV_ModEnd> ; } #
<S2SV_ModStart> ; if ( IS_ERR ( vj ) ) { err = PTR_ERR ( vj ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; if ( IS_ERR ( slcomp ) <S2SV_ModEnd> ) goto err_exit
<S2SV_ModStart> ; memcpy ( <S2SV_ModEnd> wblock -> data
<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) )
<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
<S2SV_ModStart> ) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> ) ; } if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
<S2SV_ModStart> * io1 ; unsigned long flags ; <S2SV_ModStart> inode -> i_ino ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;
<S2SV_ModStart> * wq ; unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> = size ; io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> work ) ; ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> -> list , & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> ) ; iocb
<S2SV_ModStart> return ret ; <S2SV_ModEnd> ret = ext4_convert_unwritten_extents
<S2SV_ModStart> -> inode ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <S2SV_ModEnd> ; mutex_lock ( <S2SV_ModStart> if ( ret < <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { mutex_unlock ( & inode -> i_mutex ) ; return ; } spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> i_mutex ) ; ext4_free_io_end ( io ) ;
<S2SV_ModStart> ext4_init_io_end ( inode , GFP_NOFS
<S2SV_ModStart> ( ! io ) ; if ( io -> page ) put_page ( io -> page
<S2SV_ModStart> * handle = ext4_journal_current_handle ( ) <S2SV_ModEnd> ; int ret <S2SV_ModStart> int dio_credits ; int started = 0 ; <S2SV_ModStart> = EXT4_GET_BLOCKS_IO_CREATE_EXT ; if ( ! handle ) { <S2SV_ModStart> out ; } started = 1 ; } <S2SV_ModStart> 0 ; } if ( started )
<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (
<S2SV_ModStart> mapping -> host ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset
<S2SV_ModStart> = page ; if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> , fsdata , ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata ,
<S2SV_ModStart> buffer_head * page_bufs = NULL <S2SV_ModStart> ) ; else if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else
<S2SV_ModStart> ext4_io_end_t * io ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <S2SV_ModStart> list_empty ( & ei <S2SV_ModEnd> -> i_completed_io_list ) <S2SV_ModStart> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> list_empty ( & ei <S2SV_ModEnd> -> i_completed_io_list ) <S2SV_ModStart> = list_entry ( ei <S2SV_ModEnd> -> i_completed_io_list . <S2SV_ModStart> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ext4_end_io_nolock ( io ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;
<S2SV_ModStart> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT
<S2SV_ModStart> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
<S2SV_ModStart> i_completed_io_list ) ; spin_lock_init ( & ei -> i_completed_io_lock ) ;
<S2SV_ModStart> ",norecovery" ) ; if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , ",dioread_nolock" ) ;
<S2SV_ModStart> ; break ; case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ;
<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> 0 ] ; else zap = NULL ;
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;
<S2SV_ModStart> ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (
<S2SV_ModStart> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
<S2SV_ModStart> goto out ; err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart> dentry ) ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ) ; } <S2SV_ModEnd> ovl_drop_write ( dentry
<S2SV_ModStart> { # line 2151 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2090 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1982 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1975 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1608 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> * umts_fp_conversation_info _U_ ; void * conv_proto_data = NULL <S2SV_ModStart> ( old_conversation ) { conv_proto_data = conversation_get_proto_data ( old_conversation , proto_fp ) ; if ( conv_proto_data ) <S2SV_ModStart> ( umts_fp_conversation_info , conv_proto_data <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> { # line 1605 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1598 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1593 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1501 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 no_ddi_entries
<S2SV_ModStart> { # line 2002 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1761 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1870 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1709 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1850 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1706 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1660 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1697 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1692 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1738 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2080 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2116 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1629 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1731 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1619 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2094 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1700 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1703 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1636 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> ; # line 2143 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1653 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> { # line 2147 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2086 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1978 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1971 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1605 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> umts_fp_conversation_info_t ) ; if ( old_conversation )
<S2SV_ModStart> { # line 1602 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1595 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1590 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1498 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 no_ddi_entries
<S2SV_ModStart> { # line 1998 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1757 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1866 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1705 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1846 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1702 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1656 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1693 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1688 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1734 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2076 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2112 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1624 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1727 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1615 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2090 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1696 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1699 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1632 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> ; # line 2139 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1649 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> { # line 2146 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2085 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1977 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1970 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1604 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1409 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1601 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1594 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1589 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1356 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1497 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 no_ddi_entries
<S2SV_ModStart> { # line 1997 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1756 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1865 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1704 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1845 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1701 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1655 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1692 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1687 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1733 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2075 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2111 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1623 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1726 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1614 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2089 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1695 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1698 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1631 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> umts_fp_conversation_info_t * umts_fp_conversation_info = NULL <S2SV_ModStart> if ( conversation ) { umts_fp_conversation_info = ( umts_fp_conversation_info_t * ) conversation_get_proto_data ( conversation , proto_fp ) ; } if ( ( conversation == NULL ) || ( umts_fp_conversation_info && umts_fp_conversation_info <S2SV_ModEnd> -> channel == <S2SV_ModStart> channel == CHANNEL_DCH )
<S2SV_ModStart> ; # line 2138 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1648 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> i < number_of_pdus && i < MIN ( MAX_MAC_FRAMES , MAX_RLC_CHANS )
<S2SV_ModStart> { # line 2146 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2085 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1977 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1970 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1604 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1409 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1601 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1594 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1589 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1356 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1497 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 no_ddi_entries
<S2SV_ModStart> { # line 1997 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1756 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1865 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1704 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1845 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1701 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1655 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1692 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1687 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1733 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2075 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2111 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1623 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1726 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1614 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2089 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1695 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1698 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1631 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> umts_fp_conversation_info_t * umts_fp_conversation_info = NULL <S2SV_ModStart> if ( conversation ) { umts_fp_conversation_info = ( umts_fp_conversation_info_t * ) conversation_get_proto_data ( conversation , proto_fp ) ; } if ( ( conversation == NULL ) || ( umts_fp_conversation_info && umts_fp_conversation_info <S2SV_ModEnd> -> channel == <S2SV_ModStart> channel == CHANNEL_DCH )
<S2SV_ModStart> ; # line 2138 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1648 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> sizeof ( ipid ) ) ; memset ( ip , 0 , sizeof ( ip
<S2SV_ModStart> ; gint padding_start ; gint saved_offset = offset <S2SV_ModStart> ) ; } else if ( offset == saved_offset ) { proto_tree_add_expert ( field_tree , pinfo , & ei_alljoyn_empty_arg , tvb , offset , 0 ) ; offset = ( gint ) tvb_reported_length ( tvb ) ; }
<S2SV_ModStart> void ) { expert_module_t * expert_alljoyn ; <S2SV_ModStart> ett_alljoyn_ardp } ; static ei_register_info ei [ ] = { { & ei_alljoyn_empty_arg , { "alljoyn.empty_arg" , PI_MALFORMED , PI_ERROR , "Argument<S2SV_blank>is<S2SV_blank>empty" , EXPFILL } } } ; <S2SV_ModStart> ) ) ; expert_alljoyn = expert_register_protocol ( proto_AllJoyn_mess ) ; expert_register_field_array ( expert_alljoyn , ei , array_length ( ei ) ) ;
<S2SV_ModStart> ) ; } <S2SV_ModEnd> p_t38_conv = ( <S2SV_ModStart> ) ; } if ( ! p_t38_packet_conv ) {
<S2SV_ModStart> ) ; } <S2SV_ModEnd> p_t38_conv = ( <S2SV_ModStart> ) ; } if ( ! p_t38_packet_conv ) {
<S2SV_ModStart> ( n = MAX ( <S2SV_ModStart> transport_info -> media_count , 0 )
<S2SV_ModStart> ) ; } <S2SV_ModEnd> p_t38_conv = ( <S2SV_ModStart> ) ; } if ( ! p_t38_packet_conv ) {
<S2SV_ModStart> ) ; } <S2SV_ModEnd> p_t38_conv = ( <S2SV_ModStart> ) ; } if ( ! p_t38_packet_conv ) {
<S2SV_ModStart> ) value ; wmem_free ( NULL , <S2SV_ModEnd> ( gpointer )
<S2SV_ModStart> old_umd ) ; <S2SV_ModEnd> } g_hash_table_insert (
<S2SV_ModStart> { nlm_msg_res_matched_data * md_req , * md_rep ; md_req <S2SV_ModEnd> = ( nlm_msg_res_matched_data <S2SV_ModStart> ) ) ; md_req <S2SV_ModEnd> -> req_frame = <S2SV_ModStart> -> req_frame ; md_req <S2SV_ModEnd> -> rep_frame = <S2SV_ModStart> -> num ; md_req <S2SV_ModEnd> -> ns = <S2SV_ModStart> -> ns ; md_rep = ( nlm_msg_res_matched_data * ) g_memdup ( md_req , sizeof ( nlm_msg_res_matched_data ) ) ; <S2SV_ModStart> , GINT_TO_POINTER ( md_req <S2SV_ModEnd> -> req_frame ) <S2SV_ModStart> ( gpointer ) md_req <S2SV_ModEnd> ) ; g_hash_table_insert <S2SV_ModStart> , GINT_TO_POINTER ( md_rep <S2SV_ModEnd> -> rep_frame ) <S2SV_ModStart> ( gpointer ) md_rep <S2SV_ModEnd> ) ; g_hash_table_remove <S2SV_ModStart> ( gconstpointer ) <S2SV_ModEnd> old_umd ) ;
<S2SV_ModStart> guint16 family ; guint16 addr_len = optlen - 4 ; <S2SV_ModStart> ; if ( addr_len <S2SV_ModEnd> > 16 ) <S2SV_ModStart> ei_dns_opt_bad_length ) ; addr_len = 16 <S2SV_ModEnd> ; } tvb_memcpy <S2SV_ModStart> , cur_offset , addr_len <S2SV_ModEnd> ) ; switch <S2SV_ModStart> , cur_offset , addr_len <S2SV_ModEnd> , ip_addr . <S2SV_ModStart> , cur_offset , addr_len <S2SV_ModEnd> , ip_addr .
<S2SV_ModStart> 1 ) { goto invalid ; } if ( ret >= 2 ) { switch ( first_delim [ 0 ] ) { case '.' : case ',' : if ( ret == 2 ) { goto invalid ; } strptr += g_snprintf ( strptr , 5 , "%c%.3d" , first_delim [ 0 ] , first_digits ) ; if ( ret >= 4 ) { switch ( second_delim [ 0 ] ) { case '+' : case '-' : if ( ret == 4 ) { goto invalid ; } g_snprintf ( strptr , 12 , "<S2SV_blank>(UTC%c%.4d)" , second_delim [ 0 ] , second_digits ) ; break ; case 'Z' : g_snprintf ( strptr , 7 , "<S2SV_blank>(UTC)" ) ; break ; default : break ; } } break ; case '+' : case '-' : if ( ret == 2 ) { goto invalid ; } g_snprintf ( strptr , 12 , "<S2SV_blank>(UTC%c%.4d)" , first_delim [ 0 ] , first_digits ) ; break ; case 'Z' : g_snprintf ( strptr , 7 , "<S2SV_blank>(UTC)" ) ; break ; default : break ; } } if ( hf_id >= 0 ) { proto_tree_add_string ( tree , hf_id , tvb , offset , len , str ) ; } offset += len ; return offset ; invalid : <S2SV_ModStart> end_offset ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> cur ) ; if ( cur ) { <S2SV_ModStart> ; } } }
<S2SV_ModStart> cur ) ; if ( cur ) { <S2SV_ModStart> proto_name ) ; }
<S2SV_ModStart> } if ( tot_len > AIRPDCAP_MAX_CAPLEN ) { AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapPacketProcess" , "length<S2SV_blank>too<S2SV_blank>large" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_UNSUCCESS ; } if (
<S2SV_ModStart> : CCMP_GROUP_KEY_LEN ; if ( key_len > key_bytes_len ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
<S2SV_ModStart> , prefix_len_bytes ; proto_item * pi ; <S2SV_ModStart> ENC_BIG_ENDIAN ) ; pi = <S2SV_ModStart> 1 ) ; if ( prefix_len > 128 ) { expert_add_info ( pinfo , pi , & ei_diameter_invalid_ipv6_prefix_len ) ; } <S2SV_ModStart> ; } else if ( prefix_len_bytes < 16 )
<S2SV_ModStart> } } , { & ei_diameter_invalid_ipv6_prefix_len , { "diameter.invalid_ipv6_prefix_len" , PI_MALFORMED , PI_ERROR , "Invalid<S2SV_blank>IPv6<S2SV_blank>Prefix<S2SV_blank>length" , EXPFILL } }
<S2SV_ModStart> { if ( ( tgt + 15 < rec_size ) && ( <S2SV_ModStart> == 0xe2 ) ) <S2SV_ModStart> ; } else if ( tgt + SIG_FSQ_OFF < rec_size )
<S2SV_ModStart> == 0 ) { if ( mcsIndex < G_N_ELEMENTS ( canonical_rate_legacy ) ) bitrate = canonical_rate_legacy [ mcsIndex ] ; } <S2SV_ModEnd> else if (
<S2SV_ModStart> break ; } copy_address_shallow ( <S2SV_ModEnd> & request_key . <S2SV_ModStart> ) ) ; switch ( request_key . session_type ) { case RSVP_SESSION_TYPE_IPV4 : copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> u . session_ipv4 . destination , & request_key . u . session_ipv4 . destination ) ; break ; case RSVP_SESSION_TYPE_IPV4_LSP : copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> u . session_ipv4_lsp . destination , & request_key . u . session_ipv4_lsp . destination ) ; break ; case RSVP_SESSION_TYPE_AGGREGATE_IPV4 : copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> u . session_agg_ipv4 . destination , & request_key . u . session_agg_ipv4 . destination ) ; break ; case RSVP_SESSION_TYPE_IPV4_UNI : copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> u . session_ipv4_uni . destination , & request_key . u . session_ipv4_uni . destination ) ; break ; case RSVP_SESSION_TYPE_IPV4_E_NNI : copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> u . session_ipv4_enni . destination , & request_key . u . session_ipv4_enni . destination ) ; break ; default : break ; } copy_address_wmem ( wmem_file_scope ( ) , & new_request_key -> source_info . source , & rsvph -> source ) ;
<S2SV_ModStart> data_p ) { guint8 oct ; <S2SV_ModStart> guint8 packed_len ; <S2SV_ModEnd> char * str <S2SV_ModStart> ENC_BIG_ENDIAN ) ; oct = tvb_get_guint8 ( tvb , curr_offset ) ; <S2SV_ModStart> ; str = ( char * ) <S2SV_ModStart> FALSE ) ; if ( oct & 0x01 ) { str [ ( 2 * packed_len ) - 1 ] = '\\0' ; }
<S2SV_ModStart> ENC_BIG_ENDIAN ) ; <S2SV_ModEnd> if ( curr_offset <S2SV_ModStart> & Dgt_meid , TRUE <S2SV_ModEnd> ) ; proto_tree_add_string <S2SV_ModStart> ENC_BIG_ENDIAN ) ; <S2SV_ModEnd> if ( curr_offset <S2SV_ModStart> & Dgt_msid , TRUE <S2SV_ModEnd> ) ; proto_tree_add_string_format
<S2SV_ModStart> ENC_BIG_ENDIAN ) ; <S2SV_ModEnd> if ( curr_offset <S2SV_ModStart> , NULL , TRUE <S2SV_ModEnd> ) ; proto_tree_add_string_format
<S2SV_ModStart> - len ; string_level [ string_i ] = 0 ;
<S2SV_ModStart> { # line 2148 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2087 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1979 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1972 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> offset ; } if ( num_items > 0 )
<S2SV_ModStart> { # line 1999 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1758 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1867 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1706 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1847 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1703 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1657 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1694 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1689 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1735 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2077 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2113 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1626 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset = <S2SV_ModStart> FALSE ) ; if ( num_items > 0 )
<S2SV_ModStart> { # line 1728 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1616 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset = <S2SV_ModStart> offset ; } if ( num_items > 0 )
<S2SV_ModStart> { # line 2091 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1697 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1700 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1633 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> ; # line 2140 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1650 <S2SV_ModEnd> "../../asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> : default : return tvb_reported_length ( tvb ) <S2SV_ModEnd> ; } ti
<S2SV_ModStart> ; power_profile_count = MIN ( <S2SV_ModStart> , * offset ) , ZBEE_ZCL_PWR_PROF_NUM_PWR_PROF_ETT
<S2SV_ModStart> 4 ] ; guint <S2SV_ModEnd> type , length <S2SV_ModStart> } if ( length < sizeof frame2 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "ngsniffer:<S2SV_blank>REC_FRAME2<S2SV_blank>record<S2SV_blank>length<S2SV_blank>is<S2SV_blank>less<S2SV_blank>than<S2SV_blank>record<S2SV_blank>header<S2SV_blank>length" ) ; return - 1 ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ngsniffer -> maj_vers <S2SV_ModStart> ngsniffer -> maj_vers < 5 && <S2SV_ModEnd> ngsniffer -> min_vers <S2SV_ModStart> 95 ) length += sizeof frame4 - sizeof frame2 ; if ( length < sizeof frame4 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "ngsniffer:<S2SV_blank>REC_FRAME4<S2SV_blank>record<S2SV_blank>length<S2SV_blank>is<S2SV_blank>less<S2SV_blank>than<S2SV_blank>record<S2SV_blank>header<S2SV_blank>length" ) ; return - 1 ; } if ( ! ng_read_bytes ( wth , & frame4 , ( unsigned int ) sizeof frame4 , is_random , err , err_info ) ) return - 1 ; time_low = pletoh16 ( & frame4 . time_low ) ; time_med = pletoh16 ( & frame4 . time_med ) ; time_high = frame4 . time_high ; time_day = frame4 . time_day ; size = pletoh16 ( & frame4 . size ) ; true_size = pletoh16 ( & frame4 . true_size ) ; length -= sizeof frame4 ; <S2SV_ModEnd> set_pseudo_header_frame4 ( & <S2SV_ModStart> case REC_FRAME6 : if ( length < sizeof frame6 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "ngsniffer:<S2SV_blank>REC_FRAME6<S2SV_blank>record<S2SV_blank>length<S2SV_blank>is<S2SV_blank>less<S2SV_blank>than<S2SV_blank>record<S2SV_blank>header<S2SV_blank>length" ) ; return - 1 ; } <S2SV_ModStart> , buf , size <S2SV_ModEnd> , & phdr
<S2SV_ModStart> "Unknown<S2SV_blank>NWP<S2SV_blank>packet<S2SV_blank>type<S2SV_blank>(0x%02x)" ) ; col_add_str <S2SV_ModEnd> ( pinfo ->
<S2SV_ModStart> * sub_wmemtree ; guint last_offset = G_MAXUINT ; guint <S2SV_ModEnd> size ; gboolean
<S2SV_ModStart> buffer [ MP2T_SIZE + TRAILER_LEN_MAX
<S2SV_ModStart> } if ( bitrate == 0 ) { return WTAP_OPEN_ERROR ; } if (
<S2SV_ModStart> ; if ( list_len > 0 ) { if ( <S2SV_ModStart> % list_count ; }
<S2SV_ModStart> v ) { gchar * port_str = udp_port_to_display ( NULL , v ) ; <S2SV_ModStart> , "%s<S2SV_blank>(%d)" , port_str <S2SV_ModEnd> , v ) <S2SV_ModStart> v ) ; wmem_free ( NULL , port_str ) ;
<S2SV_ModStart> ENC_LITTLE_ENDIAN ) ; if ( nl_data -> num_cols > TDS_MAX_COLUMNS ) { nl_data -> num_cols = 0 ; return 0 ; }
<S2SV_ModStart> += 8 ; memset ( & phdr , 0 , sizeof ( phdr ) ) ;
<S2SV_ModStart> , n ; gint64 column_size ; <S2SV_ModStart> = num ; ti = <S2SV_ModStart> ENC_NA ) ; column_size = num * sizeof ( struct CTableColumn ) ; if ( column_size > tvb_reported_length_remaining ( tvb , offset ) ) { expert_add_info ( pinfo , ti , & ei_mswsp_msg_cpmsetbinding_ccolumns ) ; return tvb_reported_length ( tvb ) ; }
<S2SV_ModStart> PI_WARN , "previous<S2SV_blank>messages<S2SV_blank>needed<S2SV_blank>for<S2SV_blank>context<S2SV_blank>not<S2SV_blank>captured" , EXPFILL } } , { & ei_mswsp_msg_cpmsetbinding_ccolumns , { "mswsp.msg.cpmsetbinding.ccolumns.invalude" , PI_PROTOCOL , PI_WARN , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>cColumns<S2SV_blank>for<S2SV_blank>packet"
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> ) { struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart> num_pages ++ ; <S2SV_ModEnd> count += tmp
<S2SV_ModStart> if ( indev && indev -> ifa_list <S2SV_ModEnd> ) { ifa
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;
<S2SV_ModStart> iovec , compat , & iter <S2SV_ModStart> len , iovec , & iter <S2SV_ModStart> iter_op ) { ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> nr_segs , req
<S2SV_ModStart> iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;
<S2SV_ModStart> , bool compat , struct iov_iter * iter <S2SV_ModStart> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } down_write <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
<S2SV_ModStart> ext4_lblk_t lblk ; <S2SV_ModEnd> unsigned int blkbits <S2SV_ModStart> ret ; } <S2SV_ModEnd> start = round_up <S2SV_ModStart> EXT4_EX_NOCACHE ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> inode ) ; <S2SV_ModEnd> ret = ext4_alloc_file_blocks <S2SV_ModStart> flags , mode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> last_block_offset ) ; <S2SV_ModEnd> if ( ext4_test_inode_flag <S2SV_ModStart> handle ) ; <S2SV_ModEnd> inode -> i_mtime <S2SV_ModStart> ; out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
<S2SV_ModStart> i_data_sem ) ; init_rwsem ( & ei -> i_mmap_sem ) ;
<S2SV_ModStart> inode ) { down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr
<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
<S2SV_ModStart> = ext4_xattr_create_cache ( <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }
<S2SV_ModStart> failed_mount3 ; } # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> ; failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;
<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;
<S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu ,
<S2SV_ModStart> { struct sockaddr_rc sa <S2SV_ModEnd> ; struct sock <S2SV_ModStart> sk ; int len , <S2SV_ModEnd> err = 0 <S2SV_ModStart> err = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> ; if ( sa . rc_channel <S2SV_ModEnd> && __rfcomm_get_listen_sock_by_addr ( <S2SV_ModStart> && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <S2SV_ModEnd> rc_bdaddr ) ) <S2SV_ModStart> , & sa . <S2SV_ModEnd> rc_bdaddr ) ; <S2SV_ModStart> -> channel = sa . rc_channel <S2SV_ModEnd> ; sk ->
<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =
<S2SV_ModStart> -> bio ) { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> EIO ) ; srp -> rq = NULL ; }
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
<S2SV_ModStart> termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;
<S2SV_ModStart> arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback
<S2SV_ModStart> mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> crypto_alloc_skcipher ( name <S2SV_ModStart> mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ;
<S2SV_ModStart> private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; }
<S2SV_ModStart> keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> , key , <S2SV_ModStart> keylen ) ; tfm -> has_key = ! err ; return err ;
<S2SV_ModStart> -> ctx -> task <S2SV_ModEnd> != ctx -> <S2SV_ModStart> != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context
<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
<S2SV_ModStart> ; BIGNUM * tmp = NULL ; BN_CTX * ctx = NULL ; * ret = 0 ; ctx = BN_CTX_new ( ) ; if ( ctx <S2SV_ModEnd> == NULL ) <S2SV_ModStart> goto err ; BN_CTX_start ( ctx ) ; tmp = BN_CTX_get ( ctx ) ; if ( tmp == NULL ) goto err ; BN_set_word ( tmp <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( pub_key , tmp <S2SV_ModEnd> ) <= 0 <S2SV_ModStart> ; BN_copy ( tmp <S2SV_ModEnd> , dh -> <S2SV_ModStart> ; BN_sub_word ( tmp <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( pub_key , tmp <S2SV_ModEnd> ) >= 0 <S2SV_ModStart> |= DH_CHECK_PUBKEY_TOO_LARGE ; if ( dh -> <S2SV_ModEnd> q != NULL <S2SV_ModStart> != NULL ) { if ( ! BN_mod_exp ( tmp , pub_key , dh -> q , dh -> p , ctx ) ) goto err ; if ( ! BN_is_one ( tmp ) ) * ret |= DH_CHECK_PUBKEY_INVALID ; } ok = 1 ; err : if ( ctx != NULL ) { BN_CTX_end ( ctx ) ; BN_CTX_free ( ctx ) ; } <S2SV_ModEnd> return ( ok
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! DH_generate_key ( <S2SV_ModStart> goto err ; <S2SV_ModEnd> } r [
<S2SV_ModStart> ; BIGNUM * tmp = NULL ; BN_CTX * ctx = NULL ; * ret = 0 ; ctx = BN_CTX_new ( ) ; if ( ctx <S2SV_ModEnd> == NULL ) <S2SV_ModStart> goto err ; BN_CTX_start ( ctx ) ; tmp = BN_CTX_get ( ctx ) ; if ( tmp == NULL ) goto err ; BN_set_word ( tmp <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( pub_key , tmp <S2SV_ModEnd> ) <= 0 <S2SV_ModStart> ; BN_copy ( tmp <S2SV_ModEnd> , dh -> <S2SV_ModStart> ; BN_sub_word ( tmp <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( pub_key , tmp <S2SV_ModEnd> ) >= 0 <S2SV_ModStart> |= DH_CHECK_PUBKEY_TOO_LARGE ; if ( dh -> q != NULL ) { if ( ! BN_mod_exp ( tmp , pub_key , dh -> q , dh -> p , ctx ) ) goto err ; if ( ! BN_is_one ( tmp ) ) * ret |= DH_CHECK_PUBKEY_INVALID ; } <S2SV_ModStart> ; err : if ( ctx != NULL ) { BN_CTX_end ( ctx ) ; BN_CTX_free ( ctx ) ; } <S2SV_ModEnd> return ( ok
<S2SV_ModStart> } if ( <S2SV_ModEnd> s -> cert
<S2SV_ModStart> } if ( <S2SV_ModEnd> cert -> dh_tmp
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! DH_generate_key ( <S2SV_ModStart> goto err ; <S2SV_ModEnd> } r [
<S2SV_ModStart> = 5 ; powerbufLen += <S2SV_ModEnd> top * sizeof <S2SV_ModStart> * sizeof ( mont -> N . <S2SV_ModEnd> d [ 0 <S2SV_ModStart> ; BN_ULONG * n0 = mont -> n0 , * np ; for ( i = am . top ; i < top ; i ++ ) am . d [ i ] = 0 ; for ( i = tmp . top ; i < top ; i ++ ) tmp . d [ i ] = 0 ; for ( np = am . d + top , i = 0 ; i < top ; i ++ ) np [ i ] <S2SV_ModEnd> = mont -> <S2SV_ModStart> N . d <S2SV_ModEnd> [ i ] <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , NULL , np <S2SV_ModEnd> , n0 ,
<S2SV_ModStart> , 0 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 1 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 2 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , i , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> idx , int window ) { int i , j ; int width = 1 << window ; volatile BN_ULONG * table = ( volatile BN_ULONG * ) buf <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 0 ; if ( window <= 3 ) { <S2SV_ModStart> i = 0 ; i < top ; i ++ , table += width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < width ; j ++ ) { acc |= table [ j ] & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> -> d [ i ] = acc ; } } else { int xstride = 1 << ( window - 2 ) ; BN_ULONG y0 , y1 , y2 , y3 ; i = idx >> ( window - 2 ) ; idx &= xstride - 1 ; y0 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 0 ) & 1 ) ; y1 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 1 ) & 1 ) ; y2 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 2 ) & 1 ) ; y3 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 3 ) & 1 ) ; for ( i = 0 ; i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ , table <S2SV_ModEnd> += width ) <S2SV_ModStart> width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < xstride ; j ++ ) { acc |= ( ( table [ j + 0 * xstride ] & y0 ) | ( table [ j + 1 * xstride ] & y1 ) | ( table [ j + 2 * xstride ] & y2 ) | ( table [ j + 3 * xstride ] & y3 ) ) & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d [ i ] = acc ; } <S2SV_ModEnd> } b ->
<S2SV_ModStart> idx , int window ) { int <S2SV_ModEnd> i , j <S2SV_ModStart> i , j ; int width = 1 << window ; BN_ULONG * table = ( BN_ULONG * ) buf <S2SV_ModStart> i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> width ) { table <S2SV_ModEnd> [ j ] <S2SV_ModStart> j ] = <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d <S2SV_ModEnd> [ i ]
<S2SV_ModStart> = 5 ; powerbufLen += <S2SV_ModEnd> top * sizeof <S2SV_ModStart> * sizeof ( mont -> N . <S2SV_ModEnd> d [ 0 <S2SV_ModStart> ; BN_ULONG * n0 = mont -> n0 , * np ; for ( i = am . top ; i < top ; i ++ ) am . d [ i ] = 0 ; for ( i = tmp . top ; i < top ; i ++ ) tmp . d [ i ] = 0 ; for ( np = am . d + top , i = 0 ; i < top ; i ++ ) np [ i ] <S2SV_ModEnd> = mont -> <S2SV_ModStart> N . d <S2SV_ModEnd> [ i ] <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , powerbuf , np <S2SV_ModEnd> , n0 , <S2SV_ModStart> , NULL , np <S2SV_ModEnd> , n0 ,
<S2SV_ModStart> , 0 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 1 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 2 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , i , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> idx , int window ) { int i , j ; int width = 1 << window ; volatile BN_ULONG * table = ( volatile BN_ULONG * ) buf <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 0 ; if ( window <= 3 ) { <S2SV_ModStart> i = 0 ; i < top ; i ++ , table += width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < width ; j ++ ) { acc |= table [ j ] & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> -> d [ i ] = acc ; } } else { int xstride = 1 << ( window - 2 ) ; BN_ULONG y0 , y1 , y2 , y3 ; i = idx >> ( window - 2 ) ; idx &= xstride - 1 ; y0 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 0 ) & 1 ) ; y1 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 1 ) & 1 ) ; y2 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 2 ) & 1 ) ; y3 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 3 ) & 1 ) ; for ( i = 0 ; i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ , table <S2SV_ModEnd> += width ) <S2SV_ModStart> width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < xstride ; j ++ ) { acc |= ( ( table [ j + 0 * xstride ] & y0 ) | ( table [ j + 1 * xstride ] & y1 ) | ( table [ j + 2 * xstride ] & y2 ) | ( table [ j + 3 * xstride ] & y3 ) ) & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d [ i ] = acc ; } <S2SV_ModEnd> } b ->
<S2SV_ModStart> idx , int window ) { int <S2SV_ModEnd> i , j <S2SV_ModStart> i , j ; int width = 1 << window ; BN_ULONG * table = ( BN_ULONG * ) buf <S2SV_ModStart> i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> width ) { table <S2SV_ModEnd> [ j ] <S2SV_ModStart> j ] = <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d <S2SV_ModEnd> [ i ]
<S2SV_ModStart> , 0 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 1 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , 2 , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( ! MOD_EXP_CTIME_COPY_TO_PREBUF ( & tmp , top , powerbuf , i , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto <S2SV_ModStart> , wvalue , window <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> idx , int window ) { int i , j ; int width = 1 << window ; volatile BN_ULONG * table = ( volatile BN_ULONG * ) buf <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 0 ; if ( window <= 3 ) { <S2SV_ModStart> i = 0 ; i < top ; i ++ , table += width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < width ; j ++ ) { acc |= table [ j ] & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> -> d [ i ] = acc ; } } else { int xstride = 1 << ( window - 2 ) ; BN_ULONG y0 , y1 , y2 , y3 ; i = idx >> ( window - 2 ) ; idx &= xstride - 1 ; y0 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 0 ) & 1 ) ; y1 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 1 ) & 1 ) ; y2 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 2 ) & 1 ) ; y3 = ( BN_ULONG ) 0 - ( constant_time_eq_int ( i , 3 ) & 1 ) ; for ( i = 0 ; i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ , table <S2SV_ModEnd> += width ) <S2SV_ModStart> width ) { BN_ULONG acc = 0 ; for ( j = 0 ; j < xstride ; j ++ ) { acc |= ( ( table [ j + 0 * xstride ] & y0 ) | ( table [ j + 1 * xstride ] & y1 ) | ( table [ j + 2 * xstride ] & y2 ) | ( table [ j + 3 * xstride ] & y3 ) ) & ( ( BN_ULONG ) 0 - ( constant_time_eq_int ( j , idx ) & 1 ) ) ; } <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d [ i ] = acc ; } <S2SV_ModEnd> } b ->
<S2SV_ModStart> idx , int window ) { int <S2SV_ModEnd> i , j <S2SV_ModStart> i , j ; int width = 1 << window ; BN_ULONG * table = ( BN_ULONG * ) buf <S2SV_ModStart> i < top <S2SV_ModEnd> ; i ++ <S2SV_ModStart> width ) { table <S2SV_ModEnd> [ j ] <S2SV_ModStart> j ] = <S2SV_ModEnd> b -> d <S2SV_ModStart> b -> d <S2SV_ModEnd> [ i ]
<S2SV_ModStart> ; unsigned int num_encrypted_key_bytes , key_length <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> * md ; unsigned char rand_premaster_secret [ SSL_MAX_MASTER_KEY_LENGTH ] ; unsigned char decrypt_good ; size_t j ; <S2SV_ModStart> ) ; } key_length = ( unsigned int ) EVP_CIPHER_key_length ( c ) ; if ( key_length > SSL_MAX_MASTER_KEY_LENGTH ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModStart> = 1 ; num_encrypted_key_bytes <S2SV_ModEnd> = 8 ; <S2SV_ModStart> ; } else if ( is_export ) { num_encrypted_key_bytes <S2SV_ModEnd> = 5 ; <S2SV_ModStart> = 5 ; } else { num_encrypted_key_bytes = key_length ; } if ( <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . clear + num_encrypted_key_bytes != key_length <S2SV_ModEnd> ) { ssl2_return_error <S2SV_ModStart> } if ( <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . enc < num_encrypted_key_bytes ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } if ( RAND_pseudo_bytes ( rand_premaster_secret , ( int ) num_encrypted_key_bytes ) <= 0 ) return 0 ; <S2SV_ModEnd> i = ssl_rsa_private_decrypt <S2SV_ModStart> RSA_PKCS1_PADDING ) ; ERR_clear_error ( ) ; decrypt_good = constant_time_eq_int_8 ( i , ( int ) num_encrypted_key_bytes ) ; for ( j = 0 ; j < num_encrypted_key_bytes ; j ++ ) { p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . clear + j ] = constant_time_select_8 ( decrypt_good , p [ s -> s2 -> tmp . clear + j ] , rand_premaster_secret [ j ] ) ; } s -> session -> master_key_length = ( int ) key_length ; memcpy ( s -> session -> master_key , p , key_length ) ; OPENSSL_cleanse ( p , key_length ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; unsigned int num_encrypted_key_bytes , key_length <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> * md ; unsigned char rand_premaster_secret [ SSL_MAX_MASTER_KEY_LENGTH ] ; unsigned char decrypt_good ; size_t j ; <S2SV_ModStart> ) ; } key_length = ( unsigned int ) EVP_CIPHER_key_length ( c ) ; if ( key_length > SSL_MAX_MASTER_KEY_LENGTH ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModStart> = 1 ; num_encrypted_key_bytes <S2SV_ModEnd> = 8 ; <S2SV_ModStart> ; } else if ( is_export ) { num_encrypted_key_bytes <S2SV_ModEnd> = 5 ; <S2SV_ModStart> = 5 ; } else { num_encrypted_key_bytes = key_length ; } if ( <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . clear + num_encrypted_key_bytes != key_length <S2SV_ModEnd> ) { ssl2_return_error <S2SV_ModStart> } if ( <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . enc < num_encrypted_key_bytes ) { ssl2_return_error ( s , SSL2_PE_UNDEFINED_ERROR ) ; SSLerr ( SSL_F_GET_CLIENT_MASTER_KEY , SSL_R_LENGTH_TOO_SHORT ) ; return - 1 ; } if ( RAND_pseudo_bytes ( rand_premaster_secret , ( int ) num_encrypted_key_bytes ) <= 0 ) return 0 ; <S2SV_ModEnd> i = ssl_rsa_private_decrypt <S2SV_ModStart> RSA_PKCS1_PADDING ) ; ERR_clear_error ( ) ; decrypt_good = constant_time_eq_int_8 ( i , ( int ) num_encrypted_key_bytes ) ; for ( j = 0 ; j < num_encrypted_key_bytes ; j ++ ) { p [ <S2SV_ModEnd> s -> s2 <S2SV_ModStart> . clear + j ] = constant_time_select_8 ( decrypt_good , p [ s -> s2 -> tmp . clear + j ] , rand_premaster_secret [ j ] ) ; } s -> session -> master_key_length = ( int ) key_length ; memcpy ( s -> session -> master_key , p , key_length ) ; OPENSSL_cleanse ( p , key_length ) ; return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = NULL ; int ret = 0 ; <S2SV_ModStart> dsa ) ; ret = 1 ; goto done <S2SV_ModEnd> ; decerr : <S2SV_ModStart> ; dsaerr : DSA_free ( dsa ) ; done : <S2SV_ModStart> ; if ( ndsa ) sk_ASN1_TYPE_pop_free ( ndsa , ASN1_TYPE_free ) ; else <S2SV_ModEnd> ASN1_STRING_clear_free ( privkey <S2SV_ModStart> privkey ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> p , * q , * <S2SV_ModStart> = NULL ; <S2SV_ModEnd> DSA * dsa <S2SV_ModStart> dsa = NULL ; int ret = 0 <S2SV_ModStart> palg ) ; <S2SV_ModEnd> q = p <S2SV_ModStart> goto decerr ; <S2SV_ModEnd> pstr = pval <S2SV_ModStart> dsa ) ; ret = 1 ; goto done <S2SV_ModEnd> ; decerr : <S2SV_ModStart> ; dsaerr : DSA_free ( dsa ) ; done : <S2SV_ModStart> privkey ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = NULL ; int ret = 0 ; <S2SV_ModStart> dsa ) ; ret = 1 ; goto done <S2SV_ModEnd> ; decerr : <S2SV_ModStart> ; dsaerr : DSA_free ( dsa ) ; done : <S2SV_ModStart> ; if ( ndsa ) sk_ASN1_TYPE_pop_free ( ndsa , ASN1_TYPE_free ) ; else <S2SV_ModEnd> ASN1_STRING_clear_free ( privkey <S2SV_ModStart> privkey ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> ( tag == ASN1_EOC <S2SV_ModEnd> ) { if <S2SV_ModStart> <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> > sizeof ( len <S2SV_ModEnd> ) - 1 <S2SV_ModStart> goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > <S2SV_ModStart> ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 <S2SV_ModEnd> ) goto err <S2SV_ModStart> goto err ; num = i + neg ; if ( bn == NULL ) return ( num ) ; if ( * bn == NULL ) { if ( ( ret = BN_new ( ) ) == NULL ) return ( 0 ) ; } else { ret = * bn ; BN_zero ( ret ) ; } if ( bn_expand ( ret , i * 4 ) == NULL ) goto err ;
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 ) goto err
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 <S2SV_ModEnd> ) goto err <S2SV_ModStart> goto err ; num = i + neg ; if ( bn == NULL ) return ( num ) ; if ( * bn == NULL ) { if ( ( ret = BN_new ( ) ) == NULL ) return ( 0 ) ; } else { ret = * bn ; BN_zero ( ret ) ; } if ( bn_expand ( ret , i * 4 ) == NULL ) goto err ;
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 ) goto err
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 <S2SV_ModEnd> ) goto err <S2SV_ModStart> goto err ; num = i + neg ; if ( bn == NULL ) return ( num ) ; if ( * bn == NULL ) { if ( ( ret = BN_new ( ) ) == NULL ) return ( 0 ) ; } else { ret = * bn ; BN_zero ( ret ) ; } if ( bn_expand ( ret , i * 4 ) == NULL ) goto err ;
<S2SV_ModStart> = 0 ; i <= ( INT_MAX / 4 ) && <S2SV_ModStart> i ++ ) continue ; if ( i > INT_MAX / 4 ) goto err
<S2SV_ModStart> login ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>accept\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>write\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> login ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> username ) { return find_user ( vb <S2SV_ModEnd> , username ) <S2SV_ModStart> , username ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void SRP_user_pwd_free (
<S2SV_ModStart> login ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>accept\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> ) arg ; int ret = SSL3_AL_FATAL ; <S2SV_ModStart> login ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> = SSL_AD_INTERNAL_ERROR ; goto err ; } BIO_printf ( bio_err , "SRP<S2SV_blank>parameters<S2SV_blank>set:<S2SV_blank>username<S2SV_blank>=<S2SV_blank>\\"%s\\"<S2SV_blank>info=\\"%s\\"<S2SV_blank>\\n" , p -> login , p -> user -> info ) ; ret = SSL_ERROR_NONE ; err : SRP_user_pwd_free ( p -> user ) ; p -> user = NULL ; p -> login = NULL ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>write\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> username ) { return find_user ( vb <S2SV_ModEnd> , username ) <S2SV_ModStart> , username ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void SRP_user_pwd_free (
<S2SV_ModStart> login ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>write\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> login ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm . <S2SV_ModStart> "LOOKUP<S2SV_blank>renego<S2SV_blank>during<S2SV_blank>read\\n" ) ; SRP_user_pwd_free ( <S2SV_ModStart> srp_callback_parm . user ) ; srp_callback_parm . user = SRP_VBASE_get1_by_user <S2SV_ModEnd> ( srp_callback_parm .
<S2SV_ModStart> username ) { return find_user ( vb <S2SV_ModEnd> , username ) <S2SV_ModStart> , username ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void SRP_user_pwd_free (
<S2SV_ModStart> "doapr()" ) ; if ( ! <S2SV_ModStart> , args ) ) { OPENSSL_free ( dynbuf ) ; return - 1 ; } <S2SV_ModEnd> if ( dynbuf
<S2SV_ModStart> int truncated ; if ( ! <S2SV_ModStart> , args ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> _dopr ( char <S2SV_ModStart> DP_S_FLAGS ; else if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> double ) ; if ( ! <S2SV_ModStart> , max , flags ) ) return 0 <S2SV_ModEnd> ; break ; <S2SV_ModStart> case 'c' : if ( ! <S2SV_ModStart> int ) ) ) return 0 <S2SV_ModStart> maxlen ; } if ( ! <S2SV_ModStart> , max ) ) return 0 <S2SV_ModStart> * ) ; if ( ! <S2SV_ModStart> | DP_F_NUM ) ) return 0 <S2SV_ModStart> case '%' : if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> - 1 ; if ( ! <S2SV_ModStart> , '\\0' ) ) return 0 <S2SV_ModStart> 1 ; return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> doapr_outch ( char <S2SV_ModStart> maxlen ) { if ( * maxlen > INT_MAX - BUFFER_INC ) return 0 ; <S2SV_ModStart> * maxlen += BUFFER_INC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( * buffer == NULL ) return 0 ; <S2SV_ModEnd> if ( * <S2SV_ModStart> } else { char * tmpbuf ; tmpbuf <S2SV_ModEnd> = OPENSSL_realloc ( <S2SV_ModStart> ; if ( tmpbuf == NULL ) return 0 ; * buffer = tmpbuf ; <S2SV_ModEnd> } } if <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtfp ( char <S2SV_ModStart> signvalue ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; -- padlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> if ( signvalue && ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> iplace ] ) ) return 0 ; } <S2SV_ModEnd> if ( max <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '.' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , <S2SV_ModEnd> fconvert [ -- <S2SV_ModStart> fplace ] ) ) return 0 ; } <S2SV_ModEnd> } while ( <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> padlen ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtint ( char <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ( signvalue ) if ( ! <S2SV_ModStart> , signvalue ) ) return 0 <S2SV_ModStart> prefix ) { if ( ! <S2SV_ModStart> * prefix ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> place ] ) ) return 0 ; } <S2SV_ModEnd> while ( spadlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtstr ( char <S2SV_ModStart> { int padlen ; size_t <S2SV_ModEnd> strln ; int <S2SV_ModStart> = "<NULL>" ; strln = strlen ( value ) ; if ( strln > INT_MAX ) strln = INT_MAX <S2SV_ModEnd> ; padlen = <S2SV_ModStart> ; if ( min < 0 || <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> value ++ ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 ; ++ padlen ; ++ cnt ; } return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = NULL ; if ( ! <S2SV_ModStart> , args ) ) { OPENSSL_free ( dynbuf ) ; return - 1 ; } <S2SV_ModEnd> if ( dynbuf
<S2SV_ModStart> int truncated ; if ( ! <S2SV_ModStart> , args ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> _dopr ( char <S2SV_ModStart> DP_S_FLAGS ; else if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> double ) ; if ( ! <S2SV_ModStart> , max , flags ) ) return 0 <S2SV_ModEnd> ; break ; <S2SV_ModStart> case 'c' : if ( ! <S2SV_ModStart> int ) ) ) return 0 <S2SV_ModStart> maxlen ; } if ( ! <S2SV_ModStart> , max ) ) return 0 <S2SV_ModStart> * ) ; if ( ! <S2SV_ModStart> | DP_F_NUM ) ) return 0 <S2SV_ModStart> case '%' : if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> - 1 ; if ( ! <S2SV_ModStart> , '\\0' ) ) return 0 <S2SV_ModStart> 1 ; return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> doapr_outch ( char <S2SV_ModStart> maxlen ) { if ( * maxlen > INT_MAX - BUFFER_INC ) return 0 ; <S2SV_ModStart> * maxlen += BUFFER_INC <S2SV_ModEnd> ; if ( <S2SV_ModStart> == NULL ) return 0 ; <S2SV_ModEnd> if ( * <S2SV_ModStart> } else { char * tmpbuf ; tmpbuf <S2SV_ModEnd> = OPENSSL_realloc ( <S2SV_ModStart> ; if ( tmpbuf == NULL ) return 0 ; * buffer = tmpbuf ; <S2SV_ModEnd> } } if <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtfp ( char <S2SV_ModStart> signvalue ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; -- padlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> if ( signvalue && ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> iplace ] ) ) return 0 ; } <S2SV_ModEnd> if ( max <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '.' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , <S2SV_ModEnd> fconvert [ -- <S2SV_ModStart> fplace ] ) ) return 0 ; } <S2SV_ModEnd> } while ( <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> padlen ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtint ( char <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ( signvalue ) if ( ! <S2SV_ModStart> , signvalue ) ) return 0 <S2SV_ModStart> prefix ) { if ( ! <S2SV_ModStart> * prefix ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> place ] ) ) return 0 ; } <S2SV_ModEnd> while ( spadlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtstr ( char <S2SV_ModStart> { int padlen ; size_t <S2SV_ModEnd> strln ; int <S2SV_ModStart> = "<NULL>" ; strln = strlen ( value ) ; if ( strln > INT_MAX ) strln = INT_MAX <S2SV_ModEnd> ; padlen = <S2SV_ModStart> ; if ( min < 0 || <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> value ++ ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 ; ++ padlen ; ++ cnt ; } return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> "doapr()" ) ; if ( ! <S2SV_ModStart> , args ) ) { OPENSSL_free ( dynbuf ) ; return - 1 ; } <S2SV_ModEnd> if ( dynbuf
<S2SV_ModStart> int truncated ; if ( ! <S2SV_ModStart> , args ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> _dopr ( char <S2SV_ModStart> DP_S_FLAGS ; else if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> double ) ; if ( ! <S2SV_ModStart> , max , flags ) ) return 0 <S2SV_ModEnd> ; break ; <S2SV_ModStart> case 'c' : if ( ! <S2SV_ModStart> int ) ) ) return 0 <S2SV_ModStart> maxlen ; } if ( ! <S2SV_ModStart> , max ) ) return 0 <S2SV_ModStart> * ) ; if ( ! <S2SV_ModStart> | DP_F_NUM ) ) return 0 <S2SV_ModStart> case '%' : if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> - 1 ; if ( ! <S2SV_ModStart> , '\\0' ) ) return 0 <S2SV_ModStart> 1 ; return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> doapr_outch ( char <S2SV_ModStart> maxlen ) { if ( * maxlen > INT_MAX - BUFFER_INC ) return 0 ; <S2SV_ModStart> * maxlen += BUFFER_INC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( * buffer == NULL ) return 0 ; <S2SV_ModEnd> if ( * <S2SV_ModStart> } else { char * tmpbuf ; tmpbuf <S2SV_ModEnd> = OPENSSL_realloc ( <S2SV_ModStart> ; if ( tmpbuf == NULL ) return 0 ; * buffer = tmpbuf ; <S2SV_ModEnd> } } if <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtfp ( char <S2SV_ModStart> signvalue ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; -- padlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> if ( signvalue && ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> iplace ] ) ) return 0 ; } <S2SV_ModEnd> if ( max <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '.' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , <S2SV_ModEnd> fconvert [ -- <S2SV_ModStart> fplace ] ) ) return 0 ; } <S2SV_ModEnd> } while ( <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> padlen ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtint ( char <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ( signvalue ) if ( ! <S2SV_ModStart> , signvalue ) ) return 0 <S2SV_ModStart> prefix ) { if ( ! <S2SV_ModStart> * prefix ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> place ] ) ) return 0 ; } <S2SV_ModEnd> while ( spadlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtstr ( char <S2SV_ModStart> { int padlen ; size_t <S2SV_ModEnd> strln ; int <S2SV_ModStart> = "<NULL>" ; strln = strlen ( value ) ; if ( strln > INT_MAX ) strln = INT_MAX <S2SV_ModEnd> ; padlen = <S2SV_ModStart> ; if ( min < 0 || <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> value ++ ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 ; ++ padlen ; ++ cnt ; } return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> |= SSL_OP_LEGACY_SERVER_CONNECT ; ret -> options |= SSL_OP_NO_SSLv2 ;
<S2SV_ModStart> ) } ; int ret ; int sslv2off ; <S2SV_ModStart> ssl_flag_tbl ) ; sslv2off = * cctx -> poptions & SSL_OP_NO_SSLv2 ; ret = <S2SV_ModEnd> CONF_parse_list ( value <S2SV_ModStart> cctx ) ; * cctx -> poptions |= sslv2off ; return ret ;
<S2SV_ModStart> |= SSL_OP_LEGACY_SERVER_CONNECT ; ret -> options |= SSL_OP_NO_SSLv2 ;
<S2SV_ModStart> , } ; struct dentry * root = <S2SV_ModEnd> mount_pseudo ( fs_type <S2SV_ModStart> AIO_RING_MAGIC ) ; if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ;
<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
<S2SV_ModStart> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct <S2SV_ModStart> ) ) return false ; * type |= <S2SV_ModEnd> algt -> type <S2SV_ModStart> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & <S2SV_ModEnd> CRYPTO_ALG_INTERNAL ; if <S2SV_ModStart> ; if ( * type & * <S2SV_ModEnd> mask & CRYPTO_ALG_INTERNAL <S2SV_ModStart> & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int err ; if ( ! <S2SV_ModStart> & mask ) ) return - EINVAL
<S2SV_ModStart> 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart> destroy ( dev <S2SV_ModEnd> ) ; return
<S2SV_ModStart> key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( "des" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , "first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" "(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> ; fh_drop_write ( <S2SV_ModStart> return nfserr ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh
<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh
<S2SV_ModStart> ; if ( <S2SV_ModEnd> S_ISDIR ( inode <S2SV_ModStart> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( <S2SV_ModStart> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl
<S2SV_ModStart> int time_slice ; struct rq_flags rf ; struct timespec t <S2SV_ModEnd> ; struct rq <S2SV_ModStart> ; int retval <S2SV_ModEnd> ; if ( <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; time_slice <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; rcu_read_unlock
<S2SV_ModStart> attr -> sched_policy <S2SV_ModEnd> ; const struct <S2SV_ModStart> prev_class ; struct rq_flags rf <S2SV_ModEnd> ; int reset_on_fork <S2SV_ModStart> | DEQUEUE_MOVE ; struct rq * rq ; <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; if <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; goto <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; if
<S2SV_ModStart> dl . dl_bw && task_has_dl_policy ( p )
<S2SV_ModStart> task_struct * prev , struct pin_cookie cookie <S2SV_ModStart> rq , prev , cookie <S2SV_ModStart> rq , prev , cookie <S2SV_ModStart> rq , prev , cookie
<S2SV_ModStart> 0 ) ; cpu_load_update_active <S2SV_ModEnd> ( rq )
<S2SV_ModStart> , queued ; struct rq_flags rf <S2SV_ModEnd> ; struct rq <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; if <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; }
<S2SV_ModStart> # ifdef CONFIG_SCHED_DEBUG if ( ! state_filter )
<S2SV_ModStart> p ) { struct rq_flags rf <S2SV_ModEnd> ; struct rq <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; if <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; return
<S2SV_ModStart> p ) { struct rq_flags rf <S2SV_ModEnd> ; struct rq <S2SV_ModStart> rq * rq ; init_entity_runnable_average ( & p -> se ) <S2SV_ModStart> -> pi_lock , rf . flags <S2SV_ModEnd> ) ; # <S2SV_ModStart> ; # endif post_init_entity_util_avg ( & p -> se ) ; <S2SV_ModStart> __task_rq_lock ( p , & rf <S2SV_ModStart> rq -> lock , rf . cookie <S2SV_ModStart> p ) ; lockdep_repin_lock <S2SV_ModEnd> ( & rq <S2SV_ModStart> rq -> lock , rf . cookie <S2SV_ModStart> p , & rf <S2SV_ModEnd> ) ; }
<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
<S2SV_ModStart> != mm ) { smp_mb ( ) ; <S2SV_ModStart> goto out ; } <S2SV_ModStart> ) ) ; smp_mb ( ) ;
<S2SV_ModStart> -> mm ) { <S2SV_ModStart> start ) ; } else { <S2SV_ModEnd> leave_mm ( smp_processor_id <S2SV_ModStart> ) ) ; smp_mb ( ) ; }
<S2SV_ModStart> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
<S2SV_ModStart> ; if ( ctx -> length - ctx -> num > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> ; if ( ctx -> length - ctx -> num > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> ; if ( ctx -> length - ctx -> num > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> { if ( bl - i > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> { if ( bl - i > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> { if ( bl - i > inl <S2SV_ModEnd> ) { memcpy
<S2SV_ModStart> ( bn ) && ! BN_is_zero ( bn )
<S2SV_ModStart> ; if ( ret == 1 && i == 0 ) neg = 0 ; if ( <S2SV_ModStart> ! * n && i > 1
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : tint =
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : return i2c_ASN1_INTEGER
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : case V_ASN1_BIT_STRING
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : tint =
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : return i2c_ASN1_INTEGER
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : tint =
<S2SV_ModStart> V_ASN1_INTEGER : case V_ASN1_ENUMERATED <S2SV_ModEnd> : return i2c_ASN1_INTEGER
<S2SV_ModStart> ) ) { size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE ; <S2SV_ModStart> err ; } while ( want > 0 ) { size_t chunk = want > chunk_max ? chunk_max : want ; <S2SV_ModStart> , len + chunk <S2SV_ModEnd> ) ) { <S2SV_ModStart> err ; } want -= chunk ; while ( chunk <S2SV_ModEnd> > 0 ) <S2SV_ModStart> ] ) , chunk <S2SV_ModEnd> ) ; if <S2SV_ModStart> += i ; chunk -= i ; } if ( chunk_max < INT_MAX / 2 ) chunk_max *= 2 <S2SV_ModEnd> ; } }
<S2SV_ModStart> ) ) { size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE ; <S2SV_ModStart> err ; } while ( want > 0 ) { size_t chunk = want > chunk_max ? chunk_max : want ; <S2SV_ModStart> , len + chunk <S2SV_ModEnd> ) ) { <S2SV_ModStart> err ; } want -= chunk ; while ( chunk <S2SV_ModEnd> > 0 ) <S2SV_ModStart> ] ) , chunk <S2SV_ModEnd> ) ; if <S2SV_ModStart> += i ; chunk -= i ; } if ( chunk_max < INT_MAX / 2 ) chunk_max *= 2 <S2SV_ModEnd> ; } }
<S2SV_ModStart> ) ) { size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE ; <S2SV_ModStart> err ; } while ( want > 0 ) { size_t chunk = want > chunk_max ? chunk_max : want ; <S2SV_ModStart> , len + chunk <S2SV_ModEnd> ) ) { <S2SV_ModStart> err ; } want -= chunk ; while ( chunk <S2SV_ModEnd> > 0 ) <S2SV_ModStart> ] ) , chunk <S2SV_ModEnd> ) ; if <S2SV_ModStart> += i ; chunk -= i ; } if ( chunk_max < INT_MAX / 2 ) chunk_max *= 2 <S2SV_ModEnd> ; } }
<S2SV_ModStart> -> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev
<S2SV_ModStart> mm ) { <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> mm ) { spin_lock_init ( & mm -> context . list_lock ) ; INIT_LIST_HEAD ( & mm -> context . pgtable_list ) ; INIT_LIST_HEAD ( & mm -> context . gmap_list ) ; <S2SV_ModStart> flush_mm = 0 <S2SV_ModEnd> ; # ifdef <S2SV_ModStart> ; # endif if ( <S2SV_ModStart> context . asce_limit == 0 ) { mm -> context . asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS | _ASCE_TYPE_REGION3 ; mm -> context . asce_limit <S2SV_ModStart> = STACK_TOP_MAX ; } else if ( mm -> context . asce_limit == ( 1UL << 31 ) ) { mm_inc_nr_pmds ( mm ) ; }
<S2SV_ModStart> mm ) { unsigned long * table = crst_table_alloc ( mm ) ; if ( ! table ) return NULL ; if ( <S2SV_ModEnd> mm -> context <S2SV_ModStart> -> context . asce_limit == ( 1UL << 31 ) ) { if ( ! pgtable_pmd_page_ctor ( virt_to_page ( table ) ) ) { crst_table_free ( mm , table ) ; return NULL ; } } <S2SV_ModEnd> return ( pgd_t <S2SV_ModStart> pgd_t * ) table <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> V_ASN1_IA5STRING ) { if <S2SV_ModEnd> ( num > <S2SV_ModStart> ( num > ( int ) sizeof ( ebcdic_buf ) ) num = sizeof ( ebcdic_buf ) ; ascii2ebcdic ( ebcdic_buf , q , <S2SV_ModEnd> num ) ;
<S2SV_ModStart> V_ASN1_IA5STRING ) { if <S2SV_ModEnd> ( num > <S2SV_ModStart> ( num > ( int ) sizeof ( ebcdic_buf ) ) num = sizeof ( ebcdic_buf ) ; ascii2ebcdic ( ebcdic_buf , q , <S2SV_ModEnd> num ) ;
<S2SV_ModStart> V_ASN1_IA5STRING ) { if <S2SV_ModEnd> ( num > <S2SV_ModStart> ebcdic_buf ) ) num = <S2SV_ModEnd> sizeof ( ebcdic_buf <S2SV_ModStart> ( ebcdic_buf ) ; ascii2ebcdic ( ebcdic_buf , q , <S2SV_ModEnd> num ) ;
<S2SV_ModStart> ; if ( SSL3_RANDOM_SIZE + session_length + 1 >= ( d + n ) - p ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } cookie_length = * ( <S2SV_ModStart> session_length + 1 ) ; if ( cookie_length == 0 ) return 1 ; } memcpy ( s -> s3 -> client_random , p , SSL3_RANDOM_SIZE ) ; p += SSL3_RANDOM_SIZE ; j = * ( p ++ ) ; if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < j <S2SV_ModEnd> ) { al <S2SV_ModStart> { if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < 1 ) <S2SV_ModStart> ; if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < cookie_len ) <S2SV_ModStart> } if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < 2 ) <S2SV_ModStart> if ( ( d + n ) - p < <S2SV_ModEnd> i + 1 <S2SV_ModStart> + 1 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } if ( ssl_bytes_to_cipher_list ( s , p , i , & ( ciphers ) ) == NULL ) { goto err ; } p += i ; if ( s -> hit ) { j = 0 ; id = s -> session -> cipher -> id ; # ifdef CIPHER_DEBUG fprintf ( stderr , "client<S2SV_blank>sent<S2SV_blank>%d<S2SV_blank>ciphers\\n" , sk_SSL_CIPHER_num ( ciphers ) ) ; # endif for ( i = 0 ; i < sk_SSL_CIPHER_num ( ciphers ) ; i ++ ) { c = sk_SSL_CIPHER_value ( ciphers , i ) ; # ifdef CIPHER_DEBUG fprintf ( stderr , "client<S2SV_blank>[%2d<S2SV_blank>of<S2SV_blank>%2d]:%s\\n" , i , sk_SSL_CIPHER_num ( ciphers ) , SSL_CIPHER_get_name ( c ) ) ; # endif if ( c -> id == id ) { j = 1 ; break ; } } # if 0 if ( j == 0 && ( s -> options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) && ( sk_SSL_CIPHER_num ( ciphers ) == 1 ) ) { c = sk_SSL_CIPHER_value ( ciphers , 0 ) ; if ( sk_SSL_CIPHER_find ( SSL_get_ciphers ( s ) , c ) >= 0 ) { s -> session -> cipher = c ; j = 1 ; } } # endif if ( j == 0 ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_REQUIRED_CIPHER_MISSING ) ; goto f_err ; } } i = * ( p ++ ) ; if ( <S2SV_ModEnd> ( d + <S2SV_ModStart> + n ) - p < i <S2SV_ModEnd> ) { al
<S2SV_ModStart> endif if ( limit - session_id < len <S2SV_ModEnd> ) { fatal
<S2SV_ModStart> ; if ( limit - data <= 2 <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data < 4 ) <S2SV_ModEnd> return ; n2s <S2SV_ModStart> ; if ( limit - data < size <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data != ( int ) ( <S2SV_ModEnd> len1 + len2 <S2SV_ModStart> len1 + len2 ) <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data != ( int ) ( len ) <S2SV_ModEnd> ) return ;
<S2SV_ModStart> ; if ( limit - data < 2 ) <S2SV_ModEnd> goto err ; <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( limit - <S2SV_ModStart> ( limit - data != len ) goto err ; while ( limit - data >= 4 ) <S2SV_ModEnd> { n2s ( <S2SV_ModStart> ; if ( limit - data < size <S2SV_ModEnd> ) goto err
<S2SV_ModStart> endif if ( <S2SV_ModEnd> ( d + <S2SV_ModStart> d + n ) - data <= 2 ) goto ri_check ; n2s ( data , length ) ; if ( ( d + n ) - data != length ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } while ( ( d + n ) - data >= 4 ) { n2s ( data , type ) ; n2s ( data , size ) ; if ( ( d + n ) - data < size ) goto ri_check ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_server_name ) { if ( s -> tlsext_hostname == NULL || size > 0 ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } tlsext_servername = 1 ; } # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { unsigned char * sdata = data ; int ecpointformatlist_length = * ( sdata ++ ) ; if ( ecpointformatlist_length != size - 1 || ecpointformatlist_length < 1 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit ) { s -> session -> tlsext_ecpointformatlist_length = 0 ; if ( s -> session -> tlsext_ecpointformatlist != NULL ) OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ) ; if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length ; memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ) ; } # if 0 fprintf ( stderr , "ssl_parse_serverhello_tlsext<S2SV_blank>s->session->tlsext_ecpointformatlist<S2SV_blank>" ) ; sdata = s -> session -> tlsext_ecpointformatlist ; for ( i = 0 ; i < s -> session -> tlsext_ecpointformatlist_length ; i ++ ) fprintf ( stderr , "%i<S2SV_blank>" , * ( sdata ++ ) ) ; fprintf ( stderr , "\\n" ) ; # endif } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_ticket_expected = 1 ; } # ifdef TLSEXT_TYPE_opaque_prf_input else if ( type == TLSEXT_TYPE_opaque_prf_input && s -> version != DTLS1_VERSION ) { unsigned char * sdata = data ; if ( size < 2 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } n2s ( sdata , s -> s3 -> server_opaque_prf_input_len ) ; if ( s -> s3 -> server_opaque_prf_input_len != size <S2SV_ModStart> - 2 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( s -> s3 -> server_opaque_prf_input != NULL ) { OPENSSL_free ( s -> s3 -> server_opaque_prf_input ) ; } if ( s -> s3 -> server_opaque_prf_input_len == 0 ) { s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ) ; } else { s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ) ; } if ( s -> s3 -> server_opaque_prf_input == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif else if ( type == TLSEXT_TYPE_status_request && s -> version != DTLS1_VERSION ) { if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_status_expected = 1 ; } # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { unsigned char * selected ; unsigned char selected_len ; if ( s -> ctx -> next_proto_select_cb == NULL ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! ssl_next_proto_validate ( data , size ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ) ; if ( ! s -> next_proto_negotiated ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> next_proto_negotiated , selected , selected_len ) ; s -> next_proto_negotiated_len = selected_len ; s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) ) return 0 ; renegotiate_seen = 1 ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( type == TLSEXT_TYPE_heartbeat ) { switch ( data [ 0 ] ) { case 0x01 : s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) ) return 0 ; } # endif data += size ; } if ( data <S2SV_ModEnd> != d + <S2SV_ModStart> 0 ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ++ ) ; if ( limit - p <= i ) return - 1 ; <S2SV_ModStart> += i ; } n2s ( p , i ) ; if ( limit - p <= i ) return - 1 ; p += i ; i = * ( p ++ ) ; if ( limit - p < i ) return - 1 ; p += i ; if ( limit - p <= 2 ) return 0 ; n2s ( p , i ) ; while ( limit - p >= 4 <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> ; if ( limit - p < size <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; if ( SSL3_RANDOM_SIZE + session_length + 1 >= ( d + n ) - p ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } cookie_length = * ( <S2SV_ModStart> session_length + 1 ) ; if ( cookie_length == 0 ) return 1 ; } memcpy ( s -> s3 -> client_random , p , SSL3_RANDOM_SIZE ) ; p += SSL3_RANDOM_SIZE ; j = * ( p ++ ) ; if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < j <S2SV_ModEnd> ) { al <S2SV_ModStart> { if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < 1 ) <S2SV_ModStart> ; if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> d + n ) - p < cookie_len <S2SV_ModStart> } if ( ( <S2SV_ModEnd> d + n <S2SV_ModStart> + n ) - p < 2 ) <S2SV_ModStart> if ( ( d + n ) - p < <S2SV_ModEnd> i + 1 <S2SV_ModStart> + 1 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } if ( ssl_bytes_to_cipher_list ( s , p , i , & ( ciphers ) ) == NULL ) { goto err ; } p += i ; if ( s -> hit ) { j = 0 ; id = s -> session -> cipher -> id ; # ifdef CIPHER_DEBUG fprintf ( stderr , "client<S2SV_blank>sent<S2SV_blank>%d<S2SV_blank>ciphers\\n" , sk_SSL_CIPHER_num ( ciphers ) ) ; # endif for ( i = 0 ; i < sk_SSL_CIPHER_num ( ciphers ) ; i ++ ) { c = sk_SSL_CIPHER_value ( ciphers , i ) ; # ifdef CIPHER_DEBUG fprintf ( stderr , "client<S2SV_blank>[%2d<S2SV_blank>of<S2SV_blank>%2d]:%s\\n" , i , sk_SSL_CIPHER_num ( ciphers ) , SSL_CIPHER_get_name ( c ) ) ; # endif if ( c -> id == id ) { j = 1 ; break ; } } # if 0 if ( j == 0 && ( s -> options & SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ) && ( sk_SSL_CIPHER_num ( ciphers ) == 1 ) ) { c = sk_SSL_CIPHER_value ( ciphers , 0 ) ; if ( sk_SSL_CIPHER_find ( SSL_get_ciphers ( s ) , c ) >= 0 ) { s -> session -> cipher = c ; j = 1 ; } } # endif if ( j == 0 ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_CLIENT_HELLO , SSL_R_REQUIRED_CIPHER_MISSING ) ; goto f_err ; } } i = * ( p ++ ) ; if ( <S2SV_ModEnd> ( d + <S2SV_ModStart> + n ) - p < i <S2SV_ModEnd> ) { al
<S2SV_ModStart> endif if ( limit - session_id < len <S2SV_ModEnd> ) { fatal
<S2SV_ModStart> ; if ( limit - data <= 2 <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data < 4 ) <S2SV_ModEnd> return ; n2s <S2SV_ModStart> ; if ( limit - data < size <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data != ( int ) ( <S2SV_ModEnd> len1 + len2 <S2SV_ModStart> len1 + len2 ) <S2SV_ModEnd> ) return ; <S2SV_ModStart> ; if ( limit - data != ( int ) ( len ) <S2SV_ModEnd> ) return ;
<S2SV_ModStart> ; if ( limit - data <= <S2SV_ModEnd> 2 ) return <S2SV_ModStart> ; if ( limit - data < <S2SV_ModEnd> len ) return <S2SV_ModStart> ; while ( limit - data >= <S2SV_ModEnd> 4 ) { <S2SV_ModStart> ; if ( limit - data < size <S2SV_ModEnd> ) return 1
<S2SV_ModStart> ; if ( limit - data < 2 ) <S2SV_ModEnd> goto err ; <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( limit - <S2SV_ModStart> ( limit - data != len ) goto err ; while ( limit - data >= 4 ) <S2SV_ModEnd> { n2s ( <S2SV_ModStart> ; if ( limit - data < size <S2SV_ModEnd> ) goto err
<S2SV_ModStart> endif if ( <S2SV_ModEnd> ( d + <S2SV_ModStart> d + n ) - data <= 2 ) goto ri_check ; n2s ( data , length ) ; if ( ( d + n ) - data != length ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } while ( ( d + n ) - data >= 4 ) { n2s ( data , type ) ; n2s ( data , size ) ; if ( ( d + n ) - data < size ) goto ri_check ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_server_name ) { if ( s -> tlsext_hostname == NULL || size > 0 ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } tlsext_servername = 1 ; } # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { unsigned char * sdata = data ; int ecpointformatlist_length = * ( sdata ++ ) ; if ( ecpointformatlist_length != size - 1 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit ) { s -> session -> tlsext_ecpointformatlist_length = 0 ; if ( s -> session -> tlsext_ecpointformatlist != NULL ) OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ) ; if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length ; memcpy ( s -> session -> tlsext_ecpointformatlist , sdata , ecpointformatlist_length ) ; } # if 0 fprintf ( stderr , "ssl_parse_serverhello_tlsext<S2SV_blank>s->session->tlsext_ecpointformatlist<S2SV_blank>" ) ; sdata = s -> session -> tlsext_ecpointformatlist ; for ( i = 0 ; i < s -> session -> tlsext_ecpointformatlist_length ; i ++ ) fprintf ( stderr , "%i<S2SV_blank>" , * ( sdata ++ ) ) ; fprintf ( stderr , "\\n" ) ; # endif } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ( SSL_get_options ( s ) & SSL_OP_NO_TICKET ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_ticket_expected = 1 ; } # ifdef TLSEXT_TYPE_opaque_prf_input else if ( type == TLSEXT_TYPE_opaque_prf_input ) { unsigned char * sdata = data ; if ( size < 2 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } n2s ( sdata , s -> s3 -> server_opaque_prf_input_len ) ; if ( s -> s3 -> server_opaque_prf_input_len != size <S2SV_ModStart> - 2 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( s -> s3 -> server_opaque_prf_input != NULL ) { OPENSSL_free ( s -> s3 -> server_opaque_prf_input ) ; } if ( s -> s3 -> server_opaque_prf_input_len == 0 ) { s -> s3 -> server_opaque_prf_input = OPENSSL_malloc ( 1 ) ; } else { s -> s3 -> server_opaque_prf_input = BUF_memdup ( sdata , s -> s3 -> server_opaque_prf_input_len ) ; } if ( s -> s3 -> server_opaque_prf_input == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif else if ( type == TLSEXT_TYPE_status_request ) { if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_status_expected = 1 ; } # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { unsigned char * selected ; unsigned char selected_len ; if ( s -> ctx -> next_proto_select_cb == NULL ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! ssl_next_proto_validate ( data , size ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ) ; if ( ! s -> next_proto_negotiated ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> next_proto_negotiated , selected , selected_len ) ; s -> next_proto_negotiated_len = selected_len ; s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation ) { unsigned len ; if ( ! s -> cert -> alpn_sent ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( size < 4 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } len = data [ 0 ] ; len <<= 8 ; len |= data [ 1 ] ; if ( len != ( unsigned ) size - 2 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } len = data [ 2 ] ; if ( len != ( unsigned ) size - 3 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( s -> s3 -> alpn_selected ) OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = OPENSSL_malloc ( len ) ; if ( ! s -> s3 -> alpn_selected ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> s3 -> alpn_selected , data + 3 , len ) ; s -> s3 -> alpn_selected_len = len ; } else if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_serverhello_renegotiate_ext ( s , data , size , al ) ) return 0 ; renegotiate_seen = 1 ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( type == TLSEXT_TYPE_heartbeat ) { switch ( data [ 0 ] ) { case 0x01 : s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_serverhello_use_srtp_ext ( s , data , size , al ) ) return 0 ; } # endif else if ( custom_ext_parse ( s , 0 , type , data , size , al ) <= 0 ) return 0 ; data += size ; } if ( data <S2SV_ModEnd> != d + <S2SV_ModStart> 0 ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ++ ) ; if ( limit - p <= i ) return - 1 ; <S2SV_ModStart> += i ; } n2s ( p , i ) ; if ( limit - p <= i ) return - 1 ; p += i ; i = * ( p ++ ) ; if ( limit - p < i ) return - 1 ; p += i ; if ( limit - p <= 2 ) return 0 ; n2s ( p , i ) ; while ( limit - p >= 4 <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> ; if ( limit - p < size <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> -> flags & DSA_FLAG_NO_EXP_CONSTTIME ) == 0 ) { BN_set_flags ( & k , BN_FLG_CONSTTIME ) ; } if ( dsa -> flags & <S2SV_ModStart> ) goto err ; BN_set_flags ( & kq , BN_FLG_CONSTTIME ) <S2SV_ModStart> & kq ; <S2SV_ModEnd> } else {
<S2SV_ModStart> ; if ( dsa -> flags & DSA_FLAG_CACHE_MONT_P ) { if ( ! BN_MONT_CTX_set_locked ( & dsa -> method_mont_p , dsa -> lock , dsa -> p , ctx ) ) goto err ; } if ( <S2SV_ModStart> 0 ) { if ( ! BN_copy ( kq , k ) ) goto err ; if ( ! BN_add ( kq , kq , dsa -> q ) ) goto err ; if ( BN_num_bits ( kq ) <= BN_num_bits ( dsa -> q ) ) { if ( ! BN_add ( kq , kq , dsa -> q ) ) goto err ; } K = kq ; } else { K = k <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { BN_set_flags ( K , BN_FLG_CONSTTIME ) <S2SV_ModEnd> ; } DSA_BN_MOD_EXP
<S2SV_ModStart> ; if ( dsa -> flags & DSA_FLAG_CACHE_MONT_P ) { if ( ! BN_MONT_CTX_set_locked ( & dsa -> method_mont_p , CRYPTO_LOCK_DSA , dsa -> p , ctx ) ) goto err ; } if ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> & kq ; BN_set_flags ( K , BN_FLG_CONSTTIME ) ;
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> -> flags & DSA_FLAG_NO_EXP_CONSTTIME ) == 0 ) { BN_set_flags ( & k , BN_FLG_CONSTTIME ) ; } if ( dsa -> flags & <S2SV_ModStart> ) goto err ; BN_set_flags ( & kq , BN_FLG_CONSTTIME ) <S2SV_ModStart> & kq ; <S2SV_ModEnd> } else {
<S2SV_ModStart> ; if ( dsa -> flags & DSA_FLAG_CACHE_MONT_P ) { if ( ! BN_MONT_CTX_set_locked ( & dsa -> method_mont_p , CRYPTO_LOCK_DSA , dsa -> p , ctx ) ) goto err ; } if ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> & kq ; BN_set_flags ( K , BN_FLG_CONSTTIME ) ;
<S2SV_ModStart> = 0 ; do { <S2SV_ModStart> item -> data ; if ( frag -> msg_header . seq < s -> d1 -> handshake_read_seq ) { pqueue_pop ( s -> d1 -> buffered_messages ) ; dtls1_hm_fragment_free ( frag ) ; pitem_free ( item ) ; item = NULL ; frag = NULL ; } } while ( item == NULL )
<S2SV_ModStart> = 0 ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> DTLS1_RECORD_DATA * rdata <S2SV_ModStart> -> d1 -> buffered_app_data . q <S2SV_ModEnd> ) ) != <S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free <S2SV_ModStart> ) ; } dtls1_clear_received_buffer ( s ) ; dtls1_clear_sent_buffer ( s ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; dtls1_clear_sent_buffer <S2SV_ModEnd> ( s )
<S2SV_ModStart> = 0 ; dtls1_clear_sent_buffer <S2SV_ModEnd> ( s ) <S2SV_ModStart> = 0 ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> ) ) ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> = 0 ; do { <S2SV_ModStart> item -> data ; if ( frag -> msg_header . seq < s -> d1 -> handshake_read_seq ) { pqueue_pop ( s -> d1 -> buffered_messages ) ; dtls1_hm_fragment_free ( frag ) ; pitem_free ( item ) ; item = NULL ; frag = NULL ; } } while ( item == NULL )
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> DTLS1_RECORD_DATA * rdata <S2SV_ModStart> -> d1 -> buffered_app_data . q <S2SV_ModEnd> ) ) != <S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free <S2SV_ModStart> ) ; } dtls1_clear_received_buffer ( s ) ; dtls1_clear_sent_buffer ( s ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; dtls1_clear_sent_buffer <S2SV_ModEnd> ( s )
<S2SV_ModStart> ) ) ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> ) ) ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> s ) { dtls1_clear_received_buffer ( s ) ; dtls1_clear_sent_buffer ( s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; dtls1_clear_sent_buffer <S2SV_ModEnd> ( s )
<S2SV_ModStart> = 0 ; do { <S2SV_ModStart> item -> data ; if ( frag -> msg_header . seq < s -> d1 -> handshake_read_seq ) { pqueue_pop ( s -> d1 -> buffered_messages ) ; dtls1_hm_fragment_free ( frag ) ; pitem_free ( item ) ; item = NULL ; frag = NULL ; } } while ( item == NULL )
<S2SV_ModStart> = 0 ; dtls1_clear_received_buffer ( s ) ;
<S2SV_ModStart> s ) ) dtls1_clear_sent_buffer <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) ) { dtls1_clear_sent_buffer <S2SV_ModEnd> ( s )
<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , "%s\\n" , obj_txt <S2SV_ModEnd> ) ; return
<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , "%s\\n" , obj_txt <S2SV_ModEnd> ) ; return
<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , "%s\\n" , obj_txt <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * rb ; SSL3_RECORD * rr ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; int replayok = 1 ; <S2SV_ModStart> r_epoch ) return 1 ; rr = RECORD_LAYER_get_rrec ( & s -> rlayer <S2SV_ModEnd> ) ; rb <S2SV_ModStart> s ) ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { SSLerr ( SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS , ERR_R_INTERNAL_ERROR ) ; return 0 ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) # endif { replayok = dtls1_record_replay_check ( s , bitmap ) ; } if ( ! replayok || <S2SV_ModEnd> ! dtls1_process_record ( <S2SV_ModStart> dtls1_process_record ( s , bitmap ) ) { rr -> length = 0 ; RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ; continue ; } <S2SV_ModEnd> if ( dtls1_buffer_record <S2SV_ModStart> ) ) < 0 ) return 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> 1 ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> : if ( ! <S2SV_ModStart> ( s ) <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; <S2SV_ModEnd> } rr -> <S2SV_ModStart> dtls1_process_record ( s <S2SV_ModEnd> , bitmap ) <S2SV_ModStart> , bitmap ) ) { rr -> length = 0 ; RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ; goto again ; } <S2SV_ModEnd> return ( 1
<S2SV_ModStart> SSL * s , DTLS1_BITMAP * bitmap <S2SV_ModStart> rlayer ) ; dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> : if ( ! <S2SV_ModStart> ( s ) <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; <S2SV_ModEnd> } rr -> <S2SV_ModStart> dtls1_process_record ( s <S2SV_ModEnd> , bitmap ) <S2SV_ModStart> , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <S2SV_ModEnd> return ( 1
<S2SV_ModStart> * rb ; SSL3_RECORD * rr ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; int replayok = 1 ; <S2SV_ModStart> r_epoch ) return 1 ; rr = & s -> s3 -> rrec <S2SV_ModEnd> ; rb = <S2SV_ModStart> s ) ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { SSLerr ( SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS , ERR_R_INTERNAL_ERROR ) ; return 0 ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) # endif { replayok = dtls1_record_replay_check ( s , bitmap ) ; } if ( ! replayok || <S2SV_ModEnd> ! dtls1_process_record ( <S2SV_ModStart> dtls1_process_record ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; continue ; } <S2SV_ModEnd> if ( dtls1_buffer_record <S2SV_ModStart> 0 ) return 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> 1 ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> SSL * s , DTLS1_BITMAP * bitmap <S2SV_ModStart> = 0 ; dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> : if ( ! <S2SV_ModStart> ( s ) <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; <S2SV_ModEnd> } rr -> <S2SV_ModStart> dtls1_process_record ( s <S2SV_ModEnd> , bitmap ) <S2SV_ModStart> , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } <S2SV_ModEnd> return ( 1
<S2SV_ModStart> * rb ; SSL3_RECORD * rr ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; int replayok = 1 ; <S2SV_ModStart> r_epoch ) return 1 ; rr = & s -> s3 -> rrec <S2SV_ModEnd> ; rb = <S2SV_ModStart> s ) ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { SSLerr ( SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS , ERR_R_INTERNAL_ERROR ) ; return 0 ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) # endif { replayok = dtls1_record_replay_check ( s , bitmap ) ; } if ( ! replayok || <S2SV_ModEnd> ! dtls1_process_record ( <S2SV_ModStart> dtls1_process_record ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; continue ; } <S2SV_ModEnd> if ( dtls1_buffer_record <S2SV_ModStart> 0 ) return 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> 1 ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> SSL * s , DTLS1_BITMAP * bitmap <S2SV_ModStart> = 0 ; dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> , * lp ; int bn_data_num <S2SV_ModStart> + 1 ; bn_data_num = <S2SV_ModEnd> num / BN_DEC_NUM <S2SV_ModStart> BN_DEC_NUM + 1 ; bn_data = OPENSSL_malloc ( bn_data_num <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> BN_DEC_CONV ) ; if ( * lp == ( BN_ULONG ) - 1 ) goto err ; lp ++ ; if ( lp - bn_data >= bn_data_num ) goto err <S2SV_ModEnd> ; } lp
<S2SV_ModStart> , * lp ; int bn_data_num <S2SV_ModStart> + 1 ; bn_data_num = <S2SV_ModEnd> num / BN_DEC_NUM <S2SV_ModStart> BN_DEC_NUM + 1 ; bn_data = OPENSSL_malloc ( bn_data_num <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> ; buf = <S2SV_ModEnd> OPENSSL_malloc ( num <S2SV_ModStart> BN_DEC_CONV ) ; if ( * lp == ( BN_ULONG ) - 1 ) goto err ; lp ++ ; if ( lp - bn_data >= bn_data_num ) goto err <S2SV_ModEnd> ; } lp
<S2SV_ModStart> , * lp ; int bn_data_num <S2SV_ModStart> + 1 ; bn_data_num = <S2SV_ModEnd> num / BN_DEC_NUM <S2SV_ModStart> BN_DEC_NUM + 1 ; bn_data = OPENSSL_malloc ( bn_data_num <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> ; buf = <S2SV_ModEnd> OPENSSL_malloc ( num <S2SV_ModStart> BN_DEC_CONV ) ; if ( * lp == ( BN_ULONG ) - 1 ) goto err ; lp ++ ; if ( lp - bn_data >= bn_data_num ) goto err <S2SV_ModEnd> ; } lp
<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &
<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; error = - EINVAL ; goto err_free_urb ; }
<S2SV_ModStart> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> i > pos + delta <S2SV_ModStart> off + 1 <= pos + delta <S2SV_ModEnd> ) insn ->
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
<S2SV_ModStart> len ; } if ( len == 0 ) { proto_tree_add_expert_format ( parent_tree , actx -> pinfo , & ei_ber_constr_bitstr , tvb , offset , len , "dissect_ber_constrained_bitstring():<S2SV_blank>frame:%u<S2SV_blank>offset:%d<S2SV_blank>Was<S2SV_blank>passed<S2SV_blank>an<S2SV_blank>illegal<S2SV_blank>length<S2SV_blank>of<S2SV_blank>0" , actx -> pinfo -> fd -> num , offset ) ; return offset ; }
<S2SV_ModStart> } } , { & ei_ber_constr_bitstr , { "ber.error.constr_bitstr.len" , PI_MALFORMED , PI_WARN , "BER<S2SV_blank>Error:<S2SV_blank>malformed<S2SV_blank>Bitstring<S2SV_blank>encoding" , EXPFILL } } ,
<S2SV_ModStart> ++ ; } else { offset = data_pos ; }
<S2SV_ModStart> { # line 147 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" const char
<S2SV_ModStart> { # line 91 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" int orig_offset <S2SV_ModStart> ; # line 93 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" x509af_export_publickey (
<S2SV_ModStart> direct_reference ) ; if ( algorithm_id ) { wmem_free ( wmem_file_scope ( ) , ( void * ) algorithm_id ) ; } <S2SV_ModEnd> if ( actx <S2SV_ModStart> direct_reference ) { algorithm_id = ( const char * ) wmem_strdup ( wmem_file_scope ( ) , actx -> external . direct_reference ) ; <S2SV_ModStart> ) ; } else { algorithm_id = NULL ; }
<S2SV_ModStart> { # line 126 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" const char
<S2SV_ModStart> { # line 137 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" gint8 ber_class
<S2SV_ModStart> { # line 88 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" offset =
<S2SV_ModStart> { # line 97 <S2SV_ModEnd> "../../asn1/x509af/x509af.cnf" tvbuff_t *
<S2SV_ModStart> ( hiqnet_parameter_tree , pinfo , <S2SV_ModStart> ( hiqnet_parameter_tree , pinfo , <S2SV_ModStart> ( hiqnet_attribute_tree , pinfo , <S2SV_ModStart> ( hiqnet_parameter_tree , pinfo , <S2SV_ModStart> ( hiqnet_attribute_tree , pinfo ,
<S2SV_ModStart> * hiqnet_payload_tree , packet_info * pinfo , <S2SV_ModStart> ; gint datalen = 0 ; proto_item * ti <S2SV_ModStart> offset ) ; ti = <S2SV_ModStart> += 1 ; if ( datatype < sizeof ( hiqnet_datasize_per_type ) / sizeof ( int ) ) <S2SV_ModStart> datatype ] ; else expert_add_info ( pinfo , ti , & ei_hiqnet_datatype ) ;
<S2SV_ModStart> ett_hiqnet_cats } ; static ei_register_info ei [ ] = { { & ei_hiqnet_datatype , { "hiqnet.datatype.invalid" , PI_PROTOCOL , PI_WARN , "Invalid<S2SV_blank>datatype" , EXPFILL } } , } ; expert_module_t * expert_hiqnet ; <S2SV_ModStart> ) ) ; expert_hiqnet = expert_register_protocol ( proto_hiqnet ) ; expert_register_field_array ( expert_hiqnet , ei , array_length ( ei ) ) ;
<S2SV_ModStart> packet_size + 12 + 1 ) ; packet_buf [ packet_size + 12 ] = 0 <S2SV_ModEnd> ; packet_buf [
<S2SV_ModStart> WTAP_OPEN_NOT_MINE ; } magic_buf [ 512 - 1 ] = 0 ;
<S2SV_ModStart> rtree = NULL , * fragment_item <S2SV_ModStart> ENC_BIG_ENDIAN ) ; fragment_item = <S2SV_ModStart> = NULL ; if ( ( reassembly -> len + fragment_offset + data_len ) < LBMC_EXTOPT_REASSEMBLED_DATA_MAX_LEN ) { <S2SV_ModStart> "Reassembled<S2SV_blank>EXTOPT<S2SV_blank>fragment<S2SV_blank>data" ) ; } else { expert_add_info ( pinfo , fragment_item , & ei_lbmc_extopt_fragment_offset ) ; return ( len_dissected ) ; } <S2SV_ModStart> reassembly_in_progress ) { if ( ( reassembly -> len + fragment_offset + data_len ) < LBMC_EXTOPT_REASSEMBLED_DATA_MAX_LEN ) { <S2SV_ModStart> ENC_NA ) ; } else { expert_add_info ( pinfo , fragment_item , & ei_lbmc_extopt_fragment_offset ) ; return ( len_dissected ) ; } <S2SV_ModStart> } else { if ( ( reassembly -> len + fragment_offset + data_len ) < LBMC_EXTOPT_REASSEMBLED_DATA_MAX_LEN ) { <S2SV_ModStart> data_len ; } else { expert_add_info ( pinfo , fragment_item , & ei_lbmc_extopt_fragment_offset ) ; return ( len_dissected ) ; } }
<S2SV_ModStart> } } , { & ei_lbmc_extopt_fragment_offset , { "lbmc.extopt.fragment_offset.invalid" , PI_PROTOCOL , PI_ERROR , "Invalid<S2SV_blank>fragment<S2SV_blank>offset" , EXPFILL } } ,
<S2SV_ModStart> format ) { gboolean is_iseries = FALSE ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> iseries -> have_date <S2SV_ModStart> ++ ) { memset ( buf , 0x0 , sizeof ( buf ) ) ; <S2SV_ModStart> = 0 ; break ; } if ( iseries -> format == ISERIES_FORMAT_UNICODE ) { iseries_UNICODE_to_ASCII ( ( guint8 * ) buf , ISERIES_LINE_LENGTH ) ; } ascii_strup_inplace ( buf ) ; num_items_scanned = sscanf ( buf , "%*[<S2SV_blank>\\n\\t]OBJECT<S2SV_blank>PROTOCOL%*[<S2SV_blank>.:\\n\\t]%8s" , protocol ) ; if ( num_items_scanned == 1 ) { if ( memcmp ( protocol , "ETHERNET" , 8 ) == 0 ) { * err = 0 ; is_iseries = TRUE ; } } num_items_scanned = sscanf ( buf , "%*[<S2SV_blank>\\n\\t]START<S2SV_blank>DATE/TIME%*[<S2SV_blank>.:\\n\\t]%2d/%2d/%2d" , & iseries -> month , & iseries -> day , & iseries -> year ) ; if ( num_items_scanned == 3 ) { iseries -> have_date = TRUE ; } } if ( is_iseries ) wth -> priv = ( void * ) iseries ; else g_free ( iseries ) ; return is_iseries <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> : default : return tvb_reported_length ( tvb ) <S2SV_ModEnd> ; } ti
<S2SV_ModStart> : default : return tvb_reported_length ( tvb ) <S2SV_ModEnd> ; } ti
<S2SV_ModStart> suboffset , param_end , 0
<S2SV_ModStart> ( tvb ) , 0
<S2SV_ModStart> const guint end , const guint depth <S2SV_ModStart> + real_len ; if ( depth > 16 ) { return param_end ; } <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1 <S2SV_ModStart> suboffset , param_end , depth + 1
<S2SV_ModStart> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
<S2SV_ModStart> -> running ) list_del_init <S2SV_ModEnd> ( & ti
<S2SV_ModStart> snd_timer_user * tu <S2SV_ModEnd> = file -> <S2SV_ModStart> -> private_data ; long ret <S2SV_ModEnd> ; mutex_lock ( <S2SV_ModStart> & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <S2SV_ModEnd> ; mutex_unlock ( <S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; tu
<S2SV_ModStart> = NULL ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> tu -> timeri ) ; mutex_unlock ( & tu -> ioctl_lock
<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
<S2SV_ModStart> slave_active_lock ) ; spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & master -> timer -> lock ) ;
<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
<S2SV_ModStart> slave_active_lock ) ; spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & master -> timer -> lock ) ;
<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> void unix_inflight ( struct user_struct * user , <S2SV_ModStart> ++ ; } <S2SV_ModEnd> user -> unix_inflight
<S2SV_ModStart> void unix_notinflight ( struct user_struct * user , <S2SV_ModStart> -- ; } <S2SV_ModEnd> user -> unix_inflight
<S2SV_ModStart> ] ) ; free_uid ( fpl -> user ) ;
<S2SV_ModStart> = SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
<S2SV_ModStart> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> "doapr()" ) ; if ( ! <S2SV_ModStart> , args ) ) { OPENSSL_free ( dynbuf ) ; return - 1 ; } <S2SV_ModEnd> if ( dynbuf
<S2SV_ModStart> int truncated ; if ( ! <S2SV_ModStart> , args ) ) return - 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> _dopr ( char <S2SV_ModStart> DP_S_FLAGS ; else if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> break ; } if ( ! <S2SV_ModStart> , flags ) ) return 0 <S2SV_ModStart> double ) ; if ( ! <S2SV_ModStart> , max , flags ) ) return 0 <S2SV_ModEnd> ; break ; <S2SV_ModStart> case 'c' : if ( ! <S2SV_ModStart> int ) ) ) return 0 <S2SV_ModStart> maxlen ; } if ( ! <S2SV_ModStart> , max ) ) return 0 <S2SV_ModStart> * ) ; if ( ! <S2SV_ModStart> | DP_F_NUM ) ) return 0 <S2SV_ModStart> case '%' : if ( ! <S2SV_ModStart> , ch ) ) return 0 <S2SV_ModStart> - 1 ; if ( ! <S2SV_ModStart> , '\\0' ) ) return 0 <S2SV_ModStart> 1 ; return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> doapr_outch ( char <S2SV_ModStart> maxlen ) { if ( * maxlen > INT_MAX - BUFFER_INC ) return 0 ; <S2SV_ModStart> * maxlen += BUFFER_INC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( * buffer == NULL ) return 0 ; <S2SV_ModEnd> if ( * <S2SV_ModStart> } else { char * tmpbuf ; tmpbuf <S2SV_ModEnd> = OPENSSL_realloc ( <S2SV_ModStart> ; if ( tmpbuf == NULL ) return 0 ; * buffer = tmpbuf ; <S2SV_ModEnd> } } if <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtfp ( char <S2SV_ModStart> signvalue ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; -- padlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> if ( signvalue && ! doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ) return 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> iplace ] ) ) return 0 ; } <S2SV_ModEnd> if ( max <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '.' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , <S2SV_ModEnd> fconvert [ -- <S2SV_ModStart> fplace ] ) ) return 0 ; } <S2SV_ModEnd> } while ( <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> padlen ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtint ( char <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ( signvalue ) if ( ! <S2SV_ModStart> , signvalue ) ) return 0 <S2SV_ModStart> prefix ) { if ( ! <S2SV_ModStart> * prefix ) ) return 0 <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '0' ) ) return 0 <S2SV_ModStart> > 0 ) { if ( ! <S2SV_ModStart> place ] ) ) return 0 ; } <S2SV_ModEnd> while ( spadlen <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ; } return 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fmtstr ( char <S2SV_ModStart> { int padlen ; size_t <S2SV_ModEnd> strln ; int <S2SV_ModStart> = "<NULL>" ; strln = strlen ( value ) ; if ( strln > INT_MAX ) strln = INT_MAX <S2SV_ModEnd> ; padlen = <S2SV_ModStart> ; if ( min < 0 || <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> value ++ ) ) return 0 <S2SV_ModStart> ) ) { if ( ! <S2SV_ModStart> , '<S2SV_blank>' ) ) return 0 ; ++ padlen ; ++ cnt ; } return 1 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_buffer ) * pipe_bufs <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> GFP_KERNEL ) ; } <S2SV_ModStart> -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( <S2SV_ModStart> pipe ; } free_uid ( user ) ;
<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> page ) ) <S2SV_ModEnd> SetPageDirty ( newpage <S2SV_ModStart> newpage ) ; <S2SV_ModEnd> if ( page_is_young
<S2SV_ModStart> extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> NR_FILE_PAGES ) ; __inc_zone_state ( newzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> ; if ( PageSwapBacked ( page ) && <S2SV_ModStart> ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct arpt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> arp , &
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct ip6t_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> ipv6 , &
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
<S2SV_ModStart> ) { struct usb_serial * serial = port -> serial ; struct <S2SV_ModStart> * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , "expected<S2SV_blank>endpoint<S2SV_blank>missing\\n" ) ; return - ENODEV ; } <S2SV_ModStart> -> read_urb = <S2SV_ModEnd> serial -> port
<S2SV_ModStart> * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV
<S2SV_ModStart> ; if ( in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> ) ; } no_promotions :
<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
<S2SV_ModStart> ) { struct in_device * idev <S2SV_ModEnd> = ( ( <S2SV_ModStart> ) -> ifa_dev <S2SV_ModEnd> ; struct netdev_notifier_info <S2SV_ModStart> netdev_notifier_info info ; if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> & info , idev ->
<S2SV_ModStart> -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ; if (
<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
<S2SV_ModStart> return true ; <S2SV_ModEnd> } return false
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock (
<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> & fl6 , <S2SV_ModEnd> opt , & <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> -> opt_flen + <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> opt -> opt_nflen <S2SV_ModEnd> ; inet ->
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> -> hop_limit ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> np -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) inet_csk ( <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; dccp_sync_mss (
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ( <S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass <S2SV_ModStart> np -> tclass ) ; rcu_read_unlock (
<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> pktopt = xchg <S2SV_ModStart> ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> ) ) ; atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <S2SV_ModStart> } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> -> inet_sport ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> & fl6 , <S2SV_ModEnd> opt , & <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) icsk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> -> opt_flen + <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> opt -> opt_nflen <S2SV_ModEnd> ; tp ->
<S2SV_ModStart> , fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) inet_csk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; tcp_ca_openreq_child (
<S2SV_ModStart> ipv6_txoptions * opt = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
<S2SV_ModStart> intf ) { <S2SV_ModEnd> if ( cdc_ncm_select_altsetting <S2SV_ModStart> - ENODEV ; return <S2SV_ModEnd> cdc_ncm_bind_common ( dev <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> return 0 ; if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> if ( ud <S2SV_ModStart> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <S2SV_ModStart> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , "recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }
<S2SV_ModStart> * tfi ; int depth = 1 ; if ( tree -> first_child == NULL ) { for ( tnode = tree ; tnode != NULL ; tnode = tnode -> parent ) { depth ++ ; if ( G_UNLIKELY ( depth > MAX_TREE_LEVELS ) ) { THROW_MESSAGE ( DissectorError , wmem_strdup_printf ( wmem_packet_scope ( ) , "Maximum<S2SV_blank>tree<S2SV_blank>depth<S2SV_blank>%d<S2SV_blank>exceeded<S2SV_blank>for<S2SV_blank>\\"%s\\"<S2SV_blank>-<S2SV_blank>\\"%s\\"<S2SV_blank>(%s:%u)" , MAX_TREE_LEVELS , fi -> hfinfo -> name , fi -> hfinfo -> abbrev , G_STRFUNC , __LINE__ ) ) ; } } }
<S2SV_ModStart> gint i ; guint8 c_char ; wmem_strbuf_t <S2SV_ModEnd> * string_buf ; <S2SV_ModStart> } string_buf = wmem_strbuf_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> ( ) , NULL ) <S2SV_ModEnd> ; offset ++ <S2SV_ModStart> = '?' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '*' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '?' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '*' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '.' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '.' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; } } <S2SV_ModStart> = '?' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '*' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '?' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '*' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '.' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; proto_tree_add_uint_format_value ( <S2SV_ModStart> = '.' ; wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { wmem_strbuf_append_c ( string_buf , c_char ) <S2SV_ModEnd> ; } buffer_offset <S2SV_ModStart> ; } } <S2SV_ModEnd> proto_tree_add_string ( ncp_tree <S2SV_ModStart> , string_len , wmem_strbuf_get_str ( string_buf ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> offset , 0 , NULL , 0
<S2SV_ModStart> tvbuff_t * pktc_mtafqdn_tvb ; gint8 ber_class ; gboolean pc ; gint32 tag <S2SV_ModStart> offset ) ; get_ber_identifier ( pktc_mtafqdn_tvb , 0 , & ber_class , & pc , & tag ) ; if ( ( tag == 10 ) || ( tag == 11 ) ) { <S2SV_ModStart> NULL ) ; } else { expert_add_info_format ( pinfo , item , & ei_pktc_unknown_kerberos_application , "Unknown<S2SV_blank>Kerberos<S2SV_blank>application<S2SV_blank>(%d),<S2SV_blank>expected<S2SV_blank>10<S2SV_blank>or<S2SV_blank>11" , tag ) ; return tvb_captured_length ( tvb ) ; } <S2SV_ModStart> offset ) ; get_ber_identifier ( pktc_mtafqdn_tvb , 0 , & ber_class , & pc , & tag ) ; if ( tag == 20 ) { <S2SV_ModStart> cb ) ; } else { expert_add_info_format ( pinfo , item , & ei_pktc_unknown_kerberos_application , "Unknown<S2SV_blank>Kerberos<S2SV_blank>application<S2SV_blank>(%d),<S2SV_blank>expected<S2SV_blank>20" , tag ) ; }
<S2SV_ModStart> } } , { & ei_pktc_unknown_kerberos_application , { "pktc.mtafqdn.unknown_kerberos_application" , PI_PROTOCOL , PI_WARN , "Unknown<S2SV_blank>Kerberos<S2SV_blank>application" , EXPFILL } } ,
<S2SV_ModStart> ; timestr = tvb_get_string_enc ( wmem_packet_scope ( ) , <S2SV_ModEnd> tvb , offset <S2SV_ModStart> offset , 13 , ENC_ASCII
<S2SV_ModStart> , FT_STRING , STR_UNICODE <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> . secs ; time_t abs_secs = <S2SV_ModEnd> start_secs + longts <S2SV_ModStart> longts / 1000 <S2SV_ModEnd> ; while ( <S2SV_ModStart> ; abs_secs = <S2SV_ModEnd> start_secs + longts <S2SV_ModStart> longts / 1000 <S2SV_ModEnd> ; } iax_packet
<S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] , "%d<S2SV_blank>Free<S2SV_blank>Message<S2SV_blank>Slot,<S2SV_blank>optional<S2SV_blank>reading" <S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] ) ; <S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] , "%d<S2SV_blank>Free<S2SV_blank>Message<S2SV_blank>Slot,<S2SV_blank>reading<S2SV_blank>advised" <S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] ) ; <S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] , "%d<S2SV_blank>reserved<S2SV_blank>MDT:<S2SV_blank>%x" <S2SV_ModStart> , new_slots [ i <S2SV_ModEnd> ] , octet1
<S2SV_ModStart> ) { const guint <S2SV_ModEnd> num = tvb_get_letohl
<S2SV_ModStart> * type , guint <S2SV_ModEnd> num ) { <S2SV_ModStart> ) ; const guint <S2SV_ModEnd> elsize = varsize <S2SV_ModStart> varsize ? ( guint <S2SV_ModEnd> ) sizeof ( <S2SV_ModStart> data_blob ) : ( guint ) <S2SV_ModStart> guint8 * data ; int len ; guint i ; if ( ( guint64 ) elsize * ( guint64 ) num > G_MAXUINT ) { THROW ( ReportedBoundsError ) ; } tvb_ensure_bytes_exist ( tvb , offset , elsize * num ) ; data <S2SV_ModStart> * num ) <S2SV_ModEnd> ; val ->
<S2SV_ModStart> ) { const guint <S2SV_ModEnd> num = tvb_get_letohl
<S2SV_ModStart> * type , guint <S2SV_ModEnd> num ) { <S2SV_ModStart> ) ; const guint <S2SV_ModEnd> elsize = varsize <S2SV_ModStart> varsize ? ( guint <S2SV_ModEnd> ) sizeof ( <S2SV_ModStart> data_blob ) : ( guint ) <S2SV_ModStart> guint8 * data ; int len ; guint i ; if ( ( guint64 ) elsize * ( guint64 ) num > G_MAXUINT ) { THROW ( ReportedBoundsError ) ; } tvb_ensure_bytes_exist ( tvb , offset , elsize * num ) ; data <S2SV_ModStart> * num ) <S2SV_ModEnd> ; val ->
<S2SV_ModStart> byte_string ; char * non_uni_string <S2SV_ModEnd> ; int i <S2SV_ModStart> 2 ) { non_uni_string = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , get_finfo_length <S2SV_ModEnd> ( finfo ) <S2SV_ModStart> ( finfo ) + 1 ) ; <S2SV_ModEnd> non_uni_string [ 0 <S2SV_ModStart> = '\\0' ; uni_to_string ( get_finfo_value_string ( finfo ) , get_finfo_length ( finfo ) , non_uni_string ) ; col_append_fstr ( pinfo -> cinfo , COL_INFO , ( const gchar * ) ncp_rec -> req_info_str -> first_string , non_uni_string ) ; } else { col_append_fstr ( pinfo -> cinfo , COL_INFO , ( const gchar * ) ncp_rec -> req_info_str -> first_string , get_finfo_value_string ( finfo ) ) ; } } } else { col_append_fstr ( pinfo -> cinfo , COL_INFO , ( const gchar * ) ncp_rec -> req_info_str -> first_string , get_finfo_value_integer ( finfo ) ) ; } } if ( len > 1 ) { for ( i = 1 ; i < len ; i ++ ) { <S2SV_ModStart> 2 ) { non_uni_string = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , get_finfo_length ( finfo ) + 1 ) ; non_uni_string [ 0 ] = '\\0' ;
<S2SV_ModStart> vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr <S2SV_ModStart> 0x83f ) ; <S2SV_ModEnd> if ( enable_ept
<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
<S2SV_ModStart> else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if
<S2SV_ModStart> if ( keyring && link_ret == 0
<S2SV_ModStart> struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> . devnum = <S2SV_ModStart> dev -> devnum ; ci <S2SV_ModEnd> . slow = <S2SV_ModStart> speed == USB_SPEED_LOW <S2SV_ModEnd> ; if (
<S2SV_ModStart> struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> return map ; map =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct bpf_map * <S2SV_ModEnd> bpf_map_inc ( struct <S2SV_ModStart> uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> ( & map <S2SV_ModStart> refcnt ) ; return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> usercnt ) ; return map ;
<S2SV_ModStart> return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput
<S2SV_ModStart> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart> = map ; <S2SV_ModEnd> fdput ( f
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
<S2SV_ModStart> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;
<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte
<S2SV_ModStart> = dest_mnt ; first_source = source_mnt ;
<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE
<S2SV_ModStart> -> chan_net = get_net ( net ) <S2SV_ModEnd> ; chan ->
<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ;
<S2SV_ModStart> return err ; if ( ! <S2SV_ModEnd> attrs [ TIPC_NLA_SOCK <S2SV_ModStart> attrs [ TIPC_NLA_SOCK <S2SV_ModEnd> ] ) return <S2SV_ModStart> - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> [ TIPC_NLA_SOCK_REF ] <S2SV_ModStart> [ TIPC_NLA_SOCK_REF ] <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
<S2SV_ModStart> ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
<S2SV_ModStart> } if ( ( <S2SV_ModStart> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len <S2SV_ModStart> sizeof ( EAPOL_RSN_KEY )
<S2SV_ModStart> ; c_t = ( <S2SV_ModStart> , 4 ) + 1 ) % 0xf <S2SV_ModStart> ] = c_t <S2SV_ModEnd> ; macinf -> <S2SV_ModStart> lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf <S2SV_ModStart> lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; }
<S2SV_ModStart> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
<S2SV_ModStart> = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
<S2SV_ModStart> int num_items_scanned ; int pkt_len , <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , "LEN=%9d" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> g_strdup ( "toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"
<S2SV_ModStart> int num_items_scanned ; guint pkt_len ; int <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , "LEN=%9u" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> ( buf , pkt_len <S2SV_ModEnd> ) ; pd
<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , "%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , "%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length" ) ; return FALSE
<S2SV_ModStart> { gint64 offset <S2SV_ModEnd> ; char line <S2SV_ModStart> = offset ; return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> phdr , <S2SV_ModEnd> wth -> frame_buffer <S2SV_ModStart> wth -> frame_buffer , line
<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,
<S2SV_ModStart> ) { int pkt_len ; int <S2SV_ModStart> 2 ] ; <S2SV_ModEnd> char cap_src [ <S2SV_ModStart> = 0 ; int <S2SV_ModEnd> offset = 0 <S2SV_ModStart> ( line , "%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/" <S2SV_ModEnd> , & sec <S2SV_ModStart> return - 1 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length" ) ; return FALSE
<S2SV_ModStart> , dlt ; int wtap_encap ; struct eth_phdr eth ; void * phdr ; <S2SV_ModStart> pkt_len ) ; wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> ( wtap_encap_dissector_table , wtap_encap <S2SV_ModEnd> , next_tvb , <S2SV_ModStart> pinfo , tree , TRUE , phdr
<S2SV_ModStart> struct ieee_802_11_phdr phdr ; int wtap_encap ; struct eth_phdr eth ; void * phdrp <S2SV_ModStart> } else { wtap_encap = wtap_pcap_encap_to_wtap_encap ( dlt ) ; switch ( wtap_encap ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdrp = & eth ; break ; default : phdrp = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> ( wtap_encap_dissector_table , wtap_encap <S2SV_ModEnd> , next_tvb , <S2SV_ModStart> pinfo , tree , TRUE , phdrp
<S2SV_ModStart> ; gint reported_length_remaining ; struct eth_phdr eth ; void * phdr <S2SV_ModStart> WTAP_ENCAP_UNKNOWN ) { switch ( linktype ) { case WTAP_ENCAP_ETHERNET : eth . fcs_len = - 1 ; phdr = & eth ; break ; default : phdr = NULL ; break ; } dissector_try_uint_new <S2SV_ModEnd> ( wtap_encap_dissector_table , <S2SV_ModStart> pinfo , top_tree , TRUE , phdr
<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info
<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info <S2SV_ModStart> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( &
<S2SV_ModStart> ) ; u32 count , <S2SV_ModStart> challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net
<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
<S2SV_ModStart> 1 ; } # ifdef CONFIG_PPC_TRANSACTIONAL_MEM if ( MSR_TM_SUSPENDED ( mfmsr ( ) ) ) tm_reclaim_current ( 0 ) ; # endif
<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd
<S2SV_ModStart> ab ) { long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> ; const char <S2SV_ModStart> char __user * <S2SV_ModEnd> p = ( <S2SV_ModStart> -> arg_start ; char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string" ) ; return ; } buf = buf_head ; <S2SV_ModStart> argc ) ; len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d_len=%lu" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d[%d]=" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d=" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , "%s" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> < context -> <S2SV_ModStart> execve . argc ) ; out : kfree ( buf_head <S2SV_ModEnd> ) ; }
<S2SV_ModStart> exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> s_cmd ) + s_cmd -> <S2SV_ModEnd> insize ) )
<S2SV_ModStart> goto drop ; if ( unlikely ( skb -> len < sizeof ( struct udphdr ) ) ) goto drop ;
<S2SV_ModStart> command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , "<S2SV_blank>" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , "current" ) == 0 ) { if ( strcmp ( command , "changehat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permhat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , "changeprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , "exec" ) == 0 ) { if ( strcmp ( command , "exec" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> dentry * upper <S2SV_ModEnd> ; int err <S2SV_ModStart> I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> ovl_dentry_version_inc ( dentry <S2SV_ModStart> ) ; } dput ( upper ) ; <S2SV_ModStart> dentry ) ; out_unlock :
<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
<S2SV_ModStart> ) { struct <S2SV_ModEnd> inode * inode <S2SV_ModStart> * inode = vfs_select_inode ( path -> <S2SV_ModEnd> dentry , file <S2SV_ModStart> inode ) ; file -> f_path = * path ; <S2SV_ModEnd> return do_dentry_open (
<S2SV_ModStart> ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> to_umount ) ; LIST_HEAD ( visited ) ; list_for_each_entry_reverse <S2SV_ModEnd> ( mnt , <S2SV_ModStart> * m ; if ( ! list_empty ( & mnt -> mnt_umounting ) ) continue ; list_add_tail ( & mnt -> mnt_umounting , & visited ) ; <S2SV_ModStart> ) continue ; if ( ! list_empty ( & child -> mnt_umounting ) ) { m = skip_propagation_subtree ( m , parent ) ; continue ; } else if ( child -> mnt . mnt_flags & MNT_UMOUNT ) { list_add_tail ( & child -> mnt_umounting , & visited ) ; continue ; } <S2SV_ModStart> ( & to_restore ) ; cleanup_umount_visitations ( & visited
<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
<S2SV_ModStart> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;
<S2SV_ModStart> prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
<S2SV_ModStart> = new_ns ; new_ns -> mounts ++ ;
<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
<S2SV_ModStart> ) ) { struct mnt_namespace * ns ; <S2SV_ModStart> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> p -> mnt_ns
<S2SV_ModStart> -> initial_ctx ; <S2SV_ModEnd> HMAC_CTX_init ( & <S2SV_ModStart> err ; } if ( eticklen <= 16 + EVP_CIPHER_CTX_iv_length ( & ctx ) + mlen ) { HMAC_CTX_cleanup ( & hctx ) ; EVP_CIPHER_CTX_cleanup ( & ctx ) ; return 2 ; }
<S2SV_ModStart> -> initial_ctx ; <S2SV_ModEnd> HMAC_CTX_init ( & <S2SV_ModStart> err ; } if ( eticklen <= 16 + EVP_CIPHER_CTX_iv_length ( & ctx ) + mlen ) { HMAC_CTX_cleanup ( & hctx ) ; EVP_CIPHER_CTX_cleanup ( & ctx ) ; return 2 ; }
<S2SV_ModStart> -> initial_ctx ; <S2SV_ModEnd> hctx = HMAC_CTX_new <S2SV_ModStart> err ; } if ( eticklen <= TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length ( ctx ) + mlen ) { ret = 2 ; goto err ; }
<S2SV_ModStart> { if ( <S2SV_ModEnd> len < MDC2_BLOCK <S2SV_ModStart> len < MDC2_BLOCK - i
<S2SV_ModStart> { if ( <S2SV_ModEnd> len < MDC2_BLOCK <S2SV_ModStart> len < MDC2_BLOCK - i
<S2SV_ModStart> { if ( <S2SV_ModEnd> len < MDC2_BLOCK <S2SV_ModStart> len < MDC2_BLOCK - i
<S2SV_ModStart> goto err ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( dsize > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } <S2SV_ModStart> if ( ! <S2SV_ModEnd> sk_OCSP_RESPID_push ( s
<S2SV_ModStart> return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } <S2SV_ModStart> 0 ) { <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } <S2SV_ModStart> 0 ) { <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> goto err ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( dsize > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } <S2SV_ModStart> if ( ! <S2SV_ModEnd> sk_OCSP_RESPID_push ( s
<S2SV_ModStart> ; if ( peek ) { if ( SSL3_RECORD_get_length ( rr ) == 0 ) SSL3_RECORD_set_read ( rr ) ; } else <S2SV_ModEnd> { SSL3_RECORD_sub_length (
<S2SV_ModStart> ; if ( peek ) { if ( SSL3_RECORD_get_length ( rr ) == 0 ) SSL3_RECORD_set_read ( rr ) ; } else <S2SV_ModEnd> { SSL3_RECORD_sub_length (
<S2SV_ModStart> ; ) { if ( nc + 2 > llen ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_DECODE_ERROR ) ; SSLerr ( SSL_F_SSL3_GET_CERTIFICATE_REQUEST , SSL_R_CA_DN_TOO_LONG ) ; goto err ; }
<S2SV_ModStart> ; ) { if ( nc + 3 > llen ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ; goto f_err ; }
<S2SV_ModStart> ; ) { if ( nc + 3 > llen ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ; goto f_err ; }
<S2SV_ModStart> ; ) { if ( nc + 2 > llen ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_DECODE_ERROR ) ; SSLerr ( SSL_F_SSL3_GET_CERTIFICATE_REQUEST , SSL_R_CA_DN_TOO_LONG ) ; goto err ; }
<S2SV_ModStart> ; ) { if ( nc + 3 > llen ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ; goto f_err ; }
<S2SV_ModStart> ; ) { if ( nc + 3 > llen ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_CLIENT_CERTIFICATE , SSL_R_CERT_LENGTH_MISMATCH ) ; goto f_err ; }
<S2SV_ModStart> ) > msg_len || msg_len > dtls1_max_handshake_message_len ( s )
<S2SV_ModStart> SUB_STATE_ERROR ; } if ( ! SSL_IS_DTLS ( s ) && s -> s3 -> tmp . message_size > 0 && ! BUF_MEM_grow_clean ( s -> init_buf , ( int ) s -> s3 -> tmp . message_size + SSL3_HM_HEADER_LENGTH ) ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_INTERNAL_ERROR ) ; SSLerr ( SSL_F_TLS_GET_MESSAGE_HEADER , ERR_R_BUF_LIB ) ; return SUB_STATE_ERROR ; }
<S2SV_ModStart> + SSL3_HM_HEADER_LENGTH ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> f_err ; } <S2SV_ModEnd> s -> s3 <S2SV_ModStart> al ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> SUB_STATE_ERROR ; } if ( ! SSL_IS_DTLS ( s ) && s -> s3 -> tmp . message_size > 0 && ! BUF_MEM_grow_clean ( s -> init_buf , ( int ) s -> s3 -> tmp . message_size + SSL3_HM_HEADER_LENGTH ) ) { ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_INTERNAL_ERROR ) ; SSLerr ( SSL_F_TLS_GET_MESSAGE_HEADER , ERR_R_BUF_LIB ) ; return SUB_STATE_ERROR ; }
<S2SV_ModStart> + SSL3_HM_HEADER_LENGTH ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> f_err ; } <S2SV_ModEnd> s -> s3 <S2SV_ModStart> al ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) > msg_len || msg_len > dtls1_max_handshake_message_len ( s )
<S2SV_ModStart> ) > msg_len || msg_len > dtls1_max_handshake_message_len ( s )
<S2SV_ModStart> 0 && ! grow_init_buf ( s , <S2SV_ModEnd> s -> s3
<S2SV_ModStart> 0 && ! grow_init_buf ( s , <S2SV_ModEnd> s -> s3
<S2SV_ModStart> uint64_t unpacked_lun ; <S2SV_ModEnd> int tcm_tmr ; <S2SV_ModStart> tsk_mgmt_func ) ; unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> , srp_tsk -> <S2SV_ModStart> srp_tsk -> task_tag <S2SV_ModEnd> , TARGET_SCF_ACK_KREF )
<S2SV_ModStart> 0LL ; unsigned int size , osize <S2SV_ModEnd> ; int retval <S2SV_ModStart> EFAULT ; } osize = <S2SV_ModStart> = - EFAULT ; goto cleanup ; } if ( ( osize != le16_to_cpu ( kfib -> header . Size ) + sizeof ( struct aac_fibhdr ) ) || ( size < le16_to_cpu ( kfib -> header . SenderSize ) ) ) { retval = - EINVAL
<S2SV_ModStart> break ; } if ( ptvc != NULL )
<S2SV_ModStart> int i ; guint <S2SV_ModEnd> c = indexEnd <S2SV_ModStart> + 1 ; if ( c > 0 ) { <S2SV_ModStart> } } } }
<S2SV_ModStart> offset = 0 ; gint32 save_offset <S2SV_ModStart> 1 ) { save_offset = offset ; <S2SV_ModStart> pinfo ) ; if ( save_offset <= offset ) { expert_add_info ( pinfo , ti , & ei_wsp_header_invalid ) ; break ; } } else { save_offset = offset ; <S2SV_ModEnd> offset = WellKnownOpenwaveHeader <S2SV_ModStart> pinfo ) ; if ( save_offset <= offset ) { expert_add_info ( pinfo , ti , & ei_wsp_header_invalid ) ; break ; }
<S2SV_ModStart> } } , { & ei_wsp_header_invalid , { "wsp.header_invalid" , PI_MALFORMED , PI_ERROR , "Malformed<S2SV_blank>header" , EXPFILL } } ,
<S2SV_ModStart> "Unknown<S2SV_blank>field<S2SV_blank>(0x%02x)" ) ; const char * str ; <S2SV_ModStart> tree ) { proto_tree_add_uint_format ( mmse_tree , hf_mmse_header_uint , tvb , offset - 1 , length + 1 , peek <S2SV_ModEnd> , "%s:<S2SV_blank><Well-known<S2SV_blank>value<S2SV_blank>0x%02x>" "<S2SV_blank>(not<S2SV_blank>decoded)" <S2SV_ModStart> tree ) { str = format_text ( strval , strlen ( strval ) ) ; proto_tree_add_string_format ( mmse_tree , hf_mmse_header_string , tvb , offset - 1 , length + 1 , str <S2SV_ModEnd> , "%s:<S2SV_blank>%s<S2SV_blank>(Not<S2SV_blank>decoded)" , <S2SV_ModStart> , hdr_name , str <S2SV_ModEnd> ) ; } <S2SV_ModStart> tree ) { proto_tree_add_bytes_format ( mmse_tree , hf_mmse_header_bytes , tvb , offset - 1 , length + 1 , NULL <S2SV_ModEnd> , "%s:<S2SV_blank>" "<Value<S2SV_blank>in<S2SV_blank>general<S2SV_blank>form><S2SV_blank>(not<S2SV_blank>decoded)"
<S2SV_ModStart> } } , { & hf_mmse_header_uint , { "Header<S2SV_blank>Uint<S2SV_blank>Value" , "mmse.header.uint" , FT_UINT8 , BASE_DEC , NULL , 0x00 , NULL , HFILL } } , { & hf_mmse_header_string , { "Header<S2SV_blank>String<S2SV_blank>Value" , "mmse.header.string" , FT_STRING , BASE_NONE , NULL , 0x00 , NULL , HFILL } } , { & hf_mmse_header_bytes , { "Header<S2SV_blank>Byte<S2SV_blank>array" , "mmse.header.bytes" , FT_BYTES , BASE_NONE , NULL , 0x00 , NULL , HFILL } }
<S2SV_ModStart> li_on_2_bytes ) { guint32 hdr_len , offs = 0 , li_offs ; <S2SV_ModStart> guint8 ext , num_li = 0 <S2SV_ModEnd> ; guint16 next_bytes
<S2SV_ModStart> guint8 li_idx , guint32 <S2SV_ModEnd> hdr_offs , gboolean <S2SV_ModStart> * li_tree ; guint32 <S2SV_ModEnd> li_offs ; guint64
<S2SV_ModStart> * broadcast ) { if ( ! find_conversation ( broadcast -> num , & broadcast -> broadcaster -> addr , & broadcast -> broadcaster -> addr , PT_TCP , broadcast -> broadcaster -> port , broadcast -> broadcaster -> port , NO_ADDR2 | NO_PORT2 ) ) <S2SV_ModStart> ) ; } }
<S2SV_ModStart> if ( num_li >= <S2SV_ModEnd> max_li ) {
<S2SV_ModStart> header_field_info * hfinfo ; if ( length == - 1 ) { length = 0 ; } tvb_ensure_bytes_exist ( tvb , start , length )
<S2SV_ModStart> header_field_info * hfinfo ; if ( length == - 1 ) { length = 0 ; } tvb_ensure_bytes_exist ( tvb , start , length )
<S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & length_len , pinfo , & ei_mmse_oversized_uintvar <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & length_len , pinfo , & ei_mmse_oversized_uintvar <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & length_len , pinfo , & ei_mmse_oversized_uintvar <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & strval , pinfo <S2SV_ModStart> , & count , pinfo <S2SV_ModStart> , & length_len , pinfo , & ei_mmse_oversized_uintvar
<S2SV_ModStart> * * strval , packet_info * pinfo <S2SV_ModStart> , & count , pinfo
<S2SV_ModStart> guint * byte_count , packet_info * pinfo <S2SV_ModStart> offset , byte_count , pinfo , & ei_mmse_oversized_uintvar
<S2SV_ModStart> , } ; static ei_register_info ei [ ] = { { & ei_mmse_oversized_uintvar , { "mmse.oversized_uintvar" , PI_MALFORMED , PI_ERROR , "Uintvar<S2SV_blank>is<S2SV_blank>oversized" , EXPFILL } } } ; expert_module_t * expert_mmse ; <S2SV_ModStart> ) ) ; expert_mmse = expert_register_protocol ( proto_mmse ) ; expert_register_field_array ( expert_mmse , ei , array_length ( ei ) ) ;
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> , & publicid_len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & charset_len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & str_tbl_len_len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , tvb , pinfo ,
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , tvb , pinfo , <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo <S2SV_ModStart> , & len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , & tag_len , pinfo , & ei_wbxml_oversized_uintvar <S2SV_ModStart> , tvb , pinfo , <S2SV_ModStart> , tvb , pinfo , <S2SV_ModStart> , tvb , pinfo , <S2SV_ModStart> , tvb , pinfo ,
<S2SV_ModStart> } } , { & ei_wbxml_oversized_uintvar , { "wbxml.oversized_uintvar" , PI_MALFORMED , PI_ERROR , "Uintvar<S2SV_blank>is<S2SV_blank>oversized" , EXPFILL } }
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> guint32 * length , packet_info * pinfo <S2SV_ModStart> offset , length , pinfo , & ei_wbxml_oversized_uintvar
<S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar
<S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar
<S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar
<S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & len , pinfo , & ei_wsp_oversized_uintvar
<S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar <S2SV_ModStart> , & count , pinfo , & ei_wsp_oversized_uintvar
<S2SV_ModStart> } } , { & ei_wsp_oversized_uintvar , { "wsp.oversized_uintvar" , PI_MALFORMED , PI_ERROR , "Uintvar<S2SV_blank>is<S2SV_blank>oversized" , EXPFILL } }
<S2SV_ModStart> = FALSE ; if ( * level == 255 ) { proto_tree_add_expert ( tree , pinfo , & ei_wbxml_too_much_recursion , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) ) ; return tvb_len ; }
<S2SV_ModStart> EXPFILL } } , { & ei_wbxml_too_much_recursion , { "wbxml.too_much_recursion" , PI_UNDECODED , PI_WARN , "Too<S2SV_blank>much<S2SV_blank>recursion" , EXPFILL } }
<S2SV_ModStart> out ; } same -> dest_count = count ;
<S2SV_ModStart> perf_event_context * ctx , * uninitialized_var ( gctx ) <S2SV_ModStart> move_group ) { <S2SV_ModEnd> gctx = group_leader <S2SV_ModStart> -> ctx ; mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } } else { <S2SV_ModStart> mutex_lock ( & ctx -> mutex ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) { mutex_unlock ( & <S2SV_ModStart> mutex ) ; <S2SV_ModEnd> put_ctx ( gctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * sibling ; lockdep_assert_held <S2SV_ModEnd> ( & ctx <S2SV_ModStart> func ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;
<S2SV_ModStart> refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> , arg ) <S2SV_ModStart> arg ) ; perf_event_ctx_unlock <S2SV_ModEnd> ( event , <S2SV_ModStart> ( event , ctx ) ; <S2SV_ModEnd> return ret ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> ctx ; mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <S2SV_ModEnd> -> mutex ) <S2SV_ModStart> ) ; } synchronize_rcu ( <S2SV_ModEnd> ) ; list_for_each_entry_safe <S2SV_ModStart> mutex ) ; mutex_unlock ( & src_ctx -> mutex ) ;
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <S2SV_ModEnd> perf_read_hw ( event <S2SV_ModStart> count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;
<S2SV_ModStart> owner ) { mutex_lock_nested <S2SV_ModEnd> ( & owner <S2SV_ModStart> owner -> perf_event_mutex , SINGLE_DEPTH_NESTING
<S2SV_ModStart> perf_event_context * ctx , * uninitialized_var ( gctx ) <S2SV_ModStart> move_group ) { <S2SV_ModEnd> gctx = group_leader <S2SV_ModStart> -> ctx ; mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } } else { <S2SV_ModStart> mutex_lock ( & ctx -> mutex ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) { mutex_unlock ( & <S2SV_ModStart> mutex ) ; <S2SV_ModEnd> put_ctx ( gctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * sibling ; lockdep_assert_held <S2SV_ModEnd> ( & ctx <S2SV_ModStart> func ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;
<S2SV_ModStart> refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> , arg ) <S2SV_ModStart> arg ) ; perf_event_ctx_unlock <S2SV_ModEnd> ( event , <S2SV_ModStart> ( event , ctx ) ; <S2SV_ModEnd> return ret ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> ctx ; mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <S2SV_ModEnd> -> mutex ) <S2SV_ModStart> ) ; } synchronize_rcu ( <S2SV_ModEnd> ) ; list_for_each_entry_safe <S2SV_ModStart> mutex ) ; mutex_unlock ( & src_ctx -> mutex ) ;
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <S2SV_ModEnd> perf_read_hw ( event <S2SV_ModStart> count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;
<S2SV_ModStart> owner ) { mutex_lock_nested <S2SV_ModEnd> ( & owner <S2SV_ModStart> owner -> perf_event_mutex , SINGLE_DEPTH_NESTING
<S2SV_ModStart> = NULL ; if ( tcp_sk ( sk ) -> highest_sack == skb_unlinked ) tcp_sk ( sk ) -> highest_sack = NULL ;
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> skb ) -> recursion_counter = 0 ; NAPI_GRO_CB ( skb ) ->
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> ; pp = call_gro_receive_sk ( <S2SV_ModStart> ) -> gro_receive , <S2SV_ModEnd> sk , head
<S2SV_ModStart> ; pp = call_gro_receive ( <S2SV_ModStart> callbacks . gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> } pp = call_gro_receive ( eth_gro_receive , <S2SV_ModEnd> head , skb
<S2SV_ModStart> crl_score < best_score || crl_score == 0 <S2SV_ModStart> crl_score == best_score && best_crl != NULL
<S2SV_ModStart> ) continue ; <S2SV_ModEnd> if ( ret <S2SV_ModStart> ) break ; asn1_template_free ( pchptr , tt ) ; <S2SV_ModStart> err ; } asn1_set_choice_selector ( pval , i , it ) ;
<S2SV_ModStart> ) continue ; <S2SV_ModEnd> if ( ret <S2SV_ModStart> ) break ; asn1_template_free ( pchptr , tt ) ; <S2SV_ModStart> err ; } asn1_set_choice_selector ( pval , i , it ) ;
<S2SV_ModStart> memset ( out - plen
<S2SV_ModStart> memset ( out - plen
<S2SV_ModStart> { umode_t mode ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( error <S2SV_ModEnd> ) { gossip_err <S2SV_ModStart> { gossip_err ( "%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n" <S2SV_ModEnd> , __func__ , <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { umode_t mode <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl <S2SV_ModStart> if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> return error ; <S2SV_ModEnd> error = xfs_set_mode
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
<S2SV_ModStart> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { datagrams = err ; goto out_put ; } <S2SV_ModEnd> if ( err <S2SV_ModStart> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart> datagrams ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> break ; case 5 <S2SV_ModEnd> : hf_index_off = <S2SV_ModStart> ) ) { guint addr_data_offset = <S2SV_ModEnd> lr_start + off <S2SV_ModStart> off + QNX_QNET6_LR_PKT_SIZE ; if ( i != 2 && i != 5 ) { name [ i ] = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , addr_data_offset <S2SV_ModStart> ENC_NA ) ; ti = proto_tree_add_string ( sstree , hf_index , tvb , addr_data_offset , len , name [ i ] ) ; PROTO_ITEM_SET_GENERATED ( ti ) ; } else { if ( tvb_get_guint8 ( tvb , addr_data_offset <S2SV_ModEnd> + 1 ) <S2SV_ModStart> ) == QNET_LR_SA_FAMILY_MAC && len >= 2 + 6 ) { name [ i ] = tvb_ether_to_str ( tvb , addr_data_offset + 2 ) ; ti = proto_tree_add_item <S2SV_ModEnd> ( sstree , <S2SV_ModStart> , tvb , addr_data_offset + 2 , 6 , ENC_NA <S2SV_ModEnd> ) ; PROTO_ITEM_SET_GENERATED <S2SV_ModStart> ( ti ) ; } else { name [ i ] = NULL <S2SV_ModStart> if ( p <S2SV_ModEnd> ) { col_add_fstr <S2SV_ModStart> , COL_INFO , "Who<S2SV_blank>is<S2SV_blank>\\"%s.%s\\"?<S2SV_blank>Tell<S2SV_blank>\\"%s.%s\\"@%s" <S2SV_ModEnd> , name [ <S2SV_ModStart> : "?" , p <S2SV_ModEnd> ) ; } <S2SV_ModStart> if ( p <S2SV_ModEnd> ) { col_add_fstr <S2SV_ModStart> , COL_INFO , "To<S2SV_blank>\\"%s.%s\\",<S2SV_blank>\\"%s.%s\\"<S2SV_blank>is<S2SV_blank>at<S2SV_blank>%s" <S2SV_ModEnd> , name [ <S2SV_ModStart> : "?" , p <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , "qnet6.lr.src.addr" , FT_ETHER , BASE_NONE , NULL , 0 , "LR<S2SV_blank>Message<S2SV_blank>source<S2SV_blank>address" , HFILL } } , { & hf_qnet6_lr_dst , { "Destination" , "qnet6.lr.dst" , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>node" , HFILL } } , { & hf_qnet6_lr_dst_name_off , { "Offset" , "qnet6.lr.dst.name.off" , FT_UINT32 , BASE_DEC , NULL , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>name<S2SV_blank>offset" , HFILL } } , { & hf_qnet6_lr_dst_name_len , { "Length" , "qnet6.lr.dst.name.len" , FT_UINT32 , BASE_DEC , NULL , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>name<S2SV_blank>length" , HFILL } } , { & hf_qnet6_lr_dst_name_generated , { "Name" , "qnet6.lr.dst.name" <S2SV_ModEnd> , FT_STRING , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>name" , HFILL } } , { & hf_qnet6_lr_dst_domain_off <S2SV_ModEnd> , { "Offset" <S2SV_ModStart> { "Offset" , "qnet6.lr.dst.domain.off" <S2SV_ModEnd> , FT_UINT32 , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>domain<S2SV_blank>name<S2SV_blank>offset" , HFILL } } , { & hf_qnet6_lr_dst_domain_len <S2SV_ModEnd> , { "Length" <S2SV_ModStart> { "Length" , "qnet6.lr.dst_domain_len" <S2SV_ModEnd> , FT_UINT32 , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>domain<S2SV_blank>name<S2SV_blank>length" , HFILL } } , { & hf_qnet6_lr_dst_domain_generated , { "Domain" , "qnet6.lr.dst.domain" <S2SV_ModEnd> , FT_STRING , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>domain<S2SV_blank>name" , HFILL } } , { & hf_qnet6_lr_dst_addr_off <S2SV_ModEnd> , { "Offset" <S2SV_ModStart> { "Offset" , "qnet6.lr.dst.addr.off" <S2SV_ModEnd> , FT_UINT32 , <S2SV_ModStart> , 0 , "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>address<S2SV_blank>offset" , HFILL } } , { & hf_qnet6_lr_dst_addr_len <S2SV_ModEnd> , { "Length" <S2SV_ModStart> { "Length" , "qnet6.lr.dst.addr.len" <S2SV_ModEnd> , FT_UINT32 , <S2SV_ModStart> , 0 , <S2SV_ModEnd> "LR<S2SV_blank>Message<S2SV_blank>destination<S2SV_blank>address<S2SV_blank>length" , HFILL <S2SV_ModStart> , "qnet6.lr.dst.addr" , FT_ETHER <S2SV_ModEnd> , BASE_NONE ,
<S2SV_ModStart> { # line 669 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 507 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 511 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi = <S2SV_ModStart> if ( contains_faststart ) { char temp [ 50 ] ; g_snprintf ( temp <S2SV_ModEnd> , 50 , <S2SV_ModStart> frame_label ) ; g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ; }
<S2SV_ModStart> { # line 637 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 489 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 493 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi = <S2SV_ModStart> if ( contains_faststart ) { char temp [ 50 ] ; g_snprintf ( temp <S2SV_ModEnd> , 50 , <S2SV_ModStart> frame_label ) ; g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ; }
<S2SV_ModStart> { # line 538 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 542 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi = <S2SV_ModStart> if ( contains_faststart ) { char temp [ 50 ] ; g_snprintf ( temp <S2SV_ModEnd> , 50 , <S2SV_ModStart> frame_label ) ; g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ; }
<S2SV_ModStart> { # line 312 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info *
<S2SV_ModStart> { # line 321 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 648 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 658 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 842 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gef_ctx_t * <S2SV_ModStart> ; # line 847 <S2SV_ModEnd> "./asn1/h225/h225.cnf" actx ->
<S2SV_ModStart> { # line 593 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 445 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 449 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> NULL ) { char temp [ 50 ] ; g_snprintf ( temp , 50 , "%s<S2SV_blank>%s" , <S2SV_ModEnd> h225_pi -> frame_label <S2SV_ModStart> -> frame_label , codec_str ) ; g_strlcpy ( <S2SV_ModEnd> h225_pi -> frame_label <S2SV_ModStart> -> frame_label , temp , 50 <S2SV_ModEnd> ) ; h225_pi
<S2SV_ModStart> { # line 852 <S2SV_ModEnd> "./asn1/h225/h225.cnf" void * <S2SV_ModStart> ; # line 855 <S2SV_ModEnd> "./asn1/h225/h225.cnf" actx ->
<S2SV_ModStart> { # line 604 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 828 <S2SV_ModEnd> "./asn1/h225/h225.cnf" void * <S2SV_ModStart> ; # line 838 <S2SV_ModEnd> "./asn1/h225/h225.cnf" actx ->
<S2SV_ModStart> { # line 860 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gef_ctx_t * <S2SV_ModStart> ; # line 863 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gef_ctx_update_key (
<S2SV_ModStart> { # line 802 <S2SV_ModEnd> "./asn1/h225/h225.cnf" t35CountryCode = <S2SV_ModStart> ; # line 806 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h221NonStandard =
<S2SV_ModStart> { # line 370 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 556 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 564 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 702 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 401 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 405 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 680 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 783 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 815 <S2SV_ModEnd> "./asn1/h225/h225.cnf" nsp_handle =
<S2SV_ModStart> { # line 363 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 414 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 418 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi = <S2SV_ModStart> if ( contains_faststart ) { char temp [ 50 ] ; g_snprintf ( temp <S2SV_ModEnd> , 50 , <S2SV_ModStart> frame_label ) ; g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ; }
<S2SV_ModStart> { # line 294 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 rasmessage_value
<S2SV_ModStart> { # line 691 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 713 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 525 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 529 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 736 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 744 <S2SV_ModEnd> "./asn1/h225/h225.cnf" } return
<S2SV_ModStart> { # line 432 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 436 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 470 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 475 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi = <S2SV_ModStart> if ( contains_faststart ) { char temp [ 50 ] ; g_snprintf ( temp <S2SV_ModEnd> , 50 , <S2SV_ModStart> frame_label ) ; g_strlcpy ( h225_pi -> frame_label , temp , 50 ) ; }
<S2SV_ModStart> { # line 388 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 392 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 912 <S2SV_ModEnd> "./asn1/h225/h225.cnf" int min_len
<S2SV_ModStart> { # line 377 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 381 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_pi =
<S2SV_ModStart> { # line 724 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 350 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 341 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 458 <S2SV_ModEnd> "./asn1/h225/h225.cnf" h225_packet_info * <S2SV_ModStart> ; # line 466 <S2SV_ModEnd> "./asn1/h225/h225.cnf" } return
<S2SV_ModStart> { # line 748 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 770 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 817 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 883 <S2SV_ModEnd> "./asn1/h225/h225.cnf" const gchar
<S2SV_ModStart> { # line 893 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tvbuff_t *
<S2SV_ModStart> { # line 874 <S2SV_ModEnd> "./asn1/h225/h225.cnf" guint32 value_int
<S2SV_ModStart> { # line 768 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tp_handle =
<S2SV_ModStart> { # line 760 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tpOID = <S2SV_ModStart> ; # line 762 <S2SV_ModEnd> "./asn1/h225/h225.cnf" tp_handle =
<S2SV_ModStart> { # line 626 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> { # line 615 <S2SV_ModEnd> "./asn1/h225/h225.cnf" gint32 value
<S2SV_ModStart> ( p_fp_info -> num_chans > MAX_FP_CHANS ) { p_fp_info -> num_chans = MAX_FP_CHANS ; } if ( p_fp_info ->
<S2SV_ModStart> ENC_BIG_ENDIAN ) ; rlcinf <S2SV_ModEnd> -> rbid [ <S2SV_ModStart> ) ddi ; <S2SV_ModEnd> for ( p <S2SV_ModStart> 0 ) ; if ( ! macinf ) { macinf = wmem_new0 ( wmem_packet_scope ( ) , umts_mac_info ) ; }
<S2SV_ModStart> ; if ( ! rlcinf ) { rlcinf = wmem_new0 ( wmem_packet_scope ( ) , rlc_info ) ; } if (
<S2SV_ModStart> 0 ) ; if ( ! rlcinf ) { rlcinf = wmem_new0 ( wmem_packet_scope ( ) , rlc_info ) ; } <S2SV_ModStart> 0 ) ; if ( ! macinf ) { macinf = wmem_new0 ( wmem_packet_scope ( ) , umts_mac_info ) ; }
<S2SV_ModStart> 0 ) ; if ( ! rlcinf ) { rlcinf = wmem_new0 ( wmem_packet_scope ( ) , rlc_info ) ; } <S2SV_ModStart> 0 ) ; if ( ! macinf ) { macinf = wmem_new0 ( wmem_packet_scope ( ) , umts_mac_info ) ; }
<S2SV_ModStart> 0 ) ; if ( ! rlcinf ) { rlcinf = wmem_new0 ( wmem_packet_scope ( ) , rlc_info ) ; } <S2SV_ModStart> 0 ) ; if ( ! macinf ) { macinf = wmem_new0 ( wmem_packet_scope ( ) , umts_mac_info ) ; }
<S2SV_ModStart> for ( ; ( <S2SV_ModStart> n < outhdr_string_len ) && ( number_digits < MAX_OUTHDR_VALUES )
<S2SV_ModStart> chn_num ) ; col_add_str <S2SV_ModEnd> ( pinfo ->
<S2SV_ModStart> IOPRIO_NORM ) ; task_lock ( p ) ; <S2SV_ModStart> -> ioprio ; task_unlock ( p ) ;
<S2SV_ModStart> -> actual ; bool kiocb_has_eventfd = <S2SV_ModEnd> io_data -> kiocb <S2SV_ModStart> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> ) eventfd_signal ( <S2SV_ModStart> -> req ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> fname ) ; priv -> ctrl . fname = NULL ; <S2SV_ModStart> == NULL ) return <S2SV_ModEnd> - ENOMEM ;
<S2SV_ModStart> } if ( assoc_array_ptr_is_leaf ( ptr ) &&
<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&
<S2SV_ModStart> ( ! mm || ! mm -> env_end
<S2SV_ModStart> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> ; } if
<S2SV_ModStart> } if ( strcmp <S2SV_ModEnd> ( service_name , <S2SV_ModStart> service_name , "Unknown" <S2SV_ModEnd> ) == 0
<S2SV_ModStart> ; if ( len < icmph_len ) return - EINVAL ; if (
<S2SV_ModStart> to ) { unsigned <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> size ; if <S2SV_ModStart> -> start ; if ( fromoff >= from -> len || tooff >= to -> len ) return - EINVAL ; size = min_t ( size_t , to -> len - tooff , from -> len - fromoff ) ; if ( size == <S2SV_ModEnd> 0 ) return
<S2SV_ModStart> to ) { unsigned <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> size ; if <S2SV_ModStart> -> start ; if ( fromoff >= from -> len || tooff >= to -> len ) return - EINVAL ; size = min_t ( size_t , to -> len - tooff , from -> len - fromoff ) ; if ( size == <S2SV_ModEnd> 0 ) return
<S2SV_ModStart> ; } } if ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_ALERT && SSL3_RECORD_get_length ( rr ) != 0 ) s -> rlayer . alert_count = 0 ; <S2SV_ModStart> = alert_descr ; s -> rlayer . alert_count ++ ; if ( s -> rlayer . alert_count == MAX_WARN_ALERT_COUNT ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_DTLS1_READ_BYTES , SSL_R_TOO_MANY_WARN_ALERTS ) ; goto f_err ; }
<S2SV_ModStart> [ curr_rec ] ; if ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_ALERT && SSL3_RECORD_get_length ( rr ) != 0 ) s -> rlayer . alert_count = 0 <S2SV_ModStart> rr ) ; s -> rlayer . alert_count ++ ; if ( s -> rlayer . alert_count == MAX_WARN_ALERT_COUNT ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_TOO_MANY_WARN_ALERTS ) ; goto f_err ; }
<S2SV_ModStart> ctxt -> rip_relative && likely ( ctxt -> memopp )
<S2SV_ModStart> -> ifindex ; if ( tipc_mtu_bad ( dev , sizeof ( struct iphdr ) + sizeof ( struct udphdr ) ) ) { err = - EINVAL ; goto err ; }
<S2SV_ModStart> u16 ether_type ; if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> ) ; } if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> hdr ) ; if ( fg_off + len > dg_size ) return 0 ;
<S2SV_ModStart> u32 length ; <S2SV_ModEnd> unsigned long offset <S2SV_ModStart> flags ) ; if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> == IANA_SPECIFIER_ID && <S2SV_ModStart> IANA_SPECIFIER_ID && ( gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC2734_SW_VERSION # <S2SV_ModStart> CONFIG_IPV6 ) || gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC3146_SW_VERSION # <S2SV_ModStart> endif ) ) fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> , context -> <S2SV_ModStart> true ) ; <S2SV_ModEnd> packet . payload_length
<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb )
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk ,
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb )
<S2SV_ModStart> * ctx2 ; bool more ; <S2SV_ModStart> int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> crypto_ahash_export ( req <S2SV_ModStart> , state ) : 0 ; release_sock ( sk ) <S2SV_ModStart> -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err =
<S2SV_ModStart> esize ) { <S2SV_ModEnd> res -> nlimbs <S2SV_ModStart> : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }
<S2SV_ModStart> req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <S2SV_ModStart> . pg_vec ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; } else { <S2SV_ModEnd> po -> tp_version <S2SV_ModStart> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <S2SV_ModEnd> } case PACKET_RESERVE
<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> || ( skb <S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 1 ;
<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct
<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct
<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ion_handle_put ( <S2SV_ModStart> ; ret = ion_handle_put_nolock ( handle <S2SV_ModEnd> ) ; mutex_unlock
<S2SV_ModStart> * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ctx ) ) goto out <S2SV_ModEnd> ; pos = <S2SV_ModStart> ; } } out :
<S2SV_ModStart> ; proto_item * data_item ; proto_item * <S2SV_ModStart> "PNIO" ) ; data_item = proto_tree_add_protocol_format ( tree , proto_pn_io_rtc1 , tvb , offset , tvb_captured_length ( tvb ) , "PROFINET<S2SV_blank>IO<S2SV_blank>Cyclic<S2SV_blank>Service<S2SV_blank>Data<S2SV_blank>Unit:<S2SV_blank>%u<S2SV_blank>bytes" , tvb_captured_length ( tvb ) ) ; data_tree = proto_item_add_subtree ( data_item <S2SV_ModEnd> , ett_pn_io_rtc ) <S2SV_ModStart> ett_pn_io_rtc ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> + number_iocs_input_cr ; if ( objectCounter > ( guint ) tvb_reported_length_remaining ( tvb , offset ) ) { expert_add_info_format ( pinfo , data_item , & ei_pn_io_too_many_data_objects , "Too<S2SV_blank>many<S2SV_blank>data<S2SV_blank>objects:<S2SV_blank>%d" , objectCounter ) ; return ( tvb_captured_length ( tvb ) ) ; } <S2SV_ModStart> + number_iocs_output_cr ; if ( objectCounter > ( guint ) tvb_reported_length_remaining ( tvb , offset ) ) { expert_add_info_format ( pinfo , data_item , & ei_pn_io_too_many_data_objects , "Too<S2SV_blank>many<S2SV_blank>data<S2SV_blank>objects:<S2SV_blank>%d" , objectCounter ) ; return ( tvb_captured_length ( tvb ) ) ; }
<S2SV_ModStart> ett_pn_io_io_data_object } ; static ei_register_info ei [ ] = { { & ei_pn_io_too_many_data_objects , { "pn_io.too_many_data_objects" , PI_MALFORMED , PI_ERROR , "Too<S2SV_blank>many<S2SV_blank>data<S2SV_blank>objects" , EXPFILL } } , } ; expert_module_t * expert_pn_io ; <S2SV_ModStart> ) ) ; expert_pn_io = expert_register_protocol ( proto_pn_io_rtc1 ) ; expert_register_field_array ( expert_pn_io , ei , array_length ( ei ) ) ;
<S2SV_ModStart> -> private_data = wmem_strdup ( wmem_file_scope ( ) , s ) <S2SV_ModEnd> ; } }
<S2SV_ModStart> -> private_data = wmem_strdup ( wmem_file_scope ( ) , s ) <S2SV_ModEnd> ; } }
<S2SV_ModStart> -> private_data = wmem_strdup ( wmem_file_scope ( ) , str ) <S2SV_ModEnd> ; return offset
<S2SV_ModStart> while ( * signature_length <S2SV_ModEnd> > 0 && <S2SV_ModStart> > 0 && * * signature && <S2SV_ModStart> current_type = * ( ++ ( * signature ) ) ; -- * signature_length <S2SV_ModEnd> ; if (
<S2SV_ModStart> < end_of_body && signature_length > 0 &&
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> gint packet_length = <S2SV_ModStart> ( signature , signature_length <S2SV_ModEnd> ) ; } <S2SV_ModStart> } else { guint8 sig_length_saved <S2SV_ModEnd> = * signature_length <S2SV_ModStart> - 1 ; while ( ( offset - starting_offset ) < length ) { guint8 * sig_pointer ; guint8 remaining_sig_length ; number_of_items ++ ; sig_pointer = sig_saved ; remaining_sig_length = sig_length_saved ; <S2SV_ModStart> = sig_pointer ; <S2SV_ModEnd> * signature_length = <S2SV_ModStart> = remaining_sig_length ; } } <S2SV_ModStart> = "signature" ; length <S2SV_ModEnd> = tvb_get_guint8 ( <S2SV_ModStart> ; if ( length <S2SV_ModEnd> + 2 > <S2SV_ModStart> , "BAD<S2SV_blank>DATA:<S2SV_blank>Signature<S2SV_blank>length<S2SV_blank>is<S2SV_blank>%d.<S2SV_blank>Only<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>in<S2SV_blank>packet." , length <S2SV_ModEnd> , bytes_left ) <S2SV_ModStart> ; } length ++ <S2SV_ModEnd> ; proto_tree_add_item ( <S2SV_ModStart> , ENC_ASCII ) ; * signature_length = length <S2SV_ModStart> ( * signature && * signature_length > 0
<S2SV_ModStart> ++ ) { if ( <S2SV_ModStart> & sdnv_length ) < 0 ) break ; offset += sdnv_length ; if ( <S2SV_ModEnd> evaluate_sdnv ( tvb <S2SV_ModStart> & sdnv_length ) < 0 ) break
<S2SV_ModStart> gint32 update_end ; proto_item * ti ; <S2SV_ModStart> ENC_BIG_ENDIAN ) ; offset += 2 ; ti = <S2SV_ModStart> ENC_BIG_ENDIAN ) ; offset += 2 ; if ( update_len < 4 ) { expert_add_info ( pinfo , ti , & ei_openflow_v5_length_too_short ) ; return offset ; }
<S2SV_ModStart> pad_length ) ; ti = <S2SV_ModStart> += 2 ; if ( match_length < 4 ) { expert_add_info ( pinfo , ti , & ei_openflow_v5_length_too_short ) ; return offset ; }
<S2SV_ModStart> band_len ) ; ti = <S2SV_ModStart> += 4 ; if ( band_len < 12 ) { expert_add_info ( pinfo , ti , & ei_openflow_v5_length_too_short ) ; return offset ; }
<S2SV_ModStart> prop_len ) ; ti = <S2SV_ModStart> += 4 ; if ( prop_len < 8 ) { expert_add_info ( pinfo , ti , & ei_openflow_v5_length_too_short ) ; return offset ; }
<S2SV_ModStart> EXPFILL } } , { & ei_openflow_v5_length_too_short , { "openflow_v5.message.length_too_short" , PI_MALFORMED , PI_ERROR , "Length<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short." , EXPFILL } }
<S2SV_ModStart> commands ) ; <S2SV_ModEnd> ch_end = ( <S2SV_ModStart> commands ) ; if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } }
<S2SV_ModStart> ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :
<S2SV_ModStart> ; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1
<S2SV_ModStart> : if ( is_nmi <S2SV_ModEnd> ( intr_info )
<S2SV_ModStart> ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) {
<S2SV_ModStart> error ; } ret = - EPERM ; if ( name [ 0 ] == '.' ) goto error_name ; <S2SV_ModStart> name ) ; error_name :
<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
<S2SV_ModStart> ( error ) { kmem_free ( sbuf ) ; <S2SV_ModStart> return error ; }
<S2SV_ModStart> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if (
<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val * <S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val *
<S2SV_ModStart> endif _end : <S2SV_ModEnd> kill_fasync ( & <S2SV_ModStart> POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;
<S2SV_ModStart> * nlh ; struct module * module ; <S2SV_ModStart> = false ; module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart> ; module_put ( <S2SV_ModEnd> module ) ; <S2SV_ModStart> ; consume_skb ( <S2SV_ModEnd> skb ) ;
<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
<S2SV_ModStart> < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> goto unlock ; } <S2SV_ModStart> , rsp ) ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> buf ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
<S2SV_ModStart> : if ( l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) { int len = cmd -> len - sizeof ( * rsp ) ; char req [ 64 ] ; result = L2CAP_CONF_SUCCESS ; len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ; if ( len < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) <S2SV_ModEnd> ; l2cap_send_cmd ( <S2SV_ModStart> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & <S2SV_ModEnd> req ) ; <S2SV_ModStart> ; goto done ; } l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ; if ( result != L2CAP_CONF_SUCCESS ) goto done ; break
<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
<S2SV_ModStart> } if ( pi -> num_conf_rsp || pi -> num_conf_req ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) return - ECONNREFUSED ; break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : if ( pi -> mode != rfc . mode ) { result = L2CAP_CONF_UNACCEPT ; rfc . mode = pi -> mode ; if ( pi -> num_conf_rsp == 1 ) return - ECONNREFUSED ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; } if ( <S2SV_ModStart> { if ( mtu < L2CAP_DEFAULT_MIN_MTU ) result = L2CAP_CONF_UNACCEPT ; else { <S2SV_ModEnd> pi -> omtu <S2SV_ModStart> pi -> omtu = mtu ; pi -> conf_state |= L2CAP_CONF_MTU_DONE ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ; switch ( rfc . mode ) { case L2CAP_MODE_BASIC : pi -> fcs = L2CAP_FCS_NONE ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_ERTM : pi -> remote_tx_win = rfc . txwin_size ; pi -> remote_max_tx = rfc . max_transmit ; pi -> max_pdu_size = rfc . max_pdu_size ; rfc . retrans_timeout = L2CAP_DEFAULT_RETRANS_TO ; rfc . monitor_timeout = L2CAP_DEFAULT_MONITOR_TO ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_STREAMING : pi -> remote_tx_win = rfc . txwin_size ; pi -> max_pdu_size = rfc . max_pdu_size ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; default : <S2SV_ModEnd> result = L2CAP_CONF_UNACCEPT <S2SV_ModStart> = L2CAP_CONF_UNACCEPT ; memset ( & rfc , 0 , sizeof ( rfc ) ) ; rfc . mode = pi -> mode ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; if ( result == L2CAP_CONF_SUCCESS ) <S2SV_ModEnd> pi -> conf_state <S2SV_ModStart> |= L2CAP_CONF_OUTPUT_DONE ; <S2SV_ModEnd> } rsp ->
<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
<S2SV_ModStart> , ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> irq_srcu ) ; if <S2SV_ModEnd> ( guest_irq >= <S2SV_ModStart> irq_rt -> nr_rt_entries || hlist_empty ( <S2SV_ModEnd> & irq_rt -> <S2SV_ModStart> [ guest_irq ] ) ) { pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ]
<S2SV_ModStart> ET_DYN ) { if ( elf_interpreter ) { <S2SV_ModStart> load_bias = ELF_ET_DYN_BASE <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( ) ; elf_flags |= MAP_FIXED ; } else load_bias = 0 ; load_bias = <S2SV_ModEnd> ELF_PAGESTART ( load_bias <S2SV_ModStart> ELF_PAGESTART ( load_bias - vaddr
<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
<S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> memset ( vmx_io_bitmap_b
<S2SV_ModStart> case L2CAP_CONF_EFS : <S2SV_ModEnd> if ( olen <S2SV_ModStart> efs ) ) { remote_efs = 1 ; <S2SV_ModStart> olen ) ; }
<S2SV_ModStart> efs ) ) { <S2SV_ModStart> ptr ) ; }
<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> ctx ) { <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> spin_lock ( & ctx -> <S2SV_ModStart> cancel_lock ) ; __timerfd_remove_cancel ( ctx <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> spin_unlock ( & ctx -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
<S2SV_ModStart> { struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
<S2SV_ModStart> ; break ; default : concatlen = 0 ; break ;
<S2SV_ModStart> * mq_module ; expert_module_t * expert_mq ; static ei_register_info ei [ ] = { { & ei_mq_reassembly_error , { "mq.reassembly_error" , PI_REASSEMBLE , PI_ERROR , "Reassembly<S2SV_blank>error" , EXPFILL } } } ; <S2SV_ModStart> ) ) ; expert_mq = expert_register_protocol ( proto_mq ) ; expert_register_field_array ( expert_mq , ei , array_length ( ei ) ) ;
<S2SV_ModStart> + iMulS ; gboolean reassembly_error = FALSE ; <S2SV_ModStart> : iNxtP ; if ( iSegL <= iBegL ) { fd_head = NULL ; reassembly_error = TRUE ; } else { <S2SV_ModStart> bMore ) ; } <S2SV_ModStart> iSegmIndex , iSegLength ) ; } if ( reassembly_error ) { expert_add_info_format ( pinfo , ti , & ei_mq_reassembly_error , "Wrong<S2SV_blank>fragment<S2SV_blank>length<S2SV_blank>(%d)<S2SV_blank>-<S2SV_blank>skipping<S2SV_blank>reassembly" , iSegL - iBegL
<S2SV_ModStart> ; array_tree = proto_tree_add_item <S2SV_ModEnd> ( item , <S2SV_ModStart> + count_len , ENC_BIG_ENDIAN ) ; proto_item_set_text ( array_tree ,
<S2SV_ModStart> } list_tree = proto_tree_add_item <S2SV_ModEnd> ( item , <S2SV_ModStart> + count_len , ENC_BIG_ENDIAN ) ; proto_item_set_text ( list_tree ,
<S2SV_ModStart> , name ) ; if ( * length_size == 0 ) { * length_size = tvb_reported_length_remaining ( tvb , offset ) ; } else { * length_size -= 1 ; } <S2SV_ModEnd> break ; case
<S2SV_ModStart> = 0 , <S2SV_ModEnd> tmp = 0 <S2SV_ModStart> ; guint16 info_len , item_len
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> len <= tvb_len ) && ( idx < tvb_len )
<S2SV_ModStart> ei_wbxml_oversized_uintvar ) ; if ( ( len <= tvb_len ) && ( idx < tvb_len ) ) { <S2SV_ModStart> + idx ; } else { off = tvb_len ; }
<S2SV_ModStart> ; if ( calcDataLength >= 0 ) { if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> proto_tree_add_item ( ssdo_tree
<S2SV_ModStart> acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * <S2SV_ModStart> acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node
<S2SV_ModStart> dev ) ; ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> sprintf ( buf <S2SV_ModStart> driver_override ) ; device_unlock ( dev ) ; return len ;
<S2SV_ModStart> , * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;
<S2SV_ModStart> ; if ( ! tb [ NL80211_REKEY_DATA_REPLAY_CTR ] || ! tb [ NL80211_REKEY_DATA_KEK ] || ! tb [ NL80211_REKEY_DATA_KCK ] ) return - EINVAL ; if (
<S2SV_ModStart> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif
<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
<S2SV_ModStart> ) { gpte &= level - mmu -> last_nonleaf_level ; gpte <S2SV_ModStart> PT_PAGE_TABLE_LEVEL - 1 <S2SV_ModEnd> ; return gpte
<S2SV_ModStart> + offset ; BUG_ON ( walker -> level < 1 ) ;
<S2SV_ModStart> true ) ; update_last_nonleaf_level ( vcpu , context ) ;
<S2SV_ModStart> struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }
<S2SV_ModStart> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;
<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel
<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;
<S2SV_ModStart> ip_proto = 0 ; bool ret = false <S2SV_ModStart> < 5 ) goto out_bad <S2SV_ModEnd> ; nhoff += <S2SV_ModStart> ! iph ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> ! vlan ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } } <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } goto out_good ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } ip_proto_again <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! keyid ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! eth ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ! opthdr ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> break ; } if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> ) nhoff ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * frame_ptr = wmem_new0 <S2SV_ModEnd> ( wmem_file_scope ( <S2SV_ModStart> modbus_request_info_t ) ; gint captured_length = tvb_captured_length ( tvb ) ; <S2SV_ModStart> = function_code ; if ( captured_length >= 3 ) { <S2SV_ModStart> 1 ) ; if ( captured_length >= 5 ) <S2SV_ModStart> 3 ) ; }
<S2SV_ModStart> 256 ) ; if ( strlen ( buf ) > 2 ) <S2SV_ModStart> buf + 2 ) ; else proto_item_append_text ( ti , "unknown)" <S2SV_ModStart> 256 ) ; if ( strlen ( buf ) > 2 ) <S2SV_ModStart> buf + 2 ) ; else proto_item_append_text ( ti , "unknown)"
<S2SV_ModStart> ( data_str , "%*s<S2SV_blank>%15s" <S2SV_ModEnd> , pid ) <S2SV_ModStart> ( data_str , "%*s<S2SV_blank>%15s" <S2SV_ModEnd> , pid ) <S2SV_ModStart> ) == 1 && strlen ( pid ) > 10 <S2SV_ModStart> ( data_str , "%*s<S2SV_blank>%15s" <S2SV_ModEnd> , pid ) <S2SV_ModStart> ( data_str , "%*s<S2SV_blank>%15s" <S2SV_ModEnd> , pid ) <S2SV_ModStart> == 1 && strlen ( pid ) > 10 &&
<S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "VendorID=\\"%199[^\\"]" <S2SV_ModEnd> , convertStr ) <S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "DeviceID=\\"%199[^\\"]" <S2SV_ModEnd> , convertStr ) <S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "Index=\\"%199[^\\"]" <S2SV_ModEnd> , convertStr ) <S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "ModuleIdentNumber=\\"%199[^\\"]" <S2SV_ModEnd> , convertStr ) <S2SV_ModStart> ( temp , "%*s<S2SV_blank>TextId=\\"%199[^\\"]" <S2SV_ModEnd> , tmp_moduletext ) <S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "SubmoduleIdentNumber=\\"%199[^\\"]" <S2SV_ModEnd> , convertStr )
<S2SV_ModStart> -> moduleNameStr = ( gchar * ) wmem_alloc <S2SV_ModEnd> ( wmem_file_scope ( <S2SV_ModStart> ( ) , MAX_NAMELENGTH ) ; g_strlcpy ( io_data_object -> moduleNameStr , "Unknown" , MAX_NAMELENGTH <S2SV_ModEnd> ) ; vendorMatch <S2SV_ModStart> ; if ( pch != NULL && <S2SV_ModStart> ( pch , "Value=\\"%199[^\\"]" <S2SV_ModEnd> , io_data_object ->
<S2SV_ModStart> , msdp_types , "<Unknown<S2SV_blank>MSDP<S2SV_blank>TLV<S2SV_blank>type>" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> case MSDP_SA_REQ : if ( length < 1 ) break ; <S2SV_ModStart> ENC_BIG_ENDIAN ) ; offset += 1 ; length -= 1 ; if ( length < 4 ) { offset += length ; break ; } <S2SV_ModStart> tvb , offset <S2SV_ModEnd> , 4 , <S2SV_ModStart> ; offset += 4 <S2SV_ModEnd> ; break ;
<S2SV_ModStart> * vals ; gint reported_length ; tvbuff_t * next_tvb ; if ( tlv_len < 1 ) return ; <S2SV_ModStart> += 1 ; tlv_len -= 1 ; <S2SV_ModStart> break ; } if ( tlv_len < 1 ) return ; <S2SV_ModStart> += 1 ; tlv_len -= 1 ; <S2SV_ModStart> case SA_REQUEST_ERROR : if ( tlv_len < 7 ) { * offset += tlv_len ; return ; } <S2SV_ModStart> hf_msdp_not_group_address ) ; tlv_len -= 7 ; <S2SV_ModStart> 1 ) { if ( tlv_len < 1 ) return ; <S2SV_ModStart> * offset += 1 ; tlv_len -= <S2SV_ModStart> 2 ) { if ( tlv_len < 7 ) { * offset += tlv_len ; return ; } <S2SV_ModStart> , hf_msdp_not_rp_address ) ; tlv_len -= 7 <S2SV_ModStart> 8 ) { if ( tlv_len < 7 ) { * offset += tlv_len ; return ; } <S2SV_ModStart> , hf_msdp_not_group_address ) ; tlv_len -= 7 <S2SV_ModStart> 4 ) { if ( tlv_len < 7 ) { * offset += tlv_len ; return ; } <S2SV_ModStart> , hf_msdp_not_source_address ) ; tlv_len -= 7 <S2SV_ModStart> 5 ) { if ( tlv_len < 1 ) return ; <S2SV_ModStart> * offset += 1 ; tlv_len -= <S2SV_ModStart> 6 ) { if ( tlv_len > 0 ) { reported_length = tvb_reported_length_remaining ( tvb , * offset ) ; DISSECTOR_ASSERT ( reported_length >= 0 ) ; if ( reported_length > tlv_len ) reported_length = tlv_len ; next_tvb = tvb_new_subset_length ( tvb , * offset , tlv_len ) ; dissect_msdp ( next_tvb , pinfo , tree , NULL ) ; } * offset += tlv_len ; tlv_len = 0 ; <S2SV_ModStart> 7 ) { if ( tlv_len > 0 ) { reported_length = tvb_reported_length_remaining ( tvb , * offset ) ; DISSECTOR_ASSERT ( reported_length >= 0 ) ; if ( reported_length > tlv_len ) reported_length = tlv_len ; next_tvb = tvb_new_subset_length ( tvb , * offset , tlv_len ) ; dissect_msdp ( next_tvb , pinfo , tree , NULL ) ; } * offset += tlv_len ; tlv_len = 0 ; break ; } else { if ( tlv_len > 0 ) <S2SV_ModStart> ( tree , hf_msdp_unknown_data , tvb , * offset , tlv_len <S2SV_ModEnd> , ENC_NA ) <S2SV_ModStart> offset += tlv_len ; tlv_len = 0 ; break ; } break ; case MESSAGE_HEADER_ERROR : case NOTIFICATION : if ( tlv_len > 0 ) { reported_length = tvb_reported_length_remaining ( tvb , * offset ) ; DISSECTOR_ASSERT ( reported_length >= 0 ) ; if ( reported_length > tlv_len ) reported_length = tlv_len ; next_tvb = tvb_new_subset_length ( tvb , * offset , tlv_len ) ; dissect_msdp ( next_tvb , pinfo , tree ) ; } * offset += tlv_len ; tlv_len = 0 ; break ; case FSM_ERROR : case HOLD_TIMER_EXPIRED : case CEASE : break ; default : if ( tlv_len > 0 ) <S2SV_ModEnd> proto_tree_add_item ( tree <S2SV_ModStart> offset , tlv_len <S2SV_ModEnd> , ENC_NA ) <S2SV_ModStart> offset += tlv_len ; tlv_len = 0 ; break ; } if ( tlv_len != 0 ) { <S2SV_ModEnd> proto_tree_add_item ( tree <S2SV_ModStart> ( tree , hf_msdp_trailing_junk , tvb , * offset , tlv_len <S2SV_ModEnd> , ENC_NA ) <S2SV_ModStart> offset += tlv_len <S2SV_ModEnd> ; } return
<S2SV_ModStart> enc_tree ; gint <S2SV_ModEnd> reported_length ; tvbuff_t <S2SV_ModStart> length ) ; <S2SV_ModEnd> reported_length = tvb_reported_length_remaining <S2SV_ModStart> ; DISSECTOR_ASSERT ( reported_length <S2SV_ModEnd> >= 0 ) <S2SV_ModStart> 0 ) ; if ( reported_length > <S2SV_ModEnd> length ) reported_length <S2SV_ModStart> ; next_tvb = tvb_new_subset_length ( tvb , * offset , <S2SV_ModEnd> reported_length ) ;
<S2SV_ModStart> "Trailing<S2SV_blank>junk" , "msdp.trailing_junk" <S2SV_ModEnd> , FT_BYTES ,
<S2SV_ModStart> sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
<S2SV_ModStart> -> bInterval ; <S2SV_ModEnd> result = usb_control_msg <S2SV_ModStart> ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
<S2SV_ModStart> ) { return crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> generate (
<S2SV_ModStart> ) { return crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> seedsize ;
<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
<S2SV_ModStart> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page
<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
<S2SV_ModStart> docsis_tree ) ; if ( concatlen > 0 ) { concatlen = concatlen - framelen ; concatpos += framelen ; } <S2SV_ModStart> = save_fragmented ; if ( concatlen > 0 ) { concatlen = concatlen - framelen ; concatpos += framelen ; }
<S2SV_ModStart> address dst_addr ; guint32 ip4_addr ; <S2SV_ModStart> * tmp3 ; <S2SV_ModEnd> tmp ++ ; <S2SV_ModStart> * tmp3 ; <S2SV_ModEnd> tmp ++ ; <S2SV_ModStart> guchar * tmp3 <S2SV_ModEnd> ; tmp ++
<S2SV_ModStart> * sub_wmemtree ; guint32 frame_number , curr_layer_num ; curr_layer_num = pinfo -> curr_layer_num <S2SV_ModEnd> ; key [ <S2SV_ModStart> . length = 1 ; key [ 2 ] . key = & curr_layer_num ; key [ 3 ] . length = <S2SV_ModStart> ; key [ 3 <S2SV_ModEnd> ] . key
<S2SV_ModStart> wmem_tree_key_t key [ 5 <S2SV_ModEnd> ] ; guint32 <S2SV_ModStart> ; guint32 frame_number , curr_layer_num <S2SV_ModStart> -> num ; curr_layer_num = pinfo -> curr_layer_num ; <S2SV_ModStart> key = & curr_layer_num <S2SV_ModEnd> ; key [ <S2SV_ModStart> . length = 1 <S2SV_ModEnd> ; key [ <S2SV_ModStart> key [ 3 ] . key = & frame_number ; key [ 4 ] . length = 0 ; key [ 4
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> { pair_list = wmem_array_new <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> struct mbim_pair_list ) <S2SV_ModEnd> ) ; subtree
<S2SV_ModStart> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , "port-%d" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
<S2SV_ModStart> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> ( ) ) { <S2SV_ModStart> buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user <S2SV_ModStart> state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }
<S2SV_ModStart> err = - <S2SV_ModEnd> EALREADY ; if <S2SV_ModStart> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> match -> type <S2SV_ModStart> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }
<S2SV_ModStart> = false ; lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> fanout ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out_unlock ; } <S2SV_ModEnd> if ( name
<S2SV_ModStart> "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ; if ( state == KEY_IS_POSITIVE && <S2SV_ModEnd> key -> type <S2SV_ModStart> ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec (
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_inc <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , - error <S2SV_ModEnd> ) ; now
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( keyring )
<S2SV_ModStart> long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( <S2SV_ModStart> { if ( state < 0 ) { <S2SV_ModEnd> ctx -> result <S2SV_ModStart> = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave
<S2SV_ModStart> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key
<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
<S2SV_ModStart> = 0 ; info -> port = NULL ;
<S2SV_ModStart> { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> rc ) { struct task_struct * <S2SV_ModEnd> task = kthread_run <S2SV_ModStart> ; if ( IS_ERR ( task ) ) { <S2SV_ModStart> uwbd . task = NULL ; <S2SV_ModEnd> printk ( KERN_ERR <S2SV_ModStart> "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; } else { rc -> uwbd . task = task ; <S2SV_ModEnd> rc -> uwbd <S2SV_ModStart> pid ; } }
<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>control<S2SV_blank>header\\n" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , "too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , "skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"
<S2SV_ModStart> <S2SV_null> <S2SV_null> static struct usb_host_interface * <S2SV_ModEnd> uas_find_uas_alt_setting ( struct <S2SV_ModStart> ) return alt <S2SV_ModEnd> ; } return <S2SV_ModStart> ; } return NULL <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> driver_info ; struct usb_host_interface * alt ; int r ; alt = uas_find_uas_alt_setting ( intf ) ; if ( ! alt ) return 0 ; r = uas_find_endpoints ( alt <S2SV_ModEnd> , eps )
<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
<S2SV_ModStart> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> iad_num ] = d <S2SV_ModEnd> ; iad_num ++
<S2SV_ModStart> ret , n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( "hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++
<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , "invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n" ) ; break
<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
<S2SV_ModStart> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , "Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n" , i + size , length ) ; break ; } <S2SV_ModEnd> switch ( size <S2SV_ModStart> break ; case 4 : <S2SV_ModEnd> data32 = get_unaligned_le32
<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , "Too<S2SV_blank>large<S2SV_blank>descriptor\\n" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> "Found<S2SV_blank>union<S2SV_blank>header\\n" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , "Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info . <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void )
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
<S2SV_ModStart> = { . start = link -> start , .
<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4
<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4
<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
<S2SV_ModStart> } # endif return <S2SV_ModStart> mm ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; guchar name_char ; char * name_ret_orig = name_ret <S2SV_ModStart> name_ret -- ; while ( name_ret >= name_ret_orig <S2SV_ModEnd> ) { if
<S2SV_ModStart> tvb , offset <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { return 0 ; } mpa_packetlist ( pinfo , MPA_FPDU ) ; <S2SV_ModEnd> mpa_item = proto_tree_add_item
<S2SV_ModStart> ; if ( item_length <= base_length ) { expert_add_info ( pinfo , item , & ei_mal_io ) ; return ; } if (
<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err
<S2SV_ModStart> goto bad_fork_cleanup_io ; stackleak_task_init ( p ) ;
<S2SV_ModStart> , fault_ipa , & <S2SV_ModStart> , fault_ipa , NULL <S2SV_ModEnd> ) ; ret
<S2SV_ModStart> . phys_addr , &
<S2SV_ModStart> , gpa , NULL <S2SV_ModEnd> ) ; return
<S2SV_ModStart> . gpa , <S2SV_ModEnd> val ) ;
<S2SV_ModStart> , addr , <S2SV_ModEnd> v ) ;
<S2SV_ModStart> , gpa , <S2SV_ModEnd> val ) ;
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
<S2SV_ModStart> EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
<S2SV_ModStart> break ; } <S2SV_ModEnd> dst_reg -> smin_value <S2SV_ModStart> = S64_MAX ; <S2SV_ModEnd> if ( src_known
<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> else { return false <S2SV_ModEnd> ; } case
<S2SV_ModStart> = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> tn_buf ) ; return - EACCES ;
<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
<S2SV_ModStart> ; if ( length > 0 &&
<S2SV_ModStart> ; if ( ( pinfo -> dst . type != AT_IPv4 ) ||
<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
<S2SV_ModStart> = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) <S2SV_ModStart> * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst )
<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart> I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> & amd_pinctrl_desc , <S2SV_ModStart> & amd_pinctrl_desc , <S2SV_ModEnd> gpio_dev ) ; <S2SV_ModStart> ( ret ) return ret <S2SV_ModEnd> ; ret = <S2SV_ModStart> gc ) ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> f2fs_sb_info * sbi , bool umount <S2SV_ModStart> ( sbi , ! umount <S2SV_ModEnd> ) ; }
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> md ) ) { md = NULL ; goto out ; } <S2SV_ModEnd> dm_get ( md <S2SV_ModStart> dm_get ( md ) ; out : spin_unlock ( & _minor_lock
<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; int ret <S2SV_ModStart> ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;
<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> ) get_block = ocfs2_lock_get_block <S2SV_ModEnd> ; else get_block <S2SV_ModStart> else get_block = ocfs2_dio_wr_get_block <S2SV_ModEnd> ; return __blockdev_direct_IO
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void sas_destruct_devices ( <S2SV_ModStart> sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry_safe (
<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;
<S2SV_ModStart> sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry (
<S2SV_ModStart> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> dev ) ; if <S2SV_ModEnd> ( res == <S2SV_ModStart> num_phys ) ; <S2SV_ModEnd> } return res
<S2SV_ModStart> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy
<S2SV_ModStart> gone ) ; sas_destruct_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int ret = proc_dointvec_minmax <S2SV_ModEnd> ( table ,
<S2SV_ModStart> -> b_size = ( u64 )
<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }
<S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> -> group_leader ; switch <S2SV_ModEnd> ( event -> <S2SV_ModStart> event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> rtn = find_task_by_vpid <S2SV_ModStart> -> sigev_notify_thread_id ) ; if ( ! rtn <S2SV_ModEnd> || ! same_thread_group <S2SV_ModStart> , current ) <S2SV_ModEnd> ) return NULL <S2SV_ModStart> return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> ( event -> <S2SV_ModStart> sigev_signo <= 0 || <S2SV_ModEnd> event -> sigev_signo <S2SV_ModStart> > SIGRTMAX ) <S2SV_ModEnd> return NULL ; <S2SV_ModStart> return NULL ; case SIGEV_NONE : <S2SV_ModStart> rtn ) ; default : return NULL ; }
<S2SV_ModStart> && str [ 0 <S2SV_ModEnd> ] && str <S2SV_ModStart> && str [ 0 <S2SV_ModEnd> ] != '\\n'
<S2SV_ModStart> && str [ 0 <S2SV_ModEnd> ] && str <S2SV_ModStart> && str [ 0 <S2SV_ModEnd> ] != '\\n'
<S2SV_ModStart> -> offset ; # ifdef CONFIG_SLAB_FREELIST_HARDENED BUG_ON ( object == fp ) ; # endif
<S2SV_ModStart> = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! index_key .
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if (
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
<S2SV_ModStart> 1 ] ; if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> -= EVP_GCM_TLS_TAG_LEN ; }
<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
<S2SV_ModStart> 1 ] ; if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> -= EVP_GCM_TLS_TAG_LEN ; }
<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
<S2SV_ModStart> encrypt ) { if ( len < MD5_DIGEST_LENGTH ) return - 1 ;
<S2SV_ModStart> ) ) { if ( len < MD5_DIGEST_LENGTH ) return - 1 ;
<S2SV_ModStart> ) ) { if ( len < MD5_DIGEST_LENGTH ) return - 1 ;
<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> { s -> ext . use_etm = 0 <S2SV_ModEnd> ; return 1
<S2SV_ModStart> ) s -> ext . use_etm = 1 <S2SV_ModEnd> ; return 1
<S2SV_ModStart> { if ( ! s -> ext . use_etm <S2SV_ModEnd> ) return 1 <S2SV_ModStart> { s -> ext . use_etm = 0 <S2SV_ModEnd> ; return 1
<S2SV_ModStart> ) s -> ext . use_etm = 1 <S2SV_ModEnd> ; return 1
<S2SV_ModStart> if ( ! SSL_WRITE_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ; if ( SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> if ( ! SSL_WRITE_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> } if ( SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ! SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ( ! SSL_READ_ETM ( s ) && <S2SV_ModStart> ) != NULL <S2SV_ModEnd> ) ) {
<S2SV_ModStart> if ( ! SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl ) <S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl )
<S2SV_ModStart> ( s -> ext . use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> ext . use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;
<S2SV_ModStart> & comp , s -> ext . use_etm <S2SV_ModEnd> ) ) {
<S2SV_ModStart> read_hash ) ; assert ( imac_size >= 0 && imac_size <= EVP_MAX_MD_SIZE ) ; <S2SV_ModStart> imac_size < 0 || imac_size > EVP_MAX_MD_SIZE <S2SV_ModStart> size_t ) imac_size <S2SV_ModEnd> ; for (
<S2SV_ModStart> if ( ! SSL_WRITE_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> { if ( SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ( ! SSL_READ_ETM ( s ) && <S2SV_ModStart> ) != NULL <S2SV_ModEnd> ) ) {
<S2SV_ModStart> if ( ! SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl ) <S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl )
<S2SV_ModStart> ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;
<S2SV_ModStart> & comp , s -> tlsext_use_etm <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( s -> tlsext_use_etm <S2SV_ModEnd> ) { if <S2SV_ModStart> ) s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; else {
<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
<S2SV_ModStart> endif s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; s -> <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; } else
<S2SV_ModStart> unsigned mac_size ; int imac_size ; <S2SV_ModStart> * mac ; imac_size <S2SV_ModEnd> = EVP_MD_CTX_size ( <S2SV_ModStart> read_hash ) ; assert ( imac_size >= 0 && imac_size <S2SV_ModEnd> <= EVP_MAX_MD_SIZE ) <S2SV_ModStart> <= EVP_MAX_MD_SIZE ) ; if ( imac_size < 0 || imac_size > EVP_MAX_MD_SIZE ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_RECORD , ERR_LIB_EVP ) ; goto f_err ; } mac_size = ( unsigned ) imac_size
<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> usb_dev ; char * build <S2SV_ModEnd> ; int ret <S2SV_ModStart> ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> ) ; } kfree ( build ) ;
<S2SV_ModStart> ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;
<S2SV_ModStart> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( <S2SV_ModStart> , reg , buffer <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1000 ) ; if ( <S2SV_ModEnd> ret >= 0 <S2SV_ModStart> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> ret ; } <S2SV_ModStart> ret ; } }
<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status
<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> -> pipe ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> -> count ; <S2SV_ModEnd> if ( size <S2SV_ModStart> size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> ( off ) left <S2SV_ModEnd> += off - <S2SV_ModStart> ; if ( left <S2SV_ModEnd> <= buf -> <S2SV_ModStart> ) break ; left <S2SV_ModEnd> -= buf -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> i -> idx <S2SV_ModStart> = idx ; <S2SV_ModEnd> i -> iov_offset <S2SV_ModStart> -> offset + left ; <S2SV_ModEnd> } i -> <S2SV_ModStart> -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static guint <S2SV_ModEnd> asterix_fspec_len ( tvbuff_t <S2SV_ModStart> offset ) { guint i ; guint max_length = tvb_reported_length ( tvb ) - offset <S2SV_ModEnd> ; for ( <S2SV_ModStart> && i < max_length <S2SV_ModEnd> ; i ++
<S2SV_ModStart> len ) { guint type <S2SV_ModEnd> , sub_value ; <S2SV_ModStart> * subtree2 ; int <S2SV_ModEnd> tlv5_cap_index , tlv5_counter <S2SV_ModStart> , i , tlv_len , field_len , opt_len <S2SV_ModEnd> , field_value ;
<S2SV_ModStart> ; return ( suboptoff - optoff <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; return ( suboptoff - optoff <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
<S2SV_ModStart> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock
<S2SV_ModStart> return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> * f ; mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> ; if ( f ) { <S2SV_ModEnd> po -> fanout <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( po <S2SV_ModStart> ) ; } mutex_unlock ( & fanout_mutex ) ; }
<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { while ( 1 ) { <S2SV_ModStart> ] ) ; if ( ! queue ) break ; <S2SV_ModEnd> if ( free_func <S2SV_ModStart> ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> } } hashbin <S2SV_ModStart> & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & <S2SV_ModStart> flags ) ; <S2SV_ModEnd> kfree ( hashbin
<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> = NULL ; if ( nstrace_buflen == 0 ) { return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( hdp ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "Zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; }
<S2SV_ModStart> -> pnstrace_buf ; guint32 nstrace_buf_offset = nstrace -> nstrace_buf_offset ; guint32 <S2SV_ModEnd> nstrace_buflen = nstrace <S2SV_ModStart> fh ) ) > 0 && ( ( guint32 ) <S2SV_ModEnd> bytes_read == nstrace_buflen
<S2SV_ModStart> -> pnstrace_buf ; guint32 nstrace_buf_offset = nstrace -> nstrace_buf_offset ; guint32 <S2SV_ModEnd> nstrace_buflen = nstrace <S2SV_ModStart> fh ) ) > 0 && ( ( guint32 ) <S2SV_ModEnd> bytes_read == nstrace_buflen
<S2SV_ModStart> -> pnstrace_buf ; guint32 nstrace_buf_offset = nstrace -> nstrace_buf_offset ; guint32 <S2SV_ModEnd> nstrace_buflen = nstrace <S2SV_ModStart> bytes_read > 0 && bytes_read < NSPR_PAGESIZE_TRACE <S2SV_ModStart> = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" <S2SV_ModEnd> ) ; return <S2SV_ModStart> fh ) ) > 0 <S2SV_ModStart> fh ) || ( guint32 )
<S2SV_ModStart> } if ( ( <S2SV_ModStart> messageDetail != INFERRED_PEERSHUTDOWN ) && ! PINFO_FD_VISITED ( pinfo <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ; } <S2SV_ModEnd> } return tvb_captured_length
<S2SV_ModStart> ; if ( transfer_info -> req == NULL <S2SV_ModEnd> ) { already_dissected <S2SV_ModStart> , ldss_file_t ) <S2SV_ModEnd> ; } if
<S2SV_ModStart> global_udp_port_ldss ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , iax2_tree , tvb , <S2SV_ModStart> pinfo , iax2_tree , tvb
<S2SV_ModStart> , iax2_tree , tvb , <S2SV_ModStart> pinfo , iax2_tree , tvb
<S2SV_ModStart> , iax2_tree , tvb , <S2SV_ModStart> pinfo , iax2_tree , tvb
<S2SV_ModStart> * iax2_tree , tvbuff_t * tvb , <S2SV_ModStart> shortts ) { guint <S2SV_ModEnd> longts = shortts <S2SV_ModStart> / 1000 ; if ( pinfo -> abs_ts . secs - abs_secs > MAX_SECS_DIFF ) { proto_tree_add_expert ( iax2_tree , pinfo , & ei_iax_invalid_ts , tvb , 0 , 0 ) ; } else { <S2SV_ModStart> / 1000 ; } <S2SV_ModStart> , hf_iax2_absts , tvb <S2SV_ModEnd> , 0 , <S2SV_ModStart> , hf_iax2_lateness , tvb <S2SV_ModEnd> , 0 ,
<S2SV_ModStart> EXPFILL } } , { & ei_iax_invalid_ts , { "iax2.invalid_ts" , PI_PROTOCOL , PI_WARN , "Invalid<S2SV_blank>timestamp" , EXPFILL } }
<S2SV_ModStart> ; proto_item * ti ; proto_item * <S2SV_ModStart> ei_wsp_oversized_uintvar ) ; ti = <S2SV_ModStart> += count ; if ( capabilityLength > tvb_reported_length ( tvb ) ) { expert_add_info ( pinfo , ti , & ei_wsp_capability_length_invalid ) ; break ; }
<S2SV_ModStart> , { & ei_wsp_capability_length_invalid , { "wsp.capabilities.length.invalid" , PI_PROTOCOL , PI_WARN , "Invalid<S2SV_blank>capability<S2SV_blank>length" , EXPFILL } } , { &
<S2SV_ModStart> ; int chunk_size ; guint32 save_seq = 0 <S2SV_ModStart> lastseq >= seq && tp -> lastseq >= save_seq <S2SV_ModStart> , tp ) ; save_seq = tp -> lastseq + 1
<S2SV_ModStart> = g_strdup_printf ( "k12:<S2SV_blank>Data<S2SV_blank>record<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>short" <S2SV_ModEnd> , len ) <S2SV_ModStart> src_desc ) ; return <S2SV_ModStart> , buffer , ( guint ) len , k12 , err , err_info ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; gint len ; gboolean status <S2SV_ModStart> -> rand_read_buff ; status = <S2SV_ModStart> , buffer , ( guint ) len , k12 , err , err_info <S2SV_ModEnd> ) ; K12_DBG <S2SV_ModStart> ) ; return status <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gboolean <S2SV_ModEnd> process_packet_data ( struct <S2SV_ModStart> * buffer , guint record_len <S2SV_ModEnd> , k12_t * <S2SV_ModStart> k12_t * k12 , int * err , gchar * * err_info <S2SV_ModStart> k12_src_desc_t * src_desc <S2SV_ModEnd> ; type = <S2SV_ModStart> : K12_PACKET_FRAME ; if ( buffer_offset > record_len ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "k12:<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>offset<S2SV_blank>%u<S2SV_blank>><S2SV_blank>record<S2SV_blank>length<S2SV_blank>%u" , buffer_offset , record_len ) ; return FALSE ; } length = pntoh32 ( buffer + K12_RECORD_FRAME_LEN ) & 0x00001FFF ; if ( length > record_len - buffer_offset ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "k12:<S2SV_blank>Frame<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>><S2SV_blank>record<S2SV_blank>frame<S2SV_blank>data<S2SV_blank>%u" , length , record_len - buffer_offset ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS ; ts = pntoh64 ( buffer + K12_PACKET_TIMESTAMP ) ; phdr -> ts . secs = ( guint32 ) ( ( ts / 2000000 ) + 631152000 ) ; phdr -> ts . nsecs = ( guint32 ) ( ( ts % 2000000 ) * 500 ) ; phdr -> len = phdr -> caplen = length ; <S2SV_ModStart> ; extra_len = record_len <S2SV_ModEnd> - buffer_offset - <S2SV_ModStart> K12_PACKET_OFFSET_CID ) < record_len <S2SV_ModEnd> ) { phdr <S2SV_ModStart> = k12 ; return TRUE ;
<S2SV_ModStart> sig_Signature ) ) { <S2SV_ModStart> return WTAP_FILE_TYPE_SUBTYPE_NETSCALER_2_0 ; } <S2SV_ModStart> sig_Signature ) ) { <S2SV_ModStart> WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0 ; } }
<S2SV_ModStart> 0 ; return WTAP_ERR_UNWRITABLE_ENCAP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 0 ; return WTAP_ERR_UNWRITABLE_ENCAP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 0 ; return WTAP_ERR_UNWRITABLE_ENCAP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * err = WTAP_ERR_UNWRITABLE_REC_TYPE ; return FALSE ; } if ( nstrace -> newfile == TRUE ) { nstrace -> newfile = FALSE ; <S2SV_ModEnd> if ( wdh <S2SV_ModStart> * err = WTAP_ERR_UNWRITABLE_FILE_TYPE <S2SV_ModEnd> ; return FALSE <S2SV_ModStart> * err = WTAP_ERR_UNWRITABLE_FILE_TYPE <S2SV_ModEnd> ; return FALSE <S2SV_ModStart> * err = WTAP_ERR_UNWRITABLE_FILE_TYPE <S2SV_ModEnd> ; return FALSE <S2SV_ModStart> * err = WTAP_ERR_UNWRITABLE_FILE_TYPE <S2SV_ModEnd> ; return FALSE
<S2SV_ModStart> = 0 ; if ( wdh -> file_type_subtype == WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0 ) nstrace -> page_len = NSPR_PAGESIZE_TRACE ; else <S2SV_ModStart> = 0 ; nstrace -> newfile = TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> wtap_open_return_val <S2SV_ModEnd> nstrace_open ( wtap <S2SV_ModStart> nstrace_t * nstrace <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ) return WTAP_OPEN_NOT_MINE <S2SV_ModEnd> ; nstrace_buf = <S2SV_ModStart> ) ; return WTAP_OPEN_NOT_MINE <S2SV_ModEnd> ; } if <S2SV_ModStart> 1 ) { g_free ( nstrace_buf ) ; return WTAP_OPEN_ERROR ; } if ( ! wtap_read_bytes <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> fh , nstrace_buf , page_size , err , err_info ) ) { g_free ( nstrace_buf ) ; if ( <S2SV_ModEnd> * err != <S2SV_ModStart> WTAP_ERR_SHORT_READ ) return WTAP_OPEN_ERROR ; return WTAP_OPEN_NOT_MINE <S2SV_ModEnd> ; } switch <S2SV_ModStart> 1 ) { g_free ( nstrace -> pnstrace_buf ) ; g_free ( nstrace ) ; return WTAP_OPEN_ERROR ; } if ( ! wtap_read_bytes <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> fh , nstrace_buf , page_size , err , err_info ) ) { <S2SV_ModEnd> g_free ( nstrace <S2SV_ModStart> ) ; return WTAP_OPEN_ERROR <S2SV_ModEnd> ; } nstrace <S2SV_ModStart> 0 ; return WTAP_OPEN_MINE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> pnstrace_buf ; guint32 nstrace_buf_offset = nstrace -> nstrace_buf_offset ; guint32 nstrace_buflen = nstrace -> nstrace_buflen <S2SV_ModEnd> ; int bytes_read <S2SV_ModStart> ) sizeof ( ( ( nspr_header_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ) -> ph_RecordType <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver : PACKET_DESCRIBE ( phdr , FULL , full , ver , fp , HEADERVER ) <S2SV_ModEnd> ; # define <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTRX_V ## ver : PACKET_DESCRIBE ( phdr , PART , part , ver , pp , HEADERVER ) ; <S2SV_ModEnd> switch ( pletoh16 <S2SV_ModStart> case NSPR_ABSTIME_V10 : { nspr_pktracefull_v10_t * <S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> ; break ; } <S2SV_ModStart> case NSPR_RELTIME_V10 : { nspr_pktracefull_v10_t * <S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> ; break ; } <S2SV_ModStart> ; default : { nspr_pktracefull_v10_t * <S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> ; } } } <S2SV_ModStart> fh ) ) > 0 && ( ( guint32 ) <S2SV_ModEnd> bytes_read == nstrace_buflen
<S2SV_ModStart> -> pnstrace_buf ; guint32 <S2SV_ModEnd> nstrace_buf_offset = nstrace <S2SV_ModStart> -> nstrace_buf_offset ; guint32 <S2SV_ModEnd> nstrace_buflen = nstrace <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLNEWRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , PART , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _part , <S2SV_ModStart> , pktracepart_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTNEWRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , PART , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _part , <S2SV_ModStart> , pktracepart_v ## ver , HEADERVER <S2SV_ModEnd> ) ; GENERATE_CASE_FULL <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> fh ) ) > 0 && ( ( guint32 ) <S2SV_ModEnd> bytes_read == nstrace_buflen
<S2SV_ModStart> ; guint64 nsg_creltime <S2SV_ModEnd> ; gchar * <S2SV_ModStart> -> pnstrace_buf ; guint32 nstrace_buf_offset = nstrace -> nstrace_buf_offset ; guint32 <S2SV_ModEnd> nstrace_buflen = nstrace <S2SV_ModStart> ; int bytes_read = 0 <S2SV_ModStart> = NULL ; if ( nstrace_buflen == 0 ) { return FALSE ; } do { if ( ! nstrace_buf [ nstrace_buf_offset ] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE ) { nstrace_buf_offset = NSPR_PAGESIZE_TRACE ; } if ( file_eof ( wth -> fh ) && bytes_read > 0 && bytes_read <S2SV_ModEnd> < NSPR_PAGESIZE_TRACE ) <S2SV_ModStart> < NSPR_PAGESIZE_TRACE ) { memset ( & nstrace_buf [ bytes_read ] , 0 , NSPR_PAGESIZE_TRACE - bytes_read ) ; } while ( ( nstrace_buf_offset < NSPR_PAGESIZE_TRACE ) <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( hdp ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> { # define GENERATE_CASE_FULL_V30 <S2SV_ModEnd> ( phdr , <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLNEWRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER ) ; GENERATE_CASE_FULL_V30 <S2SV_ModEnd> ( & wth <S2SV_ModStart> ; # undef GENERATE_CASE_FULL_V30 <S2SV_ModEnd> case NSPR_ABSTIME_V20 : <S2SV_ModStart> fh ) ) > 0 && ( file_eof ( wth -> fh ) || ( guint32 ) <S2SV_ModEnd> bytes_read == nstrace_buflen
<S2SV_ModStart> nspr_hd_v10_t hdr ; <S2SV_ModEnd> guint record_length ; <S2SV_ModStart> int bytes_to_read ; <S2SV_ModEnd> * err = <S2SV_ModStart> return FALSE ; if ( ! wtap_read_bytes ( <S2SV_ModEnd> wth -> random_fh <S2SV_ModStart> wth -> random_fh , ( void * ) & hdr , sizeof hdr , err , err_info ) ) return FALSE ; record_length = nspr_getv10recordsize ( & hdr ) ; ws_buffer_assure_space ( buf , record_length ) ; pd = ws_buffer_start_ptr ( buf ) ; memcpy ( pd , ( void * ) & hdr , sizeof hdr <S2SV_ModStart> ; if ( record_length > <S2SV_ModEnd> sizeof hdr ) <S2SV_ModStart> hdr ) { bytes_to_read = ( unsigned int ) ( record_length - sizeof hdr ) ; if ( ! wtap_read_bytes <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> random_fh , pd + sizeof hdr , bytes_to_read , err , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> } # define <S2SV_ModStart> , type , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> ## type : PACKET_DESCRIBE ( phdr , FULL , full , type , fp , HEADERVER ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> , type , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> ## type : PACKET_DESCRIBE ( phdr , PART , part , type , pp , HEADERVER ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> nspr_hd_v20_t hdr ; <S2SV_ModEnd> guint record_length ; <S2SV_ModStart> int bytes_to_read ; guint64 nsg_creltime ; <S2SV_ModStart> return FALSE ; if ( ! wtap_read_bytes ( <S2SV_ModEnd> wth -> random_fh <S2SV_ModStart> wth -> random_fh , ( void * ) & hdr , 2 , err <S2SV_ModEnd> , err_info ) <S2SV_ModStart> , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> hdrlen = 2 <S2SV_ModStart> NSPR_V20RECORDSIZE_2BYTES ) { if ( ! wtap_read_bytes ( wth -> random_fh , <S2SV_ModEnd> ( void * <S2SV_ModStart> , 1 , err , err_info ) ) return FALSE ; hdrlen = 3 ; } record_length = nspr_getv20recordsize ( & hdr ) ; ws_buffer_assure_space ( buf , record_length ) ; pd = ws_buffer_start_ptr ( buf ) ; memcpy ( pd , ( void * ) & hdr , hdrlen ) ; if ( record_length > hdrlen ) { bytes_to_read = ( unsigned int ) ( record_length - hdrlen ) ; if ( ! wtap_read_bytes ( <S2SV_ModStart> wth -> random_fh , <S2SV_ModEnd> pd + hdrlen <S2SV_ModStart> , bytes_to_read , err <S2SV_ModEnd> , err_info ) <S2SV_ModStart> , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> FALSE ; } <S2SV_ModEnd> # define GENERATE_CASE_FULL <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLNEWRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , PART , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _part , <S2SV_ModStart> , pktracepart_v ## ver , HEADERVER <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEPARTTX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEPARTNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEPARTNEWRX_V ## ver <S2SV_ModEnd> : PACKET_DESCRIBE ( <S2SV_ModStart> ( phdr , PART , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _part , <S2SV_ModStart> , pktracepart_v ## ver , HEADERVER <S2SV_ModEnd> ) ; switch
<S2SV_ModStart> nspr_hd_v20_t hdr ; <S2SV_ModEnd> guint record_length ; <S2SV_ModStart> int bytes_to_read ; guint64 nsg_creltime ; <S2SV_ModStart> return FALSE ; if ( ! wtap_read_bytes ( wth -> random_fh , <S2SV_ModEnd> ( void * <S2SV_ModStart> , 2 , err <S2SV_ModEnd> , err_info ) <S2SV_ModStart> , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> hdrlen = 2 <S2SV_ModStart> NSPR_V20RECORDSIZE_2BYTES ) { if ( ! wtap_read_bytes ( wth -> random_fh , <S2SV_ModEnd> ( void * <S2SV_ModStart> , 1 , err <S2SV_ModEnd> , err_info ) <S2SV_ModStart> , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> return FALSE ; hdrlen = 3 ; } <S2SV_ModEnd> record_length = nspr_getv20recordsize <S2SV_ModStart> hdr ) ; ws_buffer_assure_space <S2SV_ModEnd> ( buf , <S2SV_ModStart> ; pd = ws_buffer_start_ptr <S2SV_ModEnd> ( buf ) <S2SV_ModStart> hdrlen ) ; if ( ! wtap_read_bytes ( wth -> random_fh , <S2SV_ModEnd> pd + hdrlen <S2SV_ModStart> , bytes_to_read , err <S2SV_ModEnd> , err_info ) <S2SV_ModStart> , err_info ) ) <S2SV_ModEnd> return FALSE ; <S2SV_ModStart> FALSE ; } ( phdr ) -> caplen = ( phdr ) -> len = record_length ; <S2SV_ModEnd> # define GENERATE_CASE_V30 <S2SV_ModStart> ( phdr , ver , HEADERVER <S2SV_ModEnd> ) case NSPR_PDPKTRACEFULLTX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLTXB_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLTXB_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLRX_V ## ver <S2SV_ModEnd> : case NSPR_PDPKTRACEFULLNEWRX_V <S2SV_ModStart> case NSPR_PDPKTRACEFULLNEWRX_V ## ver : PACKET_DESCRIBE ( phdr , FULL , ver <S2SV_ModEnd> , v ## <S2SV_ModStart> , v ## ver <S2SV_ModEnd> ## _full , <S2SV_ModStart> , pktracefull_v ## ver , HEADERVER ) <S2SV_ModEnd> ; switch (
<S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( pletoh16 ( & fp -> nsprRecordSize ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; }
<S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; } <S2SV_ModStart> nstrace_buf_offset ] ; if ( nspr_getv20recordsize ( ( nspr_hd_v20_t * ) fp20 ) == 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "nstrace:<S2SV_blank>zero<S2SV_blank>size<S2SV_blank>record<S2SV_blank>found" ) ; return FALSE ; }
<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
<S2SV_ModStart> long flags ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> -> node ) ; else ucounts = NULL <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
<S2SV_ModStart> ) != ulen || replay_esn -> bmp_len != up -> bmp_len
<S2SV_ModStart> & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4
<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats
<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
<S2SV_ModStart> sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&
<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL )
<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
<S2SV_ModStart> struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci
<S2SV_ModStart> keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> out ; } ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING "%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> ( & keyring_key <S2SV_ModStart> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; }
<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =
<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> loop , tmp , paddedlen <S2SV_ModStart> - EINVAL ; paddedlen <S2SV_ModEnd> = ( tmp <S2SV_ModStart> ~ 3 ; if ( paddedlen > toklen ) return - EINVAL ; princ -> name_parts [ loop ] = kmalloc ( tmp + 1 , GFP_KERNEL ) ; if ( ! princ -> name_parts [ loop ] ) return - ENOMEM ; memcpy ( princ -> name_parts [ loop ] , xdr , tmp ) ; princ -> name_parts [ loop ] [ tmp ] = 0 ; toklen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ; <S2SV_ModStart> - EINVAL ; paddedlen <S2SV_ModEnd> = ( tmp <S2SV_ModStart> ~ 3 ; if ( paddedlen > toklen ) return - EINVAL ; princ -> realm = kmalloc ( tmp + 1 , GFP_KERNEL ) ; if ( ! princ -> realm ) return - ENOMEM ; memcpy ( princ -> realm , xdr , tmp ) ; princ -> realm [ tmp ] = 0 ; toklen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ;
<S2SV_ModStart> _toklen , len , paddedlen <S2SV_ModStart> - EINVAL ; paddedlen <S2SV_ModEnd> = ( len <S2SV_ModStart> ~ 3 ; if ( paddedlen > toklen ) return - EINVAL ; td -> data_len = len ; if ( len > 0 ) { td -> data = kmemdup ( xdr , len , GFP_KERNEL ) ; if ( ! td -> data ) return - ENOMEM ; toklen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ;
<S2SV_ModStart> _toklen , len , paddedlen <S2SV_ModStart> - EINVAL ; paddedlen <S2SV_ModEnd> = ( len <S2SV_ModStart> ~ 3 ; if ( paddedlen > toklen ) return - EINVAL ; * _tktlen = len ; _debug ( "ticket<S2SV_blank>len<S2SV_blank>%u" , len ) ; if ( len > 0 ) { * _ticket = kmemdup ( xdr , len , GFP_KERNEL ) ; if ( ! * _ticket ) return - ENOMEM ; toklen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ;
<S2SV_ModStart> int len , paddedlen <S2SV_ModEnd> , loop , <S2SV_ModStart> -= 4 ; paddedlen <S2SV_ModEnd> = ( len <S2SV_ModStart> ; if ( paddedlen <S2SV_ModEnd> > datalen ) <S2SV_ModStart> goto not_xdr ; for ( ; loop < paddedlen <S2SV_ModEnd> ; loop ++ <S2SV_ModStart> , len , paddedlen <S2SV_ModEnd> , len , <S2SV_ModStart> ; datalen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ; <S2SV_ModStart> sec_ix ) ; paddedlen = ( toklen + 3 ) & ~ 3 ; <S2SV_ModStart> toklen > datalen || paddedlen > datalen <S2SV_ModStart> ; datalen -= paddedlen <S2SV_ModEnd> ; xdr += <S2SV_ModStart> ; xdr += paddedlen <S2SV_ModEnd> >> 2 ;
<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
<S2SV_ModStart> ( vcpu ) ; ctxt -> tf = ( ctxt -> eflags & X86_EFLAGS_TF ) != 0
<S2SV_ModStart> vcpu ) ; if ( unlikely ( rflags & X86_EFLAGS_TF ) ) kvm_vcpu_do_singlestep ( vcpu <S2SV_ModEnd> , & r
<S2SV_ModStart> r == EMULATE_DONE && ( ctxt -> tf || ( vcpu -> guest_debug & KVM_GUESTDBG_SINGLESTEP ) ) ) kvm_vcpu_do_singlestep ( vcpu <S2SV_ModEnd> , & r
<S2SV_ModStart> * trap ; struct name_snapshot <S2SV_ModEnd> old_name ; trap <S2SV_ModStart> goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> , d_is_dir ( <S2SV_ModStart> old_dentry ) ; release_dentry_name_snapshot ( & <S2SV_ModEnd> old_name ) ;
<S2SV_ModStart> old_dentry ) ; <S2SV_ModEnd> struct inode * <S2SV_ModStart> -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> old_dentry -> d_name <S2SV_ModStart> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return
<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> * exthdr ; unsigned int len ; <S2SV_ModStart> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> ; * nexthdr
<S2SV_ModStart> -> ipaddr , sizeof ( from -> ipaddr ) ) ; memset ( info + sizeof ( from -> ipaddr ) , 0 , addrlen - sizeof ( from -> ipaddr ) <S2SV_ModEnd> ) ; info
<S2SV_ModStart> -> a , sizeof ( laddr -> a ) ) ; memset ( info + sizeof ( laddr -> a ) , 0 , addrlen - sizeof ( laddr -> a ) <S2SV_ModEnd> ) ; info
<S2SV_ModStart> , sizeof ( prim -> ipaddr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> int off ; gint <S2SV_ModEnd> alen , aoff
<S2SV_ModStart> ei_wbxml_oversized_uintvar ) ; if ( len <= tvb_len ) { <S2SV_ModStart> + len ; } else { off = tvb_len ; } <S2SV_ModStart> ei_wbxml_oversized_uintvar ) ; if ( len <= tvb_len ) { <S2SV_ModStart> + len ; } else { off = tvb_len ; } <S2SV_ModStart> ) ; } if ( len <= tvb_len ) { <S2SV_ModStart> + len ; } else { off = tvb_len ; } <S2SV_ModStart> ei_wbxml_oversized_uintvar ) ; if ( len <= tvb_len ) { <S2SV_ModStart> + len ; } else { off = tvb_len ; } <S2SV_ModStart> ; } } if ( len <= tvb_len ) { <S2SV_ModStart> } else { off = tvb_len ; } } else { <S2SV_ModStart> ei_wbxml_oversized_uintvar ) ; if ( len <= tvb_len ) { <S2SV_ModStart> + idx ; } else { off = tvb_len ; }
<S2SV_ModStart> guchar * line ; const guchar * lineend <S2SV_ModStart> linelen ) ; lineend = ( line + linelen ) ; <S2SV_ModStart> ( line , lineend <S2SV_ModEnd> , & next_token <S2SV_ModStart> ( line , lineend <S2SV_ModEnd> , & next_token <S2SV_ModStart> ( uid_line , lineend <S2SV_ModEnd> , & uid_next_token <S2SV_ModStart> ( folder_line , lineend <S2SV_ModEnd> , & folder_next_token <S2SV_ModStart> ( folder_line , lineend <S2SV_ModEnd> , & folder_next_token <S2SV_ModStart> ( folder_line , lineend <S2SV_ModEnd> , & folder_next_token
<S2SV_ModStart> ; return offset + available <S2SV_ModStart> ; return offset + available
<S2SV_ModStart> ) key ; guint16 <S2SV_ModEnd> i ; for
<S2SV_ModStart> return 0 ; if ( ( offset + ( segment_count * 16 ) ) < offset || ( offset + ( segment_count * 16 ) ) > max_offset ) return 0 ; <S2SV_ModStart> * 16 ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> } if ( ( <S2SV_ModStart> >= UDVM_MEMORY_SIZE ) || ( n + handle_now >= UDVM_MEMORY_SIZE ) ) { <S2SV_ModStart> goto decompression_failure ; }
<S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ; <S2SV_ModStart> += 4 ; if ( j > tvb_reported_length_remaining ( tvb , offset ) ) break ;
<S2SV_ModStart> : addrValue_item = proto_tree_add_bytes_format_value <S2SV_ModEnd> ( addr_tree , <S2SV_ModStart> - mid_index , NULL , "%s" , bytes_to_str ( wmem_packet_scope ( ) , addr , head_length + midSize ) <S2SV_ModEnd> ) ; break
<S2SV_ModStart> , "Capability" ) ; if ( capaValueLen > tvb_len ) return <S2SV_ModStart> , wsp_capability_vals , "Invalid<S2SV_blank>capability" <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
<S2SV_ModStart> head -> iov_base ; if ( hdr > head -> iov_len ) return 0
<S2SV_ModStart> <S2SV_null> <S2SV_null> static struct tc_cookie * nla_memdup_cookie ( <S2SV_ModEnd> struct nlattr * <S2SV_ModStart> tb ) { struct tc_cookie * c <S2SV_ModEnd> = kzalloc ( <S2SV_ModStart> sizeof ( * c <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> if ( ! c ) return NULL ; c <S2SV_ModEnd> -> data = <S2SV_ModStart> if ( ! c <S2SV_ModEnd> -> data ) <S2SV_ModStart> { kfree ( c <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return NULL ; } c <S2SV_ModEnd> -> len = <S2SV_ModStart> ) ; return c <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> tc_action_ops * a_o ; struct tc_cookie * cookie = NULL <S2SV_ModStart> goto err_out ; if ( tb [ TCA_ACT_COOKIE ] ) { int cklen = nla_len ( tb [ TCA_ACT_COOKIE ] ) ; if ( cklen > TC_COOKIE_MAX_SIZE ) goto err_out ; cookie = nla_memdup_cookie ( tb ) ; if ( ! cookie ) { err = - ENOMEM ; goto err_out ; } } <S2SV_ModStart> ; if ( name == NULL && <S2SV_ModStart> ] ) { if ( a -> act_cookie ) { kfree ( a -> act_cookie -> data ) ; kfree ( a -> act_cookie ) ; } a -> act_cookie = cookie ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ; err_out : if ( cookie ) { kfree ( cookie -> data ) ; kfree ( cookie ) ; }
<S2SV_ModStart> hx ; u8 * buf <S2SV_ModEnd> ; int ret <S2SV_ModStart> = 0 ; u16 cpu_cs_register = <S2SV_ModEnd> cypress [ type <S2SV_ModStart> ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) { buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> usb_cypress_writemem ( udev <S2SV_ModStart> ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
<S2SV_ModStart> -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( <S2SV_ModStart> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> = 1 ; ret = <S2SV_ModEnd> dvb_usb_generic_rw ( d <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 50 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap , NULL <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap ,
<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex
<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen
<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( "%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen
<S2SV_ModStart> ; struct gs_host_config * hconf <S2SV_ModEnd> ; struct gs_device_config <S2SV_ModStart> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> ; rc = <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> hconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; kfree ( hconf ) ; <S2SV_ModStart> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> dconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> icount + 1 <S2SV_ModStart> GS_MAX_INTF ) ; kfree ( dconf ) ; <S2SV_ModStart> ! dev ) { kfree ( dconf ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> , intf , <S2SV_ModEnd> dconf ) ; <S2SV_ModStart> ; kfree ( dconf ) ; kfree ( <S2SV_ModStart> dev ; } kfree ( dconf ) ;
<S2SV_ModStart> [ 1 ] ; void * data ; int ret <S2SV_ModStart> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> ( sg , data <S2SV_ModEnd> , count ) <S2SV_ModStart> count ) ; ret = <S2SV_ModEnd> __send_to_port ( port <S2SV_ModStart> , count , data <S2SV_ModEnd> , false ) <S2SV_ModStart> false ) ; kfree ( data ) ; return ret ;
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> u16 size , const <S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> "Checking<S2SV_blank>memory<S2SV_blank>size\\n" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> fail ; } mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; cp2112_gpio_set <S2SV_ModStart> ; fail : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; buf <S2SV_ModStart> ret ) ; mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; return ret < <S2SV_ModEnd> 0 ? ret
<S2SV_ModStart> goto out_release ; if ( sk -> sk_state == DCCP_CLOSED ) { rc = - ENOTCONN ; goto out_discard ; }
<S2SV_ModStart> sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; <S2SV_ModStart> ( sk ) ; ccid_hc_rx_delete ( dp -> dccps_hc_rx_ccid , sk ) ; ccid_hc_tx_delete ( dp -> dccps_hc_tx_ccid , sk ) ; dp -> dccps_hc_rx_ccid = NULL ; dp -> dccps_hc_tx_ccid = NULL
<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
<S2SV_ModStart> rq_flags ) ) current_restore_flags ( <S2SV_ModEnd> pflags , PF_LESS_THROTTLE
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list
<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list
<S2SV_ModStart> ; print_bpf_insn ( env ,
<S2SV_ModStart> void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , <S2SV_ModEnd> insn -> dst_reg <S2SV_ModStart> -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ;
<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
<S2SV_ModStart> ; if ( ( pinfo -> dst . type != AT_IPv4 ) ||
<S2SV_ModStart> >= 500 || max_interval == 0 ||
<S2SV_ModStart> , PI_WARN , "Parameter<S2SV_blank>mismatch" <S2SV_ModEnd> , EXPFILL }
<S2SV_ModStart> 1 ; int pointers_count = 0 <S2SV_ModEnd> ; int component_len <S2SV_ModStart> break ; } <S2SV_ModEnd> switch ( component_len <S2SV_ModStart> -- ; offset <S2SV_ModEnd> ++ ; } <S2SV_ModStart> offset ++ ; pointers_count <S2SV_ModEnd> ++ ; if <S2SV_ModStart> } if ( indir_offset == offset + 2 || pointers_count > MAXDNAME / 4 <S2SV_ModEnd> ) { *
<S2SV_ModStart> ) ) { j = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , j , "Number<S2SV_blank>of<S2SV_blank>directories:<S2SV_blank>%u" , j ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> + len ; j2 = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , j2 , "Directory<S2SV_blank>#%d<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%u" , i + 1 , j2 ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i2 < j2 <S2SV_ModStart> i2 < j2 ; i2 ++ <S2SV_ModStart> + len ; j3 = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>attributes:<S2SV_blank>%d" , i + 1 , i2 + 1 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i3 < j3 <S2SV_ModStart> i3 < j3 ; i3 ++ ) { if ( check_slsk_format ( uncompr_tvb , uncompr_tvb_offset , "ii*" ) ) { proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>type:<S2SV_blank>%s<S2SV_blank>(Code:<S2SV_blank>%d)" , i + 1 , i2 + 1 , i3 + 1 , val_to_str_const ( tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , slsk_attr_type , "Unknown" ) , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>value:<S2SV_blank>%d" , i + 1 , i2 + 1 , i3 + 1 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; } else { break ; } } } else { break ; } } } else { break ; } <S2SV_ModEnd> } } } <S2SV_ModStart> += 4 ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> + len ; j2 = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , j , "File<S2SV_blank>#%d<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>attributes:<S2SV_blank>%d" , i + 1 , j ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i2 < j2 <S2SV_ModStart> i2 < j2 ; i2 ++ ) { if ( check_slsk_format ( uncompr_tvb , uncompr_tvb_offset , "ii*" ) ) { proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>type:<S2SV_blank>%s<S2SV_blank>(Code:<S2SV_blank>%d)" , i + 1 , i2 + 1 , val_to_str_const ( tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , slsk_attr_type , "Unknown" ) , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>value:<S2SV_blank>%d" , i + 1 , i2 + 1 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; } else { break ; } } } else { break ; } <S2SV_ModEnd> } proto_tree_add_uint_format ( <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_status_code , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Status<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%s<S2SV_blank>(Code:<S2SV_blank>%d)" , i + 1 , val_to_str_const ( tvb_get_letohl ( tvb , offset ) , slsk_status_codes , "Unknown" ) , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } if <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "iiiii*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Average<S2SV_blank>Speed<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Downloadnum<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Something<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Files<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Folders<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } if <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Slots<S2SV_blank>full<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } } <S2SV_ModStart> += 4 ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> + len ; j2 = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , j2 , "Directory<S2SV_blank>#%d<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>files:<S2SV_blank>%d" , i + 1 , j2 ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i2 < j2 <S2SV_ModStart> i2 < j2 ; i2 ++ <S2SV_ModStart> + len ; j3 = tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , j3 , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>attributes:<S2SV_blank>%d" , i + 1 , i2 + 1 , j3 ) ; uncompr_tvb_offset += 4 ; for ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i3 < j3 <S2SV_ModStart> i3 < j3 ; i3 ++ ) { if ( check_slsk_format ( uncompr_tvb , uncompr_tvb_offset , "ii*" ) ) { proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>type:<S2SV_blank>%s<S2SV_blank>(Code:<S2SV_blank>%d)" , i + 1 , i2 + 1 , i3 + 1 , val_to_str_const ( tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , slsk_attr_type , "Unknown" ) , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; proto_tree_add_uint_format ( slsk_compr_packet_tree , hf_slsk_integer , uncompr_tvb , uncompr_tvb_offset , 4 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) , "Dir<S2SV_blank>#%d<S2SV_blank>File<S2SV_blank>#%d<S2SV_blank>Attr<S2SV_blank>#%d<S2SV_blank>value:<S2SV_blank>%d" , i + 1 , i2 + 1 , i3 + 1 , tvb_get_letohl ( uncompr_tvb , uncompr_tvb_offset ) ) ; uncompr_tvb_offset += 4 ; } else { break ; } } } else { break ; } } } else { break ; } <S2SV_ModEnd> } } } <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> 4 ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> 4 ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } } if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint ( slsk_tree , hf_slsk_number_of_rooms , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; for ( i <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_string_length , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Users<S2SV_blank>in<S2SV_blank>Room<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } } <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } } if ( check_slsk_format ( tvb , offset , "i*" ) ) { i = 0 ; j = tvb_get_letohl ( tvb , offset ) ; proto_tree_add_uint ( slsk_tree , hf_slsk_users_in_room , tvb , offset , 4 , j ) ; offset += 4 ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_status_code , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Status<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%s<S2SV_blank>(Code:<S2SV_blank>%d)" , i + 1 , val_to_str_const ( tvb_get_letohl ( tvb , offset ) , slsk_status_codes , "Unknown" ) , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } if <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "iiiii*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Average<S2SV_blank>Speed<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Downloadnum<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Something<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Files<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Folders<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } if <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ ) { if ( check_slsk_format ( tvb , offset , "i*" ) ) { proto_tree_add_uint_format ( slsk_tree , hf_slsk_integer , tvb , offset , 4 , tvb_get_letohl ( tvb , offset ) , "Slots<S2SV_blank>full<S2SV_blank>of<S2SV_blank>User<S2SV_blank>#%d:<S2SV_blank>%d" , i + 1 , tvb_get_letohl ( tvb , offset ) ) ; offset += 4 ; } else { break ; } <S2SV_ModEnd> } } } <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> 4 ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> += 4 ; proto_tree_add_item_ret_uint ( slsk_tree , hf_slsk_number_of_users , tvb , offset , 4 , ENC_LITTLE_ENDIAN , & j <S2SV_ModEnd> ) ; offset <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> 4 ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> 4 ; } else { break ; } <S2SV_ModEnd> } } break <S2SV_ModStart> ) break ; for ( i = 0 ; <S2SV_ModEnd> i < j <S2SV_ModStart> i < j ; i ++ <S2SV_ModStart> len ; } else { break ; } <S2SV_ModEnd> } } break
<S2SV_ModStart> ( ( session != NULL ) && ( oid
<S2SV_ModStart> ( ( session != NULL ) && ( oid
<S2SV_ModStart> self ) { guint32 size = self -> len ; ( void ) OALMarshal_UncompressValue ( DOFOBJECTID_MAX_CLASS_SIZE , & size , <S2SV_ModEnd> self -> oid <S2SV_ModStart> oid ) ; return size ;
<S2SV_ModStart> break ; } if ( size > * bufLength ) return 0 ;
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> > pdu_len ) || ( pdv_len + 4 < pdv_len ) )
<S2SV_ModStart> ; if ( ( gint ) dataLength < ( payloadOffset - db0Offset ) ) { expert_add_info_format ( pinfo , opensafety_item , & ei_payload_length_not_positive , "Calculation<S2SV_blank>for<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>yielded<S2SV_blank>non-positive<S2SV_blank>result<S2SV_blank>[%d]" , ( gint ) payloadSize ) ; return ; } if (
<S2SV_ModStart> * vendor_class_id_p = tvb_get_string_enc ( wmem_packet_scope ( ) , <S2SV_ModEnd> tvb , voff <S2SV_ModStart> consumed - 2 , ENC_ASCII
<S2SV_ModStart> len = 0 , current_len <S2SV_ModStart> + 1 ; current_len = len ; <S2SV_ModStart> , next_offset ) ; if ( current_len > len ) return - 1 <S2SV_ModStart> case 'b' : current_len = len ; <S2SV_ModStart> + len ) ; if ( current_len > len ) return - 1
<S2SV_ModStart> ; guint i ; if ( ( pinfo -> dst . type != AT_IPv6 ) || ( pinfo -> src . type != AT_IPv6 ) ) return
<S2SV_ModStart> ; if ( ( pinfo -> dst . type != AT_IPv4 ) ||
<S2SV_ModStart> ; uint32_t backup_handle = 0 <S2SV_ModStart> ret == 0 ) { if ( <S2SV_ModEnd> res -> backup <S2SV_ModStart> goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
<S2SV_ModStart> * * ar , guint recursion_count <S2SV_ModStart> = 0 ; if ( ++ recursion_count >= PN_IO_MAX_RECURSION_DEPTH ) { proto_tree_add_expert ( tree , pinfo , & ei_pn_io_max_recursion_depth_reached , tvb , 0 , 0 ) ; return tvb_captured_length ( tvb ) ; } <S2SV_ModStart> drep , ar , recursion_count ++
<S2SV_ModStart> = NULL ; guint recursion_count = 0 ; <S2SV_ModStart> , & ar , recursion_count
<S2SV_ModStart> } } , { & ei_pn_io_max_recursion_depth_reached , { "pn_io.max_recursion_depth_reached" , PI_PROTOCOL , PI_WARN , "Maximum<S2SV_blank>allowed<S2SV_blank>recursion<S2SV_blank>depth<S2SV_blank>reached<S2SV_blank>-<S2SV_blank>stopping<S2SV_blank>dissection" , EXPFILL } }
<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
<S2SV_ModStart> BN_CTX * ctx = NULL <S2SV_ModStart> = NULL ; if ( BN_num_bits ( dh -> p ) > OPENSSL_DH_MAX_MODULUS_BITS ) { DHerr ( DH_F_GENERATE_KEY , DH_R_MODULUS_TOO_LARGE ) ; return 0 ; }
<S2SV_ModStart> BN_CTX * ctx = NULL <S2SV_ModStart> = NULL ; if ( BN_num_bits ( dh -> p ) > OPENSSL_DH_MAX_MODULUS_BITS ) { DHerr ( DH_F_GENERATE_KEY , DH_R_MODULUS_TOO_LARGE ) ; return 0 ; }
<S2SV_ModStart> ; BN_set_flags ( rsa -> p , BN_FLG_CONSTTIME ) ; BN_set_flags ( rsa -> q , BN_FLG_CONSTTIME ) ; BN_set_flags (
<S2SV_ModStart> r ; } BN_set_flags ( prime , BN_FLG_CONSTTIME ) ;
<S2SV_ModStart> ; BN_set_flags ( rsa -> p , BN_FLG_CONSTTIME ) ; BN_set_flags ( rsa -> q , BN_FLG_CONSTTIME ) ; BN_set_flags (
<S2SV_ModStart> opt , ctx , 0
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> = 0 ; if ( ++ depth > ASN1_MAX_CONSTRUCTED_NEST ) { ASN1err ( ASN1_F_ASN1_ITEM_EMBED_D2I , ASN1_R_NESTED_TOO_DEEP ) ; goto err ; } <S2SV_ModStart> opt , ctx , depth <S2SV_ModStart> 1 , ctx , depth <S2SV_ModStart> isopt , ctx , depth
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> opt , ctx , depth <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> opt , ctx , 0
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> = 0 ; if ( ++ depth > ASN1_MAX_CONSTRUCTED_NEST ) { ASN1err ( ASN1_F_ASN1_ITEM_EMBED_D2I , ASN1_R_NESTED_TOO_DEEP ) ; goto err ; } <S2SV_ModStart> opt , ctx , depth <S2SV_ModStart> 1 , ctx , depth <S2SV_ModStart> isopt , ctx , depth
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> opt , ctx , depth <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> ctx ) { return asn1_item_ex_d2i <S2SV_ModEnd> ( pval , <S2SV_ModStart> opt , ctx <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , & c , 0
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> ASN1_TLC * ctx , int depth <S2SV_ModStart> if ( ! asn1_item_ex_d2i <S2SV_ModEnd> ( & skfield <S2SV_ModStart> 0 , ctx , depth <S2SV_ModStart> { ret = asn1_item_ex_d2i ( val , & p , len , <S2SV_ModEnd> ASN1_ITEM_ptr ( tt <S2SV_ModStart> opt , ctx , depth <S2SV_ModStart> { ret = asn1_item_ex_d2i <S2SV_ModEnd> ( val , <S2SV_ModStart> opt , ctx , depth
<S2SV_ModStart> atomic , hop , NULL
<S2SV_ModStart> 1 , NULL , NULL
<S2SV_ModStart> ) ) { if ( atomic_read ( & client -> pool -> counter ) ) return - EBUSY ;
<S2SV_ModStart> ; if ( unlikely ( mm_is_oom_victim ( mm ) ) ) { mutex_lock ( & oom_lock ) ; __oom_reap_task_mm ( mm ) ; mutex_unlock ( & oom_lock ) ; set_bit ( MMF_OOM_SKIP , & mm -> flags ) ; down_write ( & mm -> mmap_sem ) ; up_write ( & mm -> mmap_sem ) ; } if ( <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> free_pgtables ( &
<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> IPT_F_GOTO ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> = e ; }
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> tmp = *
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
<S2SV_ModStart> -> server -> <S2SV_ModEnd> ops -> generate_signingkey <S2SV_ModStart> ( ses ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } <S2SV_ModStart> GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ;
<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
<S2SV_ModStart> ctxt -> exception , true
<S2SV_ModStart> ctxt -> exception , true
<S2SV_ModStart> ctxt -> exception , false
<S2SV_ModStart> ctxt -> exception , false
<S2SV_ModStart> x86_exception * exception , bool system <S2SV_ModStart> ctxt ) ; u32 access = 0 ; if ( ! system && kvm_x86_ops -> get_cpl ( vcpu ) == 3 ) access |= PFERR_USER_MASK ; <S2SV_ModStart> , vcpu , access <S2SV_ModEnd> , exception )
<S2SV_ModStart> x86_exception * exception , bool system <S2SV_ModStart> ctxt ) ; u32 access = PFERR_WRITE_MASK ; if ( ! system && kvm_x86_ops -> get_cpl ( vcpu ) == 3 ) access |= PFERR_USER_MASK ; <S2SV_ModStart> , vcpu , access <S2SV_ModEnd> , exception )
<S2SV_ModStart> && kvm_read_guest_virt ( vcpu <S2SV_ModEnd> , kvm_get_linear_rip (
<S2SV_ModStart> ; if ( depth < 0 || depth > EXT4_MAX_EXTENT_DEPTH ) { EXT4_ERROR_INODE ( inode , "inode<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>extent<S2SV_blank>depth:<S2SV_blank>%d" , depth ) ; ret = - EFSCORRUPTED ; goto err ; } if (
<S2SV_ModStart> ; if ( <S2SV_ModEnd> BHDR ( bh <S2SV_ModStart> ) goto errout ; if ( buffer_verified ( bh ) ) return 0
<S2SV_ModStart> ext4_xattr_entry * last , * next <S2SV_ModStart> ; last = next ) { next = <S2SV_ModStart> ( last ) ; if ( ( void * ) next >= s -> end ) { EXT4_ERROR_INODE ( inode , "corrupted<S2SV_blank>xattr<S2SV_blank>entries" ) ; ret = - EFSCORRUPTED ; goto out ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ) ) { if ( ( last -> e_name_len == 4 ) && ( last -> e_name_index == EXT4_XATTR_INDEX_SYSTEM ) && ! memcmp ( last -> e_name , "data" , 4 ) ) continue ;
<S2SV_ModStart> EXT4_MIN_INLINE_DATA_SIZE ) ; memset ( ei -> i_data , 0 , EXT4_MIN_INLINE_DATA_SIZE ) ;
<S2SV_ModStart> ENOSPC ) { ext4_journal_stop ( handle ) ; <S2SV_ModStart> flags , fsdata <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( error ) <S2SV_ModEnd> return error ; <S2SV_ModStart> return error ; <S2SV_ModEnd> header = IHDR
<S2SV_ModStart> bh ) ; if ( jh -> b_transaction == transaction && jh -> b_jlist != BJ_Metadata ) pr_err ( "JBD2:<S2SV_blank>assertion<S2SV_blank>failure:<S2SV_blank>h_type=%u<S2SV_blank>" "h_line_no=%u<S2SV_blank>block_no=%llu<S2SV_blank>jlist=%u\\n" , handle -> h_type , handle -> h_line_no , ( unsigned long long ) bh -> b_blocknr , jh -> b_jlist ) ; <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( handle <S2SV_ModStart> out_unlock_bh ; } jh -> b_modified = 1 ;
<S2SV_ModStart> ; if ( ( ino == EXT4_ROOT_INO ) && ( raw_inode -> i_links_count == 0 ) ) { EXT4_ERROR_INODE ( inode , "root<S2SV_blank>inode<S2SV_blank>unallocated" ) ; ret = - EFSCORRUPTED ; goto bad_inode ; } if (
<S2SV_ModStart> desc ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct <S2SV_ModStart> desc ) ; if ( ( bitmap_blk <= le32_to_cpu ( sbi -> s_es -> s_first_data_block ) ) || ( bitmap_blk >= ext4_blocks_count ( sbi -> s_es ) ) ) { ext4_error ( sb , "Invalid<S2SV_blank>block<S2SV_blank>bitmap<S2SV_blank>block<S2SV_blank>%llu<S2SV_blank>in<S2SV_blank>" "block_group<S2SV_blank>%u" , bitmap_blk , block_group ) ; return ERR_PTR ( - EFSCORRUPTED ) ; }
<S2SV_ModStart> ; if ( offset < 0 || EXT4_B2C ( sbi , offset ) >= sb -> s_blocksize || <S2SV_ModStart> ; if ( offset < 0 || EXT4_B2C ( sbi , offset ) >= sb -> s_blocksize || <S2SV_ModStart> - group_first_block ; if ( offset < 0 || EXT4_B2C ( sbi , offset ) >= sb -> s_blocksize || EXT4_B2C ( sbi , offset + sbi -> s_itb_per_group ) >= sb -> s_blocksize ) return blk ;
<S2SV_ModStart> desc ; struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct <S2SV_ModStart> desc ) ; if ( ( bitmap_blk <= le32_to_cpu ( sbi -> s_es -> s_first_data_block ) ) || ( bitmap_blk >= ext4_blocks_count ( sbi -> s_es ) ) ) { ext4_error ( sb , "Invalid<S2SV_blank>inode<S2SV_blank>bitmap<S2SV_blank>blk<S2SV_blank>%llu<S2SV_blank>in<S2SV_blank>" "block_group<S2SV_blank>%u" , bitmap_blk , block_group ) ; return ERR_PTR ( - EFSCORRUPTED ) ; }
<S2SV_ModStart> cantfind_ext4 ; } <S2SV_ModEnd> sbi -> s_chksum_driver <S2SV_ModStart> goto failed_mount ; <S2SV_ModEnd> } if (
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> ) ) { u32 size = le32_to_cpu <S2SV_ModEnd> ( entry -> <S2SV_ModStart> entry -> e_value_size ) ; if ( size > INT_MAX ) return - EFSCORRUPTED ; if ( size <S2SV_ModStart> e_value_offs ) ; <S2SV_ModEnd> void * value
<S2SV_ModStart> ; if ( crng_ready ( ) <S2SV_ModEnd> && time_after (
<S2SV_ModStart> ; if ( unlikely ( crng_init == 0 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ; if ( unlikely ( crng_init == 0 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ; if ( crng_init != 0 <S2SV_ModEnd> ) { spin_unlock_irqrestore
<S2SV_ModStart> ( ) ; numa_crng_init ( ) ;
<S2SV_ModStart> void ) { <S2SV_ModEnd> init_std_data ( & <S2SV_ModStart> primary_crng ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> crng_ready ( ) && size ) crng_slow_load <S2SV_ModEnd> ( buf , <S2SV_ModStart> size ) ; <S2SV_ModEnd> trace_add_device_randomness ( size
<S2SV_ModStart> return NULL ; memset ( & node -> msg , 0 , sizeof node -> msg ) ;
<S2SV_ModStart> , this_len , FOLL_ANON <S2SV_ModEnd> ) ; if
<S2SV_ModStart> VM_IO | VM_PFNMAP ) ) return - EFAULT ; if ( gup_flags & FOLL_ANON && ! vma_is_anonymous ( vma
<S2SV_ModStart> goto err ; cpu = cpumask_first ( mask ) ;
<S2SV_ModStart> 2 ) ; col_add_str <S2SV_ModEnd> ( pinfo ->
<S2SV_ModStart> , offset , pinfo ,
<S2SV_ModStart> int offset , packet_info * pinfo , <S2SV_ModStart> pkt_seq_num , pkt_count , delta_index = 0 <S2SV_ModStart> RTCP_HEADER_LENGTH ; int <S2SV_ModEnd> padding_length = offset <S2SV_ModStart> ) ) { guint <S2SV_ModEnd> length = chunk <S2SV_ModStart> length <= 0 || pkt_count - delta_index < length ) { proto_tree_add_expert ( pkt_chunk_tree , pinfo , & ei_rtcp_rtpfb_transportcc_bad , tvb , offset , 2 ) <S2SV_ModEnd> ; offset += <S2SV_ModStart> ; for ( guint <S2SV_ModEnd> j = 0 <S2SV_ModStart> ; for ( guint <S2SV_ModEnd> j = 0 <S2SV_ModStart> } else { if ( delta_index >= pkt_count ) { proto_tree_add_expert ( pkt_chunk_tree , pinfo , & ei_rtcp_rtpfb_transportcc_bad , tvb , offset , 2 ) ; offset += 2 ; return offset ; } <S2SV_ModStart> case 1 : if ( delta_index >= pkt_count ) { proto_tree_add_expert ( pkt_chunk_tree , pinfo , & ei_rtcp_rtpfb_transportcc_bad , tvb , offset , 2 ) ; offset += 2 ; return offset ; } <S2SV_ModStart> case 2 : if ( delta_index >= pkt_count ) { proto_tree_add_expert ( pkt_chunk_tree , pinfo , & ei_rtcp_rtpfb_transportcc_bad , tvb , offset , 2 ) ; offset += 2 ; return offset ; }
<S2SV_ModStart> } } , { & ei_rtcp_rtpfb_transportcc_bad , { "rtcp.rtpfb.transportcc_bad" , PI_MALFORMED , PI_WARN , "Too<S2SV_blank>many<S2SV_blank>packet<S2SV_blank>chunks<S2SV_blank>(more<S2SV_blank>than<S2SV_blank>packet<S2SV_blank>status<S2SV_blank>count)" , EXPFILL } } ,
<S2SV_ModStart> type == T_SRV && name [ 0 ]
<S2SV_ModStart> initialized ) ; if ( length < 0 ) return FALSE ;
<S2SV_ModStart> , int initial_codeset , q931_packet_info * q931_pi <S2SV_ModStart> | Q931_IE_CAUSE : dissect_q931_cause_ie_with_info <S2SV_ModEnd> ( tvb , <S2SV_ModStart> dummy , q931_info_element_vals0 , q931_pi <S2SV_ModStart> hf_q931_connected_number , e164_info , q931_pi <S2SV_ModStart> hf_q931_calling_party_number , e164_info , q931_pi <S2SV_ModStart> hf_q931_called_party_number , e164_info , q931_pi <S2SV_ModStart> hf_q931_redirecting_number , e164_info , q931_pi <S2SV_ModStart> locked_codeset ; } <S2SV_ModEnd> tap_queue_packet ( q931_tap <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ie_vals ) { dissect_q931_cause_ie_with_info <S2SV_ModEnd> ( tvb , <S2SV_ModStart> cause_value , ie_vals , NULL ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 0 , 0 , NULL
<S2SV_ModStart> 0 , 7 , NULL
<S2SV_ModStart> , e164_info_t e164_info , q931_packet_info * q931_pi <S2SV_ModStart> == CALLING_PARTY_NUMBER && q931_pi <S2SV_ModEnd> ) q931_pi -> <S2SV_ModStart> == CALLED_PARTY_NUMBER && q931_pi <S2SV_ModEnd> ) q931_pi ->
<S2SV_ModStart> = NULL ; q931_packet_info * q931_pi = NULL ; q931_pi = <S2SV_ModEnd> wmem_new ( wmem_packet_scope <S2SV_ModStart> ( q931_pi ) <S2SV_ModEnd> ; col_set_str ( <S2SV_ModStart> offset ) ; q931_pi <S2SV_ModEnd> -> message_type = <S2SV_ModStart> = message_type ; <S2SV_ModEnd> col_add_str ( pinfo <S2SV_ModStart> offset , 0 , q931_pi <S2SV_ModStart> offset , 0 , q931_pi <S2SV_ModStart> 0 , 0 , q931_pi
<S2SV_ModStart> { field_info * fi ; if ( ! pi ) return - 1 ;
<S2SV_ModStart> ) , ia5_string_len + 1
<S2SV_ModStart> DOT11DECRYPT_DEBUG_TRACE_START ( "Dot11DecryptScanForKeys" ) ; DISSECTOR_ASSERT ( tot_len >= mac_header_len + DOT11DECRYPT_CRYPTED_DATA_MINLEN ) ; DISSECTOR_ASSERT ( tot_len <= DOT11DECRYPT_MAX_CAPLEN <S2SV_ModStart> status != 0 && status != 85 <S2SV_ModStart> ) ) { guint8 element_id = data [ offset ] ; guint8 length = data [ offset + 1 ] ; guint min_length = length ; switch ( element_id ) { case 48 : <S2SV_ModEnd> offset_rsne = offset <S2SV_ModStart> = offset ; min_length = 1 ; break ; case 55 : <S2SV_ModEnd> offset_fte = offset <S2SV_ModStart> = offset ; min_length = 2 + 16 + 32 + 32 ; break ; case 56 : <S2SV_ModEnd> offset_timeout = offset <S2SV_ModStart> = offset ; min_length = 1 + 4 ; break ; case 101 : <S2SV_ModEnd> offset_link = offset <S2SV_ModStart> = offset ; min_length = 6 + 6 + 6 ; break ; } if ( length < min_length || <S2SV_ModEnd> tot_len < offset <S2SV_ModStart> < offset + 2 + length <S2SV_ModEnd> ) { return <S2SV_ModStart> } offset += 2 + length <S2SV_ModEnd> ; } if
<S2SV_ModStart> ; line = tvb_get_string_enc <S2SV_ModEnd> ( wmem_packet_scope ( <S2SV_ModStart> offset , linelen , ENC_ASCII <S2SV_ModEnd> ) ; line_tree
<S2SV_ModStart> not_found ) { if ( is . s . here -> e_value_inum ) { EXT4_ERROR_INODE ( inode , "inline<S2SV_blank>data<S2SV_blank>xattr<S2SV_blank>refers<S2SV_blank>" "to<S2SV_blank>an<S2SV_blank>external<S2SV_blank>xattr<S2SV_blank>inode" ) ; error = - EFSCORRUPTED ; goto out ; }
<S2SV_ModStart> } else { ret = <S2SV_ModStart> , ei ) ; if ( ret ) goto bad_inode
<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> ext4_iget_extra_inode ( struct <S2SV_ModStart> EXT4_STATE_XATTR ) ; return <S2SV_ModStart> = 0 ; return 0 ;
<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> filp ) { __sock_release <S2SV_ModEnd> ( SOCKET_I ( <S2SV_ModStart> ( inode ) , inode
<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; if ( sock -> sk ) <S2SV_ModStart> -> ia_uid ; else err = - ENOENT ;
<S2SV_ModStart> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> copy_from_user ( buf + sizeof ( hdr ) <S2SV_ModStart> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;
<S2SV_ModStart> ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> kc -> timer_forward
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr <S2SV_ModStart> info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer
<S2SV_ModStart> vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
<S2SV_ModStart> vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
<S2SV_ModStart> error ) { if ( bp && ( <S2SV_ModEnd> xfs_da_shrink_inode ( args <S2SV_ModStart> , bp ) != 0 ) <S2SV_ModEnd> ) goto out
<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;
<S2SV_ModStart> header_field_info * hfinfo ; gint item_length ; PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ; get_hfi_length ( hfinfo , tvb , start , & length , & item_length , ENC_NA ) ; if ( item_length != 0 ) test_length ( hfinfo , tvb , start , item_length , ENC_NA )
<S2SV_ModStart> is_little_endian = TRUE ; tvb_ensure_bytes_exist ( tvb , offset , vl_max )
<S2SV_ModStart> ENC_BIG_ENDIAN ) ; if ( aoff + tlen > path_attr_len - i ) { proto_tree_add_expert_format ( subtree2 , pinfo , & ei_bgp_length_invalid , tvb , o + i + aoff , tlen , "Path<S2SV_blank>attribute<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid:<S2SV_blank>%u<S2SV_blank>byte%s" , tlen , plurality ( tlen , "" , "s" ) ) ; return ; }
<S2SV_ModStart> tvb , len <S2SV_ModEnd> , o +
<S2SV_ModStart> } if ( tmp_length > ( guint32 ) G_MAXINT32 ) tmp_length = ( guint32 ) G_MAXINT32 ; if (
<S2SV_ModStart> = 0 ; guint32 <S2SV_ModEnd> tuple_length = 0 <S2SV_ModStart> proto_item * edp_ti <S2SV_ModEnd> ; proto_tree * <S2SV_ModStart> ) ) { <S2SV_ModEnd> edp_tuples_leaf_tree = proto_tree_add_subtree_format <S2SV_ModStart> , offset , 4 <S2SV_ModEnd> , ett_ismp_edp_tuples_leaf , <S2SV_ModStart> += 2 ; proto_tree_add_item_ret_uint <S2SV_ModEnd> ( edp_tuples_leaf_tree , <S2SV_ModStart> 2 , ENC_BIG_ENDIAN , & tuple_length ) ; if ( tuple_length < 4 ) { proto_tree_add_expert ( edp_tree , pinfo , & ei_ismp_malformed , tvb , offset , 2 ) ; return ; } <S2SV_ModEnd> offset += 2 <S2SV_ModStart> += 2 ; proto_item_set_len ( edp_tuples_leaf_tree , tuple_length ) ; tuple_length -= 4 ; if ( ( guint ) <S2SV_ModEnd> tvb_reported_length_remaining ( tvb <S2SV_ModStart> case EDP_TUPLE_HOLD : <S2SV_ModEnd> proto_tree_add_item ( edp_tuples_leaf_tree <S2SV_ModStart> , offset , tuple_length , ENC_BIG_ENDIAN <S2SV_ModEnd> ) ; break <S2SV_ModStart> case EDP_TUPLE_IPX_ADDR : if ( tuple_length != 4 + 6 ) { proto_tree_add_expert ( edp_tree , pinfo , & ei_ismp_malformed , tvb , offset , tuple_length ) ; return ; } <S2SV_ModStart> offset ) , tvb_get_ptr ( <S2SV_ModEnd> tvb , offset <S2SV_ModStart> tuple_length - 4 <S2SV_ModEnd> ) ) )
<S2SV_ModStart> = NULL ; coinfo = ( coap_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_coap , 0 ) ; if ( coinfo == NULL ) <S2SV_ModEnd> { coinfo = <S2SV_ModStart> 0 , coinfo <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , offset , - 1 , <S2SV_ModEnd> ENC_NA ) ; <S2SV_ModStart> prefixed_bencode_tree ) ; proto_item_set_len ( ti , 4 + plen ) ;
<S2SV_ModStart> , offset , - 1 <S2SV_ModEnd> , ENC_NA ) <S2SV_ModStart> ett_prefixed_bytes ) ; <S2SV_ModEnd> proto_tree_add_item ( prefixed_bytes_tree <S2SV_ModStart> ENC_NA ) ; proto_item_set_len ( ti , 4 + plen ) ; <S2SV_ModEnd> return 4 +
<S2SV_ModStart> , "bzr.bencode" , FT_NONE <S2SV_ModEnd> , BASE_NONE , <S2SV_ModStart> , "bzr.bytes" , FT_NONE <S2SV_ModEnd> , BASE_NONE ,
<S2SV_ModStart> } } else if ( header_data -> current ) <S2SV_ModStart> ) ; } } else { return ;
<S2SV_ModStart> DOT11DECRYPT_DEBUG_TRACE_START ( "Dot11DecryptScanForKeys" ) ; DISSECTOR_ASSERT ( tot_len >= mac_header_len + DOT11DECRYPT_CRYPTED_DATA_MINLEN ) ; DISSECTOR_ASSERT ( tot_len <= DOT11DECRYPT_MAX_CAPLEN <S2SV_ModStart> status != 0 && status != 85 <S2SV_ModStart> ) ) { guint8 element_id = data [ offset ] ; guint8 length = data [ offset + 1 ] ; guint min_length = length ; switch ( element_id ) { case 48 : <S2SV_ModEnd> offset_rsne = offset <S2SV_ModStart> = offset ; min_length = 1 ; break ; case 55 : <S2SV_ModEnd> offset_fte = offset <S2SV_ModStart> = offset ; min_length = 2 + 16 + 32 + 32 ; break ; case 56 : <S2SV_ModEnd> offset_timeout = offset <S2SV_ModStart> = offset ; min_length = 1 + 4 ; break ; case 101 : <S2SV_ModEnd> offset_link = offset <S2SV_ModStart> = offset ; min_length = 6 + 6 + 6 ; break ; } if ( length < min_length || <S2SV_ModEnd> tot_len < offset <S2SV_ModStart> < offset + 2 + length <S2SV_ModEnd> ) { return <S2SV_ModStart> } offset += 2 + length <S2SV_ModEnd> ; } if
<S2SV_ModStart> AIRPDCAP_DEBUG_TRACE_START ( "AirPDcapScanForKeys" ) ; DISSECTOR_ASSERT ( tot_len <= AIRPDCAP_MAX_CAPLEN <S2SV_ModStart> status != 0 && status != 85 <S2SV_ModStart> ) ) { guint8 element_id = data [ offset ] ; guint8 length = data [ offset + 1 ] ; guint min_length = length ; switch ( element_id ) { case 48 : <S2SV_ModEnd> offset_rsne = offset <S2SV_ModStart> = offset ; min_length = 1 ; break ; case 55 : <S2SV_ModEnd> offset_fte = offset <S2SV_ModStart> = offset ; min_length = 2 + 16 + 32 + 32 ; break ; case 56 : <S2SV_ModEnd> offset_timeout = offset <S2SV_ModStart> = offset ; min_length = 1 + 4 ; break ; case 101 : <S2SV_ModEnd> offset_link = offset <S2SV_ModStart> = offset ; min_length = 6 + 6 + 6 ; break ; } if ( length < min_length || <S2SV_ModEnd> tot_len < offset <S2SV_ModStart> < offset + 2 + length <S2SV_ModEnd> ) { return <S2SV_ModStart> } offset += 2 + length <S2SV_ModEnd> ; } if
<S2SV_ModStart> out ; } if ( strlen ( chap_r ) != MD5_SIGNATURE_SIZE * 2 ) { pr_err ( "Malformed<S2SV_blank>CHAP_R\\n" ) ; goto out ; } if ( hex2bin ( client_digest , chap_r , MD5_SIGNATURE_SIZE ) < 0 ) { pr_err ( "Malformed<S2SV_blank>CHAP_R\\n" ) ; goto out ; } <S2SV_ModStart> "[server]<S2SV_blank>Got<S2SV_blank>CHAP_R=%s\\n" , chap_r <S2SV_ModEnd> ) ; tfm <S2SV_ModStart> out ; } challenge_len = DIV_ROUND_UP ( strlen ( challenge ) , 2 <S2SV_ModEnd> ) ; if <S2SV_ModStart> } if ( hex2bin ( challenge_binhex , challenge , challenge_len ) < 0 ) { pr_err ( "Malformed<S2SV_blank>CHAP_C\\n" ) ; goto out ; } pr_debug ( "[server]<S2SV_blank>Got<S2SV_blank>CHAP_C=%s\\n" , challenge ) ; if (
<S2SV_ModStart> & multicast_idr , NULL <S2SV_ModEnd> , 0 ,
<S2SV_ModStart> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;
<S2SV_ModStart> * mapping = <S2SV_ModEnd> vif -> hash <S2SV_ModStart> hash . mapping <S2SV_ModEnd> ; struct gnttab_copy <S2SV_ModStart> . dest . <S2SV_ModEnd> domid = DOMID_SELF <S2SV_ModStart> DOMID_SELF , . <S2SV_ModEnd> len = len <S2SV_ModStart> * sizeof ( * mapping <S2SV_ModEnd> ) , . <S2SV_ModStart> off + len < off ) || ( off + len <S2SV_ModStart> size ) || <S2SV_ModEnd> len > XEN_PAGE_SIZE <S2SV_ModStart> len > XEN_PAGE_SIZE / sizeof ( * mapping ) <S2SV_ModStart> ) return XEN_NETIF_CTRL_STATUS_INVALID_PARAMETER ; copy_op . dest . u . gmfn = virt_to_gfn ( mapping + off ) ; copy_op . dest . offset = xen_offset_in_page ( mapping + off )
<S2SV_ModStart> ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModEnd> return len ; <S2SV_ModStart> return len ; } <S2SV_ModEnd> b -> opcode
<S2SV_ModStart> < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModStart> return len ; }
<S2SV_ModStart> f ) { int r ; <S2SV_ModStart> ; ) { _cleanup_free_ char * line = NULL ; char <S2SV_ModEnd> * l , <S2SV_ModStart> size_t k ; r = read_line ( f , LONG_LINE_MAX , & line ) ; if ( r < 0 ) return log_error_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>serialization<S2SV_blank>line:<S2SV_blank>%m" ) ; if ( r == 0 ) return 0 ; l = strstrip <S2SV_ModEnd> ( line ) <S2SV_ModStart> ( line ) ; if ( isempty ( l ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; ) { _cleanup_free_ char * line = NULL <S2SV_ModEnd> ; const char <S2SV_ModStart> * l ; r = read_line ( f , LONG_LINE_MAX , & line ) ; if ( r < 0 ) return log_error_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>serialization<S2SV_blank>line:<S2SV_blank>%m" ) ; if ( r == 0 ) break ; l = strstrip <S2SV_ModEnd> ( line ) <S2SV_ModStart> ( line ) ; if ( isempty ( l ) <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; ) { _cleanup_free_ char * line = NULL <S2SV_ModEnd> ; const char <S2SV_ModStart> * unit_name ; Unit * u ; r = read_line ( f , LONG_LINE_MAX , & line ) ; if ( r < 0 ) return log_error_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>serialization<S2SV_blank>line:<S2SV_blank>%m" ) ; if ( r == 0 ) break <S2SV_ModEnd> ; unit_name = <S2SV_ModStart> = strstrip ( line <S2SV_ModEnd> ) ; r <S2SV_ModStart> unit_name ) ; r = <S2SV_ModStart> ( f ) ; if ( r < 0 ) return r
<S2SV_ModStart> ( int fd <S2SV_ModEnd> , const struct <S2SV_ModStart> gid ) { char procfs_path [ STRLEN ( "/proc/self/fd/" ) + DECIMAL_STR_MAX ( int ) + 1 ] <S2SV_ModEnd> ; assert ( <S2SV_ModStart> return 0 ; xsprintf ( procfs_path , "/proc/self/fd/%i" , fd ) ; if ( chown ( procfs_path <S2SV_ModEnd> , uid , <S2SV_ModStart> , gid ) <S2SV_ModEnd> < 0 ) <S2SV_ModStart> - errno ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> st_mode ) ) if ( chmod ( procfs_path <S2SV_ModEnd> , st -> <S2SV_ModStart> st -> st_mode & 07777 ) <S2SV_ModEnd> < 0 )
<S2SV_ModStart> gid ) { <S2SV_ModEnd> _cleanup_closedir_ DIR * <S2SV_ModStart> d = NULL ; bool changed = false <S2SV_ModStart> * de ; int r ; assert ( fd >= 0 ) ; assert ( st ) ; <S2SV_ModStart> d ) { safe_close ( fd ) ; return <S2SV_ModEnd> - errno ; <S2SV_ModStart> - errno ; } FOREACH_DIRENT_ALL ( de , d , return - errno ) { _cleanup_close_ int path_fd <S2SV_ModEnd> = - 1 <S2SV_ModStart> - 1 ; <S2SV_ModEnd> struct stat fst <S2SV_ModStart> ) continue ; path_fd = openat <S2SV_ModEnd> ( dirfd ( <S2SV_ModStart> -> d_name , O_PATH <S2SV_ModEnd> | O_CLOEXEC | <S2SV_ModStart> O_CLOEXEC | O_NOFOLLOW ) ; if ( path_fd < 0 ) return - errno ; if ( fstat ( path_fd , & fst ) < 0 ) return - errno ; if ( S_ISDIR ( fst . st_mode ) ) { int subdir_fd ; subdir_fd = fd_reopen ( path_fd , O_RDONLY | O_CLOEXEC <S2SV_ModStart> < 0 ) return subdir_fd ; <S2SV_ModEnd> r = chown_recursive_internal <S2SV_ModStart> < 0 ) return r <S2SV_ModEnd> ; if ( <S2SV_ModStart> = chown_one ( path_fd , & fst , uid , gid ) ; if ( r < 0 ) return r ; if ( r > 0 ) changed = true ; } } r = chown_one ( <S2SV_ModStart> d ) , st <S2SV_ModEnd> , uid , <S2SV_ModStart> < 0 ) return r ; return <S2SV_ModEnd> r > 0 <S2SV_ModStart> || changed ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> path , O_RDONLY <S2SV_ModEnd> | O_DIRECTORY |
<S2SV_ModStart> * buflen < offsetof ( DHCP6Option , data ) +
<S2SV_ModStart> 4 ) { btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a56" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> ) break ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2A0C" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> += 9 ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2A0F" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> += 2 ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2A14" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> ) break ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a56" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> += 1 ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a58" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> ett_btatt_value ) ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a08" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> ett_btatt_value ) ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a08" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> ett_btatt_value ) ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a08" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> case 0x07 : btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a08" <S2SV_ModEnd> , tvb_new_subset_length_caplen ( <S2SV_ModStart> += 7 ; btatt_call_dissector_by_dissector_name_with_data ( "btgatt.uuid0x2a08" <S2SV_ModEnd> , tvb_new_subset_length_caplen (
<S2SV_ModStart> ; sep_data = wmem_new0 <S2SV_ModEnd> ( wmem_file_scope ( <S2SV_ModStart> ; sep_data -> <S2SV_ModEnd> codec = - <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; if (
<S2SV_ModStart> dev ; int len <S2SV_ModEnd> = 0 ; <S2SV_ModStart> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave <S2SV_ModStart> flags ) ; len <S2SV_ModEnd> = snprintf ( <S2SV_ModStart> flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
<S2SV_ModStart> { if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> 0 } ; <S2SV_ModEnd> guint8 * devicename <S2SV_ModStart> = tvb_get_string_enc ( wmem_packet_scope ( ) <S2SV_ModEnd> , pb . <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 } ; <S2SV_ModEnd> guint8 * hostname <S2SV_ModStart> * hostname ; <S2SV_ModEnd> nstime_t timestamp ; <S2SV_ModStart> = tvb_get_string_enc ( wmem_packet_scope ( ) <S2SV_ModEnd> , pb . <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> parse_PropertySetArray ( tvb , pinfo
<S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> parse_CInGroupSortAggregSets ( tvb , pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> text ) ; value -> vType = tvb_get_letohs ( tvb , offset ) ; value -> type = vType_get_type ( value -> vType & 0xFF ) ; if ( <S2SV_ModEnd> value -> type <S2SV_ModStart> value -> type == NULL ) { ti_type = proto_tree_add_string ( tree , hf_mswsp_cbasestorvariant_vtype , tvb , offset , 2 , "Unknown<S2SV_blank>CBaseStorageVariant<S2SV_blank>type" ) ; offset += 2 ; expert_add_info ( pinfo , ti_type , & ei_mswsp_invalid_variant_type ) ; THROW_MESSAGE ( ReportedBoundsError , "Unknown<S2SV_blank>CBaseStorageVariant<S2SV_blank>type" ) ; return offset ; } <S2SV_ModEnd> ti_type = proto_tree_add_string
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> parse_CInGroupSortAggregSets ( tvb , pinfo
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> ( tvb , pinfo , <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> proto_item * item , * ti_type <S2SV_ModStart> vtype_val ) ; if ( type == NULL ) { ti_type = proto_tree_add_string ( tree , hf_mswsp_ctablecolumn_vtype , tvb , offset , 4 , "Unknown<S2SV_blank>CTableColumn<S2SV_blank>type" ) ; expert_add_info ( pinfo , ti_type , & ei_mswsp_invalid_variant_type ) ; } else <S2SV_ModEnd> proto_tree_add_string_format_value ( tree
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> parse_CDbPropSet ( tvb , pinfo
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> tvbuff_t * tvb , packet_info * pinfo <S2SV_ModStart> ( tvb , pinfo ,
<S2SV_ModStart> CRowVariant * variant , <S2SV_ModEnd> struct vtype_data * <S2SV_ModStart> vtype_data * vt_list_type ) { guint32 i = 0 ; guint64 count = 0 ; int buf_offset = 0 ; proto_tree * sub_tree <S2SV_ModEnd> ; wmem_strbuf_t * <S2SV_ModStart> wmem_strbuf_t * strbuf <S2SV_ModEnd> ; offset =
<S2SV_ModStart> * tvb , packet_info * pinfo , <S2SV_ModStart> proto_item * item , * ti_type <S2SV_ModStart> variant -> vtype <S2SV_ModEnd> ) ; vtype_high <S2SV_ModStart> "|Unknown,<S2SV_blank>possibly<S2SV_blank>error" ; } } if ( vt_type == NULL ) { ti_type = proto_tree_add_string ( tree , hf_mswsp_ctablecolumn_vtype , tvb , offset , 4 , "Unknown<S2SV_blank>variant<S2SV_blank>column<S2SV_blank>type" ) ; expert_add_info ( pinfo , ti_type , & ei_mswsp_invalid_variant_type ) ; offset += 2 ; THROW_FORMATTED ( ReportedBoundsError , "Unknown<S2SV_blank>variant<S2SV_blank>column<S2SV_blank>type%s" , modifier ) ; return offset ; <S2SV_ModStart> is_64bit , variant , vt_type
<S2SV_ModStart> ] = { { & ei_mswsp_invalid_variant_type , { "mswsp.invalid_variant_type" , PI_PROTOCOL , PI_ERROR , "Invalid<S2SV_blank>variant<S2SV_blank>type" , EXPFILL } } ,
<S2SV_ModStart> ( tty ) && ! L_EXTPROC ( tty )
<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
<S2SV_ModStart> { if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> { guint offset , old_offset <S2SV_ModStart> offset = 2 ; old_offset = 1 <S2SV_ModStart> ) ) ; if ( offset <= old_offset ) { REPORT_DISSECTOR_BUG ( "Offset<S2SV_blank>isn\'t<S2SV_blank>increasing" ) ; } old_offset = offset ;
<S2SV_ModStart> ++ ; } tvb_ensure_bytes_exist ( tvb , offset , field ) ;
<S2SV_ModStart> ; int seglen <S2SV_ModEnd> = 0 ; <S2SV_ModStart> 1 ; } <S2SV_ModEnd> ofs = offset <S2SV_ModStart> = 0 ; <S2SV_ModEnd> idx < field_count <S2SV_ModStart> idx < field_count <S2SV_ModEnd> ; idx ++ <S2SV_ModStart> [ idx ] < 0 || ofs_list [ idx ] < 0 ) { THROW ( ReportedBoundsError ) ; } if ( id_list [ idx ]
<S2SV_ModStart> total_config_bytes ) ; if ( ! ptr ) { return offset ; }
<S2SV_ModStart> tvbuff_t * tvb _U_ <S2SV_ModStart> counter ) { return counter <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> > G_MAXINT ) { pszStr [ 0 ] = 0 ; <S2SV_ModStart> return offset ; }
<S2SV_ModStart> / NS_IN_US ; int m_ptr_offset = stats_offset + 8 + 12 ; m_ptr = rec + m_ptr_offset <S2SV_ModEnd> ; pay_off = <S2SV_ModStart> , rec_size - m_ptr_offset <S2SV_ModEnd> , pay_off ,
<S2SV_ModStart> value ) { if ( value == 0 ) { <S2SV_ModStart> , ITEM_LABEL_LENGTH , "%u<S2SV_blank>[Mired]" , value ) ; } else { g_snprintf ( s , ITEM_LABEL_LENGTH , "%u<S2SV_blank>[Mired]<S2SV_blank>(%u<S2SV_blank>[K])" <S2SV_ModEnd> , value , <S2SV_ModStart> value ) ; }
<S2SV_ModStart> args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> , int sig_off , int sig_max <S2SV_ModStart> ; guint64 sig_ts ; if ( sig_off + 15 >= sig_max ) return 0
<S2SV_ModStart> ) && ( <S2SV_ModEnd> f_flow != 0 <S2SV_ModStart> m_ptr , sig_off , msdu_length
<S2SV_ModStart> ; if ( <S2SV_ModEnd> m_ptr [ sig_off <S2SV_ModStart> == 0xdd ) sig_ts = get_signature_ts ( m_ptr , sig_off , <S2SV_ModEnd> rec_size - v22_W_STATS_LEN <S2SV_ModStart> rec_size - v22_W_STATS_LEN <S2SV_ModEnd> ) ; else
<S2SV_ModStart> ; if ( <S2SV_ModEnd> m_ptr [ sig_off <S2SV_ModStart> == 0xdd ) sig_ts = get_signature_ts ( m_ptr , sig_off , <S2SV_ModEnd> rec_size - vVW510021_W_STATS_TRAILER_LEN <S2SV_ModStart> rec_size - vVW510021_W_STATS_TRAILER_LEN <S2SV_ModEnd> ) ; else
<S2SV_ModStart> } else { if ( buf_ptr -> buf_cur + len > buf_end ) { expert_add_info_format ( pinfo , cd_item , & ei_wcp_invalid_window_offset , "Uncompressed<S2SV_blank>data<S2SV_blank>exceeds<S2SV_blank>available<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%d)" , len , ( int ) ( buf_end - buf_ptr -> buf_cur ) ) ; return NULL ; }
<S2SV_ModStart> < 0 ) { tt -> recursion_depth -- ; <S2SV_ModStart> - 1 ; } <S2SV_ModStart> < 0 ) { tt -> recursion_depth -- ; <S2SV_ModStart> 1 ; } } else { tt -> recursion_depth -- ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } tt -> recursion_depth -- ;
<S2SV_ModStart> ; # endif tt -> recursion_depth -- ; <S2SV_ModStart> ; } } tt -> recursion_depth -- ;
<S2SV_ModStart> -> end_offset ) { tt -> recursion_depth -- ; <S2SV_ModStart> - 1 ; } <S2SV_ModStart> } else { tt -> recursion_depth -- ; <S2SV_ModStart> ) ; } tt -> recursion_depth -- ;
<S2SV_ModStart> -> end_offset ) { tt -> recursion_depth -- ; <S2SV_ModStart> - 1 ; } <S2SV_ModStart> ++ ; } tt -> recursion_depth -- ;
<S2SV_ModStart> end_offset ) ; tt -> recursion_depth -- ;
<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
<S2SV_ModStart> } comment_rec = g_new0 <S2SV_ModEnd> ( struct netmonrec_comment
<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> i , clean_item_instance <S2SV_ModEnd> ) ; default
<S2SV_ModStart> i , write_one_file <S2SV_ModEnd> ) ; if <S2SV_ModStart> i , path_set_perms <S2SV_ModEnd> ) ; if <S2SV_ModStart> : r = glob_item_recursively ( i , fd_set_perms ) ; if ( r < 0 ) return r ; break ; case SET_XATTR : r = <S2SV_ModStart> ( i , path_set_xattrs <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case RECURSIVE_SET_XATTR : r = glob_item_recursively ( i , fd_set_xattrs ) ; if ( r < 0 ) return r ; break ; case SET_ACL <S2SV_ModEnd> : r = <S2SV_ModStart> ( i , path_set_acls <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case RECURSIVE_SET_ACL : r = glob_item_recursively ( i , fd_set_acls ) ; if ( r < 0 ) return r ; break ; case SET_ATTRIBUTE <S2SV_ModEnd> : r = <S2SV_ModStart> ( i , path_set_attribute <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case RECURSIVE_SET_ATTRIBUTE : r = glob_item_recursively ( i , fd_set_attribute <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; break ; <S2SV_ModEnd> } return 0
<S2SV_ModStart> , action_t action <S2SV_ModEnd> ) { _cleanup_globfree_ <S2SV_ModStart> = k ; <S2SV_ModEnd> } return r
<S2SV_ModStart> 0 ; # ifdef HAVE_ACL <S2SV_ModEnd> _cleanup_close_ int fd <S2SV_ModStart> path ) ; r = fd_set_acls ( item , fd , & st <S2SV_ModEnd> ) ; #
<S2SV_ModStart> stat st ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( path , O_CLOEXEC | O_NOFOLLOW | O_PATH <S2SV_ModEnd> ) ; if <S2SV_ModStart> < 0 ) <S2SV_ModEnd> return log_error_errno ( <S2SV_ModStart> path ) ; <S2SV_ModEnd> if ( fstat <S2SV_ModStart> path ) ; return fd_set_attribute ( item , fd , & st ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> path ) { <S2SV_ModEnd> _cleanup_close_ int fd <S2SV_ModStart> ( path ) <S2SV_ModEnd> ; fd = <S2SV_ModStart> path ) ; return fd_set_perms ( i , fd , & st <S2SV_ModEnd> ) ; }
<S2SV_ModStart> path ) { _cleanup_close_ int fd = - 1 <S2SV_ModEnd> ; assert ( <S2SV_ModStart> path ) ; fd = open ( path , O_CLOEXEC | O_NOFOLLOW | O_PATH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( fd <S2SV_ModEnd> < 0 ) <S2SV_ModStart> ( errno , "Cannot<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%m" <S2SV_ModEnd> , path ) <S2SV_ModStart> path ) ; return fd_set_xattrs ( i , fd , NULL ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> i , remove_item_instance <S2SV_ModEnd> ) ; default
<S2SV_ModStart> guint16 value1 ; gint next_operand_address ; next_operand_address <S2SV_ModEnd> = decode_udvm_multitype_operand ( <S2SV_ModStart> 0xffff ; return next_operand_address <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> guint8 temp_data ; if ( operand_address >= UDVM_MEMORY_SIZE ) return - 1 ;
<S2SV_ModStart> value = 0 ; if ( operand_address >= UDVM_MEMORY_SIZE ) return - 1
<S2SV_ModStart> = 0 ; gint <S2SV_ModEnd> next_operand_address ; guint8 <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> & operand_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & value ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & n ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> value ) ; if ( next_operand_address < 0 ) goto decompression_failure ; <S2SV_ModStart> & value ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & destination ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ( next_operand_address < 0 <S2SV_ModEnd> ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & multy_offset ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & at_address_1 ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> at_address_2 ) ; if ( next_operand_address < 0 ) goto decompression_failure ; <S2SV_ModStart> at_address_3 ) ; if ( next_operand_address < 0 ) goto decompression_failure ; <S2SV_ModStart> , current_address ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & j ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> at_address_1 ) ; if ( next_operand_address < 0 ) goto decompression_failure ; <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & at_address ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & at_address ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> , current_address ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & n ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & uncompressed_n ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & state_instruction ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & state_retention_priority ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & p_id_length ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & output_length ) ; if ( next_operand_address < 0 ) goto decompression_failure <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> ; if ( next_operand_address < 0 ) goto decompression_failure ; if ( <S2SV_ModStart> & state_retention_priority ) ; if ( next_operand_address < 0 ) goto decompression_failure
<S2SV_ModStart> ; guint16 temp_data16 ; if ( operand_address >= UDVM_MEMORY_SIZE ) return - 1 <S2SV_ModStart> 1 ) return - 1 <S2SV_ModEnd> ; return offset
<S2SV_ModStart> * sub_tree ; proto_item * type_pi ; <S2SV_ModStart> tvb ) ; guint32 <S2SV_ModEnd> type ; col_set_str <S2SV_ModStart> length ) { type_pi = proto_tree_add_item_ret_uint ( sub_tree , hf_thrift_type , tvb , offset , 1 , ENC_BIG_ENDIAN , & type <S2SV_ModEnd> ) ; if <S2SV_ModStart> += 2 ; if ( <S2SV_ModEnd> dissect_thrift_type ( tvb <S2SV_ModStart> , sub_tree , type_pi , type , & <S2SV_ModEnd> offset , length <S2SV_ModStart> , length ) < 0 ) { break ; } <S2SV_ModEnd> } } }
<S2SV_ModStart> proto_item * ti , * type_pi <S2SV_ModStart> "List" ) ; type_pi = <S2SV_ModStart> i ) { if ( <S2SV_ModEnd> dissect_thrift_type ( tvb <S2SV_ModStart> , sub_tree , type_pi , type , & <S2SV_ModEnd> offset , length <S2SV_ModStart> , length ) < 0 ) { break ; } <S2SV_ModEnd> } list_len =
<S2SV_ModStart> proto_item * ti , * ktype_pi , * vtype_pi <S2SV_ModStart> "Map" ) ; ktype_pi = <S2SV_ModStart> offset ++ ; vtype_pi = <S2SV_ModStart> i ) { if ( <S2SV_ModEnd> dissect_thrift_type ( tvb <S2SV_ModStart> , sub_tree , ktype_pi , ktype , & <S2SV_ModEnd> offset , length <S2SV_ModStart> , length ) < 0 ) { break ; } if ( <S2SV_ModEnd> dissect_thrift_type ( tvb <S2SV_ModStart> , sub_tree , vtype_pi , vtype , & <S2SV_ModEnd> offset , length <S2SV_ModStart> , length ) < 0 ) { break ; } <S2SV_ModEnd> } map_len =
<S2SV_ModStart> proto_item * ti , * type_pi ; guint32 <S2SV_ModEnd> type ; int <S2SV_ModStart> length ) { type_pi = proto_tree_add_item_ret_uint <S2SV_ModEnd> ( sub_tree , <S2SV_ModStart> 1 , ENC_BIG_ENDIAN , & type <S2SV_ModStart> += 2 ; if ( <S2SV_ModEnd> dissect_thrift_type ( tvb <S2SV_ModStart> , sub_tree , type_pi , type , & offset , length ) < 0 ) { break ; } <S2SV_ModEnd> } return offset
<S2SV_ModStart> packet_info * pinfo <S2SV_ModEnd> , proto_tree * <S2SV_ModStart> proto_tree * tree , proto_item * pi <S2SV_ModStart> type , int * <S2SV_ModStart> , tvb , * offset , 1 , ENC_BIG_ENDIAN ) ; * <S2SV_ModEnd> offset += 1 <S2SV_ModStart> , tvb , * offset , 1 , ENC_BIG_ENDIAN ) ; * <S2SV_ModEnd> offset += 1 <S2SV_ModStart> , tvb , * offset , 8 , ENC_BIG_ENDIAN ) ; * <S2SV_ModEnd> offset += 8 <S2SV_ModStart> , tvb , * <S2SV_ModStart> ENC_BIG_ENDIAN ) ; * <S2SV_ModStart> , tvb , * <S2SV_ModStart> ENC_BIG_ENDIAN ) ; * <S2SV_ModStart> , tvb , * offset , 8 , ENC_BIG_ENDIAN ) ; * <S2SV_ModEnd> offset += 8 <S2SV_ModStart> , tvb , * offset , 8 , ENC_BIG_ENDIAN ) ; * <S2SV_ModEnd> offset += 8 <S2SV_ModStart> case 11 : * <S2SV_ModStart> , tree , * <S2SV_ModStart> case 12 : * <S2SV_ModStart> , tree , * <S2SV_ModStart> case 13 : * <S2SV_ModStart> , tree , * <S2SV_ModStart> case 15 : * <S2SV_ModStart> , tree , * <S2SV_ModStart> ; default : expert_add_info ( pinfo , pi , & ei_thrift_wrong_type ) ; * offset = tvb_reported_length ( tvb ) ; return - 1 <S2SV_ModEnd> ; } return <S2SV_ModStart> ; } return *
<S2SV_ModStart> , } ; static ei_register_info ei [ ] = { { & ei_thrift_wrong_type , { "thrift.wrong_type" , PI_PROTOCOL , PI_ERROR , "Type<S2SV_blank>value<S2SV_blank>not<S2SV_blank>expected" , EXPFILL } } } ; expert_module_t * expert_thrift ; <S2SV_ModStart> "thrift" ) ; expert_thrift = expert_register_protocol ( proto_thrift ) ; expert_register_field_array ( expert_thrift , ei , array_length ( ei ) ) ;
<S2SV_ModStart> else if ( ( <S2SV_ModStart> vl <= endpos ) && ( offset + vl > offset )
<S2SV_ModStart> - new_length ; if ( total_length < 0 ) return length ;
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> - new_length ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length ) <S2SV_ModStart> - new_length ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length ) <S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> info_tree ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( capability_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length ) <S2SV_ModStart> info_tree ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> element_tree ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length ) <S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> addr_table ) ; CHECK_LENGTH_ADVANCE_OFFSET <S2SV_ModEnd> ( new_length )
<S2SV_ModStart> = 0 ; int <S2SV_ModEnd> offset = 0
<S2SV_ModStart> * tree , int <S2SV_ModEnd> offset , sccp_decode_context_t
<S2SV_ModStart> guint8 parameter_type , int <S2SV_ModEnd> offset , guint16
<S2SV_ModStart> guint8 parameter_type , int <S2SV_ModEnd> offset , sccp_decode_context_t
<S2SV_ModStart> , offset ) > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> ; default : if ( length > tvb_reported_length ( tvb ) ) { expert_add_info ( pinfo , ti_type , & ei_rpkirtr_bad_length ) ; <S2SV_ModEnd> return tvb_reported_length ( <S2SV_ModStart> ) ; } offset += length ; break ; } } return tvb_reported_length ( tvb ) ; }
<S2SV_ModStart> } } , { & ei_rpkirtr_bad_length , { "rpkirtr.bad_length" , PI_MALFORMED , PI_ERROR , "Invalid<S2SV_blank>length<S2SV_blank>field" , EXPFILL } } ,
<S2SV_ModStart> ) { guint8 <S2SV_ModEnd> type , length <S2SV_ModStart> type_tree ; guint32 i ,
<S2SV_ModStart> proto_item * ti , * prop_item <S2SV_ModStart> += 2 ; prop_item = <S2SV_ModStart> case OFPACPT_EXPERIMENTER_MASTER : if ( prop_len <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_len <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> packet_info * pinfo <S2SV_ModEnd> , proto_tree * <S2SV_ModStart> , guint16 length <S2SV_ModEnd> ) { proto_tree <S2SV_ModStart> proto_tree * prop_tree ; proto_item * prop_item <S2SV_ModStart> ENC_BIG_ENDIAN ) ; prop_item = <S2SV_ModStart> case OFPBPT_EXPERIMENTER : if ( prop_len <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_len <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> * prop_tree ; proto_item * prop_item ; <S2SV_ModStart> += 2 ; prop_item = <S2SV_ModStart> case OFPPDPT_EXPERIMENTER : if ( prop_length <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_length <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> * prop_tree ; proto_item * prop_item ; <S2SV_ModStart> += 2 ; prop_item = <S2SV_ModStart> case OFPPMPT_EXPERIMENTER : if ( prop_length <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_length <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> * prop_tree ; proto_item * prop_item ; <S2SV_ModStart> += 2 ; prop_item = <S2SV_ModStart> case OFPMP_EXPERIMENTER : if ( prop_length <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_length <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> proto_item * ti , * prop_item <S2SV_ModStart> += 2 ; prop_item = <S2SV_ModStart> case OFPTMPT_EXPERIMENTER : if ( prop_length <= 12 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; } <S2SV_ModStart> ; default : if ( prop_length <= 4 ) { expert_add_info ( pinfo , prop_item , & ei_openflow_v6_length_too_short ) ; offset = length ; break ; }
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> len < frame_header_length ) || ( frame_header_length < 20 )
<S2SV_ModStart> ( i < ( item_count - 1 ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( i = 0 ; i < <S2SV_ModEnd> item_count ; i <S2SV_ModStart> ( i < ( item_count - 1 ) <S2SV_ModEnd> ) ) { <S2SV_ModStart> "<S2SV_blank>[%d]:<S2SV_blank>(%s)" , i + 1
<S2SV_ModStart> ( i = 0 ; i < <S2SV_ModEnd> item_count ; i <S2SV_ModStart> "<S2SV_blank>[%d]:<S2SV_blank>(%s)" , i + 1
<S2SV_ModStart> ( i = 0 ; i < <S2SV_ModEnd> nr_objects ; i <S2SV_ModStart> "<S2SV_blank>[%d]" , i + 1
<S2SV_ModStart> ( i < ( item_count - 1 ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> = tlv_len ; gint <S2SV_ModEnd> check_offset = offset <S2SV_ModStart> + 1 ; guint16 <S2SV_ModEnd> masklen ; while
<S2SV_ModStart> = tlv_len ; gint <S2SV_ModEnd> check_offset = offset <S2SV_ModStart> + 1 ; guint16 <S2SV_ModEnd> masklen ; while
<S2SV_ModStart> len ) { ber_add_large_length_error <S2SV_ModEnd> ( actx -> <S2SV_ModStart> -> pinfo , tree , tvb , offset , len <S2SV_ModEnd> ) ; return
<S2SV_ModStart> val_length ) { ber_add_large_length_error <S2SV_ModEnd> ( actx -> <S2SV_ModStart> -> pinfo , tree , tvb , offset , val_length <S2SV_ModEnd> ) ; return
<S2SV_ModStart> + len ; if ( len > ( guint32 ) ( end_offset - offset ) || len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) ) { ber_add_large_length_error ( actx -> pinfo , tree , tvb , offset , len ) ; return end_offset ; }
<S2SV_ModStart> ) ; } ber_add_large_length_error ( pinfo , tree , tvb , offset , len <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; if ( kind_responses_length > G_MAXUINT16 ||
<S2SV_ModStart> guint segment_count ; guint max_count = ( guint ) tvb_reported_length_remaining ( tvb , offset + 4 ) / 16 ; <S2SV_ModStart> offset ) ; if ( segment_count > max_count ) { segment_count = max_count ; }
<S2SV_ModStart> ; if ( chunk_size == 0 <S2SV_ModEnd> ) break ;
<S2SV_ModStart> ( ( offset > max_offset ) || ( max_offset - offset < chunk_size ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> 4 ) ; if ( c_t == 15 ) { expert_add_info ( pinfo , NULL , & ei_mac_reserved_c_t ) ; break ; }
<S2SV_ModStart> 4 ) ; if ( c_t == 15 ) { expert_add_info ( pinfo , NULL , & ei_mac_reserved_c_t ) ; break ; }
<S2SV_ModStart> } } , { & ei_mac_reserved_c_t , { "mac.reserved_ct" , PI_PROTOCOL , PI_WARN , "C/T<S2SV_blank>has<S2SV_blank>a<S2SV_blank>reserved<S2SV_blank>value,<S2SV_blank>PDU<S2SV_blank>is<S2SV_blank>discarded" , EXPFILL } }
<S2SV_ModStart> key_found ) { if ( decrypted_data [ key_index + 1 ] <= 6 ) { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; }
<S2SV_ModStart> + 1 ; guint cmac_write_len ; <S2SV_ModStart> 16 ) ; cmac_write_len = <S2SV_ModEnd> data [ offset_fte <S2SV_ModStart> [ offset_fte + 1 ] + 2 ; if ( cmac_write_len < 20 ) { AIRPDCAP_DEBUG_PRINT_LINE ( "AirPDcapTDLSDeriveKey" , "Bad<S2SV_blank>MAC<S2SV_blank>len" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_UNSUCCESS ; } aes_cmac_encrypt_update ( & aes_ctx , & <S2SV_ModEnd> data [ offset_fte <S2SV_ModStart> [ offset_fte + 20 ] , cmac_write_len <S2SV_ModEnd> - 20 )
<S2SV_ModStart> != FCP_IU_UNSOL_CTL ) && ( proto_data != NULL )
<S2SV_ModStart> proto_tree * docsis_tree <S2SV_ModEnd> ; fc = <S2SV_ModStart> ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> hdrlen ) ; <S2SV_ModEnd> next_tvb = tvb_new_subset_remaining <S2SV_ModStart> ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> docsis_tree ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> hdrlen ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> = save_fragmented ; <S2SV_ModEnd> break ; } <S2SV_ModStart> hdrlen ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> hdrlen ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> } default : <S2SV_ModEnd> break ; }
<S2SV_ModStart> } ; guint cmd = tvb_get_guint8 ( tvb , 0 ) ; const ipmi_header_t * header = ipmi_get_hdr ( pinfo ) ; if ( header == NULL ) return ; guint to_shmm = header <S2SV_ModEnd> -> rs_sa == <S2SV_ModStart> rs_sa == 0x20 <S2SV_ModEnd> ; ipmi_set_data (
<S2SV_ModStart> ; length = tvb_reported_length ( tvb <S2SV_ModEnd> ) ; try_again
<S2SV_ModStart> { # line 2162 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2101 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1993 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1986 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1619 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1419 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1616 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1609 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1604 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1366 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1512 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" guint32 no_ddi_entries
<S2SV_ModStart> { # line 1127 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2013 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1772 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1881 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address null_addr
<S2SV_ModStart> { # line 1720 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1861 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> { # line 1717 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1671 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" int protocol_ie_id
<S2SV_ModStart> { # line 1708 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1703 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1749 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2091 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2127 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" umts_fp_conversation_info_t *
<S2SV_ModStart> { # line 1640 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1742 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1630 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 2105 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" nbap_com_context_id_t *
<S2SV_ModStart> { # line 1711 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1714 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1647 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" guint32 rlc_mode
<S2SV_ModStart> { # line 1138 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr <S2SV_ModStart> = com_context_id ; if ( dch_id != 0xffffffff ) { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> { # line 1254 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" address dst_addr
<S2SV_ModStart> ; # line 2154 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> prev_dch_id != 0 && prev_dch_id != 0xffffffff
<S2SV_ModStart> { # line 1133 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" offset =
<S2SV_ModStart> { # line 1049 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" transportFormatSet_type = <S2SV_ModStart> = NBAP_DCH_DL ; if ( dch_id != 0xffffffff ) { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> { # line 1037 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" transportFormatSet_type = <S2SV_ModStart> = NBAP_DCH_DL ; if ( dch_id != 0xffffffff ) { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> { # line 1664 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" guint32 hsdsch_physical_layer_category
<S2SV_ModStart> { # line 1055 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" transportFormatSet_type =
<S2SV_ModStart> { # line 1043 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" transportFormatSet_type = <S2SV_ModStart> = NBAP_DCH_UL ; if ( dch_id != 0xffffffff ) { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> = NBAP_DCH_UL ; if ( dch_id != 0xffffffff ) { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> { # line 1061 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items =
<S2SV_ModStart> { # line 1064 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" num_items ++
<S2SV_ModStart> { # line 1068 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" guint32 NrOfTransportBlocks <S2SV_ModStart> num_items > 0 && dch_id != 0xffffffff
<S2SV_ModStart> { # line 1100 <S2SV_ModEnd> "./asn1/nbap/nbap.cnf" guint32 TransportBlockSize <S2SV_ModStart> num_items > 0 && dch_id != 0xffffffff
<S2SV_ModStart> PCAPNG_BLOCK_NOT_SHB ; } if ( bh . block_total_length > MAX_BLOCK_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "pcapng_read_block:<S2SV_blank>total<S2SV_blank>block<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(><S2SV_blank>%u)" , bh . block_total_length , MAX_BLOCK_SIZE ) ; return PCAPNG_BLOCK_ERROR ; }
<S2SV_ModStart> } if ( <S2SV_ModEnd> ! wtap_read_bytes (
<S2SV_ModStart> block_total_length , MIN_ISB_SIZE <S2SV_ModEnd> ) ; return
<S2SV_ModStart> block_total_length , MIN_NRB_SIZE <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; # endif <S2SV_ModEnd> if ( enhanced
<S2SV_ModStart> block_total_length , MIN_SPB_SIZE <S2SV_ModEnd> ) ; return
<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> return ret ; memcpy ( & inparam . g , outparam , offsetof ( struct floppy_struct , name ) ) ; outparam = & inparam . g ;
<S2SV_ModStart> : kfree ( req ) ; kfree (
<S2SV_ModStart> 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
<S2SV_ModStart> NULL } ; guint encap_nested_count ; <S2SV_ModStart> "<S2SV_blank>802.11<S2SV_blank>Packet" ) ; <S2SV_ModEnd> ti = proto_tree_add_item <S2SV_ModStart> ENC_NA ) ; encap_nested_count = GPOINTER_TO_UINT ( p_get_proto_data ( pinfo -> pool , pinfo , proto_lwapp , 0 ) ) ; if ( ++ encap_nested_count > LWAPP_MAX_NESTED_ENCAP ) { expert_add_info ( pinfo , ti , & ei_lwapp_too_many_encap ) ; return tvb_captured_length ( tvb ) ; } p_add_proto_data ( pinfo -> pool , pinfo , proto_lwapp , 0 , GUINT_TO_POINTER ( encap_nested_count ) ) ; if ( tree ) {
<S2SV_ModStart> ett_lwapp_flags } ; static ei_register_info ei [ ] = { { & ei_lwapp_too_many_encap , { "lwapp.too_many_encap" , PI_UNDECODED , PI_WARN , "Too<S2SV_blank>many<S2SV_blank>LWAPP<S2SV_blank>encapsulation<S2SV_blank>levels" , EXPFILL } } } ; <S2SV_ModStart> * lwapp_module ; expert_module_t * expert_lwapp ; <S2SV_ModStart> ) ) ; expert_lwapp = expert_register_protocol ( proto_lwapp ) ; expert_register_field_array ( expert_lwapp , ei , array_length ( ei ) ) ;
<S2SV_ModStart> += 4 ; if ( result_rows_columns_count ) { <S2SV_ModStart> } } } }
<S2SV_ModStart> old_len ) { if ( pinfo -> desegment_offset == 0 )
<S2SV_ModStart> ( BOX_TYPE_NONE , 0 ,
<S2SV_ModStart> parent_box_type _U_ , guint depth , <S2SV_ModStart> offset_start ) ; depth ++ ; if ( depth > MP4_BOX_MAX_REC_LVL ) { proto_tree_add_expert ( tree , pinfo , & ei_mp4_too_many_rec_lvls , tvb , offset_start , ( gint ) box_size ) ; return - 1 ; } <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> , pinfo , depth , <S2SV_ModStart> body_size , pinfo , depth <S2SV_ModStart> ( box_type , depth ,
<S2SV_ModStart> packet_info * pinfo , guint depth <S2SV_ModStart> ( BOX_TYPE_DREF , depth ,
<S2SV_ModStart> packet_info * pinfo _U_ , guint depth
<S2SV_ModStart> packet_info * pinfo _U_ , guint depth
<S2SV_ModStart> packet_info * pinfo _U_ , guint depth
<S2SV_ModStart> * pinfo , guint depth _U_ ,
<S2SV_ModStart> packet_info * pinfo , guint depth <S2SV_ModStart> ( BOX_TYPE_STSD , depth ,
<S2SV_ModStart> packet_info * pinfo _U_ , guint depth
<S2SV_ModStart> pinfo _U_ , guint depth _U_ ,
<S2SV_ModStart> packet_info * pinfo _U_ , guint depth
<S2SV_ModStart> , { & ei_mp4_too_many_rec_lvls , { "mp4.too_many_levels" , PI_UNDECODED , PI_WARN , "too<S2SV_blank>many<S2SV_blank>recursion<S2SV_blank>levels" , EXPFILL } } , { &
<S2SV_ModStart> if ( ! PINFO_FD_VISITED ( pinfo ) || ( <S2SV_ModEnd> ieee_hints = ( <S2SV_ModStart> proto_ieee802154 , 0 ) ) == NULL ) { ieee_hints = wmem_new0 ( wmem_file_scope ( ) , ieee802154_hints_t ) ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_ieee802154 , 0 , ieee_hints
<S2SV_ModStart> next_dch != 0 && umts_fp_conversation_info -> num_dch_in_flow < FP_maxNrOfDCHs
<S2SV_ModStart> next_dch != 0 && umts_fp_conversation_info -> num_dch_in_flow < FP_maxNrOfDCHs
<S2SV_ModStart> next_dch != 0 && umts_fp_conversation_info -> num_dch_in_flow < FP_maxNrOfDCHs
<S2SV_ModStart> prev_dch_id != 0xffffffff && prev_dch_id != dch_id
<S2SV_ModStart> * item ; guint vlan_nested_count ; <S2SV_ModStart> = NULL ; ti = proto_tree_add_item ( tree , hfi_vlan , tvb , 0 , 4 , ENC_NA ) ; vlan_nested_count = GPOINTER_TO_UINT ( p_get_proto_data ( pinfo -> pool , pinfo , proto_vlan , 0 ) ) ; if ( ++ vlan_nested_count > VLAN_MAX_NESTED_TAGS ) { expert_add_info ( pinfo , ti , & ei_vlan_too_many_tags ) ; return tvb_captured_length ( tvb ) ; } p_add_proto_data ( pinfo -> pool , pinfo , proto_vlan , 0 , GUINT_TO_POINTER ( vlan_nested_count ) ) ; if ( tree ) { <S2SV_ModEnd> if ( vlan_summary_in_tree
<S2SV_ModStart> } } , { & ei_vlan_too_many_tags , { "vlan.too_many_tags" , PI_UNDECODED , PI_WARN , "Too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>VLAN<S2SV_blank>tags" , EXPFILL } } , <S2SV_ModStart> * expert_vlan ; <S2SV_ModEnd> proto_vlan = proto_register_protocol
<S2SV_ModStart> keytype != 0 && private_data -> key . keylength > 0
<S2SV_ModStart> ; if ( ! pinfo -> fd -> flags . visited && command_data && command_data -> reassemble_data_length < command_data -> data_length ) { guint chunklen = tvb_captured_length_remaining ( tvb , offset ) ; if ( chunklen > command_data -> data_length - command_data -> reassemble_data_length ) { chunklen = command_data -> data_length - command_data -> reassemble_data_length ; command_data -> reassemble_error_in_frame = frame_number ; } tvb_memcpy ( tvb , command_data -> reassemble_data + command_data -> reassemble_data_length , offset , chunklen ) ; command_data -> reassemble_data_length += chunklen ; if ( command_data -> reassemble_data_length >= command_data -> data_length ) command_data -> completed_in_frame = frame_number ; } if ( frame_number == command_data -> reassemble_error_in_frame ) { proto_tree_add_expert ( main_tree , pinfo , & ei_invalid_data , tvb , offset , - 1 ) ; } if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> proto_tree_add_item ( main_tree
<S2SV_ModStart> } } , { & ei_invalid_data , { "adb.expert.data_error" , PI_PROTOCOL , PI_ERROR , "Mismatch<S2SV_blank>between<S2SV_blank>message<S2SV_blank>payload<S2SV_blank>size<S2SV_blank>and<S2SV_blank>data<S2SV_blank>length" , EXPFILL } } ,
<S2SV_ModStart> -> data_length ) ; command_data -> reassemble_error_in_frame = 0
<S2SV_ModStart> tn3270_conv_info_t ) ; copy_address_wmem ( wmem_file_scope ( ) , <S2SV_ModEnd> & ( tn3270_info <S2SV_ModStart> -> destport ; copy_address_wmem ( wmem_file_scope ( ) , <S2SV_ModEnd> & ( tn3270_info
<S2SV_ModStart> ISUP_ITU_STANDARD_VARIANT , 0 ) ; g_free ( version ) ; g_free ( base
<S2SV_ModStart> lapd_convo_data_t ) ; copy_address_wmem ( wmem_file_scope ( ) , <S2SV_ModEnd> & convo_data -> <S2SV_ModStart> src ) ; copy_address_wmem ( wmem_file_scope ( ) , <S2SV_ModEnd> & convo_data ->
<S2SV_ModStart> SMB2_EI_FILENAME ) { wmem_free ( wmem_file_scope ( ) , <S2SV_ModEnd> si -> saved <S2SV_ModStart> gchar * ) wmem_alloc ( wmem_file_scope ( ) , <S2SV_ModEnd> f_olb . len
<S2SV_ModStart> SMB2_EI_FILENAME ) { wmem_free ( wmem_file_scope ( ) , <S2SV_ModEnd> si -> saved
<S2SV_ModStart> -> extra_info = wmem_alloc ( wmem_file_scope ( ) , <S2SV_ModEnd> olb . len
<S2SV_ModStart> extra_info ) ; wmem_free ( wmem_file_scope ( ) , <S2SV_ModEnd> si -> saved
<S2SV_ModStart> } modname = wmem_strndup ( wmem_packet_scope ( ) , <S2SV_ModEnd> repoid + 4
<S2SV_ModStart> 0xffffffff ) { wmem_free ( scope , * subids_p ) ;
<S2SV_ModStart> mimetypename = NULL ; char * tmp <S2SV_ModStart> content_type_str ) ; tmp <S2SV_ModEnd> = ws_find_media_type_parameter ( <S2SV_ModStart> "name" ) ; if ( tmp ) { mimetypename = wmem_strdup ( wmem_packet_scope ( ) , tmp ) ; g_free ( tmp ) ; } <S2SV_ModStart> POS_CONTENT_DISPOSITION : { tmp = ws_find_media_type_parameter ( value_str , "filename" ) ; if ( tmp ) { filename = wmem_strdup ( wmem_packet_scope ( ) , tmp ) ; g_free ( tmp ) ; } <S2SV_ModEnd> } break ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> return boundary_start +
<S2SV_ModStart> datax ) ; copy_address_wmem ( wmem_file_scope ( ) , <S2SV_ModEnd> & ( datax
<S2SV_ModStart> pcp_conv_info_t * ) wmem_alloc ( wmem_file_scope ( ) , <S2SV_ModEnd> sizeof ( pcp_conv_info_t
<S2SV_ModStart> err_info ) { if ( err < 0 ) { char * <S2SV_ModEnd> file_description = input_file_description <S2SV_ModStart> filename ) ; <S2SV_ModEnd> switch ( err
<S2SV_ModStart> file_type_subtype ) { if ( err < 0 ) { <S2SV_ModStart> char * file_description = input_file_description <S2SV_ModEnd> ( filename ) <S2SV_ModStart> filename ) ; <S2SV_ModEnd> switch ( err
