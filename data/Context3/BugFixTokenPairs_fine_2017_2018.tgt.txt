<S2SV_ModStart> { p_fm_config_conx_hdlt hdl = NULL <S2SV_ModStart> ) ; goto cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto cleanup <S2SV_ModEnd> ; } for <S2SV_ModStart> 0 ) { res = <S2SV_ModEnd> commandList [ i <S2SV_ModStart> ] ) ; goto cleanup ; <S2SV_ModStart> - 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> free ( hdl <S2SV_ModStart> hdl ) ; }
<S2SV_ModStart> sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> ; } snprintf <S2SV_ModStart> 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> } if ( <S2SV_ModStart> 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> ; } memset <S2SV_ModStart> 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> ; } hdl <S2SV_ModStart> = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
<S2SV_ModStart> ; } } cleanup : <S2SV_ModEnd> return res ;
<S2SV_ModStart> * mgr_hdl ; <S2SV_ModEnd> memset ( s_path <S2SV_ModStart> ( c_path ) <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c_path , "%s%s%d_C_XXXXXX" <S2SV_ModEnd> , HSM_FM_SCK_PREFIX , <S2SV_ModStart> hdl -> instance <S2SV_ModEnd> ) ; if
<S2SV_ModStart> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , <S2SV_ModStart> ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits <S2SV_ModStart> ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval = <S2SV_ModStart> ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = <S2SV_ModStart> res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
<S2SV_ModStart> += 2 ; if ( i + 1 < data_size )
<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
<S2SV_ModStart> void ) { test_parser_param ( <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( parserTestSuite , "Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
<S2SV_ModStart> ) { static <S2SV_ModEnd> gid_t gid_cluster = <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( crm_user_lookup <S2SV_ModStart> } if ( uid_client != 0 ) { crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , - 1 <S2SV_ModEnd> , gid_cluster ,
<S2SV_ModStart> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s.html" , <S2SV_ModStart> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s-links.html" , <S2SV_ModStart> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s_thumb_%03d" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_uint8 <S2SV_ModStart> + 1 , "prestring=%490s" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ) ) > L_BUFSIZE <S2SV_ModEnd> - 3 ) <S2SV_ModStart> + 1 , "protos=%490s" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.data.%d" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%f<S2SV_blank>%f\\n" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.cmd" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.png" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.ps" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.eps" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.tex" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>title<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>xlabel<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>ylabel<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>x" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>y" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "gnuplot<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "wgnuplot<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( fp , "Rootname:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf )
<S2SV_ModStart> ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n" <S2SV_ModEnd> , & n
<S2SV_ModStart> char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------" <S2SV_ModEnd> , selname )
<S2SV_ModStart> char combname [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dh" , <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dv" ,
<S2SV_ModStart> == 0 ) if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> { uschar * hn ; if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_ModStart> ( ret = ff_set_dimensions ( avctx , <S2SV_ModEnd> s -> width <S2SV_ModStart> s -> height <S2SV_ModEnd> ) ) <
<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> av_strstart ( proto_name <S2SV_ModStart> ( proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> , NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA ;
<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> ; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME
<S2SV_ModStart> } else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRIu64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\\n" , s
<S2SV_ModStart> = NULL ; uint64_t <S2SV_ModEnd> off = s <S2SV_ModStart> len , "Range:<S2SV_blank>bytes=%" PRIu64 <S2SV_ModEnd> "-" , s <S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
<S2SV_ModStart> -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for (
<S2SV_ModStart> s -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { if <S2SV_ModStart> -> chunksize = strtoull <S2SV_ModEnd> ( line , <S2SV_ModStart> ; av_log ( h <S2SV_ModEnd> , AV_LOG_TRACE , <S2SV_ModStart> AV_LOG_TRACE , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\'\\n" , s <S2SV_ModStart> return 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , "Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%" PRIu64 "\\n" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> ) ) { uint64_t <S2SV_ModEnd> target = h <S2SV_ModStart> AV_LOG_INFO , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "<S2SV_blank>error=%s.\\n" , s <S2SV_ModStart> AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> ".\\n" , target
<S2SV_ModStart> -> hd ; uint64_t <S2SV_ModEnd> old_off = s <S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> && whence ==
<S2SV_ModStart> -> off = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( slash +
<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,
<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (
<S2SV_ModStart> VOS_STARTCODE ) { int profile , level ; <S2SV_ModStart> s , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <S2SV_ModStart> FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( <S2SV_ModEnd> level > 0 <S2SV_ModStart> > 0 && <S2SV_ModEnd> level < 9 <S2SV_ModStart> ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
<S2SV_ModStart> GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits <S2SV_ModStart> 4 ) ; * <S2SV_ModEnd> level = get_bits <S2SV_ModStart> ; if ( * <S2SV_ModEnd> profile == 0 <S2SV_ModStart> == 0 && * <S2SV_ModEnd> level == 8 <S2SV_ModStart> 8 ) { * <S2SV_ModEnd> level = 0
<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> ; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; } if (
<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
<S2SV_ModStart> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> gb ) ; return 0 ;
<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> AVINDEX_KEYFRAME ) ; }
<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
<S2SV_ModStart> pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> frame -> color_primaries <S2SV_ModStart> frame -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> avctx -> width || <S2SV_ModEnd> s -> height
<S2SV_ModStart> ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> -> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> pb ) ; } <S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> pb ) ; } <S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> & 0xFFFF ; }
<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> item_num > 65536 || item_num < 0
<S2SV_ModStart> c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> c -> buffer_ptr <S2SV_ModStart> ; else { av_assert0 ( len <= c -> chunk_size ) ;
<S2SV_ModStart> ; if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ; if (
<S2SV_ModStart> , size2 , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
<S2SV_ModStart> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> av_log ( mxf -> fc
<S2SV_ModStart> cur_pic . field_picture <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return
<S2SV_ModStart> studio_profile ) { <S2SV_ModEnd> if ( !
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
<S2SV_ModStart> ; if ( * value == 0 ||
<S2SV_ModStart> * ptrptr && <S2SV_ModEnd> nmemb && size <S2SV_ModStart> nmemb && size <S2SV_ModEnd> ) return AVERROR
<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> , * ptr <S2SV_ModEnd> ; int ncolors <S2SV_ModStart> = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> + avpkt -> <S2SV_ModStart> ; while ( end - ptr > 9 && <S2SV_ModStart> , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log <S2SV_ModStart> ) size *= 95 <S2SV_ModEnd> ; if ( <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> s ) { int64_t <S2SV_ModEnd> hours , minutes
<S2SV_ModStart> bpp <= 8 && c -> format != CHUNKY
<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1
<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;
<S2SV_ModStart> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>before<S2SV_blank>IHDR\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>after<S2SV_blank>IDAT\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> != 6 ) || s -> bit_depth == 1
<S2SV_ModStart> ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;
<S2SV_ModStart> < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> timescale > UINT16_MAX || ! track -> par -> channels
<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> ; rc = foreach_shareopt <S2SV_ModEnd> ( shareopts ,
<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> BufferOffset <S2SV_ModStart> -> BufferOffset + ( UINT64 ) <S2SV_ModStart> fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> count ) { UINT32 <S2SV_ModEnd> count = bitmapUpdate <S2SV_ModStart> * 2 ; BITMAP_DATA *
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_decode ( NSC_CONTEXT <S2SV_ModStart> ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart> 8 ) ; <S2SV_ModEnd> shift = context <S2SV_ModStart> - 1 ; <S2SV_ModEnd> bmpdata = context <S2SV_ModStart> context -> BitmapData ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> ; } } return TRUE ;
<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out , UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;
<S2SV_ModStart> UINT32 nsc_rle_encode ( const
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( NSC_CONTEXT <S2SV_ModStart> ) ; } return TRUE ;
<S2SV_ModStart> TRUE ; } <S2SV_ModEnd> } else if <S2SV_ModStart> TRUE ; } <S2SV_ModEnd> } else if <S2SV_ModStart> TRUE ; } } else <S2SV_ModEnd> { g_set_error (
<S2SV_ModStart> gchar * filename = NULL ; gint file_handle <S2SV_ModStart> use_gimp_2_8_features ) ; file_handle = g_file_open_tmp ( "gimp-test-XXXXXX.xcf" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> ) ; file
<S2SV_ModStart> = conn ; <S2SV_ModEnd> g_debug ( "GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s"
<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
<S2SV_ModStart> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> ( ice_conn ) <S2SV_ModStart> ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( <S2SV_ModStart> sms_conn ) ; data <S2SV_ModEnd> = ice_conn -> <S2SV_ModStart> -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; gsm_xsmp_client_connect <S2SV_ModStart> ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn ,
<S2SV_ModStart> < 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity
<S2SV_ModStart> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1
<S2SV_ModStart> l ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> XML_ERR_NAME_TOO_LONG , "Name" ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , "unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"
<S2SV_ModStart> gboolean res ; g_autofree gchar * trusted = NULL ; <S2SV_ModStart> TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> ( file ) && trusted != NULL
<S2SV_ModStart> ) ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,
<S2SV_ModStart> , _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( "Trust<S2SV_blank>and<S2SV_blank>_Launch" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , "yes" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file
<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
<S2SV_ModStart> { guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> { gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
<S2SV_ModStart> ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
<S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor
<S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image <S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels ,
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { <S2SV_ModStart> ( CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> filename <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) "<S2SV_blank>Debug" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) "<S2SV_blank>Cipher" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) "<S2SV_blank>Modules" <S2SV_ModStart> "<S2SV_blank>OpenMP" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) "<S2SV_blank>Zero-configuration" # endif
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> , imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> , imbuf + ( size_t ) <S2SV_ModStart> ( imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> MagickCoreSignature ) ; pixel = 0 ;
<S2SV_ModStart> == VFF_TYP_BIT ) { if ( CheckMemoryOverflow <S2SV_ModEnd> ( ( image <S2SV_ModStart> ) >> 3UL , <S2SV_ModEnd> image -> rows <S2SV_ModStart> image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModEnd> max_packets = ( <S2SV_ModStart> number_data_bands ) ; }
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if (
<S2SV_ModStart> , extent , height , <S2SV_ModStart> "UnableToReadImageData" ) ; <S2SV_ModEnd> height = sun_info <S2SV_ModStart> "MemoryAllocationFailed" ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> sun_data ) ; <S2SV_ModEnd> p = sun_pixels
<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ <S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++
<S2SV_ModStart> DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t bit <S2SV_ModStart> ++ ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( ( <S2SV_ModStart> 255 , q , exception <S2SV_ModEnd> ) ; q <S2SV_ModStart> ++ ; } if ( x != image -> columns ) <S2SV_ModStart> ; } } <S2SV_ModEnd> return ( SyncAuthenticPixels
<S2SV_ModStart> number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info =
<S2SV_ModStart> AcquireQuantumMemory ( pixels_length + image -> rows
<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
<S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels =
<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { for
<S2SV_ModStart> , "enter" ) ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" ) ; <S2SV_ModEnd> status = PersistPixelCache
<S2SV_ModStart> maptype ) { case RMT_NONE : break ;
<S2SV_ModStart> = height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> depth ++ ) <S2SV_ModEnd> ; image ->
<S2SV_ModStart> Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
<S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> + plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } <S2SV_ModStart> + offset ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> "ImproperImageHeader" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> ( size_t ) MagickMax ( <S2SV_ModStart> . length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> sun_info . height <S2SV_ModEnd> ; if (
<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> "UnableToReadImageData" ) ; }
<S2SV_ModStart> exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> = mask ; }
<S2SV_ModStart> options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModStart> CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> colormap = ( <S2SV_ModStart> x ++ ) { <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModStart> CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t ) <S2SV_ModStart> ( image , ( ssize_t )
<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" )
<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> "ImproperImageHeader" ) ; }
<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bitmapDC = CreateCompatibleDC
<S2SV_ModStart> extent , height <S2SV_ModEnd> ; ssize_t count <S2SV_ModStart> PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> columns <S2SV_ModStart> % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p ++ <S2SV_ModStart> * p ++ ) <S2SV_ModStart> q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> if ( ( <S2SV_ModEnd> ( bytes_per_pixel *
<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->
<S2SV_ModStart> * output ; MagickBooleanType status ; <S2SV_ModStart> ) ; } status = MagickTrue ; <S2SV_ModStart> i ++ ) { <S2SV_ModEnd> input = fopen_utf8 <S2SV_ModStart> input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> ( void ) fclose ( input <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> output ) ; <S2SV_ModStart> ; return ( status <S2SV_ModEnd> ) ; }
<S2SV_ModStart> != '\\0' ) && ( c != EOF ) <S2SV_ModStart> 2 ] ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity <S2SV_ModStart> 1 ] ; } <S2SV_ModStart> , width ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> & width ) == 2 ) { <S2SV_ModEnd> image -> columns <S2SV_ModStart> ) height ; }
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,
<S2SV_ModStart> ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> ( void ) strncpy <S2SV_ModEnd> ( clone_info ->
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> length , padding <S2SV_ModEnd> , version , <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) break ; <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> } return ( ( int )
<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
<S2SV_ModStart> ; image -> <S2SV_ModEnd> colors = sun_info <S2SV_ModStart> / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModStart> maptype ) { <S2SV_ModEnd> case RMT_EQUAL_RGB : <S2SV_ModStart> char * sun_colormap <S2SV_ModEnd> ; sun_colormap =
<S2SV_ModStart> size_t ) ldblk + 1
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof
<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> image , ssize_t bpp <S2SV_ModEnd> , unsigned char <S2SV_ModStart> exception ) { int bit ; Quantum index <S2SV_ModEnd> ; register Quantum <S2SV_ModStart> ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> ; switch ( bpp <S2SV_ModEnd> ) { case <S2SV_ModStart> 1 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> bit < ( ssize_t ) ( <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 2 : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> * p >> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ( * p ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ( image ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 8 : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x <S2SV_ModStart> ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception ) <S2SV_ModStart> , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> name , MaxTextExtent - 1
<S2SV_ModStart> image ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )

<S2SV_ModStart> = 1.0f / MagickMax ( w . x , MagickMax <S2SV_ModEnd> ( w .
<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 8 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> , y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> MagickFalse ; } return ( <S2SV_ModStart> dds_info , 4 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> MagickFalse ; } return ( <S2SV_ModStart> dds_info , 3 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> index ) ; q ++ ; p <S2SV_ModEnd> ++ ; } <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 2 ) {
<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> "ImproperImageHeader" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob
<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> "MemoryAllocationFailed" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> ( ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> image , q ) , exception
<S2SV_ModStart> { MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
<S2SV_ModStart> ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
<S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> "MemoryAllocationFailed" ) ; } <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> "MemoryAllocationFailed" ) ; } <S2SV_ModStart> NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> != MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> "ImproperImageHeader" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } if (
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> g_path_is_absolute ( filename
<S2SV_ModStart> [ i ] ) ; log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf
<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
<S2SV_ModStart> ] ) { int ret_value = 0 ; <S2SV_ModStart> "\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n" ) ; ret_value = <S2SV_ModEnd> write_output ( ) <S2SV_ModStart> write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled." , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>" <S2SV_ModEnd> , EF_GBL_OPTIONS ->
<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> += hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> += 4 ; hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> hmi_mdi , hmi_data , data_siz <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> ; if ( data_siz && <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> > 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data > <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; hmi_data ++ ; data_siz --
<S2SV_ModStart> ] + chunk_length [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> += 3 ; chunk_length [ i ] -= 3 ; <S2SV_ModStart> hmp_mdi , hmp_chunk [ i ] , chunk_length <S2SV_ModStart> ] = 1 ; chunk_length [ i ] -= 3 <S2SV_ModStart> += setup_ret ; chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> ; if ( chunk_length [ i ] && <S2SV_ModStart> { do { if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> ] ++ ; chunk_length [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> i ] ++ ; chunk_length [ i ] --
<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
<S2SV_ModStart> = 0.0 ; # define MUS_SZ 4 <S2SV_ModStart> uint8_t mus_event [ MUS_SZ <S2SV_ModStart> * ) mus_event , MUS_SZ
<S2SV_ModStart> , xmi_data , xmi_size ,

<S2SV_ModStart> M_fs_error_t res ; <S2SV_ModEnd> res = M_fs_file_open
<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN
<S2SV_ModStart> . id ; if ( bufLen < 2 ) break ; <S2SV_ModStart> += 2 ; bufLen -= 2 ;
<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
<S2SV_ModStart> "Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut" ) ; if ( len > 0 ) { <S2SV_ModStart> = len ; }
<S2SV_ModStart> sec_attr == NULL || sec_attr_len
<S2SV_ModStart> ; bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> } bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> len = file && file -> size > 0
<S2SV_ModStart> break ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line , <S2SV_ModStart> line , "<S2SV_blank>" , sizeof line <S2SV_ModStart> } line [ ( sizeof <S2SV_ModEnd> line ) - <S2SV_ModStart> 1 ] = '\\0' ; line [ strlen ( line ) - 1 ] =
<S2SV_ModStart> , len ; <S2SV_ModEnd> WCHAR * data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } size <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } read <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> + len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> free ( data <S2SV_ModStart> ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) == <S2SV_ModStart> { error ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied" , path_name <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> s ) { HTChunk * target = NULL ; <S2SV_ModStart> case HTML_TITLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> title <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_STYLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> style_block <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_SCRIPT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> script <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OBJECT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> object <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_TEXTAREA : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> textarea <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OPTION : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> option <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_MATH : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> math <S2SV_ModEnd> ; break ; <S2SV_ModStart> } } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , "BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }
<S2SV_ModStart> * function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
<S2SV_ModStart> -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> ; break ; <S2SV_ModStart> case OBJECT_TYPE_STRING : if ( <S2SV_ModStart> YR_OBJECT_STRING * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break ;
<S2SV_ModStart> { assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> : # line 113 <S2SV_ModEnd> "hex_grammar.y" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 126 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> "hex_grammar.y" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 205 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> "hex_grammar.y" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> "hex_grammar.y" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> "hex_grammar.y" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> "hex_grammar.y" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> "hex_grammar.c" default :
<S2SV_ModStart> : # line 101 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 102 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 103 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 104 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 107 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 106 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 105 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "hex_grammar.c" break ;
<S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate
<S2SV_ModStart> ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 2 ] ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 3 ] ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> "<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x" ) ; assert_regexp_syntax_error ( "\\\\x0" ) ; assert_regexp_syntax_error ( "\\\\x" ) ; assert_regexp_syntax_error ( "\\\\xxy" ) ;
<S2SV_ModStart> 2 ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
<S2SV_ModStart> { assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> -> length , 0 ,
<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr =
<S2SV_ModStart> target ) , 0 ,
<S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> , data + offset , data_size -
<S2SV_ModStart> "a\\0x\\0x\\0b\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\ta\\0b\\0c\\0" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\ta\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0x\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0b\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "abc" ) ; <S2SV_ModStart> ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE ) <S2SV_ModStart> ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE )
<S2SV_ModStart> re_ast ) -> levels = 0 ; ( * re_ast ) ->
<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
<S2SV_ModStart> otp_id ) ; fclose ( opwfile ) ;
<S2SV_ModStart> ) ; } # if 0 <S2SV_ModStart> ; } } # endif
<S2SV_ModStart> , fsuid , <S2SV_ModEnd> NULL ) ;
<S2SV_ModStart> , int source_base_ofs , uid_t uid , gid_t gid <S2SV_ModStart> ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; }
<S2SV_ModStart> FILENAME_MAPS ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_LIMITS ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_CGROUP ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_OPEN_FDS ) ; <S2SV_ModEnd> dump_fd_info ( dest_filename <S2SV_ModStart> source_filename , source_base_ofs <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid <S2SV_ModEnd> ) ; free
<S2SV_ModStart> ( path , g_settings_privatereports ? 0 :
<S2SV_ModStart> 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( "abrt" ) ; if ( ! gr ) { error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; return 403 ; } } else
<S2SV_ModStart> ; } } const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> ( path , dduid <S2SV_ModEnd> , DEFAULT_DUMP_DIR_MODE ,
<S2SV_ModStart> = 0 ; value = get_map_string_item_or_NULL ( settings , "PrivateReports" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , "PrivateReports" ) ; }
<S2SV_ModStart> struct dump_dir * dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else
<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> ( dest_filename , "wx" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> O_APPEND | O_CREAT | O_NOFOLLOW
<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |
<S2SV_ModStart> ( filepath , "r" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; file = fopen_safe <S2SV_ModEnd> ( "/tmp/keepalived.json" ,
<S2SV_ModStart> ( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,
<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , "w" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file
<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,
<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
<S2SV_ModStart> ) ; return 0
<S2SV_ModStart> vrrp_rx_bufs_multiples ) ; conf_write ( fp , "<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o" , global_data -> umask ) ;
<S2SV_ModStart> ; # endif install_keyword ( "umask" , & umask_handler ) ;
<S2SV_ModStart> ; # endif umask ( 022 ) ; <S2SV_ModStart> ( ) ; global_data -> umask = umask_val ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> # ifdef _MEM_CHECK_
<S2SV_ModStart> ; unsigned facility ; mode_t new_umask_val <S2SV_ModStart> 'G' } , { "umask" , required_argument , NULL , 'u' } , <S2SV_ModStart> , argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" <S2SV_ModEnd> # if defined <S2SV_ModStart> break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case
<S2SV_ModStart> "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n" ) ;
<S2SV_ModStart> ACPI_STATUS Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * Prev <S2SV_ModStart> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
<S2SV_ModStart> <= * len && plen > 0
<S2SV_ModStart> - 2 ; if ( plen < 0 ) return 0 ;
<S2SV_ModStart> - 1 ; int n = 0 ; <S2SV_ModStart> ( & h <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( L , 2 <S2SV_ModEnd> , "too<S2SV_blank>many<S2SV_blank>results" ) <S2SV_ModStart> res ) ; n ++ ; <S2SV_ModStart> f ) ; n ++ ; <S2SV_ModStart> d ) ; n ++ ; <S2SV_ModStart> { if ( n == 0 || <S2SV_ModStart> ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" <S2SV_ModEnd> ) ; size <S2SV_ModStart> 1 ) ; n -- ; <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" <S2SV_ModStart> , size ) ; n ++ <S2SV_ModStart> 1 ) ; n ++ ; <S2SV_ModStart> ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , MAXALIGN
<S2SV_ModStart> int getnum ( <S2SV_ModEnd> const char * <S2SV_ModStart> ; do { <S2SV_ModEnd> a = a
<S2SV_ModStart> return getnum ( <S2SV_ModEnd> fmt , 1 <S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , sizeof
<S2SV_ModStart> 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."
<S2SV_ModStart> lua_newtable ( L ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"
<S2SV_ModStart> len ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array" ) ;
<S2SV_ModStart> len = 0 ; luaL_checkstack ( L , 3 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map" )
<S2SV_ModStart> ++ ) { luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_check" ) ;
<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_unpack_full" ) ;
<S2SV_ModStart> -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break ;
<S2SV_ModStart> void ) { <S2SV_ModEnd> if ( config <S2SV_ModStart> ) return ; sds prompt = sdsempty ( ) ; <S2SV_ModStart> != NULL ) { prompt = sdscatfmt ( prompt , "redis<S2SV_blank>%s" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , "[%i]" , config . dbnum ) ; prompt = sdscatlen ( prompt , "><S2SV_blank>" , 2 ) ; <S2SV_ModEnd> snprintf ( config <S2SV_ModStart> prompt ) , "%s" , prompt ) ; sdsfree ( prompt <S2SV_ModEnd> ) ; }
<S2SV_ModStart> o == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , "offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater" ) ; pos -- <S2SV_ModEnd> ; int n <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"
<S2SV_ModStart> ) ; } attr = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> printer , job <S2SV_ModEnd> ) ; if
<S2SV_ModStart> "localhost." ) || <S2SV_ModEnd> ! strcmp (
<S2SV_ModStart> } if ( caplentoobig ) { printf ( "\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n" "Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> fd ) ; break <S2SV_ModEnd> ; } printf
<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> ui -> ft_in_start && bu
<S2SV_ModStart> , strlen ( cp <S2SV_ModEnd> ) - 1
<S2SV_ModStart> TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( "Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> jid_create ( to <S2SV_ModEnd> ) ; char
<S2SV_ModStart> ; stbbr_send ( "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>" <S2SV_ModEnd> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>" "<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"
<S2SV_ModStart> ++ ; } if ( pattern [ end ] == 0 ) break ;
<S2SV_ModStart> = Mymr_C_VIRAMA ; if ( len > 0 )
<S2SV_ModStart> endif if ( ctxt -> instate == XML_PARSER_EOF ) return ; if (
<S2SV_ModStart> NULL ) ; if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> ) ; } if ( <S2SV_ModStart> ctxt -> instate != XML_PARSER_EOF ) ctxt -> instate
<S2SV_ModStart> Browser_Window * window ; char * window_size_string = NULL <S2SV_ModStart> evas_engine_name ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> ; if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if (
<S2SV_ModStart> -> window , window_width , window_height <S2SV_ModEnd> ) ; evas_object_show
<S2SV_ModStart> if ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
<S2SV_ModStart> ; if ( ( len > 12 ) && <S2SV_ModStart> else if ( ( len > 9 ) &&
<S2SV_ModStart> DEBUG ( "snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree" ) ; snmp_free_pdu ( req <S2SV_ModStart> = NULL ; <S2SV_ModEnd> sfree ( errstr <S2SV_ModStart> ; if ( <S2SV_ModEnd> status == 0
<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , "DEADBEEF" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , "%2.0f" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & "DEADBEEF" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
<S2SV_ModStart> . data = instance -> private_key <S2SV_ModEnd> ; hash_param . <S2SV_ModStart> . len = instance -> private_key_len <S2SV_ModEnd> ; hash_slot =
<S2SV_ModStart> == * ptr && ptr [ 1 ]
<S2SV_ModStart> 0 ) { if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ; <S2SV_ModStart> 0 ) { size_t maxprec = sizeof ( work ) - 2 ; double val = p -> data . dnum ; while ( val >= 10.0 ) { val /= 10 ; maxprec -- ; } if ( prec > ( long ) maxprec ) prec = maxprec - 1 ; <S2SV_ModStart> dnum ) ; # ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ; # endif
<S2SV_ModStart> ( ) ; errors += test_float_formatting ( ) ;
<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }
<S2SV_ModStart> ( 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
<S2SV_ModStart> len -= cut + 1
<S2SV_ModStart> > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
<S2SV_ModStart> ) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> ) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> { if ( ! imapd_userisadmin ) goto badcmd ; if ( <S2SV_ModStart> ) ) { if ( ! imapd_userisadmin ) goto badcmd ;
<S2SV_ModStart> char * base <S2SV_ModEnd> = isarchive ? <S2SV_ModStart> part ) ; <S2SV_ModEnd> assert ( base
<S2SV_ModStart> if ( prefixlen <= <S2SV_ModEnd> len ) {
<S2SV_ModStart> int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> ) , got_ds64 = 0 , format_chunk <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> if ( bytecnt >= 2 <S2SV_ModStart> byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( <S2SV_ModStart> CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( <S2SV_ModStart> ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 2 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 3 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( (
<S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & bcount <S2SV_ModStart> || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line <S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , "dmmy" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
<S2SV_ModStart> NULL ; static size_t <S2SV_ModEnd> len = 0
<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
<S2SV_ModStart> } if ( strlen ( token ) > 4 &&
<S2SV_ModStart> int res ; clist * list ; <S2SV_ModStart> res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
<S2SV_ModStart> NULL , NULL ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> NULL ; } gss_release_buffer ( & min , & out ) ;
<S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } len_buf_pos <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } tmpbuf_pos <S2SV_ModStart> - 2 ; bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ;
<S2SV_ModStart> + 10 ; if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> ; } ; } ;
<S2SV_ModStart> size_t chanmap_size = SF_MIN ( <S2SV_ModStart> sf . channels , layout_tag & 0xffff )
<S2SV_ModStart> LEX_ID ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , "ID:%s" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> LEX_STR ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , "String:\'%s\'" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 10 ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ; }
<S2SV_ModStart> } else { strcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , "undefined" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> val ) ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "NaN" <S2SV_ModEnd> ) ; else <S2SV_ModStart> < 0 ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "-Infinity" <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "Infinity" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_ModStart> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; }
<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;
<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "EOF" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "ID" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "INT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "FLOAT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "STRING" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>STRING" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "REGEX" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>REGEX" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>COMMENT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str
<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if (
<S2SV_ModStart> -> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec ->
<S2SV_ModStart> ; if ( <S2SV_ModEnd> i_status != OK
<S2SV_ModStart> } } } <S2SV_ModEnd> } else {
<S2SV_ModStart> -> u1_first_slice_in_stream && <S2SV_ModEnd> ps_dec -> u4_first_slice_in_pic <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { pocstruct_t <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic == 0 <S2SV_ModEnd> ) { i1_is_end_of_poc <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { if <S2SV_ModStart> } else { prev_slice_err = 2 <S2SV_ModEnd> ; num_mb_skipped = <S2SV_ModStart> ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( <S2SV_ModStart> u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_ModEnd> { prev_slice_err = <S2SV_ModStart> ; num_mb_skipped = <S2SV_ModEnd> ( u2_first_mb_in_slice << <S2SV_ModStart> << u1_mbaff ) - <S2SV_ModEnd> ps_dec -> u2_total_mbs_coded <S2SV_ModStart> ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( <S2SV_ModEnd> ( u2_first_mb_in_slice << <S2SV_ModStart> << u1_mbaff ) <S2SV_ModEnd> < ps_dec -> <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { ret <S2SV_ModStart> ps_dec -> u4_first_slice_in_pic <S2SV_ModEnd> ) { if <S2SV_ModStart> { ps_dec -> <S2SV_ModEnd> u1_first_slice_in_stream = 0
<S2SV_ModStart> -> pu4_wts_ofsts_mat ; ps_dec -> u4_first_slice_in_pic = 0 ;
<S2SV_ModStart> buflen , buf_size - 8
<S2SV_ModStart> IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
<S2SV_ModStart> u1_level_idc , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> ! u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> -> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT (
<S2SV_ModStart> - 1 ; <S2SV_ModEnd> ps_dec -> u4_slice_start_code_found <S2SV_ModStart> ps_dec ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } }
<S2SV_ModStart> WORD32 ret ; UNUSED ( u1_is_idr_slice ) ; <S2SV_ModStart> = u2_frame_num ; <S2SV_ModEnd> { WORD32 i
<S2SV_ModStart> dec_struct_t * ps_dec <S2SV_ModEnd> ) { dec_slice_params_t <S2SV_ModStart> ; WORD32 ret <S2SV_ModEnd> ; { dec_err_status_t <S2SV_ModStart> return ret ; <S2SV_ModEnd> H264_MUTEX_UNLOCK ( &
<S2SV_ModStart> if ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! <S2SV_ModStart> u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( u1_field_pic_flag
<S2SV_ModStart> pv_api_op ) { ih264d_create_ip_t * ps_create_ip ; <S2SV_ModStart> ; WORD32 ret ; ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip <S2SV_ModStart> = 0 ; dec_hdl = NULL ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> IV_FAIL == ret <S2SV_ModStart> == ret ) { if ( dec_hdl ) { if ( dec_hdl -> pv_codec_handle <S2SV_ModEnd> ) { ih264d_free_static_bufs <S2SV_ModStart> dec_hdl ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ; } }
<S2SV_ModStart> -> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps = 0
<S2SV_ModStart> * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t *
<S2SV_ModStart> return ret ; if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } }
<S2SV_ModStart> ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> } i1_is_end_of_poc = 1 ; <S2SV_ModEnd> ps_dec -> ps_dec_err_status <S2SV_ModStart> &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_ModEnd> } u1_mbaff =
<S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if
<S2SV_ModStart> MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT ( <S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } ps_seq <S2SV_ModStart> ps_seq ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; if ( <S2SV_ModStart> u1_is_valid ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u2_frame_num = <S2SV_ModStart> 65535 ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT ( <S2SV_ModStart> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; s_tmp_poc . <S2SV_ModStart> MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u1_redundant_pic_cnt =
<S2SV_ModStart> 128 , size + EXTRA_BS_OFFSET
<S2SV_ModStart> 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0xff == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> 0 == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> { ps_dec ->
<S2SV_ModStart> while ( bin && ( numones <= 16 ) <S2SV_ModStart> numones -= 1 <S2SV_ModEnd> ; if (
<S2SV_ModStart> cu_qp_delta_abs ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> + 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <S2SV_ModStart> = value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
<S2SV_ModStart> ) { WORD32 tu_coeff_data_reset_size ; <S2SV_ModEnd> ps_codec -> s_parse <S2SV_ModStart> i4_pic_pu_idx = i4_pic_pu_idx <S2SV_ModEnd> ; tu_coeff_data_reset_size = <S2SV_ModStart> ) pu1_tu_coeff_data ; ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> ; ps_codec -> <S2SV_ModStart> } else { ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> ; } if
<S2SV_ModStart> pv_api_op ) { ihevcd_cxa_create_ip_t * ps_create_ip ; <S2SV_ModStart> * ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ; <S2SV_ModStart> = 0 ; ps_codec_obj = NULL ; <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( IV_FAIL == <S2SV_ModStart> == ret ) { if <S2SV_ModEnd> ( NULL != <S2SV_ModStart> != ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle <S2SV_ModStart> ps_codec_obj ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } }
<S2SV_ModStart> 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> ; WORD32 slice_address ; WORD32 prev_slice_incomplete_flag = 0 <S2SV_ModStart> i4_pic_present ) { prev_slice_incomplete_flag = 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) ; prev_slice_incomplete_flag = 1 ; ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) <S2SV_ModEnd> ; ps_slice_hdr_prev -> <S2SV_ModStart> ; } } if ( prev_slice_incomplete_flag ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; }
<S2SV_ModStart> { ps_codec -> <S2SV_ModEnd> pu1_inp_bitsbuf += (
<S2SV_ModStart> ; WORD32 i , j <S2SV_ModStart> ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> -> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF )
<S2SV_ModStart> { WORD32 i , j <S2SV_ModStart> ; for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> -> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF )
<S2SV_ModStart> max_dpb_size ++ ; ps_codec -> i4_max_dpb_size = max_dpb_size ;
<S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; } <S2SV_ModStart> = 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> u4_payload_size ) ; }
<S2SV_ModStart> } else { ret = <S2SV_ModStart> ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; }
<S2SV_ModStart> { ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; ps_codec ->
<S2SV_ModStart> u4_ofst ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; }
<S2SV_ModStart> ) ) { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> } } { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> default_ctxt ) { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> } else { ret = <S2SV_ModStart> au1_ctxt_models_sync ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> end_of_slice_flag ) ; ps_codec -> i4_slice_error = 0 ;
<S2SV_ModStart> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> -> i1_num_tile_columns > max_tile_cols <S2SV_ModEnd> ) || ( <S2SV_ModStart> -> i1_num_tile_rows > max_tile_rows <S2SV_ModEnd> ) ) return
<S2SV_ModStart> , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; } <S2SV_ModStart> , u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; }
<S2SV_ModStart> 0 ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
<S2SV_ModStart> ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec ->
<S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }
<S2SV_ModStart> u2_decode_header ) && ( <S2SV_ModStart> bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done )
<S2SV_ModStart> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; } ps_dec
<S2SV_ModStart> = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
<S2SV_ModStart> = u2_height ; } else { <S2SV_ModStart> == ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <S2SV_ModEnd> ; } else <S2SV_ModStart> if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH <S2SV_ModEnd> ) || ( <S2SV_ModStart> ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <S2SV_ModEnd> ; } else <S2SV_ModStart> ; return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS
<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
<S2SV_ModStart> 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
<S2SV_ModStart> i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> ) ; NLSF_Q15
<S2SV_ModStart> break ; } w = d_w ; h = d_h ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; if ( ! img ) { img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { uint64_t alloc_size ; <S2SV_ModStart> : s ; <S2SV_ModEnd> alloc_size = (
<S2SV_ModStart> - 1 ) { <S2SV_ModStart> - 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; }
<S2SV_ModStart> # if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads ( pbi
<S2SV_ModStart> -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_post <S2SV_ModStart> -> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { sem_destroy <S2SV_ModStart> = NULL ; vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;
<S2SV_ModStart> int i ; <S2SV_ModEnd> vpx_free ( pbi <S2SV_ModStart> -> mt_yabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_uabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_vabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_yleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_uleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_vleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x_e , x_f <S2SV_ModEnd> ; WORD32 n0 <S2SV_ModStart> x0 ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> y1 [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> y3 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 [ <S2SV_ModStart> [ h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; } x0
<S2SV_ModStart> , fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , yt0_0 <S2SV_ModStart> , yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , xh1_0 <S2SV_ModStart> ; xh0_0 = ( WORD64 ) x_0 + ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xl0_0 <S2SV_ModStart> ; xl0_0 = ( WORD64 ) x_0 - ( WORD64 ) <S2SV_ModEnd> x_l1_0 ; xh20_0 <S2SV_ModStart> ; xh20_0 = ( WORD64 ) x_h2_0 + ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; xl20_0 <S2SV_ModStart> ; xl20_0 = ( WORD64 ) x_h2_0 - ( WORD64 ) <S2SV_ModEnd> x_l2_0 ; x <S2SV_ModStart> 0 ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 = <S2SV_ModStart> ; xt0_0 = ( WORD64 ) xh0_0 - ( WORD64 ) <S2SV_ModEnd> xh20_0 ; x_1 <S2SV_ModStart> ; xh1_0 = ( WORD64 ) x_1 + ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xl1_0 <S2SV_ModStart> ; xl1_0 = ( WORD64 ) x_1 - ( WORD64 ) <S2SV_ModEnd> x_l1_1 ; xh21_0 <S2SV_ModStart> ; xh21_0 = ( WORD64 ) x_h2_1 + ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; xl21_0 <S2SV_ModStart> ; xl21_0 = ( WORD64 ) x_h2_1 - ( WORD64 ) <S2SV_ModEnd> x_l2_1 ; x <S2SV_ModStart> 1 ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 = <S2SV_ModStart> ; yt0_0 = ( WORD64 ) xh1_0 - ( WORD64 ) <S2SV_ModEnd> xh21_0 ; xt1_0 <S2SV_ModStart> ; xt1_0 = ( WORD64 ) xl0_0 + ( WORD64 ) <S2SV_ModEnd> xl21_0 ; xt2_0 <S2SV_ModStart> ; xt2_0 = ( WORD64 ) xl0_0 - ( WORD64 ) <S2SV_ModEnd> xl21_0 ; yt2_0 <S2SV_ModStart> ; yt2_0 = ( WORD64 ) xl1_0 + ( WORD64 ) <S2SV_ModEnd> xl20_0 ; yt1_0 <S2SV_ModStart> ; yt1_0 = ( WORD64 ) xl1_0 - ( WORD64 ) <S2SV_ModEnd> xl20_0 ; mul_11
<S2SV_ModStart> ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i1 , <S2SV_ModStart> ; treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i2 ,
<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
<S2SV_ModStart> ; if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> ( synth_buf_r ,
<S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ) ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> & ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ; break ; <S2SV_ModEnd> } } if <S2SV_ModStart> 1 ; } }
<S2SV_ModStart> } else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
<S2SV_ModStart> = port & USHRT_MAX <S2SV_ModEnd> ; * str
<S2SV_ModStart> * pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( "b/34031018,<S2SV_blank>stackPtr(%d)" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , "34031018" ) ; <S2SV_ModEnd> return EAS_ERROR_FILE_FORMAT ; <S2SV_ModStart> return EAS_ERROR_FILE_FORMAT ; }
<S2SV_ModStart> book -> dim && i < n
<S2SV_ModStart> book -> dim && i < n <S2SV_ModStart> book -> dim && i < n
<S2SV_ModStart> goto errout ; int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; }
<S2SV_ModStart> * zone ; size_t tilemap_size ; <S2SV_ModStart> . height ; tilemap_size = <S2SV_ModEnd> x_size * y_size <S2SV_ModStart> struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
<S2SV_ModStart> available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> -> d_memory , original_length <S2SV_ModEnd> ) ; qp
<S2SV_ModStart> buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer -> <S2SV_ModStart> , buffer -> data , buffer -> <S2SV_ModStart> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data + <S2SV_ModStart> -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
<S2SV_ModStart> ; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
<S2SV_ModStart> ) ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( "Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; side_closed ( side ) ; break ; }
<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
<S2SV_ModStart> * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
<S2SV_ModStart> ) pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , "63662938" ) ; return - EINVAL ; }
<S2SV_ModStart> value ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> ret ) ; } if ( error == NULL ) <S2SV_ModEnd> if ( verify <S2SV_ModStart> verify ) ; <S2SV_ModEnd> } table =
<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( h2o_http2_conn_t <S2SV_ModStart> conn ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> parse_input ( h2o_http2_conn_t <S2SV_ModStart> ) ; } return <S2SV_ModStart> ( conn ) <S2SV_ModEnd> ; } h2o_buffer_consume <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> sock ) ; return 0 ;
<S2SV_ModStart> if ( param2 < 0 || param2 <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32438598" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32436341" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32247948" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; }
<S2SV_ModStart> -> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,
<S2SV_ModStart> , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> principal ) , tgt_realm <S2SV_ModEnd> ) ; if
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_row_idx <S2SV_ModStart> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx <S2SV_ModStart> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> sr ) { <S2SV_ModEnd> uint16_t StructSize ; <S2SV_ModStart> ) ; } smb_ofile_flush ( sr , <S2SV_ModEnd> sr -> fid_ofile <S2SV_ModStart> sr -> fid_ofile <S2SV_ModEnd> ) ; (
<S2SV_ModStart> ) ; } smb_ofile_flush <S2SV_ModEnd> ( sr , <S2SV_ModStart> f_mutex ) ; smb_ofile_flush <S2SV_ModEnd> ( sr ,
<S2SV_ModStart> , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit (
<S2SV_ModStart> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ch , seq , size << 3
<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> INTERNAL_NODE ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset
<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> NYT , fout , maxoffset <S2SV_ModStart> NULL , fout , maxoffset
<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> node , fout , maxoffset <S2SV_ModStart> child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }
<S2SV_ModStart> , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> msg -> bit , msg -> cursize << 3 <S2SV_ModStart> ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }
<S2SV_ModStart> ( msg -> overflowed ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> { if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> & 7 ; if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> msg -> bit , msg -> maxsize << 3 <S2SV_ModStart> 8 ) ; if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; }
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ( & t ) ; if ( tm == NULL ) return g_strdup ( "???"
<S2SV_ModStart> NICK_REC * list , * newlist <S2SV_ModStart> list == nick ) { newlist = <S2SV_ModEnd> nick -> next <S2SV_ModStart> nick -> next ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { newlist = list ; <S2SV_ModStart> next ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }
<S2SV_ModStart> ; signal_remove ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
<S2SV_ModStart> read_settings ) ; signal_add ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;
<S2SV_ModStart> VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load <S2SV_ModStart> out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> "Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type" ) ; goto done ; <S2SV_ModStart> , "Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images" ) ; goto done
<S2SV_ModStart> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>image<S2SV_blank>dimensions" ) ; goto done ; }
<S2SV_ModStart> svbranch . len + 1
<S2SV_ModStart> \'"\' ) { char * p = end = <S2SV_ModEnd> * value + <S2SV_ModStart> value + 1 ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'"\' ) break ; } p ++ ; end ++ ; } if ( * end != \'"\' <S2SV_ModEnd> ) { DBG <S2SV_ModStart> '\\0' ; end = ++ p <S2SV_ModEnd> ; } else
<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
<S2SV_ModStart> , valsz , "<S2SV_blank>\\\\\\"\'$`<>" <S2SV_ModEnd> ) ; fputs <S2SV_ModStart> , valsz , "\\"\\\\" ) ; fputs ( "\\"" <S2SV_ModEnd> , stdout )
<S2SV_ModStart> * tmpname , const <S2SV_ModStart> char * dir , const char * prefix <S2SV_ModStart> * localtmp ; const <S2SV_ModStart> , rc ; <S2SV_ModEnd> tmpenv = dir <S2SV_ModStart> tmpenv = dir ? dir : <S2SV_ModEnd> getenv ( "TMPDIR" <S2SV_ModStart> ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> rc = asprintf <S2SV_ModStart> , tmpenv , prefix <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ctl -> pw , ".chfn"
<S2SV_ModStart> setpwnam ( pw , ".chsh"
<S2SV_ModStart> passwd * pwd , const char * prefix <S2SV_ModStart> = NULL ; <S2SV_ModEnd> pw_init ( ) <S2SV_ModStart> & tmpname , "/etc" , prefix <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , "/etc" , ".vipw" <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> file ) ; int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , "maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n" ) ; return 1 ; }
<S2SV_ModStart> goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
<S2SV_ModStart> code == gcode && wordlist [ key ] . index >= 0
<S2SV_ModStart> ; } } if ( * state != CCS_START )
<S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 <S2SV_ModStart> ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT
<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
<S2SV_ModStart> CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> low ) ; }
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> = 0 ; last_name = 0 ;
<S2SV_ModStart> ) { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG )
<S2SV_ModStart> krb5_key_data * key_data = NULL ; if ( n_key_data < <S2SV_ModEnd> 0 ) return <S2SV_ModStart> ; if ( key_data <S2SV_ModEnd> == NULL ) <S2SV_ModStart> = 0 ; ret [ i ] != NULL <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) <S2SV_ModEnd> free ( ret
<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : "" ;
<S2SV_ModStart> if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
<S2SV_ModStart> krb5_data null_server ; krb5_data d ; <S2SV_ModStart> retval ) ; d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> if ( appl_version != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> ) { problem
<S2SV_ModStart> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
<S2SV_ModStart> objp ) ; * objp = NULL ;
<S2SV_ModStart> tl2 ; } * tl_data_head = NULL ;
<S2SV_ModStart> out_buf ) ; <S2SV_ModEnd> XDR_DESTROY ( &
<S2SV_ModStart> ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> KADM5_POLICY ) && entry -> policy == NULL <S2SV_ModEnd> ) return KADM5_BAD_MASK <S2SV_ModStart> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart> ) return KADM5_BAD_MASK <S2SV_ModEnd> ; ret =
<S2SV_ModStart> ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> KADM5_POLICY ) && entry -> policy == NULL <S2SV_ModEnd> ) return KADM5_BAD_MASK <S2SV_ModStart> ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> ; if (
<S2SV_ModStart> kret = 0 ; if ( sprinc == NULL ) return NULL
<S2SV_ModStart> ; if ( password == NULL ||
<S2SV_ModStart> if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> goto cleanup ; <S2SV_ModStart> cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ;
<S2SV_ModStart> if ( rep != NULL && rep <S2SV_ModStart> . data = ( char * )
<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
<S2SV_ModStart> NULL ; char <S2SV_ModEnd> * strval [ <S2SV_ModStart> FALSE ; krb5_boolean <S2SV_ModEnd> establish_links = FALSE <S2SV_ModStart> TRUE ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> ntrees ) ; <S2SV_ModStart> ( st ) <S2SV_ModEnd> goto cleanup ;
<S2SV_ModStart> == NULL ) return retval <S2SV_ModEnd> ; status = <S2SV_ModStart> = 0 ; <S2SV_ModEnd> X509_NAME_free ( is
<S2SV_ModStart> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) <S2SV_ModStart> goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> subject_dn <S2SV_ModStart> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> issuer_dn <S2SV_ModStart> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans
<S2SV_ModStart> errcode != 0 && state -> status == NULL ) state -> status = "UNKNOWN_REASON" <S2SV_ModEnd> ; au_state ->
<S2SV_ModStart> ; cleanup : if ( status == NULL ) status = "UNKNOWN_REASON" <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_FOR_USER" ; return code ; } <S2SV_ModEnd> code = verify_for_user_checksum
<S2SV_ModStart> ) ) { * status = "INVALID_S4U2PROXY_OPTIONS" ; <S2SV_ModStart> ) ) { * status = "EVIDENCE_TICKET_MISMATCH" ;
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_S4U_X509_USER" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
<S2SV_ModStart> ) ) { int len <S2SV_ModEnd> ; char * <S2SV_ModStart> if ( ! ( hdr -> filename = fn ) ) <S2SV_ModEnd> return MSPACK_ERR_NOMEMORY ; <S2SV_ModStart> return MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( hdr <S2SV_ModStart> { if ( ( len = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> ; if ( ( len = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn --
<S2SV_ModStart> chm -> index_root >= <S2SV_ModEnd> chm -> num_chunks <S2SV_ModStart> goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;
<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out , * p <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> while ( * <S2SV_ModStart> * fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname ++ <S2SV_ModStart> fname ++ ; strcpy ( out , ( * fname ) ? fname : "x" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
<S2SV_ModStart> goto chunk_end ; <S2SV_ModEnd> name = p <S2SV_ModStart> ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> numFiles * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> * p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
<S2SV_ModStart> ; if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> outbuff ) - 128 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , "Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n" ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue ; <S2SV_ModStart> if ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> else if ( temp_buffer >= 0x120 &&
<S2SV_ModStart> ; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret
<S2SV_ModStart> '[' ) { size_t <S2SV_ModEnd> len ; if <S2SV_ModStart> } len = <S2SV_ModEnd> ( cp - <S2SV_ModStart> ( len > <S2SV_ModEnd> sizeof ( buf
<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;
<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom
<S2SV_ModStart> -> dp ; if ( dp -> pos < 0 || dp -> pos >= dp -> realSize ) { return 0 ; } <S2SV_ModStart> remain ; } if ( dp -> pos + rlen > dp -> realSize ) { rlen = dp -> realSize - dp -> pos ; }
<S2SV_ModStart> if ( remain <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> { if ( buffer_caret + pixel_block_size > rle_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } if (
<S2SV_ModStart> ( ) { check_file ( "heap_overflow_1.tga" ) ; check_file ( "heap_overflow_2.tga" <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * res ; size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> u < line_length <S2SV_ModStart> u ++ ) <S2SV_ModEnd> { res -> <S2SV_ModStart> ) gdMalloc ( weights_size ) ; if ( <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> int i ; <S2SV_ModEnd> for ( i <S2SV_ModStart> 0 ; i < <S2SV_ModEnd> u ; i
<S2SV_ModStart> border < 0 || color < 0 <S2SV_ModStart> { return ; } if ( ! im -> trueColor ) { if ( ( color > ( im -> colorsTotal - 1 ) ) || ( border > ( im -> colorsTotal - 1 ) ) ) { return ; }
<S2SV_ModStart> ) > image_block_size || buffer_caret + pixel_block_size > rle_size <S2SV_ModStart> ) > image_block_size || buffer_caret + ( encoded_pixels * pixel_block_size ) > rle_size
<S2SV_ModStart> = GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> += 3 ; len -= 3 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '<S2SV_blank>' , len <S2SV_ModStart> = '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> + 1 ; len -= 1 ; <S2SV_ModStart> ( ptr = memchr <S2SV_ModEnd> ( line , <S2SV_ModStart> line , '\\n' , len
<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
<S2SV_ModStart> ) off |= ( ( unsigned ) <S2SV_ModStart> ++ << 24UL )
<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
<S2SV_ModStart> = 0 ; # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) <S2SV_ModEnd> * delta ++ <S2SV_ModStart> delta ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x04 ) ADD_DELTA ( off , 16UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x08 ) ADD_DELTA ( off , <S2SV_ModEnd> 24UL ) ; <S2SV_ModStart> & 0x10 ) ADD_DELTA ( len , 0UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x20 ) ADD_DELTA ( len , 8UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> & 0x40 ) ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0x10000 ; # undef ADD_DELTA
<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
<S2SV_ModStart> len = 0 , end <S2SV_ModStart> ADD_DELTA if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || base_len < end <S2SV_ModEnd> || res_sz <
<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" <S2SV_ModEnd> , __func__ )
<S2SV_ModStart> = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; do { while ( ptr < buf + len && ( * ptr == '<S2SV_blank>' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <S2SV_ModEnd> } } while
<S2SV_ModStart> filestats ) ; if ( filestats . st_size < 8 ) { printf ( "ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n" ) ; return - 1 ; }
<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> -> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> -> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ( szFileName , pszFileName , <S2SV_ModStart> ) - 5 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> = - 1 <S2SV_ModStart> 1 , ret <S2SV_ModEnd> ; bool grab_newname <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , getpid <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } fd <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , pid <S2SV_ModStart> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>" "user<S2SV_blank>IDs:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> setns ( fd <S2SV_ModStart> ( fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( fd <S2SV_ModStart> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>" "the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> if ( ! ifindex ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( "Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n" , ret , <S2SV_ModEnd> oldname , * <S2SV_ModStart> * newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> [ IFNAMSIZ ] ; char <S2SV_ModEnd> * namep = <S2SV_ModStart> ) ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } * <S2SV_ModStart> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> setns ( ofd <S2SV_ModStart> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>" "of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> ofd ) ; <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> ipc_socket ; <S2SV_ModEnd> lxc_attach_options_t * options <S2SV_ModStart> int fd ; int lsm_labelfd ; <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>" "that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> "privileges." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ( "PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>" "gainable<S2SV_blank>privileges." ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> ( lsm_set_label_at ( lsm_labelfd <S2SV_ModEnd> , on_exec , <S2SV_ModStart> 0 ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> "Loading<S2SV_blank>seccomp<S2SV_blank>policy" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> lxc_proc_put_context_info ( init_ctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> rexit ( payload
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec <S2SV_ModStart> * lsm_label ) { int fret <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; const char <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ( write ( lsm_labelfd <S2SV_ModEnd> , command , <S2SV_ModStart> { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s." , command ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , command ) ; } else if ( strcmp ( name , "SELinux" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label" ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , lsm_label ) ; } else <S2SV_ModEnd> { ERROR ( <S2SV_ModStart> name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free <S2SV_ModStart> ; if ( lsm_labelfd <S2SV_ModEnd> != - 1 <S2SV_ModStart> ) close ( lsm_labelfd <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> signed long personality <S2SV_ModStart> pid ) { int procfd = - 1 ; <S2SV_ModStart> cleanup_error ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc." <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( status ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } <S2SV_ModStart> ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>" "from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>" "initialization<S2SV_blank>(2):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> |= CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = lxc_attach_to_ns <S2SV_ModStart> = exec_payload , <S2SV_ModEnd> } ; pid
<S2SV_ModStart> tmp ) { goto softfail <S2SV_ModEnd> ; } case <S2SV_ModStart> ) ) { goto softfail <S2SV_ModEnd> ; } state <S2SV_ModStart> end ) ; softfail : state -> offset = 0 ;
<S2SV_ModStart> 3 * len + 8
<S2SV_ModStart> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ; jpc_pchg_t
<S2SV_ModStart> int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> v = 0
<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
<S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd <S2SV_ModStart> i ] ) ) <S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd <S2SV_ModStart> ] ) ) )
<S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl ->
<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( "warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>" "(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )
<S2SV_ModStart> numlvls > 0 && jas_seq2d_size ( a )
<S2SV_ModStart> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> actualnumcolors = hdr
<S2SV_ModStart> = 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( image <S2SV_ModStart> ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = <S2SV_ModStart> EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> i ) { if ( ! ( <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> char * buf <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ) ) ) && bufsize

<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( buf = jas_alloc3 <S2SV_ModEnd> ( bufsize , <S2SV_ModStart> ( bufsize , JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
<S2SV_ModStart> ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
<S2SV_ModStart> long n ; image = 0 ; info = 0 ; <S2SV_ModStart> "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>" "mincolors<S2SV_blank>%ld\\n" , JAS_CAST ( long <S2SV_ModEnd> , info -> <S2SV_ModStart> info -> len ) , JAS_CAST ( long <S2SV_ModStart> info -> width ) , JAS_CAST ( long <S2SV_ModStart> info -> height ) , JAS_CAST ( long <S2SV_ModStart> info -> numplanes ) , JAS_CAST ( long , <S2SV_ModEnd> info -> depth <S2SV_ModStart> info -> depth ) , JAS_CAST ( long <S2SV_ModStart> info -> enctype ) , JAS_CAST ( long <S2SV_ModStart> info -> siz ) , JAS_CAST ( long <S2SV_ModStart> info -> hres ) , JAS_CAST ( long <S2SV_ModStart> info -> vres ) , JAS_CAST ( long , <S2SV_ModEnd> info -> numcolors <S2SV_ModStart> info -> numcolors ) , JAS_CAST ( long <S2SV_ModStart> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; goto error ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModStart> info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> image ) ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> inmem ) ? jas_stream_memopen2 <S2SV_ModEnd> ( 0 ,
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble" ) ; }
<S2SV_ModStart> bufsize ) { char * new_buf ; size_t new_bufsize <S2SV_ModEnd> ; JAS_DBGLOG ( <S2SV_ModStart> ; if ( bufsize < 0 ) { jas_deprecated ( "negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( "Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n" ) ; jas_deprecated ( "A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>" "jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n" ) ; } <S2SV_ModEnd> if ( bufsize <S2SV_ModStart> 0 ) { new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { new_bufsize <S2SV_ModEnd> = bufsize ; <S2SV_ModStart> = bufsize ; new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write" ) ; }
<S2SV_ModStart> cnt ) { ssize_t <S2SV_ModEnd> n ; assert
<S2SV_ModStart> * m , size_t <S2SV_ModEnd> bufsize ) { <S2SV_ModStart> * buf ; <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( "mem_resize(%p,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , m , <S2SV_ModStart> ) ) ; if ( ! bufsize ) { jas_eprintf ( "mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n" "This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n" ) ; }
<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG
<S2SV_ModStart> cnt ) { size_t <S2SV_ModEnd> n ; int <S2SV_ModStart> ) obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; assert <S2SV_ModStart> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( "new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n" ) ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> ; } } JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }
<S2SV_ModStart> char * fmtname ; int debug <S2SV_ModStart> = 0 ; debug = 0 ; <S2SV_ModStart> break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> ; } } jas_setdbglevel ( debug ) ; <S2SV_ModStart> ) ) { jas_stream_close ( instream ) ;
<S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>" "mincolors<S2SV_blank>%d\\n" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;
<S2SV_ModStart> v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 )
<S2SV_ModStart> 101 , ( "jas_malloc(%zu)\\n" <S2SV_ModEnd> , size )
<S2SV_ModStart> 101 , ( "jas_realloc(%x,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , ptr ,
<S2SV_ModStart> int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> 0 ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } matrix <S2SV_ModStart> -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
<S2SV_ModStart> -> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )

<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> x % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) <S2SV_ModStart> y % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )

<S2SV_ModStart> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n" ) ; return - 1 ; } if (

<S2SV_ModStart> info = boxinfo <S2SV_ModEnd> ; box -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" <S2SV_ModStart> ( tmpstream ) ; box -> ops = & boxinfo -> ops
<S2SV_ModStart> size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> 0 ] ; max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> break ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> ) ; } snprintf ( optstr , sizeof ( optstr ) , "max_samples=%-zu" , max_samples ) ; <S2SV_ModStart> , fmtid , optstr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( "format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> 0 ; } printf ( "%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n" , fmtname <S2SV_ModEnd> , numcmpts , <S2SV_ModStart> , depth , JAS_CAST ( long , <S2SV_ModEnd> jas_image_rawsize ( image <S2SV_ModStart> jas_image_rawsize ( image )
<S2SV_ModStart> size_t j ; jas_uchar <S2SV_ModEnd> * dp ;
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if <S2SV_ModStart> - JAS_CAST ( jas_longlong <S2SV_ModEnd> , ( ( <S2SV_ModStart> : JAS_CAST ( jas_longlong <S2SV_ModEnd> , tmp )
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> * val ) <S2SV_ModStart> int c ; jas_ulonglong <S2SV_ModEnd> v ; v
<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,
<S2SV_ModStart> int n , jas_longlong <S2SV_ModEnd> val ) { <S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; tmp
<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
<S2SV_ModStart> 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }
<S2SV_ModStart> * cmpt ; size_t size ; <S2SV_ModStart> tileheight ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> numhtiles <S2SV_ModStart> dec -> numhtiles , <S2SV_ModEnd> dec -> numvtiles <S2SV_ModStart> dec -> numvtiles , & size <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( "numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }
<S2SV_ModStart> jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" <S2SV_ModStart> 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" ) ; return - 1 ; }
<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
<S2SV_ModStart> len = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) <S2SV_ModStart> ) ) { box -> ops = & jp2_boxinfo_unk . ops ;
<S2SV_ModStart> { jas_eprintf ( "got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n" <S2SV_ModEnd> , box ->
<S2SV_ModStart> ( box = jp2_box_create0 ( <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 0 ; } <S2SV_ModEnd> box -> type
<S2SV_ModStart> ( box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( jp2_getuint32 <S2SV_ModStart> 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>" "type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%" PRIuFAST32 "\\n" <S2SV_ModEnd> , \'"\' , <S2SV_ModStart> 1 ) { JAS_DBGLOG ( 10 , ( "big<S2SV_blank>length\\n" ) ) ;
<S2SV_ModStart> ) ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ;
<S2SV_ModStart> unsigned int i ; bpcc -> bpcs = 0
<S2SV_ModStart> unsigned int channo ; cdef -> ents = 0
<S2SV_ModStart> unsigned int i ; cmap -> ents = 0
<S2SV_ModStart> = 0 ; pclr -> bpc = 0 ;
<S2SV_ModStart> -> prcwidthexpn + <S2SV_ModEnd> picomp -> numrlvls <S2SV_ModStart> -> prcheightexpn + <S2SV_ModEnd> picomp -> numrlvls
<S2SV_ModStart> uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( "reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( "tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( "number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( "XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( "YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( "XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( "YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if
<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
<S2SV_ModStart> 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> n ) ; if ( n == 0 ) { <S2SV_ModStart> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;
<S2SV_ModStart> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
<S2SV_ModStart> base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> } else { # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> return HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif
<S2SV_ModStart> + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
<S2SV_ModStart> Lut ) ; Lut = NULL ; <S2SV_ModStart> ; Error : if ( Lut != NULL )
<S2SV_ModStart> len - o - 4
<S2SV_ModStart> "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test59.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ;
<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
<S2SV_ModStart> -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> , c ) ; status = c -> status <S2SV_ModStart> ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_RUNNING <S2SV_ModStart> == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED <S2SV_ModStart> ) ; } old_c <S2SV_ModEnd> -> status = <S2SV_ModStart> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED <S2SV_ModStart> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( vmexec
<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE
<S2SV_ModStart> * s && ( <S2SV_ModStart> s != \'\\"\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )
<S2SV_ModStart> , s + 2 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n" )
<S2SV_ModStart> [ LONG_STRING ] = "" <S2SV_ModStart> ( line , "%1023s<S2SV_blank>" <S2SV_ModEnd> ANUM "<S2SV_blank>" ANUM <S2SV_ModStart> ANUM "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%8191[^\\n]" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , "Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n" , line ) ; <S2SV_ModStart> return 0 ; }
<S2SV_ModStart> ) ) { if ( dlen < 2 ) break ; <S2SV_ModStart> dlen -= 2 <S2SV_ModEnd> ; * pt
<S2SV_ModStart> buf + 2 , sizeof ( obuf )
<S2SV_ModStart> buf + 2 , sizeof ( buf2 ) <S2SV_ModStart> buf + 2 , sizeof ( buf2 )
<S2SV_ModStart> char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;
<S2SV_ModStart> ENCBASE64 ) { const int olen = <S2SV_ModEnd> 3 * len <S2SV_ModStart> 4 + 1 ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> out , it , olen
<S2SV_ModStart> buffer , encoded , sizeof ( buffer )
<S2SV_ModStart> out2 , out1 , sizeof ( out2 ) <S2SV_ModStart> out2 , out1 , sizeof ( out2 )
<S2SV_ModStart> 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
<S2SV_ModStart> ImapMbox mx ; size_t len = 0 ; <S2SV_ModStart> errstr ) ; len = <S2SV_ModStart> mbox ) , "%smailboxes<S2SV_blank>" <S2SV_ModEnd> , subscribe ? <S2SV_ModStart> "" : "un" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data )
<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
<S2SV_ModStart> char ) ) ; if ( fc . messages == NULL ) return - 1
<S2SV_ModStart> ; dlen -= 3 <S2SV_ModEnd> ; for (
<S2SV_ModStart> account . user , false <S2SV_ModStart> account . pass , false
<S2SV_ModStart> list . name , true
<S2SV_ModStart> p . str , false <S2SV_ModStart> ) , delim , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false
<S2SV_ModStart> dlen , buf , false
<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *
<S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.zshrc" , <S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.cshrc" , <S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.bashrc" ,
<S2SV_ModStart> "setregid" ) ; <S2SV_ModEnd> char * arg <S2SV_ModStart> 0 ] = "/bin/sh" <S2SV_ModEnd> ; arg [
<S2SV_ModStart> 0 ) { struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( "uname" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , "%d.%d" , & major , & minor ) ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , "Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>" "A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>" "Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n" , major , minor ) ; exit ( 1 ) ; }
<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) <S2SV_ModEnd> , S_IRUSR | <S2SV_ModStart> | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink
<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) <S2SV_ModEnd> , S_IRUSR | <S2SV_ModStart> | S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; unlink
<S2SV_ModStart> ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> 0 ) { copy_file_as_user ( "/etc/skel/.zshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.zshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , "%s/.cshrc" , homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_ModStart> ( is_link ( fname <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname <S2SV_ModEnd> ) ; exit <S2SV_ModStart> } if ( stat ( "/etc/skel/.cshrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.cshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.cshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , "%s/.bashrc" , homedir <S2SV_ModEnd> ) == - <S2SV_ModStart> ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( stat ( "/etc/skel/.bashrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.bashrc" , fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger <S2SV_ModStart> ; fs_logger ( "clone<S2SV_blank>/etc/skel/.bashrc" ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n" , src <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ) ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != 0 ) { <S2SV_ModEnd> fprintf ( stderr <S2SV_ModStart> ( stderr , "Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> fs_logger2 ( "clone" <S2SV_ModStart> "clone" , dest <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( stderr , "Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" ) ; return 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> ( src , <S2SV_ModEnd> dest , getuid <S2SV_ModStart> getgid ( ) , 0600 ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> S_IWUSR ) ; <S2SV_ModEnd> fs_logger2 ( "clone" <S2SV_ModStart> "clone" , dest <S2SV_ModEnd> ) ; unlink
<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> S_IWUSR ) ; <S2SV_ModEnd> fs_logger2 ( "clone" <S2SV_ModStart> "clone" , dest <S2SV_ModEnd> ) ; unlink
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.zshrc" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( "clone<S2SV_blank>/etc/skel/.zshrc" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.cshrc" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( "clone<S2SV_blank>/etc/skel/.cshrc" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( "/etc/skel/.bashrc" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( "clone<S2SV_blank>/etc/skel/.bashrc" <S2SV_ModStart> ) ; } <S2SV_ModEnd> free ( fname
<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> 0644 ) ; <S2SV_ModEnd> fs_logger2 ( "clone" <S2SV_ModStart> "clone" , dest <S2SV_ModEnd> ) ; return
<S2SV_ModStart> 0 ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> 0600 ) ; <S2SV_ModEnd> fs_logger2 ( "clone" <S2SV_ModStart> "clone" , dest <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
<S2SV_ModStart> . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> xfr_cmd , fname <S2SV_ModEnd> ) ; free
<S2SV_ModStart> int fd , const char * cmd , const char * args_extra <S2SV_ModEnd> ) { pid_t <S2SV_ModStart> long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> ; term_remove ( <S2SV_ModStart> STO ) ; argc = 0 ; r = split_quoted <S2SV_ModEnd> ( cmd , <S2SV_ModStart> ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>command\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , "No<S2SV_blank>command<S2SV_blank>given\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , "$<S2SV_blank>%s<S2SV_blank>%s\\n" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> fd_printf ( STDERR_FILENO <S2SV_ModStart> ( STDERR_FILENO , "exec:<S2SV_blank>%s\\n" , strerror ( errno ) <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ; exit ( RUNCMD_EXEC_FAIL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "stats<S2SV_blank>%s<S2SV_blank>unrecognized" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized" , filegen_file ) ; continue ; }
<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &
<S2SV_ModStart> { char prefix <S2SV_ModEnd> ; char * <S2SV_ModStart> char * type ; switch ( <S2SV_ModEnd> ( yyvsp [ <S2SV_ModStart> . String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> + 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> ) ] . <S2SV_ModStart> String ) ) ) ; } break ; case 235 : # line 1082 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 "ntp_parser.y" { ( yyval <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) <S2SV_ModEnd> = enqueue_in_new_queue ( <S2SV_ModStart> = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] . <S2SV_ModStart> break ; case <S2SV_ModEnd> 238 : # <S2SV_ModStart> : # line 1092 <S2SV_ModEnd> "ntp_parser.y" { if <S2SV_ModStart> : # line 1100 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1101 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1105 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1116 <S2SV_ModEnd> "ntp_parser.y" { cfgt <S2SV_ModStart> : # line 1130 <S2SV_ModEnd> "ntp_parser.y" { old_config_style <S2SV_ModStart> : # line 1134 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1135 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1139 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1140 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1144 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1145 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1150 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1154 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1158 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1162 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1163 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1168 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1172 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1173 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1178 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1180 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1182 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1184 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1186 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> ; # line 3836 <S2SV_ModEnd> "ntp_parser.c" default :
<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu\\r\\n" "Content-Type:<S2SV_blank>%s/%s\\r\\n" "Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu--\\r\\n" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , "byteranges;<S2SV_blank>boundary=%llu" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd
<S2SV_ModStart> sshd_hostkey_sign ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> void ) { <S2SV_ModEnd> struct monitor * <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return mon ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } if (
<S2SV_ModStart> sshbuf * b = NULL <S2SV_ModStart> char * pkalg = NULL <S2SV_ModStart> u_char * pkblob = NULL <S2SV_ModStart> , * sig = NULL <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> r ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done <S2SV_ModStart> b ) ; <S2SV_ModEnd> auth2_record_key ( authctxt <S2SV_ModStart> ) ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } <S2SV_ModStart> ca_s ) ; free ( sig ) ;
<S2SV_ModStart> , av , "cDdksE:a:P:t:" <S2SV_ModEnd> ) ) != <S2SV_ModStart> : k_flag ++ ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( "-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> ; if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ( pledge ( "stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> stderr , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" ) ;
<S2SV_ModStart> & O_ACCMODE ) != O_RDONLY <S2SV_ModEnd> || ( flags <S2SV_ModStart> ( flags & ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ; int r , dontmax = 0 <S2SV_ModStart> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;
<S2SV_ModStart> options . disable_forwarding || ! use_privsep
<S2SV_ModStart> options . disable_forwarding && use_privsep
<S2SV_ModStart> 1 ] ; if ( len < EVP_CCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < cctx -> M ) return 0 ; <S2SV_ModStart> -> M ; }
<S2SV_ModStart> 1 ] ; if ( len < EVP_GCM_TLS_EXPLICIT_IV_LEN ) return 0 ; <S2SV_ModStart> c ) ) { if ( len < EVP_GCM_TLS_TAG_LEN ) return 0 ; <S2SV_ModStart> -= EVP_GCM_TLS_TAG_LEN ; }
<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> if ( ! SSL_WRITE_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> { if ( SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ( ! SSL_READ_ETM ( s ) && <S2SV_ModStart> ) != NULL <S2SV_ModEnd> ) ) {
<S2SV_ModStart> if ( ! SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl ) <S2SV_ModStart> send && ! SSL_READ_ETM <S2SV_ModEnd> ( ssl )
<S2SV_ModStart> ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_READ ; if ( s -> <S2SV_ModStart> } else { if ( s -> tlsext_use_etm ) s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ; else s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE ;
<S2SV_ModStart> & comp , s -> tlsext_use_etm <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( s -> tlsext_use_etm <S2SV_ModEnd> ) { if <S2SV_ModStart> ) s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; else {
<S2SV_ModStart> ; s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; # ifndef <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; else if
<S2SV_ModStart> endif s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; s -> <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; } else
<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> skey ) ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; }
<S2SV_ModStart> ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if (
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> ; default : return OFPERR_OFPGMFC_BAD_TYPE <S2SV_ModEnd> ; } switch <S2SV_ModStart> ; default : return OFPERR_OFPGMFC_BAD_COMMAND <S2SV_ModEnd> ; } if
<S2SV_ModStart> OFPERR_OFPBAC_BAD_LEN ; } else { <S2SV_ModStart> header ; } }
<S2SV_ModStart> . dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data . <S2SV_ModStart> pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( "PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( "PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> : return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; case CERT_E_UNTRUSTEDROOT : return "The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted." ; case TRUST_E_NOSIGNATURE : return "Not<S2SV_blank>digitally<S2SV_blank>signed." ; case TRUST_E_EXPLICIT_DISTRUST : return "One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."
<S2SV_ModStart> : if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> ; client -> <S2SV_ModEnd> pool = get_pool
<S2SV_ModStart> if ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> { char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> ( ! eof && vars -> str . c != vars -> ptr
<S2SV_ModStart> long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , "Bad<S2SV_blank>unserialize<S2SV_blank>data" ) ; return - 1 ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; # line 501 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE <S2SV_ModStart> : # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { return <S2SV_ModStart> } # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : <S2SV_ModStart> ; # line 869 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref <S2SV_ModStart> } # line 612 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : <S2SV_ModStart> ; # line 717 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> } # line 795 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : <S2SV_ModStart> ; # line 704 "ext/standard/var_unserializer.re" { long elements ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements <S2SV_ModEnd> ) ; } <S2SV_ModStart> } # line 833 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : <S2SV_ModStart> ; # line 683 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : <S2SV_ModStart> ; # line 648 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 931 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : <S2SV_ModStart> ; # line 615 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 985 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : <S2SV_ModStart> ; # line 605 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1083 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : <S2SV_ModStart> ; # line 590 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1157 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : <S2SV_ModStart> ; # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1211 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : <S2SV_ModStart> ; # line 556 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1226 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 : <S2SV_ModStart> ; # line 549 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1236 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : <S2SV_ModStart> ; # line 526 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1282 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : <S2SV_ModStart> ; # line 505 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1326 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } # <S2SV_ModStart> } # line 877 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0
<S2SV_ModStart> = 1 ; apr_brigade_cleanup ( brigade ) ;
<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
<S2SV_ModStart> = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> } if ( <S2SV_ModEnd> * p == <S2SV_ModStart> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash
<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
<S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> border < 0 || color < 0
<S2SV_ModStart> { char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> classes = NULL ; zval * retval <S2SV_ModStart> ; } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY
<S2SV_ModStart> ; if ( zend_hash_find <S2SV_ModEnd> ( ht ,
<S2SV_ModStart> # ifdef HAVE_IPV6 <S2SV_ModEnd> if ( * <S2SV_ModStart> 1 ) { char * <S2SV_ModStart> - 2 ) , * e = NULL <S2SV_ModStart> * portno = strtol <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> colon ) { char * e = NULL ; <S2SV_ModStart> * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( str <S2SV_ModStart> ) ; } } <S2SV_ModEnd> if ( get_err <S2SV_ModStart> NULL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
<S2SV_ModStart> ) ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> -> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;
<S2SV_ModStart> int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long <S2SV_ModStart> id_table ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table . <S2SV_ModStart> . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> xattr_id_table_start <S2SV_ModStart> ( id_table ) ) ) ) { ERROR ( "read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ) + ( ( long long )
<S2SV_ModStart> NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> size_t pathlen ; <S2SV_ModStart> '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( PR_LOG_WARNING <S2SV_ModStart> ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> size_t pathlen ; <S2SV_ModStart> '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( PR_LOG_WARNING <S2SV_ModStart> ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM
<S2SV_ModStart> ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if (
<S2SV_ModStart> ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> ; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL
<S2SV_ModStart> case 'l' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> 0 ) ; } <S2SV_ModStart> case 'i' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> 0 ) ; }
<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; }
<S2SV_ModStart> pos + 8 + 8 <S2SV_ModStart> size ; } const <S2SV_ModStart> 4 ) ) ; const int <S2SV_ModEnd> max_val = (
<S2SV_ModStart> parameters_size ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> . name ) { continue ; } <S2SV_ModEnd> if ( values
<S2SV_ModStart> || obuf_len < 1 <S2SV_ModEnd> ) { return <S2SV_ModStart> } break ; # if 0 <S2SV_ModStart> ; break ; # endif <S2SV_ModStart> length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; } <S2SV_ModStart> 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; }

<S2SV_ModStart> 1 ; } int len = to - from ; <S2SV_ModStart> = calloc ( len <S2SV_ModEnd> , 1 ) <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ; while <S2SV_ModStart> ) > 5 + rc <S2SV_ModStart> bool is_wide32 = ( <S2SV_ModStart> 2 < to ) && ( <S2SV_ModEnd> ! w [ <S2SV_ModStart> [ 4 ] )
<S2SV_ModStart> int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( <S2SV_ModStart> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ++ ) { ut32 delta = <S2SV_ModEnd> i * sizeof <S2SV_ModStart> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> ) ) ; if ( r ) { <S2SV_ModStart> ( obj , & <S2SV_ModStart> entry ) ; }
<S2SV_ModStart> , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> ; if (
<S2SV_ModStart> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( "Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( <S2SV_ModStart> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> 1 ) ; }
<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ret ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> hdr . startaddr , ( ut8 * ) image_infos , sz <S2SV_ModStart> ; dyld_vmbase = r_buf_read64le <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> = liboff ; int pfo = <S2SV_ModEnd> image_infos [ idx <S2SV_ModStart> ] . pathFileOffset ; if ( pfo < 0 || pfo <S2SV_ModStart> { eprintf ( "corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n" , pfo <S2SV_ModEnd> ) ; free <S2SV_ModStart> } libname = r_buf_read_string <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , pfo , 64 <S2SV_ModEnd> ) ; data
<S2SV_ModStart> r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||
<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , "%d<S2SV_blank>" ,
<S2SV_ModStart> sh_info && ( end - <S2SV_ModStart> * ) defs > i <S2SV_ModEnd> ) ; ++ <S2SV_ModStart> vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free
<S2SV_ModStart> == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr <S2SV_ModStart> off ) ) { <S2SV_ModStart> ) ; } } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> "Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n" ) ; } <S2SV_ModStart> offset ) ) { <S2SV_ModStart> input ) ; }
<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , "invalid<S2SV_blank>extent" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> "something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
<S2SV_ModStart> buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = (
<S2SV_ModStart> c ) { char * fpath = grub_malloc ( <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> while ( * <S2SV_ModStart> currfound = currnode ; free ( fpath ) <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> ( grub_errno ) { free ( fpath ) ; <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> oldnode , c ) ; free ( fpath <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> = type ; free ( fpath ) ; <S2SV_ModStart> next ; } free ( fpath ) ;
<S2SV_ModStart> -> device ) { <S2SV_ModStart> disk ) ; }
<S2SV_ModStart> { if ( ! disk ) { eprintf ( "oops.<S2SV_blank>no<S2SV_blank>disk\\n" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;

<S2SV_ModStart> ( ! data || len < 2 ) { <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; }
<S2SV_ModStart> ; } } return - 1 ;
<S2SV_ModStart> 0 ) { char * filename = grub_malloc ( <S2SV_ModEnd> dirent . namelen <S2SV_ModStart> namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * <S2SV_ModStart> = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc <S2SV_ModStart> ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; <S2SV_ModEnd> grub_free ( fdiro <S2SV_ModStart> closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos
<S2SV_ModStart> < INDIRECT_BLOCKS ) { <S2SV_ModStart> ] ) ; }
<S2SV_ModStart> - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> object -> list
<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
<S2SV_ModStart> 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> ; j < minsz <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ j <S2SV_ModStart> + idx ] ; r_cons_printf ( "%02x" , ch <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> val ) ; } <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> ptr ) ; } <S2SV_ModStart> - 1 ) { <S2SV_ModStart> refptr ) ; }
<S2SV_ModStart> if ( argReg > <S2SV_ModEnd> regsz ) { <S2SV_ModStart> regsz ) { return ;
<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; }
<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
<S2SV_ModStart> . string ; if ( name > 1024 ) { <S2SV_ModStart> ) ; } else { eprintf ( "Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n" , name ) ; } }
<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , "%d<S2SV_blank>" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , "%d" ,
<S2SV_ModStart> ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> len ) ; }
<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (
<S2SV_ModStart> sts ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> -> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ; if ( bin -> dyld_info ) { if ( <S2SV_ModStart> "Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n" ) ; R_FREE <S2SV_ModEnd> ( bin -> <S2SV_ModStart> ; } } }
<S2SV_ModStart> < 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free
<S2SV_ModStart> ) { i ++ <S2SV_ModEnd> ; } if
<S2SV_ModStart> = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ut32 <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false
<S2SV_ModStart> header . types_size <S2SV_ModEnd> ) { continue
<S2SV_ModStart> [ 0 ] % 6 <S2SV_ModStart> = 0x8b ; data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> | 0x5 ; } <S2SV_ModStart> >> 24 ; } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> ) { data <S2SV_ModStart> ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | <S2SV_ModEnd> op -> operands
<S2SV_ModStart> 24 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> 8 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i" , <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#04hx" , <S2SV_ModStart> # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>class+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>field+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%" PFMT64x <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>thing+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>method+%i" ,
<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart> , "anal.cpu" , <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r , binfile ) ; free ( cpu ) ; free ( arch
<S2SV_ModStart> + i ; size_t vstart_off = i ; <S2SV_ModStart> < 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> ; } vstart += vdaux ; vstart_off <S2SV_ModStart> . vda_next ; vstart_off += aux . vda_next ;
<S2SV_ModStart> filter ) ) ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> "}\\n" ) ; dot_filename = g_strdup_printf ( "/tmp/rs-filter-graph.%u" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( "%s.%u.png" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> , str -> <S2SV_ModStart> NULL ) ; command_line = g_strdup_printf ( "dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s" , png_filename , dot_filename ) ; <S2SV_ModStart> != system ( command_line <S2SV_ModEnd> ) ) g_warning <S2SV_ModStart> "Calling<S2SV_blank>dot<S2SV_blank>failed" ) ; g_free ( command_line ) ; command_line = g_strdup_printf ( "gnome-open<S2SV_blank>%s" , png_filename ) ; <S2SV_ModStart> != system ( command_line <S2SV_ModEnd> ) ) g_warning <S2SV_ModStart> g_warning ( "Calling<S2SV_blank>gnome-open<S2SV_blank>failed." ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename
<S2SV_ModStart> exfat_error ( "exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart> } if ( <S2SV_ModEnd> le64_to_cpu ( ef
<S2SV_ModStart> == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , "/dev/null/" , 2 ) ; # else <S2SV_ModStart> 2 ) ; # endif
<S2SV_ModStart> , rpmpsm psm , int exclusive <S2SV_ModStart> ( dest , exclusive ? "wx.ufdio" : "a.ufdio" <S2SV_ModEnd> ) ; umask <S2SV_ModStart> old_umask ) ; if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; }
<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,
<S2SV_ModStart> , psm , 0 ,
<S2SV_ModStart> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if (
<S2SV_ModStart> , rpmfi fi , const struct stat * fsb <S2SV_ModStart> ) ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> fpath , fi , & sb
<S2SV_ModStart> * sock , "%s" , <S2SV_ModStart> * sock , "%s" ,
<S2SV_ModStart> -> socket , "%s" , <S2SV_ModStart> -> socket , "%s" ,
<S2SV_ModStart> "auth_tag_len" ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> char * name <S2SV_ModEnd> ; name = <S2SV_ModStart> , NULL , NULL <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , server -> method ) ; else if ( manager -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf
<S2SV_ModStart> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> ; build_config ( <S2SV_ModStart> ( working_dir , manager , server ) <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , BUF_SIZE , "%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf" <S2SV_ModEnd> , executable , <S2SV_ModStart> , executable , <S2SV_ModEnd> manager -> manager_address <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port , working_dir <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port ) ;
<S2SV_ModStart> ; if ( keylen >= nodesize - rec_off <S2SV_ModEnd> ) { tsk_error_set_errno <S2SV_ModStart> , keylen , ( nodesize - rec_off ) <S2SV_ModEnd> ) ; free
<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
<S2SV_ModStart> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) == 0
<S2SV_ModStart> ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , "Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n" , tmp_dir ) ; exit ( 1 ) ; } # endif
<S2SV_ModStart> = "/tmp" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , "/w3m-XXXXXX" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
<S2SV_ModStart> 0 , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> { if ( l == NULL ) break ; if (
<S2SV_ModStart> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
<S2SV_ModStart> NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> ( len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" <S2SV_ModEnd> , len )
<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>?)" ) ) ; break ; }
<S2SV_ModStart> ND_TTEST2 ( * TPA <S2SV_ModEnd> ( ap ) <S2SV_ModStart> ( ndo , "who-has<S2SV_blank>" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>%s" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ( ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ( ndo , "who-has<S2SV_blank>" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , "at<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , "for<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>c<S2SV_blank>%04x" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
<S2SV_ModStart> ( dp [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank><%s>" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) )
<S2SV_ModStart> uint32_t ) ; ND_TCHECK <S2SV_ModEnd> ( dp [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; astat
<S2SV_ModStart> < 3 ) goto trunc ; <S2SV_ModEnd> if ( * <S2SV_ModStart> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , "Tag[%u]<S2SV_blank>" , * data ) ) ; else ND_PRINT ( ( ndo , "Tag[Unused]<S2SV_blank>" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> = 0 ; i < length && * data <S2SV_ModEnd> ; i ++
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; else <S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> , u_int length <S2SV_ModEnd> ) { if <S2SV_ModStart> { if ( ! ND_TTEST ( * p ) <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; if ( length <S2SV_ModEnd> > 1 ) <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; return
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid
<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
<S2SV_ModStart> ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , <S2SV_ModStart> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> type = "<S2SV_blank>^<S2SV_blank>" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> } trunc : ND_PRINT ( ( ndo , "[|esis]" ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> u_int tval ; u_int <S2SV_ModEnd> i ; if <S2SV_ModStart> ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u" <S2SV_ModEnd> , tval >> <S2SV_ModStart> & 0x07 ) , <S2SV_ModEnd> EXTRACT_16BITS ( tptr
<S2SV_ModStart> length ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> 4 ) ) ; if ( i + 4 + optlen > length ) return - 1
<S2SV_ModStart> 0 ; int elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> ndo -> ndo_snapend <S2SV_ModStart> ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , "<BAD<S2SV_blank>PTR>" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> i = * <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> continue ; } <S2SV_ModStart> += l ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> tmp ) { ND_TCHECK2 ( * tptr , alen ) ;
<S2SV_ModStart> uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t <S2SV_ModStart> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
<S2SV_ModStart> ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> dp -> ip6r_len <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *
<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
<S2SV_ModStart> ; if ( opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> flags & TH_SYN <S2SV_ModStart> += 4 ; opt_len -= 4 ; <S2SV_ModStart> MP_DSS_a ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> += 8 ; opt_len -= 8 ; <S2SV_ModStart> } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> += 4 ; opt_len -= 4 ; <S2SV_ModStart> MP_DSS_m ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> += 8 ; opt_len -= 8 ; <S2SV_ModStart> } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> += 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> += 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>csum<S2SV_blank>0x%x" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> == 12 && ( <S2SV_ModStart> & TH_SYN ) ) <S2SV_ModStart> == 24 && ( <S2SV_ModStart> flags & TH_ACK )
<S2SV_ModStart> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
<S2SV_ModStart> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> ; i <= sysid_len <S2SV_ModEnd> ; i ++
<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; }
<S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_length <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_type <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } switch <S2SV_ModStart> case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ndo , tptr + 1 , chassis_id_length <S2SV_ModStart> 0 ) { break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } cfm_tlv_len <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> ( ndo , "<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> cfm_tlv_len ) ; next_tlv :
<S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> p + offset <S2SV_ModEnd> , tim .
<S2SV_ModStart> 0 ) { if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> , cp ) ; if ( advance < 0 ) return <S2SV_ModStart> padlen ) ; if ( advance < 0 ) return ;
<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( dp -> <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ] & 0xc0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> 1 ] & 0x80 ) ND_PRINT ( ( ndo , "M" ) ) ; if ( dp -> icmp6_data16 [ 1 ] &
<S2SV_ModStart> + 1 ; ND_TCHECK2 ( * s , 1 ) ;
<S2SV_ModStart> case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> len ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) return ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; cp <S2SV_ModStart> ; tp -> bs_name <S2SV_ModEnd> = strdup ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
<S2SV_ModStart> static inline struct bsnamemem <S2SV_ModEnd> * lookup_bytestring ( <S2SV_ModStart> ) { struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr0 == i <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> == k && <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> ) , nlen <S2SV_ModStart> = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> = ( u_char <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> = ( struct <S2SV_ModStart> = ( struct bsnamemem <S2SV_ModEnd> * ) calloc <S2SV_ModStart> ( tp -> bs_nxt <S2SV_ModEnd> == NULL )
<S2SV_ModStart> ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; }
<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , "%sRPKI-RTRv%u<S2SV_blank>(unknown)" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , "(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> length ) ; <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( encapsulated_pdu_length <S2SV_ModStart> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ndo , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> + 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length ; <S2SV_ModStart> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length = <S2SV_ModStart> ; text_length = <S2SV_ModEnd> EXTRACT_32BITS ( tptr <S2SV_ModStart> EXTRACT_32BITS ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , "%sError<S2SV_blank>text:<S2SV_blank>" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( * <S2SV_ModStart> * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE <S2SV_ModStart> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc : <S2SV_ModStart> ; trunc : ND_PRINT ( ( ndo , "\\n\\t%s" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
<S2SV_ModStart> EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo ,
<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
<S2SV_ModStart> ++ ; } ND_TCHECK ( * p ) ;
<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> * tptr , 2 <S2SV_ModEnd> ) ) return
<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , "unknown" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> -> caplen ; u_int <S2SV_ModEnd> hdrlen ; uint16_t <S2SV_ModStart> uint8_t seq ; <S2SV_ModEnd> uint16_t panid = <S2SV_ModStart> = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ndo , p + 2 <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> ) { case <S2SV_ModStart> ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> 0 ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> char buf [ 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> ; register u_int <S2SV_ModStart> ) ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> , lp -> <S2SV_ModStart> lp -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> ; sepstr = <S2SV_ModStart> } if ( bufp == buf <S2SV_ModEnd> ) ( void
<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart> , p , h -> len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ;
<S2SV_ModStart> ( tlen < 1U +
<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> ; subtlv_spb_mcid = <S2SV_ModStart> = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> ; break ; <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID : { while ( stlv_len <S2SV_ModEnd> >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0
<S2SV_ModStart> -> header_len ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> ( pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> & pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> , "origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print (
<S2SV_ModStart> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) ND_PRINT <S2SV_ModStart> ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s" , netal , <S2SV_ModEnd> isonsap_string ( ndo
<S2SV_ModStart> , uint32_t phase _U_ <S2SV_ModStart> , int depth _U_ <S2SV_ModStart> ep ) { <S2SV_ModEnd> switch ( ntohs <S2SV_ModStart> [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) <S2SV_ModStart> ) ; } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_ModStart> ) ) ; ND_PRINT ( ( ndo , ")" ) ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; }
<S2SV_ModStart> ( ndo , "<S2SV_blank>n<S2SV_blank>len=%u" <S2SV_ModEnd> , ntohs ( <S2SV_ModStart> ; if ( ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 2 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> else if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> * ) ( <S2SV_ModEnd> ext + 1 <S2SV_ModStart> trunc ; } }
<S2SV_ModStart> ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" <S2SV_ModEnd> , len - <S2SV_ModStart> ; if ( len > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo -> ndo_vflag <S2SV_ModEnd> ) { if <S2SV_ModStart> trunc ; } }
<S2SV_ModStart> ; u_char showspi <S2SV_ModEnd> , showsomedata ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> showsomedata = 0 <S2SV_ModStart> showsomedata = 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; if ( cp < ep ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 3 <S2SV_ModEnd> || ( showsomedata <S2SV_ModStart> 30 ) ) <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> if ( showsomedata <S2SV_ModEnd> ) { if <S2SV_ModStart> goto trunc ; }
<S2SV_ModStart> length ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1
<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) ) { ND_TCHECK_8BITS ( tptr ) ;
<S2SV_ModStart> ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
<S2SV_ModStart> aodv_hello * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u" , ep -> length ) ) ; break ; }
<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
<S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) )
<S2SV_ModStart> , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> tlen = len <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> int * len , int * truncated <S2SV_ModStart> * s ; <S2SV_ModEnd> s = * <S2SV_ModStart> * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> * * pptr <S2SV_ModStart> * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> ( * pptr <S2SV_ModStart> ) -- ; <S2SV_ModEnd> return s ;
<S2SV_ModStart> = 0 ; int truncated = 0 ; <S2SV_ModStart> , & parselen , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( lose ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|zephyr]<S2SV_blank>(%d)" , length ) ) ; return ;
<S2SV_ModStart> ] , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> pptr += BGP_VPN_RD_LEN + 4
<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> ) ) ; } return ; <S2SV_ModEnd> } sport = <S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( bp ) ;
<S2SV_ModStart> ! saw_digit ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\r' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\n' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> ; trunc : * endp = bp ; <S2SV_ModStart> ; invalid : * endp = bp ;
<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> & 0xf0 ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( mh -> <S2SV_ModStart> [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ;
<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( eigrp_opcode_values , "unknown<S2SV_blank>(%u)" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
<S2SV_ModStart> const u_char * ep2 <S2SV_ModEnd> ) { int <S2SV_ModStart> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ] ) ; } if ( ep2 <S2SV_ModEnd> < p + <S2SV_ModStart> ) ; return ep2 <S2SV_ModEnd> + 1 ; <S2SV_ModStart> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> 2 ] ; if ( ! <S2SV_ModStart> , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } <S2SV_ModEnd> } else { <S2SV_ModStart> , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo <S2SV_ModStart> 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> + totlen ; trunc : return NULL ;
<S2SV_ModStart> const u_char * ep2 <S2SV_ModEnd> , const struct <S2SV_ModStart> , v ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ] ) ; } if ( ep2 <S2SV_ModEnd> < p + <S2SV_ModStart> ) ; return ep2 <S2SV_ModEnd> + 1 ; <S2SV_ModStart> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> , "value=" ) ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> ) ; else { if ( ! <S2SV_ModStart> , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } <S2SV_ModEnd> } else { <S2SV_ModStart> , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo <S2SV_ModStart> 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> + totlen ; trunc : return NULL ;
<S2SV_ModStart> , cp , ep2 <S2SV_ModEnd> , map , <S2SV_ModStart> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; }
<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u:" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , "[|ripng]" ) ) ; return ;
<S2SV_ModStart> case IPOPT_LSRR : if ( <S2SV_ModStart> , option_len ) == - 1 ) goto trunc
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> , length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ) + 4 ; ND_TCHECK ( cp [ 0 ] )
<S2SV_ModStart> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;
<S2SV_ModStart> uint16_t length ; tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart> 3 ) ; <S2SV_ModEnd> type = * <S2SV_ModStart> 1 ) ; tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart> ] , length <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case BGP_AIGP_TLV : if ( length < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> EXTRACT_64BITS ( tptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ndo , tptr <S2SV_ModEnd> , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , <S2SV_ModStart> "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length <S2SV_ModEnd> ) ; }
<S2SV_ModStart> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family (
<S2SV_ModStart> or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> circ ) ) { <S2SV_ModStart> circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> , end_reason , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; log_info <S2SV_ModStart> , END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ; connection_free
<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
<S2SV_ModStart> { rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
<S2SV_ModStart> tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( "%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }
<S2SV_ModStart> err = - <S2SV_ModEnd> EALREADY ; if <S2SV_ModStart> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> match -> type <S2SV_ModStart> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }
<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> ps ) { int i ; <S2SV_ModStart> ) ) ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , ps -> <S2SV_ModStart> -> channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
<S2SV_ModStart> long flags ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> -> node ) ; else ucounts = NULL <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void sas_destruct_devices ( <S2SV_ModStart> sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry_safe (
<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;
<S2SV_ModStart> sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry (
<S2SV_ModStart> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> dev ) ; if <S2SV_ModEnd> ( res == <S2SV_ModStart> num_phys ) ; <S2SV_ModEnd> } return res
<S2SV_ModStart> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy
<S2SV_ModStart> gone ) ; sas_destruct_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> usb_dev ; char * build <S2SV_ModEnd> ; int ret <S2SV_ModStart> ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> ) ; } kfree ( build ) ;
<S2SV_ModStart> ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;
<S2SV_ModStart> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( <S2SV_ModStart> , reg , buffer <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1000 ) ; if ( <S2SV_ModEnd> ret >= 0 <S2SV_ModStart> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> ret ; } <S2SV_ModStart> ret ; } }
<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
<S2SV_ModStart> key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( "des" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
<S2SV_ModStart> ; uint32_t backup_handle = 0 <S2SV_ModStart> ret == 0 ) { if ( <S2SV_ModEnd> res -> backup <S2SV_ModStart> goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
<S2SV_ModStart> { struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
<S2SV_ModStart> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
<S2SV_ModStart> -> map = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4
<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4
<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; print_bpf_insn ( env ,
<S2SV_ModStart> void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , <S2SV_ModEnd> insn -> dst_reg <S2SV_ModStart> -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ;
<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info . <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void )
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
<S2SV_ModStart> = { . start = link -> start , .
<S2SV_ModStart> mixer ) { if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> urb ) ; if ( mixer -> rc_urb ) <S2SV_ModStart> rc_urb ) ; mixer -> disconnected = true ;
<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
<S2SV_ModStart> head -> iov_base ; if ( hdr > head -> iov_len ) return 0
<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status
<S2SV_ModStart> int ret = proc_dointvec_minmax <S2SV_ModEnd> ( table ,
<S2SV_ModStart> , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; error = - EINVAL ; goto err_free_urb ; }
<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
<S2SV_ModStart> else { return false <S2SV_ModEnd> ; } case
<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL )
<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
<S2SV_ModStart> struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci
<S2SV_ModStart> keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> out ; } ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING "%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> ( & keyring_key <S2SV_ModStart> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; }
<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> ctx ) { <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> spin_lock ( & ctx -> <S2SV_ModStart> cancel_lock ) ; __timerfd_remove_cancel ( ctx <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> spin_unlock ( & ctx -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
<S2SV_ModStart> & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4
<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
<S2SV_ModStart> , } ; struct dentry * root = <S2SV_ModEnd> mount_pseudo ( fs_type <S2SV_ModStart> AIO_RING_MAGIC ) ; if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ;
<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }
<S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
<S2SV_ModStart> ( tag == ASN1_EOC <S2SV_ModEnd> ) { if <S2SV_ModStart> <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> > sizeof ( len <S2SV_ModEnd> ) - 1 <S2SV_ModStart> goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > <S2SV_ModStart> ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
<S2SV_ModStart> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> & amd_pinctrl_desc , <S2SV_ModStart> & amd_pinctrl_desc , <S2SV_ModEnd> gpio_dev ) ; <S2SV_ModStart> ( ret ) return ret <S2SV_ModEnd> ; ret = <S2SV_ModStart> gc ) ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> netdev_tx_t <S2SV_ModEnd> hns_nic_net_xmit_hw ( struct <S2SV_ModStart> len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;
<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
<S2SV_ModStart> 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> = 0 ; info -> port = NULL ;
<S2SV_ModStart> goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
<S2SV_ModStart> struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }
<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> "Checking<S2SV_blank>memory<S2SV_blank>size\\n" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;
<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , "invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n" ) ; break
<S2SV_ModStart> -> bInterval ; <S2SV_ModEnd> result = usb_control_msg <S2SV_ModStart> ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock
<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart> I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ; if ( state == KEY_IS_POSITIVE && <S2SV_ModEnd> key -> type <S2SV_ModStart> ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec (
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_inc <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , - error <S2SV_ModEnd> ) ; now
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( keyring )
<S2SV_ModStart> long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( <S2SV_ModStart> { if ( state < 0 ) { <S2SV_ModEnd> ctx -> result <S2SV_ModStart> = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave
<S2SV_ModStart> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key
<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
<S2SV_ModStart> if ( keyring && link_ret == 0
<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , "first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" "(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
<S2SV_ModStart> , ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> irq_srcu ) ; if <S2SV_ModEnd> ( guest_irq >= <S2SV_ModStart> irq_rt -> nr_rt_entries || hlist_empty ( <S2SV_ModEnd> & irq_rt -> <S2SV_ModStart> [ guest_irq ] ) ) { pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ]
<S2SV_ModStart> acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * <S2SV_ModStart> acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node
<S2SV_ModStart> ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen
<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
<S2SV_ModStart> ) get_block = ocfs2_lock_get_block <S2SV_ModEnd> ; else get_block <S2SV_ModStart> else get_block = ocfs2_dio_wr_get_block <S2SV_ModEnd> ; return __blockdev_direct_IO
<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> break ; } <S2SV_ModEnd> dst_reg -> smin_value <S2SV_ModStart> = S64_MAX ; <S2SV_ModEnd> if ( src_known
<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return err ; if ( ! <S2SV_ModEnd> attrs [ TIPC_NLA_SOCK <S2SV_ModStart> attrs [ TIPC_NLA_SOCK <S2SV_ModEnd> ] ) return <S2SV_ModStart> - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> [ TIPC_NLA_SOCK_REF ] <S2SV_ModStart> [ TIPC_NLA_SOCK_REF ] <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;
<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
<S2SV_ModStart> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct <S2SV_ModStart> ) ) return false ; * type |= <S2SV_ModEnd> algt -> type <S2SV_ModStart> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & <S2SV_ModEnd> CRYPTO_ALG_INTERNAL ; if <S2SV_ModStart> ; if ( * type & * <S2SV_ModEnd> mask & CRYPTO_ALG_INTERNAL <S2SV_ModStart> & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int err ; if ( ! <S2SV_ModStart> & mask ) ) return - EINVAL
<S2SV_ModStart> = false ; lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> fanout ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out_unlock ; } <S2SV_ModEnd> if ( name
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
<S2SV_ModStart> sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> * trap ; struct name_snapshot <S2SV_ModEnd> old_name ; trap <S2SV_ModStart> goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> , d_is_dir ( <S2SV_ModStart> old_dentry ) ; release_dentry_name_snapshot ( & <S2SV_ModEnd> old_name ) ;
<S2SV_ModStart> old_dentry ) ; <S2SV_ModEnd> struct inode * <S2SV_ModStart> -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> old_dentry -> d_name <S2SV_ModStart> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return
<S2SV_ModStart> mask ) { struct name_snapshot name ; <S2SV_ModStart> |= FS_EVENT_ON_CHILD ; take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> , FSNOTIFY_EVENT_PATH , name <S2SV_ModEnd> . name , <S2SV_ModStart> , FSNOTIFY_EVENT_INODE , name <S2SV_ModEnd> . name , <S2SV_ModStart> name , 0 ) ; release_dentry_name_snapshot ( & name
<S2SV_ModStart> : kfree ( req ) ; kfree (
<S2SV_ModStart> & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { while ( 1 ) { <S2SV_ModStart> ] ) ; if ( ! queue ) break ; <S2SV_ModEnd> if ( free_func <S2SV_ModStart> ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> } } hashbin <S2SV_ModStart> & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & <S2SV_ModStart> flags ) ; <S2SV_ModEnd> kfree ( hashbin
<S2SV_ModStart> iovec , compat , & iter <S2SV_ModStart> len , iovec , & iter <S2SV_ModStart> iter_op ) { ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> nr_segs , req
<S2SV_ModStart> iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;
<S2SV_ModStart> , bool compat , struct iov_iter * iter <S2SV_ModStart> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;
<S2SV_ModStart> intf ) { <S2SV_ModEnd> if ( cdc_ncm_select_altsetting <S2SV_ModStart> - ENODEV ; return <S2SV_ModEnd> cdc_ncm_bind_common ( dev <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
<S2SV_ModStart> EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
<S2SV_ModStart> ) { struct usb_serial * serial = port -> serial ; struct <S2SV_ModStart> * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , "expected<S2SV_blank>endpoint<S2SV_blank>missing\\n" ) ; return - ENODEV ; } <S2SV_ModStart> -> read_urb = <S2SV_ModEnd> serial -> port
<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats
<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
<S2SV_ModStart> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> IPT_F_GOTO ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> = e ; }
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModEnd> return len ; <S2SV_ModStart> return len ; } <S2SV_ModEnd> b -> opcode
<S2SV_ModStart> < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModStart> return len ; }
<S2SV_ModStart> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if (
<S2SV_ModStart> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page
<S2SV_ModStart> = dest_mnt ; first_source = source_mnt ;
<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE
<S2SV_ModStart> return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
<S2SV_ModStart> -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( <S2SV_ModStart> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> = 1 ; ret = <S2SV_ModEnd> dvb_usb_generic_rw ( d <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 50 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap , NULL <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap ,
<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex
<S2SV_ModStart> 0 ) ; scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ) + RDS_CONG_MAP_BYTES ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret
<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
<S2SV_ModStart> dev ) ; ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> sprintf ( buf <S2SV_ModStart> driver_override ) ; device_unlock ( dev ) ; return len ;
<S2SV_ModStart> , * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> f2fs_sb_info * sbi , bool umount <S2SV_ModStart> ( sbi , ! umount <S2SV_ModEnd> ) ; }
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> * exthdr ; unsigned int len ; <S2SV_ModStart> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> ; * nexthdr
<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
<S2SV_ModStart> . fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head
<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
<S2SV_ModStart> hx ; u8 * buf <S2SV_ModEnd> ; int ret <S2SV_ModStart> = 0 ; u16 cpu_cs_register = <S2SV_ModEnd> cypress [ type <S2SV_ModStart> ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) { buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> usb_cypress_writemem ( udev <S2SV_ModStart> ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> filp ) { __sock_release <S2SV_ModEnd> ( SOCKET_I ( <S2SV_ModStart> ( inode ) , inode
<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; if ( sock -> sk ) <S2SV_ModStart> -> ia_uid ; else err = - ENOENT ;
<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (
<S2SV_ModStart> ) & desc , sizeof ( * desc )
<S2SV_ModStart> * * ptr , size_t minsize <S2SV_ModStart> bLength < 2 || header -> bLength > size <S2SV_ModStart> bDescriptorType == type && header -> bLength >= minsize
<S2SV_ModStart> ) & secd , sizeof ( * secd )
<S2SV_ModStart> if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
<S2SV_ModStart> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , "port-%d" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return
<S2SV_ModStart> "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
<S2SV_ModStart> vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
<S2SV_ModStart> vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> ) ; } if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
<S2SV_ModStart> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }
<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;
<S2SV_ModStart> ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> kc -> timer_forward
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr <S2SV_ModStart> info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer
<S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> u16 size , const <S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> fail ; } mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; cp2112_gpio_set <S2SV_ModStart> ; fail : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; buf <S2SV_ModStart> ret ) ; mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; }
<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
<S2SV_ModStart> ( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in
<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;
<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> ( ) ) { <S2SV_ModStart> buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user <S2SV_ModStart> state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }
<S2SV_ModStart> { lockdep_assert_irqs_disabled ( ) ; if ( preempt_count ( ) == cnt ) trace_preempt_on ( CALLER_ADDR0 , get_lock_parent_ip ( ) <S2SV_ModStart> _RET_IP_ ) ; __preempt_count_sub <S2SV_ModEnd> ( cnt )
<S2SV_ModStart> out_free ; } if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; }
<S2SV_ModStart> pin_lock ) ; hlist_del_init <S2SV_ModEnd> ( & pin <S2SV_ModStart> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin
<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; int ret <S2SV_ModStart> ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;
<S2SV_ModStart> sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&
<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> mtu , flags , rt
<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )
<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV
<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , "interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; err = - EINVAL ;
<S2SV_ModStart> ; return ret < <S2SV_ModEnd> 0 ? ret
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err
<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> return map ; map =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct bpf_map * <S2SV_ModEnd> bpf_map_inc ( struct <S2SV_ModStart> uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> ( & map <S2SV_ModStart> refcnt ) ; return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> usercnt ) ; return map ;
<S2SV_ModStart> return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput
<S2SV_ModStart> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart> = map ; <S2SV_ModEnd> fdput ( f
<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> } err = crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> seed (
<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
<S2SV_ModStart> if ( indev && indev -> ifa_list <S2SV_ModEnd> ) { ifa
<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &
<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , "Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u" , addr . nl_pid ) ; continue ; }
<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
<S2SV_ModStart> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;
<S2SV_ModStart> ( tty ) && ! L_EXTPROC ( tty )
<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
<S2SV_ModStart> inet_daddr ; struct dst_entry * dst ; struct <S2SV_ModStart> * rt ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ) { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> inet_opt = rcu_dereference <S2SV_ModStart> sk_bound_dev_if ) ; dst = <S2SV_ModEnd> ! IS_ERR ( <S2SV_ModStart> ( rt ) ? <S2SV_ModEnd> & rt -> <S2SV_ModStart> & rt -> dst : NULL ; sk_dst_set ( sk ,
<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
<S2SV_ModStart> ; if ( fp &&
<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;
<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
<S2SV_ModStart> 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart> destroy ( dev <S2SV_ModEnd> ) ; return
<S2SV_ModStart> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;
<S2SV_ModStart> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , "Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n" , i + size , length ) ; break ; } <S2SV_ModEnd> switch ( size <S2SV_ModStart> break ; case 4 : <S2SV_ModEnd> data32 = get_unaligned_le32
<S2SV_ModStart> = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }
<S2SV_ModStart> ip_proto = 0 ; bool ret = false <S2SV_ModStart> < 5 ) goto out_bad <S2SV_ModEnd> ; nhoff += <S2SV_ModStart> ! iph ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> ! vlan ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } } <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } goto out_good ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } ip_proto_again <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! keyid ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! eth ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ! opthdr ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> break ; } if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> ) nhoff ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; ret = aio_setup_single_vector ( READ , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( READ <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( WRITE
<S2SV_ModStart> ssize_t aio_setup_single_vector ( int type , struct file * file , <S2SV_ModStart> kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> -> iov_len = bytes <S2SV_ModEnd> ; kiocb ->
<S2SV_ModStart> goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found
<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
<S2SV_ModStart> void * buffer ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL
<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
<S2SV_ModStart> -> b_size = ( u64 )
<S2SV_ModStart> kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> md ) ) { md = NULL ; goto out ; } <S2SV_ModEnd> dm_get ( md <S2SV_ModStart> dm_get ( md ) ; out : spin_unlock ( & _minor_lock
<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> -> pipe ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> -> count ; <S2SV_ModEnd> if ( size <S2SV_ModStart> size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> ( off ) left <S2SV_ModEnd> += off - <S2SV_ModStart> ; if ( left <S2SV_ModEnd> <= buf -> <S2SV_ModStart> ) break ; left <S2SV_ModEnd> -= buf -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> i -> idx <S2SV_ModStart> = idx ; <S2SV_ModEnd> i -> iov_offset <S2SV_ModStart> -> offset + left ; <S2SV_ModEnd> } i -> <S2SV_ModStart> -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
<S2SV_ModStart> error ) { if ( bp && ( <S2SV_ModEnd> xfs_da_shrink_inode ( args <S2SV_ModStart> , bp ) != 0 ) <S2SV_ModEnd> ) goto out
<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> rc ) { struct task_struct * <S2SV_ModEnd> task = kthread_run <S2SV_ModStart> ; if ( IS_ERR ( task ) ) { <S2SV_ModStart> uwbd . task = NULL ; <S2SV_ModEnd> printk ( KERN_ERR <S2SV_ModStart> "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; } else { rc -> uwbd . task = task ; <S2SV_ModEnd> rc -> uwbd <S2SV_ModStart> pid ; } }
<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;
<S2SV_ModStart> ( used_address && msg_sys -> msg_name && <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name , <S2SV_ModStart> -> msg_namelen ; if ( msg_sys -> msg_name ) <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name ,
<S2SV_ModStart> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> copy_from_user ( buf + sizeof ( hdr ) <S2SV_ModStart> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> iad_num ] = d <S2SV_ModEnd> ; iad_num ++
<S2SV_ModStart> u64 ) len - s
<S2SV_ModStart> { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>control<S2SV_blank>header\\n" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , "too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , "skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"
<S2SV_ModStart> = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! index_key .
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if (
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
<S2SV_ModStart> ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;
<S2SV_ModStart> -> ctx -> task <S2SV_ModEnd> != ctx -> <S2SV_ModStart> != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context
<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
<S2SV_ModStart> [ 1 ] ; void * data ; int ret <S2SV_ModStart> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> ( sg , data <S2SV_ModEnd> , count ) <S2SV_ModStart> count ) ; ret = <S2SV_ModEnd> __send_to_port ( port <S2SV_ModStart> , count , data <S2SV_ModEnd> , false ) <S2SV_ModStart> false ) ; kfree ( data ) ; return ret ;
<S2SV_ModStart> iovec ) { size_t len = kiocb -> ki_nbytes ; if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> iov_len = len <S2SV_ModEnd> ; * nr_segs
<S2SV_ModStart> * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
<S2SV_ModStart> rqstp = vrqstp ; struct net * net = & init_net ; struct lockd_net * ln = net_generic ( net , lockd_net_id ) <S2SV_ModStart> ( ) ; cancel_delayed_work_sync ( & ln -> grace_period_end ) ; locks_end_grace ( & ln -> lockd_manager ) ;
<S2SV_ModStart> net ) ; <S2SV_ModEnd> svc_shutdown_net ( serv
<S2SV_ModStart> ; if ( <S2SV_ModEnd> status == nlm_lck_denied_grace_period <S2SV_ModStart> ) ; } <S2SV_ModEnd> nlmsvc_release_block ( block
<S2SV_ModStart> while ( ! kthread_freezable_should_stop ( NULL <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { if ( signal_pending ( current ) ) flush_signals ( current ) ; <S2SV_ModStart> ) ; } svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ;
<S2SV_ModStart> ; serv = svc_create_pooled <S2SV_ModEnd> ( & nfs4_callback_program
<S2SV_ModStart> p ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ; } return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> source ) { <S2SV_ModEnd> target -> cr_principal <S2SV_ModStart> target -> cr_principal = kstrdup ( <S2SV_ModEnd> source -> cr_principal <S2SV_ModStart> source -> cr_principal , GFP_KERNEL ) ; target -> cr_raw_principal = kstrdup ( source -> cr_raw_principal , GFP_KERNEL <S2SV_ModStart> ; if ( ( source -> cr_principal && ! target -> cr_principal ) || ( source -> cr_raw_principal && ! target -> cr_raw_principal ) ) return - ENOMEM <S2SV_ModEnd> ; target ->
<S2SV_ModStart> FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; <S2SV_ModStart> ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; p ++ ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 <S2SV_ModStart> v ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> PAGE_SIZE ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
<S2SV_ModStart> { if ( ! d_inode <S2SV_ModEnd> ( dentry ) <S2SV_ModStart> ( dentry ) ) return 0 ; if ( exp -> ex_flags & NFSEXP_V4ROOT <S2SV_ModStart> ; if ( d_mountpoint ( dentry ) ) return 2 ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; struct gs_host_config * hconf <S2SV_ModEnd> ; struct gs_device_config <S2SV_ModStart> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> ; rc = <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> hconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; kfree ( hconf ) ; <S2SV_ModStart> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> dconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> icount + 1 <S2SV_ModStart> GS_MAX_INTF ) ; kfree ( dconf ) ; <S2SV_ModStart> ! dev ) { kfree ( dconf ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> , intf , <S2SV_ModEnd> dconf ) ; <S2SV_ModStart> ; kfree ( dconf ) ; kfree ( <S2SV_ModStart> dev ; } kfree ( dconf ) ;
<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =
<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> tmp = *
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
<S2SV_ModStart> -> server -> <S2SV_ModEnd> ops -> generate_signingkey <S2SV_ModStart> ( ses ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } <S2SV_ModStart> GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ;
<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> & multicast_idr , NULL <S2SV_ModEnd> , 0 ,
<S2SV_ModStart> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;
<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> -> group_leader ; switch <S2SV_ModEnd> ( event -> <S2SV_ModStart> event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> rtn = find_task_by_vpid <S2SV_ModStart> -> sigev_notify_thread_id ) ; if ( ! rtn <S2SV_ModEnd> || ! same_thread_group <S2SV_ModStart> , current ) <S2SV_ModEnd> ) return NULL <S2SV_ModStart> return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> ( event -> <S2SV_ModStart> sigev_signo <= 0 || <S2SV_ModEnd> event -> sigev_signo <S2SV_ModStart> > SIGRTMAX ) <S2SV_ModEnd> return NULL ; <S2SV_ModStart> return NULL ; case SIGEV_NONE : <S2SV_ModStart> rtn ) ; default : return NULL ; }
<S2SV_ModStart> -> msg_name ; if ( sin ) { <S2SV_ModStart> sin ) ; } <S2SV_ModStart> -> msg_name ; if ( sin6 ) { <S2SV_ModStart> sin6 ) ; }
<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> * f ; mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> ; if ( f ) { <S2SV_ModEnd> po -> fanout <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( po <S2SV_ModStart> ) ; } mutex_unlock ( & fanout_mutex ) ; }
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) <S2SV_ModStart> * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst )
<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * cred , fmode_t <S2SV_ModEnd> mode ) {
<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
<S2SV_ModStart> { if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;
<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , "Too<S2SV_blank>large<S2SV_blank>descriptor\\n" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> "Found<S2SV_blank>union<S2SV_blank>header\\n" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , "Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
<S2SV_ModStart> tn_buf ) ; return - EACCES ;
<S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk
<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
<S2SV_ModStart> goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ret , n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( "hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++
<S2SV_ModStart> goto err ; cpu = cpumask_first ( mask ) ;
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
<S2SV_ModStart> dev ; int len <S2SV_ModEnd> = 0 ; <S2SV_ModStart> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave <S2SV_ModStart> flags ) ; len <S2SV_ModEnd> = snprintf ( <S2SV_ModStart> flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> } if ( rq -> curr -> se . on_rq &&
<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
<S2SV_ModStart> * rq ) <S2SV_ModEnd> { int cpu <S2SV_ModStart> ; u64 irq_time ; if ( rq -> skip_clock_update ) return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (
<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp .
<S2SV_ModStart> crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher .
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp .
<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
<S2SV_ModStart> skb ) { strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl .
<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) != ulen || replay_esn -> bmp_len != up -> bmp_len
<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> arg ) { return video_usercopy <S2SV_ModEnd> ( file , <S2SV_ModStart> , cmd , arg , __video_do_ioctl ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> err = - <S2SV_ModStart> - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> switch ( _IOC_DIR <S2SV_ModStart> ) ) { <S2SV_ModEnd> case _IOC_READ : <S2SV_ModStart> _IOC_READ : case <S2SV_ModEnd> ( _IOC_WRITE | <S2SV_ModStart> : if ( <S2SV_ModEnd> copy_to_user ( (
<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> max ) ; d2 = b <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> i < ( loopmaxh <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> 2U ) { size_t j ; <S2SV_ModStart> + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> ( i < loopmaxh ) { size_t j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> { for ( pad = ( <S2SV_ModEnd> w % 4
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , "%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> max = w
<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
<S2SV_ModStart> |= 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> = 256 ; }
<S2SV_ModStart> ( header -> biBitCount == 0 ) { fprintf ( stderr , "Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n" , 0 ) ; return OPJ_FALSE ; } if ( header ->
<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> p_stream ) ; <S2SV_ModEnd> if ( p_total_data_size
<S2SV_ModStart> J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 2 ) ; } return OPJ_FALSE ; }
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; } } if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 2 ) { if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> 4U ; } if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL ; }
<S2SV_ModStart> , p_data , p_total_data_size , <S2SV_ModStart> , p_data , p_total_data_size ,
<S2SV_ModStart> , p_data , p_total_data_size ,
<S2SV_ModStart> p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <S2SV_ModStart> p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ( f , "PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d" <S2SV_ModEnd> , temp ,
<S2SV_ModStart> ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( "invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> dir , dir_len <S2SV_ModStart> dir , dir_len , "" , 0 ) <S2SV_ModEnd> ; char * <S2SV_ModStart> dst ) ; free ( src ) ; <S2SV_ModStart> NULL ; } free ( src ) ;
<S2SV_ModStart> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> ; stripsperplane = TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> ( td -> <S2SV_ModStart> td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ;
<S2SV_ModStart> s < ns && row < imagelength
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpContig2SeparateByRow" ) ; return 0 ; }
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpSeparate2ContigByRow" ) ; return 0 ; }
<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
<S2SV_ModStart> { uint16 bitspersample = 1
<S2SV_ModStart> int outskew , int64 <S2SV_ModEnd> inskew ) {
<S2SV_ModStart> in ) ; int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> tilew ; uint8 <S2SV_ModStart> if ( colb > iskew <S2SV_ModEnd> ) { uint32
<S2SV_ModStart> } bufp += stripsize <S2SV_ModEnd> ; } return
<S2SV_ModStart> uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField (
<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
<S2SV_ModStart> if ( count > <S2SV_ModEnd> 4 ) {
<S2SV_ModStart> ; retval = htc_request_check_hdrs <S2SV_ModEnd> ( sp , <S2SV_ModStart> ( sp , hp <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> r ) )
<S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) ;
<S2SV_ModStart> ! vct_iscrlf ( & <S2SV_ModStart> ! vct_iscrlf ( &
<S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ( vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ( vct_iscrlf ( <S2SV_ModEnd> p ) ) <S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> p ) )
<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
<S2SV_ModStart> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } }
<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&
<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> "checked_xcalloc" , ( res <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( "checked_xmalloc" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,
<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> ptr = malloc <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if <S2SV_ModStart> '\\0' , ( res <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; } else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> ; } } else { free ( buf ) ; }
<S2SV_ModStart> ; } else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <S2SV_ModStart> ; } } else { free ( obj ) ; }
<S2SV_ModStart> ; uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> send_buf_size ) ; if ( send_buf == NULL ) { return - 1 ; } <S2SV_ModEnd> } memcpy (
<S2SV_ModStart> connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
<S2SV_ModStart> ( length > 1 <S2SV_ModEnd> ) { if
<S2SV_ModStart> mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char <S2SV_ModStart> = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> return NULL ; length = strlen ( mask <S2SV_ModEnd> ) + 256 <S2SV_ModStart> + 1 ; mask2 <S2SV_ModEnd> = malloc ( <S2SV_ModStart> if ( ! mask2 <S2SV_ModEnd> ) goto end <S2SV_ModStart> seconds ) ; mask2 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = '\\0' ; if ( strftime ( mask2 <S2SV_ModEnd> , length - <S2SV_ModStart> - 1 , mask <S2SV_ModEnd> , date_tmp ) <S2SV_ModStart> , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , "\\01" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , "\\\\" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , "\\01" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , mask , mask7 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( mask3 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask6 <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return mask7 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return "4" "invalid<S2SV_blank>Padding<S2SV_blank>String" ; } <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> ctx , expr -> unary . child
<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
<S2SV_ModStart> ; if ( ! str ) return false ; if (
<S2SV_ModStart> ( s ) && ! eof ( s )
<S2SV_ModStart> LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , "Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n" ) ; } else { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> , pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } }
<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
