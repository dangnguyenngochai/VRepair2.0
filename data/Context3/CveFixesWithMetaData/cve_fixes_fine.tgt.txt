<S2SV_ModStart> { p_fm_config_conx_hdlt hdl = NULL <S2SV_ModStart> ) ; goto cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto cleanup <S2SV_ModEnd> ; } for <S2SV_ModStart> 0 ) { res = <S2SV_ModEnd> commandList [ i <S2SV_ModStart> ] ) ; goto cleanup ; <S2SV_ModStart> - 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> free ( hdl <S2SV_ModStart> hdl ) ; }
<S2SV_ModStart> sockaddr_un unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> ) ) { res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> ; } snprintf <S2SV_ModStart> 0 ) { res = HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModEnd> } if ( <S2SV_ModStart> 0 ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> ; } memset <S2SV_ModStart> 0 ) { res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> ; } hdl <S2SV_ModStart> = HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
<S2SV_ModStart> ; } } cleanup : <S2SV_ModEnd> return res ;
<S2SV_ModStart> * mgr_hdl ; <S2SV_ModEnd> memset ( s_path <S2SV_ModStart> ( c_path ) <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c_path , "%s%s%d_C_XXXXXX" <S2SV_ModEnd> , HSM_FM_SCK_PREFIX , <S2SV_ModStart> hdl -> instance <S2SV_ModEnd> ) ; if
<S2SV_ModStart> TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , <S2SV_ModStart> ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits <S2SV_ModStart> ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval = <S2SV_ModStart> ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = <S2SV_ModStart> res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
<S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> array_index_stack [ ARRAY_INDEX_STACK_SIZE
<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length ) {
<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length , const <S2SV_ModStart> check_dollar ) { size_t <S2SV_ModEnd> position = 0
<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = recv
<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = send
<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> sl = strlen
<S2SV_ModStart> * data , size_t <S2SV_ModEnd> len ) {
<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> overhead = 16 <S2SV_ModStart> + 1 ; size_t <S2SV_ModEnd> size = overhead
<S2SV_ModStart> * mongo_message_create ( size_t <S2SV_ModEnd> len , int <S2SV_ModStart> . len = ( int )
<S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , "Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set" ) ; <S2SV_ModStart> ( pb , LDAP_INVALID_CREDENTIALS , NULL , <S2SV_ModEnd> NULL , 0
<S2SV_ModStart> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , "Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , "Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , "Invalid<S2SV_blank>credentials" ) ;
<S2SV_ModStart> ( pb , SLAPI_RESULT_TEXT <S2SV_ModEnd> , "at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>required<S2SV_blank>attribute<S2SV_blank>has<S2SV_blank>been<S2SV_blank>moved<S2SV_blank>to<S2SV_blank>the<S2SV_blank>BDB<S2SV_blank>scecific<S2SV_blank>configuration<S2SV_blank>entry" )
<S2SV_ModStart> ( pb , SLAPI_RESULT_TEXT <S2SV_ModEnd> , & pbtext
<S2SV_ModStart> ( f , "%79s<S2SV_blank>%99[^\\n]\\n" <S2SV_ModEnd> , def ,
<S2SV_ModStart> += 2 ; if ( i + 1 < data_size )
<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( op1 ) && pointZZ_pIsIdentityElement ( op2 ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; } else if ( pointZZ_pIsIdentityElement ( op1 ) ) { mpz_set ( rop -> x , op2 -> x ) ; mpz_set ( rop -> y , op2 -> y ) ; return ; } else if ( pointZZ_pIsIdentityElement ( op2 ) ) { mpz_set ( rop -> x , op1 -> x ) ; mpz_set ( rop -> y , op1 -> y ) ; return ; } if ( pointZZ_pEqual ( op1 , op2 ) ) { pointZZ_pDouble ( rop , op1 , curve ) ; return ; } mpz_t negy ; mpz_init ( negy ) ; mpz_sub ( negy , curve -> p , op2 -> y ) ; if ( mpz_cmp ( op1 -> x , op2 -> x ) == 0 && mpz_cmp ( op1 -> y , negy ) == 0 ) { mpz_clear ( negy ) ; return pointZZ_pSetToIdentityElement ( rop ) ; } mpz_t <S2SV_ModEnd> xdiff , ydiff <S2SV_ModStart> ; mpz_clears ( negy ,
<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( op ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
<S2SV_ModStart> curve ) { if ( pointZZ_pIsIdentityElement ( point ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
<S2SV_ModStart> = ptr ; op -> tas . rsize = size <S2SV_ModEnd> ; push ( <S2SV_ModStart> * op1 ; op [ - 3 ] . <S2SV_ModEnd> value . bytes <S2SV_ModStart> + size ; if ( forward ) { op [ - 1 ] . tas . rsize = ptr - op [ - 1 ] . value . bytes ; op [ - 3 ] . tas . rsize = count ; } else { op [ - 1 ] . tas . rsize = count ; op [ - 3 ] . tas . rsize -= count + size ; } <S2SV_ModEnd> make_true ( op
<S2SV_ModStart> return 0 ; if ( ( UINT32_MAX - src -> width < ( x > 0 ? x : - x ) ) || ( UINT32_MAX - src -> height < ( y > 0 ? y : - y ) ) ) { # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , "overflow<S2SV_blank>in<S2SV_blank>compose_image" ) ; # endif return 0 ; }
<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
<S2SV_ModStart> void ) { test_parser_param ( <S2SV_ModEnd> 0 ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( parserTestSuite , "Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
<S2SV_ModStart> ntbytes , int32_t destsize <S2SV_ModEnd> , const uint8_t <S2SV_ModStart> neblock ] ; if ( ntbytes > destsize ) { return - 1 ; } <S2SV_ModStart> + maxout > destsize <S2SV_ModEnd> ) { maxout <S2SV_ModStart> ( int64_t ) destsize <S2SV_ModEnd> - ( int64_t <S2SV_ModStart> neblock ) > destsize <S2SV_ModEnd> ) { return
<S2SV_ModStart> -> fmap ; size_t <S2SV_ModEnd> length , offset <S2SV_ModStart> ; goto exit_toc ; } if ( hdr . toc_length_decompressed != strm . total_out ) { cli_dbgmsg ( "TOC<S2SV_blank>decompress<S2SV_blank>length<S2SV_blank>%" PRIu64 "<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>amount<S2SV_blank>decompressed<S2SV_blank>%lu\\n" , hdr . toc_length_decompressed , strm . total_out ) ; toc [ strm . total_out ] = '\\0' ; hdr . toc_length_decompressed = strm . total_out <S2SV_ModStart> } cli_dbgmsg ( "cli_scanxar:<S2SV_blank>decompress<S2SV_blank>into<S2SV_blank>temp<S2SV_blank>file:\\n%s,<S2SV_blank>size<S2SV_blank>%zu,\\n" "from<S2SV_blank>xar<S2SV_blank>heap<S2SV_blank>offset<S2SV_blank>%zu<S2SV_blank>length<S2SV_blank>%zu\\n" <S2SV_ModEnd> , tmpname , <S2SV_ModStart> long in_remaining = MIN ( length , map -> len - at ) <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> ; int lret ; if ( length > in_remaining ) length = in_remaining <S2SV_ModStart> ; cli_dbgmsg ( "cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:%s.\\n" , CLI_LZMA_HDR_SIZE <S2SV_ModEnd> , at , <S2SV_ModStart> ( "cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%li<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li,<S2SV_blank>errno:<S2SV_blank>%s.\\n" , lz . avail_in <S2SV_ModEnd> , at , <S2SV_ModStart> 0 ; { size_t writelen = MIN ( map -> len - at , length ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> maxfilesize ) writelen <S2SV_ModEnd> = MIN ( <S2SV_ModStart> maxfilesize ) , writelen ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , at , writelen <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ; cli_dbgmsg ( "cli_scanxar:<S2SV_blank>Can\'t<S2SV_blank>read<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%zu,<S2SV_blank>errno:%s.\\n" , writelen <S2SV_ModEnd> , at , <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> , a_hash ) <S2SV_ModStart> , blockp , writelen <S2SV_ModEnd> ) < 0 <S2SV_ModStart> { cli_dbgmsg ( "cli_scanxar:<S2SV_blank>cli_writen<S2SV_blank>error<S2SV_blank>%zu<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>%li.\\n" , writelen <S2SV_ModEnd> , at ) <S2SV_ModStart> 0 ) { cli_dbgmsg ( "cli_scanxar:<S2SV_blank>%u<S2SV_blank>checksum<S2SV_blank>errors<S2SV_blank>and<S2SV_blank>%u<S2SV_blank>extraction<S2SV_blank>errors.\\n" <S2SV_ModEnd> , cksum_fails ,
<S2SV_ModStart> sync_reply ) { if ( client_obj -> ipc ) { <S2SV_ModStart> "" ) ; } else { crm_trace ( "Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s" , client_obj -> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; }
<S2SV_ModStart> ipc == NULL && client -> session == NULL
<S2SV_ModStart> client = user_data ; int csock = 0 <S2SV_ModStart> num_clients ) ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } if ( client -> encrypted ) { # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> session ) { void * sock_ptr = gnutls_transport_get_ptr ( * client -> session ) ; csock = GPOINTER_TO_INT ( sock_ptr ) ; if ( client -> handshake_complete ) { gnutls_bye ( * client -> session , GNUTLS_SHUT_WR ) ; } gnutls_deinit ( * client -> session ) ; gnutls_free ( client -> session ) ; } # endif } else { csock = GPOINTER_TO_INT ( client -> session ) ; } client -> session = NULL ; if ( csock > 0 ) { close ( csock ) ; } <S2SV_ModStart> free ( client -> recv_buf ) ; free ( client
<S2SV_ModStart> ) { int <S2SV_ModEnd> csock = 0 <S2SV_ModStart> ; unsigned laddr <S2SV_ModEnd> ; struct sockaddr_in <S2SV_ModStart> ) data ; int flag ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> static struct mainloop_fd_callbacks <S2SV_ModStart> } if ( ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) { if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) { crm_err ( "fcntl()<S2SV_blank>write<S2SV_blank>failed" ) ; close ( csock ) ; return TRUE ; } } else { crm_err ( "fcntl()<S2SV_blank>read<S2SV_blank>failed" ) ; close ( csock ) ; return TRUE ; } if ( <S2SV_ModStart> HAVE_GNUTLS_GNUTLS_H session = crm_create_anon_tls_session <S2SV_ModEnd> ( csock , <S2SV_ModStart> csock , GNUTLS_SERVER , anon_cred_s <S2SV_ModStart> # endif } num_clients ++ ; new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ; new_client -> id = crm_generate_uuid ( ) ; new_client -> callback_id = NULL ; new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client <S2SV_ModEnd> ) ; if <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H new_client -> encrypted = TRUE ; new_client -> session = session <S2SV_ModEnd> ; # endif <S2SV_ModStart> } else { new_client -> session = <S2SV_ModEnd> GINT_TO_POINTER ( csock <S2SV_ModStart> ( csock ) ; } <S2SV_ModEnd> new_client -> remote <S2SV_ModStart> return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> data ) { <S2SV_ModEnd> xmlNode * command <S2SV_ModStart> client = data ; int disconnected = 0 ; int timeout = client -> remote_auth ? - 1 : 1000 <S2SV_ModStart> "clear-text" ) ; # ifdef HAVE_GNUTLS_GNUTLS_H if ( client -> encrypted && ( client -> handshake_complete == FALSE ) ) { int rc = 0 ; do { rc = gnutls_handshake ( * <S2SV_ModEnd> client -> session <S2SV_ModStart> client -> session ) ; if ( rc < 0 && rc != GNUTLS_E_AGAIN ) { crm_err ( "Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>failed" ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } } while ( rc == GNUTLS_E_INTERRUPTED ) ; if ( rc == 0 ) { crm_debug ( "Remote<S2SV_blank>cib<S2SV_blank>tls<S2SV_blank>handshake<S2SV_blank>completed" ) ; client -> handshake_complete = TRUE ; if ( client -> remote_auth_timeout ) { g_source_remove ( client -> remote_auth_timeout ) ; } client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , client ) ; } return 0 ; } # endif crm_recv_remote_msg ( client -> session , & client -> recv_buf , client -> encrypted , timeout , & disconnected ) ; if ( client -> remote_auth == FALSE ) { xmlNode * reg <S2SV_ModEnd> ; # if <S2SV_ModStart> # if ENABLE_ACL const char * user = NULL ; # endif command = crm_parse_remote_buffer ( & client -> recv_buf ) ; if ( cib_remote_auth ( command ) == FALSE ) { free_xml ( command ) ; return - 1 ; } crm_debug ( "remote<S2SV_blank>connection<S2SV_blank>authenticated<S2SV_blank>successfully" ) ; client -> remote_auth = TRUE ; g_source_remove ( client -> remote_auth_timeout ) ; client -> remote_auth_timeout = 0 ; client -> name = crm_element_value_copy ( command , "name" ) ; # if ENABLE_ACL user = crm_element_value ( command , "user" ) ; if ( user ) { new_client -> user = strdup ( user ) ; } # endif reg = create_xml_node ( NULL , "cib_result" <S2SV_ModEnd> ) ; crm_xml_add <S2SV_ModStart> ; crm_xml_add ( reg , F_CIB_OPERATION , CRM_OP_REGISTER ) ; crm_xml_add ( reg , F_CIB_CLIENTID , client -> id ) ; crm_send_remote_msg ( client -> session , reg , client -> encrypted ) ; free_xml ( reg ) ; free_xml ( command ) ; } command = crm_parse_remote_buffer ( & client -> recv_buf ) ; while ( command ) { crm_trace ( "command<S2SV_blank>received" ) ; cib_handle_remote_msg ( client , command ) ; free_xml ( command ) ; command = crm_parse_remote_buffer ( & client -> recv_buf ) ; } if ( disconnected ) { crm_trace ( "disconnected<S2SV_blank>while<S2SV_blank>receiving<S2SV_blank>remote<S2SV_blank>cib<S2SV_blank>msg." ) ; return - 1 ; } return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> = pcmk_ok ; int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> if ( cib <S2SV_ModStart> op ) ; if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> ( private -> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> session , op_msg <S2SV_ModStart> encrypted ) ; } <S2SV_ModStart> "Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply" ) ; start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> cib -> call_timeout <S2SV_ModStart> cib -> call_timeout ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> ) { int <S2SV_ModStart> -> call_id ; <S2SV_ModEnd> crm_recv_remote_msg ( private <S2SV_ModStart> . session , & <S2SV_ModStart> -> command . recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> ) { break <S2SV_ModStart> , & reply_id <S2SV_ModEnd> ) ; if <S2SV_ModStart> = NULL ; remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( "Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply." ) ; return - ENOTCONN ; } else <S2SV_ModEnd> if ( op_reply
<S2SV_ModStart> -> command ) , FALSE <S2SV_ModStart> -> callback ) , TRUE
<S2SV_ModStart> cib -> variant_opaque <S2SV_ModEnd> ; # ifdef <S2SV_ModStart> encrypted ) { if ( private -> command . session ) { <S2SV_ModStart> session ) ; } if ( private -> callback . session ) { <S2SV_ModStart> session ) ; } private -> command . session = NULL ; private -> callback . session = NULL ; if ( remote_gnutls_credentials_init ) { <S2SV_ModStart> ( ) ; remote_gnutls_credentials_init = FALSE ; } <S2SV_ModStart> } # endif if ( private -> command . socket ) { shutdown ( private -> command . socket , SHUT_RDWR ) ; close ( private -> command . socket ) ; } if ( private -> callback . socket ) { shutdown ( private -> callback . socket , SHUT_RDWR ) ; close ( private -> callback . socket ) ; } private -> command . socket = 0 ; private -> callback . socket = 0 ; free ( private -> command . recv_buf ) ; free ( private -> callback . recv_buf ) ; private -> command . recv_buf = NULL ; private -> callback . recv_buf = NULL ;
<S2SV_ModStart> remote_connection_s * connection , gboolean event_channel <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> int rc = <S2SV_ModStart> = 0 ; int disconnected = 0 <S2SV_ModEnd> ; xmlNode * <S2SV_ModStart> mainloop_fd_callbacks cib_fd_callbacks = { 0 , } ; cib_fd_callbacks <S2SV_ModEnd> . dispatch = <S2SV_ModStart> . dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch ; cib_fd_callbacks <S2SV_ModEnd> . destroy = <S2SV_ModStart> destroy = cib_remote_connection_destroy <S2SV_ModEnd> ; connection -> <S2SV_ModStart> ; sock = crm_remote_tcp_connect ( private -> server , private -> port ) ; if ( sock <= 0 ) { crm_perror ( LOG_ERR , "remote<S2SV_blank>tcp<S2SV_blank>connection<S2SV_blank>to<S2SV_blank>%s:%d<S2SV_blank>failed" , private -> server , private -> port ) ; } connection -> socket = sock ; <S2SV_ModEnd> if ( connection <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H if ( remote_gnutls_credentials_init == FALSE ) { <S2SV_ModStart> anon_cred_c ) ; remote_gnutls_credentials_init = TRUE ; } connection -> session = crm_create_anon_tls_session <S2SV_ModEnd> ( sock , <S2SV_ModStart> sock , GNUTLS_CLIENT , anon_cred_c ) ; if ( crm_initiate_client_tls_handshake ( connection -> session , DEFAULT_CLIENT_HANDSHAKE_TIMEOUT ) != 0 ) { crm_err ( "Session<S2SV_blank>creation<S2SV_blank>for<S2SV_blank>%s:%d<S2SV_blank>failed" , private -> <S2SV_ModEnd> server , private <S2SV_ModStart> port ) ; gnutls_deinit ( * connection -> session ) ; gnutls_free ( connection -> session ) ; connection -> session = NULL <S2SV_ModEnd> ; cib_tls_close ( <S2SV_ModStart> login ) ; <S2SV_ModEnd> crm_recv_remote_msg ( connection <S2SV_ModStart> -> session , & connection -> recv_buf , <S2SV_ModStart> connection -> encrypted , - 1 , & disconnected ) ; if ( disconnected ) { rc = - ENOTCONN ; } answer = crm_parse_remote_buffer ( & connection -> recv_buf <S2SV_ModStart> ; } } free_xml ( answer ) ; answer = NULL ; <S2SV_ModStart> cib ) ; return rc ; } crm_trace ( "remote<S2SV_blank>client<S2SV_blank>connection<S2SV_blank>established" ) <S2SV_ModEnd> ; connection ->
<S2SV_ModStart> id ) ; source -> id = 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> gboolean <S2SV_ModEnd> crm_recv_remote_msg ( void <S2SV_ModStart> void * session , char * * recv_buf <S2SV_ModStart> , gboolean encrypted , int total_timeout , int * disconnected ) { int ret ; size_t request_len = 0 ; time_t start = time ( NULL ) ; char * raw_request <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; int remaining_timeout = 0 ; if ( total_timeout == 0 ) { total_timeout = 10000 ; } else if ( total_timeout < 0 ) { total_timeout = 60000 ; } * disconnected = 0 ; remaining_timeout = total_timeout ; while ( ( remaining_timeout > 0 ) && ! ( * disconnected ) ) { crm_trace ( "waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>starting<S2SV_blank>timeout<S2SV_blank>%d,<S2SV_blank>remaining_timeout<S2SV_blank>%d" , total_timeout , remaining_timeout ) ; ret = crm_recv_remote_ready ( session , encrypted , remaining_timeout ) ; raw_request <S2SV_ModEnd> = NULL ; <S2SV_ModStart> ; if ( ret == 0 ) { crm_err ( "poll<S2SV_blank>timed<S2SV_blank>out<S2SV_blank>(%d<S2SV_blank>ms)<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>msg" , remaining_timeout ) ; return FALSE ; } else if ( ret < 0 ) { if ( errno != EINTR ) { crm_debug ( "poll<S2SV_blank>returned<S2SV_blank>error<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>msg,<S2SV_blank>rc:<S2SV_blank>%d,<S2SV_blank>errno:<S2SV_blank>%d" , ret , errno ) ; * disconnected = 1 ; return FALSE ; } crm_debug ( "poll<S2SV_blank>EINTR<S2SV_blank>encountered<S2SV_blank>during<S2SV_blank>poll,<S2SV_blank>retrying" ) ; } else { raw_request = crm_recv_remote_raw ( session , encrypted , 0 , & request_len , disconnected ) ; } remaining_timeout = remaining_timeout - ( ( time ( NULL ) - start ) * 1000 ) ; if ( ! raw_request ) { crm_debug ( "Empty<S2SV_blank>msg<S2SV_blank>received<S2SV_blank>after<S2SV_blank>poll" ) ; continue ; } if ( * recv_buf ) { int old_len = strlen ( * recv_buf ) ; crm_trace ( "Expanding<S2SV_blank>recv<S2SV_blank>buffer<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d" , old_len , old_len + request_len ) ; * recv_buf = realloc ( * recv_buf , old_len + request_len + 1 ) ; memcpy ( * recv_buf + old_len , raw_request , request_len ) ; * ( * recv_buf + old_len + request_len ) = '\\0' ; free ( raw_request ) ; } else { * recv_buf = raw_request ; } if ( strstr ( * recv_buf , REMOTE_MSG_TERMINATOR ) ) { return TRUE ; } } return FALSE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> crm_send_remote_msg ( void <S2SV_ModStart> encrypted ) { int rc = - 1 ; char * xml_text = NULL ; int len = 0 ; xml_text = dump_xml_unformatted ( <S2SV_ModEnd> msg ) ; <S2SV_ModStart> msg ) ; if ( xml_text ) { len = strlen ( xml_text ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { crm_err ( "Invalid<S2SV_blank>XML,<S2SV_blank>can<S2SV_blank>not<S2SV_blank>send<S2SV_blank>msg" ) ; return - 1 ; } rc = crm_send_remote_msg_raw ( session , xml_text , len , encrypted ) ; if ( rc < 0 ) { goto done ; } rc = crm_send_remote_msg_raw ( session , REMOTE_MSG_TERMINATOR , strlen ( REMOTE_MSG_TERMINATOR ) , encrypted ) ; done : if ( rc < 0 ) { crm_err ( "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>%d" , rc <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } free ( xml_text ) ; return rc ;
<S2SV_ModStart> { print_as ( "Notification<S2SV_blank>setup<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>won\'t<S2SV_blank>be<S2SV_blank>able<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>after<S2SV_blank>failure" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> PIXA * pixa , * pixa2 <S2SV_ModStart> pixim ) ; pixa2 = pixaCreate ( 3 ) ; pix1 = pixRead ( "weasel8.png" ) ; pixGammaTRC ( pix1 , pix1 , 1.0 , 0 , 270 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixGetDimensions ( pix1 , & w , & h , NULL ) ; pixRasterop ( pix1 , 0 , 0 , 5 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 <S2SV_ModEnd> , 20 , <S2SV_ModStart> , 20 , 0 , 2 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 40 , 0 , 3 , h , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 0 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 15 , w , 3 , PIX_SET , NULL , 0 , 0 ) ; pixRasterop ( pix1 , 0 , 35 , w , 2 , PIX_SET , NULL , 0 , 0 ) ; pixaAddPix ( pixa2 , pix1 , L_COPY ) ; pixFillMapHoles ( pix1 , w , h , L_FILL_WHITE ) ; pixaAddPix ( pixa2 , pix1 , L_INSERT ) ; pix2 = pixaDisplayTiledInColumns ( pixa2 , 3 , 1.0 , 20 , 1 ) ; regTestWritePixAndCheck ( rp , pix2 , IFF_PNG <S2SV_ModEnd> ) ; pixDisplayWithTitle <S2SV_ModStart> ; pixDisplayWithTitle ( pix2 , 50 , 850 <S2SV_ModEnd> , NULL , <S2SV_ModStart> display ) ; pixaDestroy ( & pixa2 ) ; pixDestroy ( & pix2 ) ; pix1 = pixaDisplayTiledAndScaled ( pixa , 32 , 400 , 4 , 0 , 20 , 2 ) ; pixWrite ( "/tmp/lept/adapt/results.jpg" , pix1 , IFF_JFIF_JPEG ) ; pixDisplayWithTitle ( pix1 , 50 , 0 , NULL , rp -> display ) ;
<S2SV_ModStart> NUMA * na <S2SV_ModEnd> ; PROCNAME ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> goodcol = 0 <S2SV_ModStart> j -- ) <S2SV_ModEnd> pixRasterop ( pix <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j + <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } for ( <S2SV_ModStart> , PIX_SRC , pix <S2SV_ModEnd> , j - <S2SV_ModStart> 0 ) ; } } <S2SV_ModEnd> } if (
<S2SV_ModStart> "lept/model" ) ; lept_rmdir ( "lept/dewmod" ) ; lept_mkdir ( "lept/dewmod" ) ; <S2SV_ModStart> lept_stderr ( "pdf<S2SV_blank>file<S2SV_blank>made:<S2SV_blank>/tmp/lept/model/dewarptest1.pdf\\n" <S2SV_ModEnd> ) ; pixDestroy
<S2SV_ModStart> lined ; PIX * pix1 , <S2SV_ModStart> if ( ( pix1 <S2SV_ModEnd> = pixFewColorsOctcubeQuant1 ( <S2SV_ModStart> procName , NULL ) ; pixc = pixConvertTo8 ( pix1 , 1 ) ; pixDestroy ( & pix1
<S2SV_ModStart> pos ] ; if ( npx < 0 || npx >= w || npy < 0 || npy >= h ) continue ;
<S2SV_ModStart> 1 ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s.html" , <S2SV_ModStart> charbuf ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s-links.html" , <S2SV_ModStart> factor ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s_thumb_%03d" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_uint8 <S2SV_ModStart> + 1 , "prestring=%490s" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ) ) > L_BUFSIZE <S2SV_ModEnd> - 3 ) <S2SV_ModStart> + 1 , "protos=%490s" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.data.%d" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%f<S2SV_blank>%f\\n" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.cmd" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.png" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.ps" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.eps" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "%s.tex" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>title<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>xlabel<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>ylabel<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>x" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>y" ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "gnuplot<S2SV_blank>%s" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , "wgnuplot<S2SV_blank>%s" ,
<S2SV_ModStart> char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( fp , "Rootname:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf )
<S2SV_ModStart> ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n" <S2SV_ModEnd> , & n
<S2SV_ModStart> char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------" <S2SV_ModEnd> , selname )
<S2SV_ModStart> char combname [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dh" , <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dv" ,
<S2SV_ModStart> ++ len ) { <S2SV_ModStart> == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = (
<S2SV_ModStart> str ) ; <S2SV_ModEnd> g_string_free ( result
<S2SV_ModStart> ; JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef js_script <S2SV_ModStart> JSContextGetGlobalObject ( context <S2SV_ModEnd> ) ; js_script <S2SV_ModStart> ) ; } <S2SV_ModEnd> JSStringRelease ( js_script
<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw <S2SV_ModStart> count = 0 ; addnode ( env , "DOAS_USER" , mypw -> pw_name ) <S2SV_ModStart> } } } else { static const char * copyset [ ] = { "DISPLAY" , "TERM" , NULL } ; addnode ( env , "HOME" , targpw -> pw_dir ) ; addnode ( env , "LOGNAME" , targpw -> pw_name ) ; addnode ( env , "PATH" , getenv ( "PATH" ) ) ; addnode ( env , "SHELL" , targpw -> pw_shell ) ; addnode ( env , "USER" , targpw -> pw_name ) ; fillenv ( env , copyset ) ; }
<S2SV_ModStart> rule * rule , const struct passwd * mypw , const struct passwd * targpw ) { <S2SV_ModEnd> struct env * <S2SV_ModStart> createenv ( rule , mypw , targpw <S2SV_ModEnd> ) ; if
<S2SV_ModStart> else path = g_get_home_dir <S2SV_ModEnd> ( ) ;
<S2SV_ModStart> ) ) , ETH_ASCII_ADDR_LEN <S2SV_ModEnd> ) ; strncat <S2SV_ModStart> , "/" , 1 <S2SV_ModEnd> ) ; strncat <S2SV_ModStart> ) ) , IP6_ASCII_ADDR_LEN <S2SV_ModEnd> ) ; gtkui_start_mitm
<S2SV_ModStart> == 0 ) if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> { uschar * hn ; if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_ModStart> ( ret = ff_set_dimensions ( avctx , <S2SV_ModEnd> s -> width <S2SV_ModStart> s -> height <S2SV_ModEnd> ) ) <
<S2SV_ModStart> j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> start ) ; if ( length > end - start ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> av_strstart ( proto_name <S2SV_ModStart> ( proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> , NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA ;
<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> 4 ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> codec_id == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> ) ; } <S2SV_ModEnd> { unsigned long <S2SV_ModStart> if ( dc_count != dc_w * dc_h * 3 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> int xd_size = 1 <S2SV_ModEnd> ; int data_len <S2SV_ModStart> xd_size += len + 1 + len / 255 ; } ret = ff_alloc_extradata ( st -> codecpar , xd_size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ] ) ; av_assert0 ( delta <= xd_size - offset ) ; <S2SV_ModEnd> offset += delta <S2SV_ModStart> break ; } av_assert0 ( data_len [ j ] <= xd_size - offset ) ;
<S2SV_ModStart> src < zsize + ( sub_type != 2 ) <S2SV_ModStart> bits ) { if ( src >= src_end ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> mb_height > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> AVERROR_INVALIDDATA ; } <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> ; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME
<S2SV_ModStart> } else { uint64_t <S2SV_ModEnd> target_end = s <S2SV_ModStart> s -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s -> <S2SV_ModStart> s -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) { <S2SV_ModStart> AV_LOG_ERROR , "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRIu64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\\n" , s
<S2SV_ModStart> = NULL ; uint64_t <S2SV_ModEnd> off = s <S2SV_ModStart> len , "Range:<S2SV_blank>bytes=%" PRIu64 <S2SV_ModEnd> "-" , s <S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
<S2SV_ModStart> -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for (
<S2SV_ModStart> s -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { if <S2SV_ModStart> -> chunksize = strtoull <S2SV_ModEnd> ( line , <S2SV_ModStart> ; av_log ( h <S2SV_ModEnd> , AV_LOG_TRACE , <S2SV_ModStart> AV_LOG_TRACE , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\'\\n" , s <S2SV_ModStart> return 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , "Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%" PRIu64 "\\n" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> ) ) { uint64_t <S2SV_ModEnd> target = h <S2SV_ModStart> AV_LOG_INFO , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "<S2SV_blank>error=%s.\\n" , s <S2SV_ModStart> AV_LOG_ERROR , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> ".\\n" , target
<S2SV_ModStart> -> hd ; uint64_t <S2SV_ModEnd> old_off = s <S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> && whence ==
<S2SV_ModStart> -> off = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( slash +
<S2SV_ModStart> -> filesize == UINT64_MAX <S2SV_ModEnd> ) { s <S2SV_ModStart> -> filesize = strtoull <S2SV_ModEnd> ( p , <S2SV_ModStart> -> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s -> <S2SV_ModStart> & s -> <S2SV_ModEnd> cookie_dict ) ) <S2SV_ModStart> -> icy_metaint = strtoull <S2SV_ModEnd> ( p ,
<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (
<S2SV_ModStart> VOS_STARTCODE ) { int profile , level ; <S2SV_ModStart> s , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO <S2SV_ModStart> FF_PROFILE_MPEG4_SIMPLE_STUDIO && ( <S2SV_ModEnd> level > 0 <S2SV_ModStart> > 0 && <S2SV_ModEnd> level < 9 <S2SV_ModStart> ) ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> studio_profile ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
<S2SV_ModStart> GetBitContext * gb , int * profile , int * level ) { * <S2SV_ModEnd> profile = get_bits <S2SV_ModStart> 4 ) ; * <S2SV_ModEnd> level = get_bits <S2SV_ModStart> ; if ( * <S2SV_ModEnd> profile == 0 <S2SV_ModStart> == 0 && * <S2SV_ModEnd> level == 8 <S2SV_ModStart> 8 ) { * <S2SV_ModEnd> level = 0
<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> int pixel_ptr = - 4 <S2SV_ModEnd> ; int block_ptr <S2SV_ModStart> -- ) { ADVANCE_BLOCK ( ) <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> } break ; <S2SV_ModStart> -- ) { ADVANCE_BLOCK ( ) ; <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> } break ; <S2SV_ModStart> ) return ; ADVANCE_BLOCK ( ) ; <S2SV_ModStart> row_inc ; } <S2SV_ModEnd> break ; default
<S2SV_ModStart> ; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; } if (
<S2SV_ModStart> ; y < FFMIN ( <S2SV_ModStart> s -> ymin , s -> h )
<S2SV_ModStart> ; if ( bpp == 1 && <S2SV_ModStart> else if ( bpp == 8 &&
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> return ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> ( s -> <S2SV_ModEnd> max_ra == INT_MAX
<S2SV_ModStart> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> 2 ) { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> chroma_planes = get_rac <S2SV_ModStart> state ) ; <S2SV_ModEnd> chroma_h_shift = get_symbol <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> chroma_v_shift = get_symbol <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> transparency = get_rac <S2SV_ModStart> , state ) ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( MpegEncContext <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> gb ) ; return 0 ;
<S2SV_ModStart> & 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
<S2SV_ModStart> ; sc -> drefs_count = 0 ; sc ->
<S2SV_ModStart> , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> = 1 ; } avctx -> pix_fmt = <S2SV_ModEnd> s -> has_alpha <S2SV_ModStart> s -> has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P ; <S2SV_ModEnd> s -> lossless
<S2SV_ModStart> pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> AVINDEX_KEYFRAME ) ; }
<S2SV_ModStart> ; int just_opened = 0 ; int reload_count <S2SV_ModStart> ; reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
<S2SV_ModStart> pb ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; for <S2SV_ModStart> ; int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> c -> tile_width <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3
<S2SV_ModStart> } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , "No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n" ) ; return AVERROR ( EINVAL ) ; } if (
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> frame -> color_primaries <S2SV_ModStart> frame -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , "Block<S2SV_blank>parameters<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
<S2SV_ModStart> avctx -> width || <S2SV_ModEnd> s -> height
<S2SV_ModStart> ; if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ++ ) { if ( band -> prec ) { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> -> band = av_calloc <S2SV_ModEnd> ( reslevel -> <S2SV_ModStart> -> prec = av_calloc <S2SV_ModEnd> ( reslevel ->
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> pb ) ; } <S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> pb ) ; } <S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> & 0xFFFF ; }
<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
<S2SV_ModStart> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> item_num > 65536 || item_num < 0
<S2SV_ModStart> c -> nreslevels <= <S2SV_ModEnd> s -> reduction_factor <S2SV_ModStart> -> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , "reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c -> nreslevels2decode
<S2SV_ModStart> c -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> c -> buffer_ptr <S2SV_ModStart> ; else { av_assert0 ( len <= c -> chunk_size ) ;
<S2SV_ModStart> ; if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ; if (
<S2SV_ModStart> , size2 , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
<S2SV_ModStart> chroma_v_shift , transparency , colorspace , bits_per_raw_sample <S2SV_ModStart> ] ; } <S2SV_ModEnd> colorspace = get_symbol <S2SV_ModStart> 0 ) ; bits_per_raw_sample = <S2SV_ModEnd> f -> version <S2SV_ModStart> version > 0 ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> f -> avctx <S2SV_ModStart> avctx -> bits_per_raw_sample ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> 0 ) ; chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> = get_rac ( <S2SV_ModStart> state ) ; <S2SV_ModEnd> if ( f <S2SV_ModStart> { if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> ; } } f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;
<S2SV_ModStart> 1 ) ; if ( ymax < avctx -> height )
<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
<S2SV_ModStart> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> ) { uint32_t zeroes , bits_value , <S2SV_ModStart> ; int position <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; zeroes = <S2SV_ModEnd> 0 ; while <S2SV_ModStart> gbc ) < <S2SV_ModEnd> 1 ) { <S2SV_ModStart> gbc ) ) break ; ++ zeroes ; } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { if ( get_bits_left ( gbc ) < zeroes ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , "Invalid<S2SV_blank>uvlc<S2SV_blank>code<S2SV_blank>at<S2SV_blank>" "%s:<S2SV_blank>bitstream<S2SV_blank>ended.\\n" , name ) ; return AVERROR_INVALIDDATA ; } bits_value = get_bits_long ( gbc , zeroes ) ; value = bits_value + ( UINT32_C ( 1 ) << zeroes ) - 1 ; } if ( ctx -> trace_enable ) { char bits [ 65 ] ; int i , j , k ; if ( zeroes >= 32 ) { while ( zeroes > 32 ) { k = FFMIN ( zeroes - 32 , 32 ) ; for ( i = 0 ; i < k ; i ++ ) bits [ i ] = '0' ; bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , 0 ) ; zeroes -= k ; position += k ; } } for ( i = 0 ; i < zeroes ; i ++ ) bits [ i ] = '0' ; <S2SV_ModEnd> bits [ i <S2SV_ModStart> = '1' ; if ( zeroes < 32 ) { <S2SV_ModEnd> for ( j <S2SV_ModStart> ] = ( bits_value <S2SV_ModEnd> >> ( zeroes <S2SV_ModStart> : '0' ; } <S2SV_ModEnd> bits [ i
<S2SV_ModStart> ; int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> nblocks > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> -> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> -> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> av_log ( mxf -> fc
<S2SV_ModStart> cur_pic . field_picture <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> avctx ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> { av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ; return
<S2SV_ModStart> studio_profile ) { <S2SV_ModEnd> if ( !
<S2SV_ModStart> i ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + size ; }
<S2SV_ModStart> ; if ( * value == 0 ||
<S2SV_ModStart> * ptrptr && <S2SV_ModEnd> nmemb && size <S2SV_ModStart> nmemb && size <S2SV_ModEnd> ) return AVERROR
<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> , * ptr <S2SV_ModEnd> ; int ncolors <S2SV_ModStart> = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> + avpkt -> <S2SV_ModStart> ; while ( end - ptr > 9 && <S2SV_ModStart> , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log <S2SV_ModStart> ) size *= 95 <S2SV_ModEnd> ; if ( <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> ) ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> ; } } } <S2SV_ModStart> = 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
<S2SV_ModStart> += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> c -> width + 15 <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3 ; aligned_height = <S2SV_ModEnd> c -> height <S2SV_ModStart> c -> height + 15 <S2SV_ModEnd> ; av_free (
<S2SV_ModStart> s ) { int64_t <S2SV_ModEnd> hours , minutes
<S2SV_ModStart> bpp <= 8 && c -> format != CHUNKY
<S2SV_ModStart> ( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> in -> data [ plane ] && in -> linesize
<S2SV_ModStart> src -> data [ plane ] && src -> linesize
<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> [ p ] && in -> linesize [ p ]
<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]
<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> [ i ] && out -> linesize [ i ]
<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> frame -> data [ plane ] && frame -> linesize <S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> in -> data [ plane ] && in -> linesize
<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;
<S2SV_ModStart> , i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>before<S2SV_blank>IHDR\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>after<S2SV_blank>IDAT\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> != 6 ) || s -> bit_depth == 1
<S2SV_ModStart> ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;
<S2SV_ModStart> * st ; int ret ; <S2SV_ModStart> val ) ; ret = <S2SV_ModStart> ] ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ! new_buffer ) { pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; } <S2SV_ModStart> ! new_buffer ) { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> ENOMEM ) ; }
<S2SV_ModStart> < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> timescale > UINT16_MAX || ! track -> par -> channels
<S2SV_ModStart> ] + y / s -> cdy [ compno ] <S2SV_ModStart> line + x / s -> cdx [ compno ] <S2SV_ModStart> ] + y / s -> cdy [ compno ] <S2SV_ModStart> + ( x / s -> cdx [ compno ]
<S2SV_ModStart> dst_size ) { GetByteContext gb <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( data >= data_end <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; bytestream2_init ( & gb , data , data_end - <S2SV_ModEnd> data ) ; <S2SV_ModStart> data ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name , <S2SV_ModStart> , name , <S2SV_ModEnd> dst , dst_size <S2SV_ModStart> dst , dst_size ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> , password , length <S2SV_ModEnd> ) ; attr
<S2SV_ModStart> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
<S2SV_ModStart> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> -> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> 0 ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> BufferOffset <S2SV_ModStart> -> BufferOffset + ( UINT64 ) <S2SV_ModStart> fields -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ( length > 5 <S2SV_ModEnd> ) Stream_Seek_UINT16 ( <S2SV_ModStart> ( length > 7 <S2SV_ModEnd> ) Stream_Seek_UINT16 (
<S2SV_ModStart> count ) { UINT32 <S2SV_ModEnd> count = bitmapUpdate <S2SV_ModStart> * 2 ; BITMAP_DATA *
<S2SV_ModStart> goto out_free_blob ; if ( Stream_GetRemainingLength ( licenseStream ) < 8 ) goto out_free_stream ; <S2SV_ModStart> cbScope ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbCompanyName ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ; <S2SV_ModStart> cbProductId ) ; if ( Stream_GetRemainingLength ( licenseStream ) < 4 ) goto out_free_stream ;
<S2SV_ModStart> cbBitsColor ) ; newBitMask = ( BYTE * ) realloc ( iconInfo -> bitsMask , iconInfo -> cbBitsMask ) ; if ( ! newBitMask ) { free ( iconInfo -> bitsMask ) ; iconInfo -> bitsMask = NULL ; return FALSE ; } iconInfo -> bitsMask = newBitMask ; <S2SV_ModStart> iconInfo -> cbBitsMask ) return FALSE <S2SV_ModEnd> ; Stream_Read ( <S2SV_ModStart> -> colorTable ) { if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbColorTable ) return FALSE ; <S2SV_ModStart> cbColorTable ) ; } <S2SV_ModStart> = newBitMask ; if ( Stream_GetRemainingLength ( s ) < iconInfo -> cbBitsColor ) return FALSE ;
<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )
<S2SV_ModStart> = CHANNEL_RC_OK ; void * ptr ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( printjob , ptr <S2SV_ModEnd> , Length )
<S2SV_ModStart> UINT error ; if ( Stream_GetRemainingLength ( s ) < 6 ) return ERROR_INVALID_DATA ;
<S2SV_ModStart> , packetLength ) || ( packetLength < header )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , "RDP_NEG_FAILURE" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_request ( rdpNego <S2SV_ModStart> ; UINT16 length ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_response ( rdpNego <S2SV_ModStart> NEGO_STATE_FAIL ; return FALSE <S2SV_ModStart> = NEGO_STATE_FINAL ; return TRUE ;
<S2SV_ModStart> FALSE ; } if ( ! <S2SV_ModStart> , s ) ) return FALSE
<S2SV_ModStart> case TYPE_RDP_NEG_RSP : if ( ! <S2SV_ModStart> , s ) ) return - 1 <S2SV_ModStart> case TYPE_RDP_NEG_FAILURE : if ( ! <S2SV_ModStart> , s ) ) return - 1
<S2SV_ModStart> ; length += get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ; length +=
<S2SV_ModStart> -> controlFlags , get_primary_drawing_order_field_bytes ( <S2SV_ModEnd> orderInfo -> orderType <S2SV_ModStart> orderInfo -> orderType , NULL ) <S2SV_ModEnd> ) ; update_write_bounds
<S2SV_ModStart> int status ; WCHAR * ptr ; <S2SV_ModStart> UINT32 PathLength ; if ( ! Stream_SafeSeek <S2SV_ModEnd> ( irp -> <S2SV_ModStart> , 28 ) ) return ERROR_INVALID_DATA ; if ( Stream_GetRemainingLength ( irp -> input ) < 4 ) return ERROR_INVALID_DATA <S2SV_ModStart> PathLength ) ; ptr = ( WCHAR * ) Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , PathLength ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> , 0 , ptr <S2SV_ModEnd> , PathLength /
<S2SV_ModStart> wmac ) ; if ( ! <S2SV_ModStart> , rdp ) ) return FALSE
<S2SV_ModStart> rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
<S2SV_ModStart> buffer ) { SECURITY_STATUS status = SEC_E_INVALID_TOKEN ; <S2SV_ModStart> ; UINT32 flags = 0 <S2SV_ModStart> NTLM_AV_PAIR * AvFlags = NULL <S2SV_ModStart> -> credentials ; <S2SV_ModEnd> message = & <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( message <S2SV_ModStart> != MESSAGE_TYPE_AUTHENTICATE ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ; <S2SV_ModEnd> Stream_Read_UINT32 ( s <S2SV_ModStart> Len ) ) goto fail ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ; } PayloadBufferOffset = Stream_GetPosition ( s ) ; status = SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ; if ( message -> NtChallengeResponse . Len > 0 ) { int rc ; <S2SV_ModEnd> size_t cbAvFlags ; <S2SV_ModStart> ! snt ) goto fail ; status = SEC_E_INVALID_TOKEN ; rc = ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) ; Stream_Free ( snt <S2SV_ModEnd> , FALSE ) <S2SV_ModStart> FALSE ) ; if ( rc < 0 ) goto fail ; status = SEC_E_INTERNAL_ERROR <S2SV_ModEnd> ; context -> <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( message <S2SV_ModStart> != 16 ) goto fail ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> length ) ) goto fail ; CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; status = SEC_E_INVALID_TOKEN ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ; Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } status = SEC_E_INTERNAL_ERROR ; <S2SV_ModEnd> # ifdef WITH_DEBUG_NTLM <S2SV_ModStart> . User ) goto fail ; <S2SV_ModEnd> CopyMemory ( credentials <S2SV_ModStart> . Domain ) goto fail ; <S2SV_ModEnd> CopyMemory ( credentials <S2SV_ModStart> return SEC_I_COMPLETE_NEEDED ; fail : Stream_Free ( s , FALSE ) ; return status ;
<S2SV_ModStart> SEC_E_INVALID_TOKEN ; } if ( Stream_GetRemainingLength ( s ) < 4 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> rdp_read_flow_control_pdu ( wStream <S2SV_ModStart> { UINT8 pduType ; if ( ! type ) return FALSE ; if ( Stream_GetRemainingLength ( s ) < 6 ) return FALSE <S2SV_ModStart> s ) ; return TRUE ;
<S2SV_ModStart> channel_id ) { UINT16 len ; <S2SV_ModStart> ( s , len ) ; * length = len <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( len <S2SV_ModEnd> == 0x8000 ) <S2SV_ModStart> 0x8000 ) { if ( ! <S2SV_ModStart> , type ) ) return FALSE <S2SV_ModStart> if ( ( len < 4 ) || ( ( len <S2SV_ModEnd> - 2 ) <S2SV_ModStart> Stream_GetRemainingLength ( s ) <S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 4 )
<S2SV_ModStart> { LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> ( s ) { tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 4 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
<S2SV_ModStart> if ( index >= <S2SV_ModEnd> glyphCache -> glyphCache
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_decode ( NSC_CONTEXT <S2SV_ModStart> ; UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart> 8 ) ; <S2SV_ModEnd> shift = context <S2SV_ModStart> - 1 ; <S2SV_ModEnd> bmpdata = context <S2SV_ModStart> context -> BitmapData ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> - cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> ; } } return TRUE ;
<S2SV_ModStart> return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( BYTE <S2SV_ModStart> BYTE * out , UINT32 outSize <S2SV_ModStart> 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( NSC_CONTEXT <S2SV_ModStart> UINT32 originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> 0xFF ) ; } <S2SV_ModStart> < originalSize ) { if ( ! <S2SV_ModStart> i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> originalSize ) ; } <S2SV_ModStart> planeSize ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( NSC_CONTEXT <S2SV_ModStart> rowstride ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> , rowstride ) ) return FALSE <S2SV_ModStart> ChromaSubsamplingLevel ) { if ( ! <S2SV_ModStart> ( context ) ) return FALSE ; } return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( NSC_CONTEXT <S2SV_ModStart> ; UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> -> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ) ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;
<S2SV_ModStart> UINT32 nsc_rle_encode ( const
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( NSC_CONTEXT <S2SV_ModStart> ) ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> update_read_synchronize ( rdpUpdate <S2SV_ModStart> update ) ; return Stream_SafeSeek ( s , 2 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> case UPDATE_TYPE_SYNCHRONIZE : if ( ! <S2SV_ModStart> , s ) ) goto fail
<S2SV_ModStart> , "received<S2SV_blank>Bandwidth<S2SV_blank>Measure<S2SV_blank>Results<S2SV_blank>PDU" ) ; if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1
<S2SV_ModStart> ) ) { if ( Stream_GetRemainingLength ( s ) < 8 ) return FALSE ;
<S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) { if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { <S2SV_ModStart> ) ) ; } else { xWantedSize = 0 ; } <S2SV_ModStart> } if ( ( xWantedSize > 0 ) &&
<S2SV_ModStart> } if ( ( <S2SV_ModStart> > 0 ) && ( ( xWantedSize + heapSTRUCT_SIZE ) > xWantedSize ) ) <S2SV_ModStart> ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize <S2SV_ModStart> & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize <S2SV_ModEnd> ) { xWantedSize <S2SV_ModStart> ) ) ; configASSERT ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 ) ; } else { xWantedSize = 0 ; } } else { xWantedSize = 0 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> && ( xWantedSize <= xFreeBytesRemaining <S2SV_ModEnd> ) ) {
<S2SV_ModStart> { if ( ( <S2SV_ModStart> xWantedSize > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) <S2SV_ModStart> 0x00 ) { if ( ( xWantedSize + <S2SV_ModEnd> ( portBYTE_ALIGNMENT - <S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) <S2SV_ModStart> } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> { if ( ( <S2SV_ModStart> > 0 ) && ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) ) <S2SV_ModStart> 0x00 ) { if ( ( xWantedSize + <S2SV_ModEnd> ( portBYTE_ALIGNMENT - <S2SV_ModStart> portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { xWantedSize = 0 ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { xWantedSize = 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> TRUE ; } <S2SV_ModEnd> } else if <S2SV_ModStart> TRUE ; } <S2SV_ModEnd> } else if <S2SV_ModStart> TRUE ; } } else <S2SV_ModEnd> { g_set_error (
<S2SV_ModStart> gchar * filename = NULL ; gint file_handle <S2SV_ModStart> use_gimp_2_8_features ) ; file_handle = g_file_open_tmp ( "gimp-test-XXXXXX.xcf" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> ) ; file
<S2SV_ModStart> = conn ; <S2SV_ModEnd> g_debug ( "GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s"
<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
<S2SV_ModStart> } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection <S2SV_ModEnd> ( ice_conn ) <S2SV_ModStart> ice_conn ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> IceConn ice_conn ; GsmClient * client ; GsmIceConnectionWatch * data <S2SV_ModEnd> ; if ( <S2SV_ModStart> sms_conn ) ; data <S2SV_ModEnd> = ice_conn -> <S2SV_ModStart> -> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; gsm_xsmp_client_connect <S2SV_ModStart> ; gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn ,
<S2SV_ModStart> subdir ) { dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart> subdir ) ; <S2SV_ModEnd> } else dir
<S2SV_ModStart> gint * ac ; g_assert ( box_width > 0 )
<S2SV_ModStart> sy ) { <S2SV_ModEnd> gint width , <S2SV_ModStart> sy = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * row2 ; gboolean use_box_blur ; if ( sx < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ; <S2SV_ModStart> int x ; gboolean use_box_blur ; if ( sy < 10.0 ) use_box_blur = FALSE ; else use_box_blur = TRUE ;
<S2SV_ModStart> < 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity
<S2SV_ModStart> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1
<S2SV_ModStart> l ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> XML_ERR_NAME_TOO_LONG , "Name" ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , "unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"
<S2SV_ModStart> gboolean res ; g_autofree gchar * trusted = NULL ; <S2SV_ModStart> TRUE ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> ( file ) && trusted != NULL
<S2SV_ModStart> ) ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,
<S2SV_ModStart> , _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , _ ( "Trust<S2SV_blank>and<S2SV_blank>_Launch" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> g_signal_connect ( dialog
<S2SV_ModStart> ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , "yes" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModEnd> screen = gtk_widget_get_screen <S2SV_ModStart> uri ) ; <S2SV_ModEnd> g_object_unref ( file
<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
<S2SV_ModStart> char * ininame , load_options options <S2SV_ModStart> case LINE_ERROR : if ( options & HIDE_ERRORED_LINE_CONTENT ) { <S2SV_ModStart> ( stderr , "iniparser:<S2SV_blank>syntax<S2SV_blank>error<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>(%d)\\n" , ininame , lineno ) ; } else { fprintf ( stderr , <S2SV_ModStart> line ) ; }
<S2SV_ModStart> iniparser_load ( filename , HIDE_ERRORED_LINE_CONTENT
<S2SV_ModStart> { guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> { gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> "MemoryAllocationFailed" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { <S2SV_ModStart> ( CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> filename <S2SV_ModEnd> ) ; }
<S2SV_ModStart> != MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> "ImproperImageHeader" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) "<S2SV_blank>Debug" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) "<S2SV_blank>Cipher" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) "<S2SV_blank>HDRI" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) "<S2SV_blank>Modules" <S2SV_ModStart> "<S2SV_blank>OpenMP" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) "<S2SV_blank>Zero-configuration" # endif
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> MagickCoreSignature ) ; pixel = 0 ;
<S2SV_ModStart> == VFF_TYP_BIT ) { if ( CheckMemoryOverflow <S2SV_ModEnd> ( ( image <S2SV_ModStart> ) >> 3UL , <S2SV_ModEnd> image -> rows <S2SV_ModStart> image -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModEnd> max_packets = ( <S2SV_ModStart> number_data_bands ) ; }
<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length )
<S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof ( <S2SV_ModStart> -> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels =
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> ; if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if (
<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> , extent , height , <S2SV_ModStart> "UnableToReadImageData" ) ; <S2SV_ModEnd> height = sun_info <S2SV_ModStart> "MemoryAllocationFailed" ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> sun_data ) ; <S2SV_ModEnd> p = sun_pixels
<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> sum = ( <S2SV_ModStart> ++ ; } \\\n} <S2SV_ModEnd> typedef struct PCDTable <S2SV_ModStart> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++ <S2SV_ModStart> < 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p ++
<S2SV_ModStart> DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> ) ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t bit <S2SV_ModStart> ++ ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( ( <S2SV_ModStart> 255 , q , exception <S2SV_ModEnd> ) ; q <S2SV_ModStart> ++ ; } if ( x != image -> columns ) <S2SV_ModStart> ; } } <S2SV_ModEnd> return ( SyncAuthenticPixels
<S2SV_ModStart> number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info =
<S2SV_ModStart> ++ ) { CheckNumberCompactPixels ; <S2SV_ModStart> ; } } <S2SV_ModEnd> compact_pixels ++ ;
<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> "UnableToReadImageData" ) ; }
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { for
<S2SV_ModStart> maptype ) { case RMT_NONE : break ;
<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> depth ++ ) if ( depth >= 64 ) break
<S2SV_ModStart> "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
<S2SV_ModStart> 0x0004 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0x0008 : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> 0 ; i <= <S2SV_ModEnd> ( ssize_t ) <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> GetQuantumRange ( depth <S2SV_ModStart> GetQuantumRange ( depth <S2SV_ModEnd> ) ; i <S2SV_ModStart> NULL ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> red ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> green ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * <S2SV_ModStart> j ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j <S2SV_ModStart> ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels
<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> Quantum index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> image -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" <S2SV_ModEnd> ) ; status
<S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; number_pixels <S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> ( ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; bytes_per_line <S2SV_ModStart> height ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( info <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> break ; } if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
<S2SV_ModStart> = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> bitmapDC = CreateCompatibleDC
<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
<S2SV_ModStart> "ImproperImageHeader" ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> ( size_t ) MagickMax ( <S2SV_ModStart> . length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> sun_info . height <S2SV_ModEnd> ; if (
<S2SV_ModStart> int depth ; quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> ) ; } if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> ) ; } quantum_info = ( QuantumInfo * ) NULL ; <S2SV_ModStart> BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof
<S2SV_ModStart> Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> extent , height <S2SV_ModEnd> ; ssize_t count <S2SV_ModStart> PseudoClass ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> columns <S2SV_ModStart> % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for ( <S2SV_ModStart> ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p ++ <S2SV_ModStart> * p ++ ) <S2SV_ModStart> q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> if ( ( <S2SV_ModEnd> ( bytes_per_pixel *
<S2SV_ModStart> image ) ; count = <S2SV_ModEnd> ReadBlob ( image <S2SV_ModStart> iris_info . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" <S2SV_ModStart> filler ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) <S2SV_ModEnd> ; image -> <S2SV_ModStart> } if ( <S2SV_ModEnd> ( image_info ->
<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
<S2SV_ModStart> * output ; MagickBooleanType status ; <S2SV_ModStart> ) ; } status = MagickTrue ; <S2SV_ModStart> i ++ ) { <S2SV_ModEnd> input = fopen_utf8 <S2SV_ModStart> input ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> ( void ) fclose ( input <S2SV_ModEnd> ) ; ( <S2SV_ModStart> ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( <S2SV_ModEnd> output ) ; <S2SV_ModStart> ; return ( status <S2SV_ModEnd> ) ; }
<S2SV_ModStart> != '\\0' ) && ( c != EOF ) <S2SV_ModStart> 2 ] ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> 1 ] ) == 8 ) { <S2SV_ModEnd> image -> chromaticity <S2SV_ModStart> 1 ] ; } <S2SV_ModStart> , width ; if ( <S2SV_ModEnd> sscanf ( value <S2SV_ModStart> & width ) == 2 ) { <S2SV_ModEnd> image -> columns <S2SV_ModStart> ) height ; }
<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> q ) ; q += GetPixelChannels ( image ) ; p ++ <S2SV_ModEnd> ; } if <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 2 ) {
<S2SV_ModStart> -> rows = 1 <S2SV_ModEnd> ; image -> <S2SV_ModStart> ( BImgBuff ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( data <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char explicit_vr [ <S2SV_ModStart> image ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError ,
<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j
<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length > <S2SV_ModStart> image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> 0xff ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> ( void ) strncpy <S2SV_ModEnd> ( clone_info ->
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
<S2SV_ModStart> RT_ENCODED ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . depth <S2SV_ModStart> sun_info . depth ) > ( 8 * <S2SV_ModEnd> sun_info . length <S2SV_ModStart> sun_info . length ) <S2SV_ModStart> ( bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2 )
<S2SV_ModStart> ; image -> <S2SV_ModEnd> colors = sun_info <S2SV_ModStart> / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModStart> maptype ) { <S2SV_ModEnd> case RMT_EQUAL_RGB : <S2SV_ModStart> char * sun_colormap <S2SV_ModEnd> ; sun_colormap =
<S2SV_ModStart> = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> size_t ) ldblk + 1
<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> "ImproperImageHeader" ) ; }
<S2SV_ModStart> size_t ) count + 1
<S2SV_ModStart> <S2SV_null> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( Image <S2SV_ModStart> image , ssize_t bpp <S2SV_ModEnd> , unsigned char <S2SV_ModStart> exception ) { int bit ; Quantum index <S2SV_ModEnd> ; register Quantum <S2SV_ModStart> ; register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> ; switch ( bpp <S2SV_ModEnd> ) { case <S2SV_ModStart> 1 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> bit < ( ssize_t ) ( <S2SV_ModStart> index = ( <S2SV_ModEnd> ( * p <S2SV_ModStart> 0x80 >> bit <S2SV_ModEnd> ) ? 0x01 <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 2 : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } break ; } case 4 : { <S2SV_ModEnd> for ( x <S2SV_ModStart> * p >> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ( * p ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ( image ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 4 ) & 0x0f <S2SV_ModEnd> , exception ) <S2SV_ModStart> q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> 8 : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> columns <S2SV_ModStart> image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception ) <S2SV_ModStart> exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } break ; case 24 : <S2SV_ModEnd> for ( x <S2SV_ModStart> ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception ) <S2SV_ModStart> , exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"

<S2SV_ModStart> , arg ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break
<S2SV_ModStart> 4 ] ; unsigned int <S2SV_ModEnd> value ; if <S2SV_ModStart> value = ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> ; value |= ( unsigned int ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (
<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 8 <S2SV_ModEnd> ; value |= <S2SV_ModStart> ; value |= ( unsigned short ) <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return ( <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ; return (
<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return ( <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) buffer <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; quantum . <S2SV_ModStart> . unsigned_value = <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ; return (
<S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffffffff <S2SV_ModStart> value & 0xffffffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned int ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> ] << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 2 <S2SV_ModStart> ] << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ 3 <S2SV_ModStart> [ 3 ] ; return <S2SV_ModEnd> ( value & <S2SV_ModStart> & 0xffffffff ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= <S2SV_ModEnd> ( unsigned short <S2SV_ModStart> unsigned short ) buffer [ 1 ] ; return <S2SV_ModStart> & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> Image * image ; int c <S2SV_ModStart> , padding , <S2SV_ModEnd> version , width <S2SV_ModStart> . red = ( MagickRealType ) <S2SV_ModStart> . green = ( MagickRealType ) <S2SV_ModStart> . blue = ( MagickRealType ) <S2SV_ModStart> . red = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . green = 0.0 <S2SV_ModEnd> ; image -> <S2SV_ModStart> . blue = 0.0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c <S2SV_ModEnd> ; if ( <S2SV_ModStart> char ) ( c <S2SV_ModEnd> >> 8 ) <S2SV_ModStart> ++ ) { c <S2SV_ModEnd> = XBMInteger ( <S2SV_ModStart> , hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> unsigned char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) <S2SV_ModEnd> ; } p <S2SV_ModStart> byte = ( unsigned int <S2SV_ModEnd> ) ( *
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModEnd> int XBMInteger ( <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; return ( ( int )
<S2SV_ModStart> ; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> "ImproperImageHeader" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob
<S2SV_ModStart> if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
<S2SV_ModStart> ( ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> image , q ) , exception
<S2SV_ModStart> ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor
<S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image <S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels ,
<S2SV_ModStart> ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> AcquireQuantumMemory ( imsx , imsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ; if <S2SV_ModStart> , background_color_index , ( size_t ) <S2SV_ModStart> ( imbuf + ( size_t ) <S2SV_ModStart> AcquireQuantumMemory ( dmsx , dmsy <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> "MemoryAllocationFailed" ) ; } <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> MagickFalse ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> "MemoryAllocationFailed" ) ; } <S2SV_ModStart> NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
<S2SV_ModStart> define EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> . x = ( ssize_t ) <S2SV_ModStart> . y = ( ssize_t ) <S2SV_ModStart> "ImproperImageHeader" ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModStart> CorruptImageError , "UnexpectedEndOfFile" ) ; if ( number_colormaps != 0 ) { <S2SV_ModEnd> colormap = ( <S2SV_ModStart> char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) { * p ++ = <S2SV_ModEnd> ( unsigned char <S2SV_ModStart> ( unsigned char <S2SV_ModEnd> ) ScaleQuantumToChar ( <S2SV_ModStart> ) ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> != MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModStart> CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } offset = ( ssize_t ) ( <S2SV_ModEnd> ( ( image <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> & 0x40 ) { <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> ; offset = ( ssize_t ) ( <S2SV_ModStart> number_planes + plane ) <S2SV_ModStart> ) || ( ( offset + <S2SV_ModEnd> operand * number_planes <S2SV_ModStart> number_planes ) > ( ssize_t ) <S2SV_ModStart> image ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ( image , ( ssize_t ) ( <S2SV_ModStart> p & mask ) <S2SV_ModStart> image , ( ssize_t <S2SV_ModEnd> ) ( x <S2SV_ModStart> ( image , ( Quantum )
<S2SV_ModStart> ; if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> ; while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> if ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break ; <S2SV_ModStart> + filepos ) >= <S2SV_ModEnd> GetBlobSize ( image <S2SV_ModStart> - 1 ) ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile"
<S2SV_ModStart> ( len -- > 0 <S2SV_ModStart> ( len -- > 0
<S2SV_ModStart> ; UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> Bitmap2Header1 . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> ; } } <S2SV_ModEnd> Finish : (
<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> "`%s\'" , option ) ; page_geometry = DestroyString ( page_geometry
<S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel & <S2SV_ModStart> pixel & ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel << <S2SV_ModStart> pixel << ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel | <S2SV_ModStart> pixel | ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel >> <S2SV_ModStart> pixel >> ( ssize_t <S2SV_ModEnd> ) ( value <S2SV_ModStart> ) ( ( ssize_t <S2SV_ModEnd> ) pixel ^ <S2SV_ModStart> pixel ^ ( ssize_t <S2SV_ModEnd> ) ( value
<S2SV_ModStart> "`%s\'" , option ) ; geometry = DestroyString ( geometry
<S2SV_ModStart> ; if ( <S2SV_ModEnd> g_path_is_absolute ( filename
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> [ i ] ) ; log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf
<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
<S2SV_ModStart> ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> CR_ERR_SSL_EXPECTED ) ; peer = NULL ;
<S2SV_ModStart> radius_get_vendor_attr ) { <S2SV_ModEnd> const void * <S2SV_ModStart> void * data , * raw <S2SV_ModStart> ; u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModStart> "s" , & raw <S2SV_ModEnd> , & len <S2SV_ModStart> return ; } if ( <S2SV_ModEnd> rad_get_vendor_attr ( & <S2SV_ModStart> vendor , & type , & data , & data_len , raw , len ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> , "attr" , type <S2SV_ModEnd> ) ; add_assoc_long <S2SV_ModStart> ) data , data_len <S2SV_ModEnd> , 1 )
<S2SV_ModStart> u_int32_t * vendor , unsigned char * type <S2SV_ModStart> size_t * len , const void * raw , size_t raw_len <S2SV_ModStart> * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor <S2SV_ModStart> -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }
<S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD if ( width < TS || height < TS ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; <S2SV_ModStart> throw LIBRAW_EXCEPTION_IO_CORRUPT ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) allhex [ i ] [ j ] [ k ] [ l ] = 32700 ; <S2SV_ModStart> 6 ) ) ; int minv = 0 , maxv = 0 , minh = 0 , maxh = 0 <S2SV_ModStart> 1 ] ; minv = MIN ( v , minv ) ; maxv = MAX ( v , maxv ) ; minh = MIN ( v , minh ) ; maxh = MAX ( v , maxh ) ; <S2SV_ModStart> ; } } # ifdef LIBRAW_LIBRARY_BUILD for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 8 ; l ++ ) if ( allhex [ i ] [ j ] [ k ] [ l ] > maxh + maxv * width + 1 || allhex [ i ] [ j ] [ k ] [ l ] < minh + minv * width - 1 ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; int retrycount = 0 ; # endif <S2SV_ModStart> > 2 ) { <S2SV_ModStart> row -- ; # ifdef LIBRAW_LIBRARY_BUILD if ( retrycount ++ > width * height ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif }
<S2SV_ModStart> ) == 0x48454150 <S2SV_ModEnd> # ifdef LIBRAW_LIBRARY_BUILD <S2SV_ModStart> # ifdef LIBRAW_LIBRARY_BUILD && ( save + hlen ) >= 0 && ( save + hlen ) <= ifp -> size ( ) # endif ) { # ifdef LIBRAW_LIBRARY_BUILD
<S2SV_ModStart> ifd ++ ; # ifdef LIBRAW_LIBRARY_BUILD if ( ifd >= sizeof tiff_ifd / sizeof tiff_ifd [ 0 ] ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif <S2SV_ModStart> if ( len < 1 || len
<S2SV_ModStart> + 8 ; # ifdef LIBRAW_LIBRARY_BUILD if ( offset > ifp -> size ( ) - 8 ) offset = ifp -> size ( ) - 8 ; # endif <S2SV_ModStart> ( ) ; if ( len < 0 ) return ;
<S2SV_ModStart> "Quicktake" ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ; # endif
<S2SV_ModStart> ; row < raw_height <S2SV_ModEnd> ; row ++ <S2SV_ModStart> col < width && row < height
<S2SV_ModStart> ) return ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_PARSEFUJI_PROCESSED ; # endif
<S2SV_ModStart> length == SIZE_MAX || length > INT_MAX
<S2SV_ModStart> char * data <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> toDecode ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { uint32_t tmp ; memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ; tmp <S2SV_ModEnd> ^= wsctx -> <S2SV_ModStart> mask . u ; memcpy ( data + i * sizeof ( tmp ) , & tmp , sizeof ( tmp ) )
<S2SV_ModStart> if ( length == SIZE_MAX ) { rfbErr ( "rfbProcessFileTransferReadBuffer:<S2SV_blank>too<S2SV_blank>big<S2SV_blank>file<S2SV_blank>transfer<S2SV_blank>length<S2SV_blank>requested:<S2SV_blank>%u" , ( unsigned int ) length ) ; rfbCloseClient ( cl ) ; return NULL ; } if ( length <S2SV_ModStart> malloc ( ( size_t <S2SV_ModEnd> ) length +
<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes
<S2SV_ModStart> ; uint8_t verify_crls <S2SV_ModEnd> ; if ( <S2SV_ModStart> anonTLS ) { verify_crls = cred -> x509Credential . x509CrlVerifyMode ;
<S2SV_ModStart> , sraSpan * after ) { if ( newspan && <S2SV_ModStart> newspan ; } }
<S2SV_ModStart> , sraSpan * before ) { if ( newspan && <S2SV_ModStart> newspan ; } }
<S2SV_ModStart> ( sraSpan * span ) { if ( <S2SV_ModStart> _prev ; } }
<S2SV_ModStart> i ) { if ( ! i ) return NULL ;
<S2SV_ModStart> { if ( iterator &&
<S2SV_ModStart> = AF_UNIX ; if ( strlen ( sockFile ) + 1 > sizeof ( addr . sun_path ) ) { rfbClientErr ( "ConnectToUnixSock:<S2SV_blank>socket<S2SV_blank>file<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long\\n" ) ; return - 1 ; }
<S2SV_ModStart> cl ) { union { char bytes <S2SV_ModEnd> [ sz_rfbSetColourMapEntriesMsg + <S2SV_ModStart> ] ; rfbSetColourMapEntriesMsg msg ; } buf ; rfbSetColourMapEntriesMsg * scme = & buf . msg <S2SV_ModEnd> ; uint16_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> cl , buf . bytes
<S2SV_ModStart> ; if ( width >= MAX_CURSOR_SIZE || height >= MAX_CURSOR_SIZE ) return FALSE ; if (
<S2SV_ModStart> n ) { const int USECS_WAIT_PER_RETRY = 100000 ; int retries = 0 ; <S2SV_ModStart> EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( "Connection<S2SV_blank>timed<S2SV_blank>out\\n" ) ; return FALSE ; } <S2SV_ModStart> ( client , USECS_WAIT_PER_RETRY <S2SV_ModEnd> ) ; i <S2SV_ModStart> EAGAIN ) { if ( client -> readTimeout > 0 && ++ retries > ( client -> readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY ) ) { rfbClientLog ( "Connection<S2SV_blank>timed<S2SV_blank>out\\n" ) ; return FALSE ; } <S2SV_ModStart> ( client , USECS_WAIT_PER_RETRY <S2SV_ModEnd> ) ; i
<S2SV_ModStart> connectTimeout = DEFAULT_CONNECT_TIMEOUT ; client -> readTimeout = DEFAULT_READ_TIMEOUT
<S2SV_ModStart> ; default : if ( msg . tc . length > MAX_TEXTCHAT_SIZE ) return FALSE ;
<S2SV_ModStart> = malloc ( <S2SV_ModEnd> msg . sct
<S2SV_ModStart> pixel_value += ( ( unsigned long )
<S2SV_ModStart> len ) { int result <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; rfbLog ( "%s_enter:<S2SV_blank>len=%d;<S2SV_blank>" "CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>" "writeTo=%p<S2SV_blank>" "state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>" "<S2SV_blank>nReadRaw=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p\\n" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf ) ; switch ( wsctx -> hybiDecodeState ) { case WS_HYBI_STATE_HEADER_PENDING : wsctx -> hybiDecodeState = hybiReadHeader ( cl , & result ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { goto spor ; } if ( wsctx -> hybiDecodeState != WS_HYBI_STATE_HEADER_PENDING ) { wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; } break ; case WS_HYBI_STATE_DATA_AVAILABLE : wsctx -> hybiDecodeState = hybiReturnData ( dst , len , wsctx , & result ) ; break ; case WS_HYBI_STATE_DATA_NEEDED : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; case WS_HYBI_STATE_CLOSE_REASON_PENDING : wsctx -> hybiDecodeState = hybiReadAndDecode ( cl , dst , len , & result ) ; break ; default : rfbErr ( "%s:<S2SV_blank>called<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>state<S2SV_blank>%d\\n" , wsctx -> hybiDecodeState ) ; <S2SV_ModEnd> result = - <S2SV_ModStart> - 1 ; errno = EIO ; wsctx -> hybiDecodeState = WS_HYBI_STATE_ERR ; } spor : if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { rfbLog ( "frame<S2SV_blank>received<S2SV_blank>successfully,<S2SV_blank>cleaning<S2SV_blank>up:<S2SV_blank>read=%d<S2SV_blank>hlen=%d<S2SV_blank>plen=%d\\n" , wsctx -> header . nRead , wsctx -> header . headerLen , wsctx -> header . payloadLen ) ; hybiDecodeCleanup ( wsctx ) <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_ERR ) { hybiDecodeCleanup ( wsctx ) ; } rfbLog ( "%s_exit:<S2SV_blank>len=%d;<S2SV_blank>" "CTX:<S2SV_blank>readlen=%d<S2SV_blank>readPos=%p<S2SV_blank>" "writePos=%p<S2SV_blank>" "state=%d<S2SV_blank>toRead=%d<S2SV_blank>remaining=%d<S2SV_blank>" "nRead=%d<S2SV_blank>carrylen=%d<S2SV_blank>carryBuf=%p<S2SV_blank>" "result=%d\\n" , __func__ , len , wsctx -> readlen , wsctx -> readPos , wsctx -> writePos , wsctx -> hybiDecodeState , wsctx -> nToRead , hybiRemaining ( wsctx ) , wsctx -> nReadRaw , wsctx -> carrylen , wsctx -> carryBuf , result ) ; return <S2SV_ModEnd> result ; }
<S2SV_ModStart> = base64 ; hybiDecodeCleanup ( wsctx ) ;
<S2SV_ModStart> && wsctx -> readlen <S2SV_ModEnd> ) return TRUE
<S2SV_ModStart> nameLength ) ; if ( client -> si . nameLength > 1 << 20 ) { rfbClientErr ( "Too<S2SV_blank>big<S2SV_blank>desktop<S2SV_blank>name<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n" , ( unsigned int ) client -> si . nameLength ) ; return FALSE ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> client -> si
<S2SV_ModStart> length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( "Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n" , ( unsigned int ) msg . sct . length ) ; return FALSE ; }
<S2SV_ModStart> rfbClientIteratorPtr iterator ; memset ( ( char * ) & sct , 0 , sizeof ( sct ) ) ;
<S2SV_ModStart> reasonLen ) ; if ( reasonLen > 1 << 20 ) { rfbClientLog ( "VNC<S2SV_blank>connection<S2SV_blank>failed,<S2SV_blank>but<S2SV_blank>sent<S2SV_blank>reason<S2SV_blank>length<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>exceeds<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB" , ( unsigned int ) reasonLen ) ; return ; } <S2SV_ModStart> = malloc ( <S2SV_ModEnd> reasonLen + 1
<S2SV_ModStart> authResult = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 7 ) { ReadReason ( client <S2SV_ModEnd> ) ; return
<S2SV_ModStart> , IPC_CREAT | 0600 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ] & 0x40 && i > 0
<S2SV_ModStart> ] & 0x40 && i > 0
<S2SV_ModStart> , restartpos ) ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart> } obj -> <S2SV_ModEnd> type = 0 <S2SV_ModStart> } if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> dat ) return <S2SV_ModStart> ; if ( error <S2SV_ModEnd> >= DWG_ERR_CRITICAL ) <S2SV_ModStart> = abs_dat ; <S2SV_ModEnd> } } if
<S2SV_ModStart> ; if ( <S2SV_ModEnd> is_entity ) error <S2SV_ModStart> ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else error = <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
<S2SV_ModStart> DWG_ERR_UNHANDLEDCLASS ) { unhandled : <S2SV_ModEnd> if ( obj <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_ENT ) <S2SV_ModEnd> dwg_free_UNKNOWN_ENT ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> else if ( <S2SV_ModStart> -> fixedtype == DWG_TYPE_UNKNOWN_OBJ ) <S2SV_ModEnd> dwg_free_UNKNOWN_OBJ ( dat <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if
<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
<S2SV_ModStart> ] ) { int ret_value = 0 ; <S2SV_ModStart> "\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n" ) ; ret_value = <S2SV_ModEnd> write_output ( ) <S2SV_ModStart> write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled." , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>" <S2SV_ModEnd> , EF_GBL_OPTIONS ->
<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
<S2SV_ModStart> case FRAME_TYPE_JOIN_ACCEPT : if ( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } <S2SV_ModStart> ; if ( ( <S2SV_ModStart> ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE <S2SV_ModEnd> ) ) > <S2SV_ModStart> phyParam . Value ) || ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE )
<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
<S2SV_ModStart> { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE
<S2SV_ModStart> ; if ( ! my_disable_copystat_in_redel &&
<S2SV_ModStart> ; if ( ! ( MyFlags & MY_REDEL_NO_COPY_STAT ) ) { if ( <S2SV_ModStart> goto end ; }
<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
<S2SV_ModStart> , int rep_quick , my_bool no_copy_stat <S2SV_ModStart> 0 ) { myf flags = 0 ; if ( param -> testflag & T_BACKUP_DATA ) flags |= MY_REDEL_MAKE_BACKUP ; if ( no_copy_stat ) flags |= MY_REDEL_NO_COPY_STAT ; <S2SV_ModStart> , DATA_TMP_EXT , flags <S2SV_ModEnd> ) || mi_open_datafile
<S2SV_ModStart> char * name , my_bool no_copy_stat <S2SV_ModStart> , INDEX_TMP_EXT , no_copy_stat ? MYF ( MY_REDEL_NO_COPY_STAT ) :
<S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , rep_quick , FALSE <S2SV_ModStart> filename , 1 , FALSE <S2SV_ModStart> info , filename , FALSE
<S2SV_ModStart> = hmi_data ; uint32_t data_siz ; <S2SV_ModStart> } * note <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> += hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> += 4 ; hmi_tmp = 8 ; } else { hmi_tmp = 4 ; } hmi_data <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> hmi_mdi , hmi_data , data_siz <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> ; if ( data_siz && <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> > 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> += setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data > <S2SV_ModStart> { do { if ( ! data_siz ) break ; <S2SV_ModStart> hmi_data ++ ; data_siz -- ; <S2SV_ModStart> ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> ; hmi_data ++ ; data_siz --
<S2SV_ModStart> ] + chunk_length [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> += 3 ; chunk_length [ i ] -= 3 ; <S2SV_ModStart> hmp_mdi , hmp_chunk [ i ] , chunk_length <S2SV_ModStart> ] = 1 ; chunk_length [ i ] -= 3 <S2SV_ModStart> += setup_ret ; chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> ; if ( chunk_length [ i ] && <S2SV_ModStart> { do { if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> ] ++ ; chunk_length [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> i ] ++ ; chunk_length [ i ] --
<S2SV_ModStart> uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t end_of_tracks <S2SV_ModStart> no_tracks ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> -= 4 ; tmp_val <S2SV_ModEnd> = * midi_data <S2SV_ModStart> << 24 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 16 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> << 8 ; tmp_val <S2SV_ModEnd> |= * midi_data <S2SV_ModStart> ( midi_size < tmp_val <S2SV_ModEnd> ) { _WM_GLOBAL_ERROR <S2SV_ModStart> } if ( tmp_val <S2SV_ModEnd> < 3 ) <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 3 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 2 ] <S2SV_ModStart> ( midi_data [ tmp_val <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = midi_data ; track_size [ i ] = tmp_val ; midi_data += tmp_val <S2SV_ModEnd> ; midi_size -= <S2SV_ModStart> ; midi_size -= tmp_val <S2SV_ModEnd> ; track_end [ <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> i ] , track_size [ i ] , <S2SV_ModStart> += setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> { do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- ; <S2SV_ModStart> ) ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> i ] ++ ; track_size [ i ] -- <S2SV_ModStart> tracks ) ; free ( track_size ) ;
<S2SV_ModStart> = 0.0 ; # define MUS_SZ 4 <S2SV_ModStart> uint8_t mus_event [ MUS_SZ <S2SV_ModStart> * ) mus_event , MUS_SZ
<S2SV_ModStart> , xmi_data , xmi_size ,
<S2SV_ModStart> * event_data , uint32_t siz , <S2SV_ModStart> ; if ( ! siz ) goto shortbuf ; if ( <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz == 0 ) goto shortbuf <S2SV_ModStart> : _SETUP_NOTEOFF : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> goto _SETUP_NOTEOFF ; if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xa0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xb0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> case 0xe0 : if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ; ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> ret_cnt ++ ; if ( -- siz < tmp_length ) goto shortbuf ; if ( ! tmp_length ) break ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 3 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 2 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 5 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 7 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 6 ) goto shortbuf ; <S2SV_ModStart> ) ) { if ( siz < 4 ) goto shortbuf ; <S2SV_ModStart> ; if ( -- siz && <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> += tmp_length ; if ( -- siz < tmp_length ) goto shortbuf ; <S2SV_ModStart> { do { if ( ! siz ) break ; <S2SV_ModStart> event_data ++ ; siz -- ; <S2SV_ModStart> ) ; } if ( ! siz ) goto shortbuf ; <S2SV_ModStart> event_data ++ ; ret_cnt ++ ; if ( -- siz < sysex_len ) goto shortbuf ; <S2SV_ModStart> sysex_len ) break <S2SV_ModEnd> ; sysex_store = <S2SV_ModStart> return ret_cnt ; shortbuf : _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(input<S2SV_blank>too<S2SV_blank>short)" , 0 ) ; return 0 ;

<S2SV_ModStart> M_fs_error_t res ; <S2SV_ModEnd> res = M_fs_file_open
<S2SV_ModStart> ; if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> exit ( EXIT_FAILURE <S2SV_ModEnd> ) ; }
<S2SV_ModStart> buffer ) ; break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( "received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>%P[%I]" , peer , remote_addr ) ;
<S2SV_ModStart> buffer ) ; break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( "received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I" , remote_addr ) ;
<S2SV_ModStart> tp ; { static <S2SV_ModEnd> NEARDATA const char <S2SV_ModStart> NEARDATA const char oct [ ] = "01234567" , dec [ ] = "0123456789" , <S2SV_ModStart> dp ; int cval , meta , dcount ; while ( * cp ) { meta = ( * cp == '\\\\' && ( cp [ 1 ] == 'm' || cp [ 1 ] == 'M' ) && cp [ 2 ] ) ; if ( meta ) cp += 2 ; cval = dcount <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; if ( ( * cp != '\\\\' && * cp != '^' ) || ! cp [ 1 ] ) { cval = * cp ++ ; } else if ( * cp == '^' ) { cval = ( * ++ cp & 0x1f ) ; ++ cp ; } else if ( index ( dec , cp [ 1 ] ) ) { ++ cp ; do { cval = ( cval * 10 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( dec , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] == 'o' || cp [ 1 ] == 'O' ) && cp [ 2 ] && index ( oct , cp [ 2 ] ) ) { cp += 2 ; do { cval = ( cval * 8 ) + ( * cp - '0' ) ; } while ( * ++ cp && index ( oct , * cp ) && ++ dcount < 3 ) ; } else if ( ( cp [ 1 ] <S2SV_ModEnd> == 'x' || <S2SV_ModStart> == 'x' || cp [ 1 ] <S2SV_ModEnd> == 'X' ) <S2SV_ModStart> == 'X' ) && cp [ 2 ] <S2SV_ModEnd> && ( dp <S2SV_ModStart> ( hex , cp [ 2 ] ) ) != 0 ) { cp += 2 ; do { <S2SV_ModEnd> cval = ( <S2SV_ModStart> 2 ) ; } while ( * ++ cp && ( dp = index ( hex , * cp ) ) != 0 && ++ dcount < 2 ) ; } else <S2SV_ModEnd> { switch ( <S2SV_ModStart> cp ; } ++ cp ; } <S2SV_ModEnd> if ( meta <S2SV_ModStart> tp ++ = ( char )
<S2SV_ModStart> s ; { int i ; char * tmps = 0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> { raw_printf ( "No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?" <S2SV_ModEnd> ) ; nh_terminate <S2SV_ModStart> ) ; } # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> } if ( tmps ) free ( ( genericptr_t ) tmps ) ; if (
<S2SV_ModStart> { raw_printf ( "Unknown<S2SV_blank>option:<S2SV_blank>%.60s" <S2SV_ModEnd> , * argv <S2SV_ModStart> { raw_printf ( "Unknown<S2SV_blank>option:<S2SV_blank>%.60s" <S2SV_ModEnd> , * argv
<S2SV_ModStart> = TRUE ; while ( * origbuf == '<S2SV_blank>' || * origbuf == '\\t' ) ++ origbuf ; ( void ) strncpy ( buf , origbuf , sizeof buf - 1 ) ; buf [ sizeof buf - 1 ] = '\\0' ; mungspaces ( buf <S2SV_ModEnd> ) ; bufp
<S2SV_ModStart> , * altp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0'
<S2SV_ModStart> struct obj * otmp ; if ( strlen ( buf ) >= BUFSZ ) buf [ BUFSZ - 1 ] = '\\0' ;
<S2SV_ModStart> ; if ( StateSynSentValidateTimestamp ( ssn , p ) == false ) return - 1 ; if (
<S2SV_ModStart> ) ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> } if ( smd -> is_last ) { goto match <S2SV_ModEnd> ; } SCLogDebug <S2SV_ModStart> ) ; } SCLogDebug ( "no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'" ) ; <S2SV_ModStart> -> discontinue_matching ) { SCLogDebug ( "\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( "\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( "\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)" , cd , cd -> flags ) <S2SV_ModEnd> ; prev_offset =
<S2SV_ModStart> , STREAM_PKT_BROKEN_ACK ) ; goto error
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> , 0 , ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> return mobj ;
<S2SV_ModStart> uaddr_t a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> len , & end_addr <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( a = ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> ; a < <S2SV_ModStart> ; a < end_addr <S2SV_ModEnd> ; a +=
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
<S2SV_ModStart> <S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * <S2SV_ModStart> 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> <S2SV_ModStart> = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> ; } } return TEE_SUCCESS ;
<S2SV_ModStart> mem ) { size_t req_size = 0 ; <S2SV_ModStart> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> % subsamplingver ; temp = ( row + img -> row_offset ) % rowsperstrip + nrowsub ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , "Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripContig" ) ; return 0 ; } <S2SV_ModStart> , maxstripsize , temp <S2SV_ModEnd> * scanline )
<S2SV_ModStart> nrow ) { uint32 temp ; <S2SV_ModStart> -> row_offset ; temp = ( row + img -> row_offset ) % rowsperstrip + nrow ; if ( scanline > 0 && temp > ( size_t ) ( TIFF_TMSIZE_T_MAX / scanline ) ) { TIFFErrorExt ( tif -> tif_clientdata , TIFFFileName ( tif ) , "Integer<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>gtStripSeparate" ) ; return 0 ; } <S2SV_ModStart> , bufsize , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p0 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p1 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , p2 , temp <S2SV_ModEnd> * scanline ) <S2SV_ModStart> , pa , temp <S2SV_ModEnd> * scanline )
<S2SV_ModStart> -> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN
<S2SV_ModStart> . id ; if ( bufLen < 2 ) break ; <S2SV_ModStart> += 2 ; bufLen -= 2 ;
<S2SV_ModStart> ] ) { size_t <S2SV_ModEnd> j , len <S2SV_ModStart> case 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> , d , <S2SV_ModEnd> file -> namelen <S2SV_ModStart> file -> namelen ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
<S2SV_ModStart> "Skipping<S2SV_blank>optional<S2SV_blank>EF.C_DevAut" ) ; if ( len > 0 ) { <S2SV_ModStart> = len ; }
<S2SV_ModStart> sec_attr == NULL || sec_attr_len
<S2SV_ModStart> ; bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> } bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> len = file && file -> size > 0
<S2SV_ModStart> break ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line , <S2SV_ModStart> line , "<S2SV_blank>" , sizeof line <S2SV_ModStart> } line [ ( sizeof <S2SV_ModEnd> line ) - <S2SV_ModStart> 1 ] = '\\0' ; line [ strlen ( line ) - 1 ] =
<S2SV_ModStart> outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart> & 0x07 ; <S2SV_ModEnd> octets_left = inlen <S2SV_ModStart> - 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> ) - zero_bits
<S2SV_ModStart> } else { size_t rec ; size_t <S2SV_ModEnd> offs = 0 <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> rec_len = file <S2SV_ModStart> ++ ) { if ( rec > file -> record_count ) { rv = 0 ; break ; }
<S2SV_ModStart> 0 ) { free ( info . subject . value ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> 0x02 ) ; if ( sizeof sbuf - 1 < crgram_len ) return SC_ERROR_INVALID_ARGUMENTS ;
<S2SV_ModStart> SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen
<S2SV_ModStart> ; size_t len <S2SV_ModEnd> ; sc_apdu_t apdu <S2SV_ModStart> 0 ) ; len <S2SV_ModEnd> = MIN ( <S2SV_ModStart> > 0 ; ) { <S2SV_ModEnd> apdu . resp <S2SV_ModStart> break ; } left -= len ; out_ptr += len ; len <S2SV_ModEnd> = MIN (
<S2SV_ModStart> ; size_t val_len = 0
<S2SV_ModStart> ; if ( coolkey_find_object_by_id ( & priv -> objects_list , object_id ) != NULL ) { return SC_ERROR_INTERNAL ; } if (
<S2SV_ModStart> iPinCount = iACLen > 0 ? iACLen - 1 : 0 <S2SV_ModEnd> ; if (
<S2SV_ModStart> ; unsigned char * signature = NULL <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> unsigned int siglen <S2SV_ModEnd> ; const EVP_MD <S2SV_ModStart> ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> ; err : free ( signature ) ;
<S2SV_ModStart> ; } } it = it -> next ;
<S2SV_ModStart> , len ; <S2SV_ModEnd> WCHAR * data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } size <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } read <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> + len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> free ( data <S2SV_ModStart> ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> == 0 ) { <S2SV_ModStart> = ERROR_END_OF_STREAM ; } else { <S2SV_ModEnd> error = ERROR_FAILURE <S2SV_ModStart> = ERROR_FAILURE ; }
<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> rxBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
<S2SV_ModStart> == 16 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_16 ; } <S2SV_ModStart> == 32 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_32 ; } <S2SV_ModStart> == 64 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_64 ; } <S2SV_ModStart> == 128 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_128 ; } <S2SV_ModStart> == 256 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_256 ; } <S2SV_ModStart> == 512 ) { <S2SV_ModStart> = COAP_BLOCK_SIZE_512 ; } else { <S2SV_ModEnd> request -> txBlockSzx <S2SV_ModStart> = COAP_BLOCK_SIZE_1024 ; } <S2SV_ModStart> ( ) ) { <S2SV_ModStart> ( ) ; }
<S2SV_ModStart> && last ) { <S2SV_ModStart> 0 ) ; } else { <S2SV_ModEnd> COAP_SET_BLOCK_M ( value <S2SV_ModStart> 1 ) ; }
<S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , ':' ) != NULL <S2SV_ModStart> ) if ( osStrchr <S2SV_ModEnd> ( str , <S2SV_ModStart> , '.' ) != NULL
<S2SV_ModStart> bool_t status ; # if ( TRACE_LEVEL >= TRACE_LEVEL_DEBUG ) size_t length = netBufferGetLength ( buffer ) - offset ; TRACE_DEBUG ( "Sending<S2SV_blank>packet<S2SV_blank>(%" PRIuSIZE "<S2SV_blank>bytes)...\\r\\n" , length ) ; TRACE_DEBUG_NET_BUFFER ( "<S2SV_blank><S2SV_blank>" , buffer , offset , length ) ; # endif <S2SV_ModStart> ( ) ; <S2SV_ModEnd> if ( interface
<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
<S2SV_ModStart> size ) ; message -> interface = queueItem -> interface ;
<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
<S2SV_ModStart> * interface ; if ( message -> interface != NULL ) { interface = message -> interface ; } else
<S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModEnd> buffer = ipAllocBuffer
<S2SV_ModStart> 15 && ! osStrchr <S2SV_ModEnd> ( name , <S2SV_ModStart> if ( ! osStrchr <S2SV_ModEnd> ( name ,
<S2SV_ModStart> length ) { error_t error ; size_t <S2SV_ModEnd> i ; size_t <S2SV_ModStart> + length ) <= TCP_MAX_HEADER_LENGTH ) { i = ( <S2SV_ModEnd> segment -> dataOffset <S2SV_ModStart> dataOffset * 4 ) <S2SV_ModStart> paddingSize -- ) { <S2SV_ModStart> = TCP_OPTION_NOP ; } <S2SV_ModStart> / 4 ; error = NO_ERROR ; } else { error = ERROR_FAILURE ; } return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> TCP_FLAG_RST ) ) { <S2SV_ModStart> FALSE ) ; }
<S2SV_ModStart> ) { size_t i ; size_t length <S2SV_ModEnd> ; TcpOption * <S2SV_ModStart> segment -> dataOffset >= ( sizeof ( TcpHeader ) / 4 ) ) { length = ( <S2SV_ModEnd> segment -> dataOffset <S2SV_ModStart> dataOffset * 4 ) <S2SV_ModStart> -> kind == TCP_OPTION_END ) { break ; } else if ( option -> kind == <S2SV_ModStart> i ++ ; } else { <S2SV_ModEnd> if ( ( <S2SV_ModStart> ) >= length ) break ; if ( option -> length < sizeof ( TcpOption ) <S2SV_ModStart> length ; } } }
<S2SV_ModStart> & TCP_FLAG_SYN ) { <S2SV_ModStart> ackNum ++ ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> ackNum ++ ; }
<S2SV_ModStart> & TCP_FLAG_SYN ) { <S2SV_ModStart> = 1 ; } <S2SV_ModStart> & TCP_FLAG_FIN ) { <S2SV_ModStart> + 1 ; } else { length = queueItem -> length ; } <S2SV_ModEnd> if ( TCP_CMP_SEQ
<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
<S2SV_ModStart> ; message -> interface = queueItem -> interface ; message ->
<S2SV_ModStart> * buffer ; NetInterface * interface ; <S2SV_ModStart> NetTxAncillary ancillary ; if ( message -> interface != NULL ) { interface = message -> interface ; } else { interface = socket -> interface ; } <S2SV_ModStart> = udpSendBuffer ( <S2SV_ModEnd> interface , &
<S2SV_ModStart> ( DhcpMessage ) || <S2SV_ModEnd> length > DHCP_MAX_MSG_SIZE
<S2SV_ModStart> optionCode ) { size_t <S2SV_ModEnd> i ; DhcpOption <S2SV_ModStart> if ( length >= <S2SV_ModEnd> sizeof ( DhcpMessage <S2SV_ModStart> DhcpMessage ) ) { <S2SV_ModEnd> length -= sizeof <S2SV_ModStart> == DHCP_OPT_PAD ) { } else <S2SV_ModEnd> if ( option <S2SV_ModStart> code == DHCP_OPT_END ) { break ; } else { if ( ( i + 1 ) >= length <S2SV_ModStart> ( i + sizeof ( DhcpOption ) <S2SV_ModEnd> + option -> <S2SV_ModStart> -> length ) > <S2SV_ModEnd> length ) break <S2SV_ModStart> 1 ; } } }
<S2SV_ModStart> = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG <S2SV_ModEnd> ) != 0 <S2SV_ModStart> { dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG <S2SV_ModEnd> ) ; status <S2SV_ModStart> = dm9000ReadReg ( DM9000_NSR ) ; if ( ( status & DM9000_NSR_LINKST ) != 0 ) { if ( ( status & DM9000_NSR_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> = dm9000ReadReg ( DM9000_NCR ) ; if ( ( status & DM9000_NCR_FDX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & DM9000_ISR_PR <S2SV_ModEnd> ) != 0 <S2SV_ModStart> { dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PR <S2SV_ModEnd> ) ; do <S2SV_ModStart> } dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI <S2SV_ModEnd> ) ; }
<S2SV_ModStart> productId ; uint8_t chipRev <S2SV_ModEnd> ; Dm9000Context * <S2SV_ModStart> ( dm9000ReadReg ( DM9000_VIDH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_VIDL <S2SV_ModEnd> ) ; productId <S2SV_ModStart> ( dm9000ReadReg ( DM9000_PIDH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_PIDL ) ; chipRev <S2SV_ModEnd> = dm9000ReadReg ( <S2SV_ModStart> = dm9000ReadReg ( DM9000_CHIPR <S2SV_ModEnd> ) ; if <S2SV_ModStart> } if ( chipRev != DM9000_CHIPR_REV_A && chipRev != DM9000_CHIPR_REV_B <S2SV_ModEnd> ) { return <S2SV_ModStart> } dm9000WriteReg ( DM9000_GPR <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ; dm9000WriteReg ( DM9000_NCR , DM9000_NCR_RST <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_NCR ) & DM9000_NCR_RST <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_RST <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadPhyReg ( DM9000_BMCR ) & DM9000_BMCR_RST <S2SV_ModEnd> ) != 0 <S2SV_ModStart> PRIX8 "\\r\\n" , chipRev <S2SV_ModEnd> ) ; TRACE_INFO <S2SV_ModStart> , dm9000ReadPhyReg ( DM9000_PHYIDR1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> , dm9000ReadPhyReg ( DM9000_PHYIDR2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) dm9000WriteReg ( DM9000_NCR , DM9000_NCR_LBK_PHY <S2SV_ModEnd> ) ; dm9000WritePhyReg <S2SV_ModStart> ; dm9000WritePhyReg ( DM9000_BMCR , DM9000_BMCR_LOOPBACK | DM9000_BMCR_SPEED_SEL | DM9000_BMCR_AN_EN | DM9000_BMCR_DUPLEX_MODE <S2SV_ModEnd> ) ; # <S2SV_ModStart> { dm9000WriteReg ( DM9000_PAR0 <S2SV_ModEnd> + i , <S2SV_ModStart> { dm9000WriteReg ( DM9000_MAR0 <S2SV_ModEnd> + i , <S2SV_ModStart> } dm9000WriteReg ( DM9000_MAR7 <S2SV_ModEnd> , 0x80 ) <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR ) ; dm9000WriteReg ( DM9000_NSR , DM9000_NSR_WAKEST | DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ; dm9000WriteReg ( DM9000_ISR , DM9000_ISR_LNKCHG | DM9000_ISR_UDRUN | DM9000_ISR_ROO | DM9000_ISR_ROS | DM9000_ISR_PT | DM9000_ISR_PR ) ; dm9000WriteReg ( DM9000_IMR , DM9000_IMR_PAR | DM9000_IMR_LNKCHGI | DM9000_IMR_PTI | DM9000_IMR_PRI ) ; dm9000WriteReg ( DM9000_RCR , DM9000_RCR_DIS_LONG | DM9000_RCR_DIS_CRC | DM9000_RCR_RXEN <S2SV_ModEnd> ) ; osSetEvent
<S2SV_ModStart> = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_LNKCHGI <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( status & DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> } dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_PRI <S2SV_ModEnd> ) ; interface
<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPDRH <S2SV_ModEnd> ) << 8 <S2SV_ModStart> | dm9000ReadReg ( DM9000_EPDRL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = dm9000ReadReg ( DM9000_MRCMDX <S2SV_ModEnd> ) ; DM9000_INDEX_REG <S2SV_ModStart> ; DM9000_INDEX_REG = DM9000_MRCMDX1 <S2SV_ModEnd> ; status = <S2SV_ModStart> { DM9000_INDEX_REG = DM9000_MRCMD <S2SV_ModEnd> ; status = <S2SV_ModStart> status & ( DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> ; dm9000WriteReg ( DM9000_MWCMDX <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; DM9000_INDEX_REG = DM9000_MWCMD <S2SV_ModEnd> ; p = <S2SV_ModStart> } dm9000WriteReg ( DM9000_TXPLL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_TXPLH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ; dm9000WriteReg ( DM9000_TCR , DM9000_TCR_TXREQ <S2SV_ModEnd> ) ; context
<S2SV_ModStart> { dm9000WriteReg ( DM9000_MAR0 <S2SV_ModEnd> + i , <S2SV_ModStart> , dm9000ReadReg ( DM9000_MAR0 ) , dm9000ReadReg ( DM9000_MAR1 ) , dm9000ReadReg ( DM9000_MAR2 ) , dm9000ReadReg ( DM9000_MAR3 ) , dm9000ReadReg ( DM9000_MAR4 ) , dm9000ReadReg ( DM9000_MAR5 ) , dm9000ReadReg ( DM9000_MAR6 ) , dm9000ReadReg ( DM9000_MAR7 <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPDRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPDRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( interface , ENC28J60_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC28J60_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_PHIR <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_LINKIF <S2SV_ModEnd> ) ; value <S2SV_ModStart> ( interface , ENC28J60_PHSTAT2 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( value & ENC28J60_PHSTAT2_LSTAT <S2SV_ModEnd> ) != 0 <S2SV_ModStart> } if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_PKTIF <S2SV_ModEnd> ) ; do <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE | ENC28J60_EIE_PKTIE <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( interface , ENC28J60_EREVID <S2SV_ModEnd> ) ; TRACE_INFO <S2SV_ModStart> ( interface , ENC28J60_ECOCON , ENC28J60_ECOCON_COCON_DISABLED ) ; enc28j60WriteReg ( interface , ENC28J60_MAADR5 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR4 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR3 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR2 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR1 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_MAADR0 <S2SV_ModEnd> , interface -> <S2SV_ModStart> ( interface , ENC28J60_ERXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXFCON , ENC28J60_ERXFCON_UCEN | ENC28J60_ERXFCON_CRCEN | ENC28J60_ERXFCON_HTEN | ENC28J60_ERXFCON_BCEN ) ; enc28j60WriteReg ( interface , ENC28J60_EHT0 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT1 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT3 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT4 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT5 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT6 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EHT7 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON2 , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_MACON1 , ENC28J60_MACON1_TXPAUS | ENC28J60_MACON1_RXPAUS | ENC28J60_MACON1_MARXEN <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN | ENC28J60_MACON3_FULDPX <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON3 , ENC28J60_MACON3_PADCFG_AUTO | ENC28J60_MACON3_TXCRCEN | ENC28J60_MACON3_FRMLNEN <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MACON4 , ENC28J60_MACON4_DEFER ) ; enc28j60WriteReg ( interface , ENC28J60_MAMXFLL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MAMXFLH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MABBIPG , ENC28J60_MABBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_MAIPGL , ENC28J60_MAIPGL_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MAIPGH , ENC28J60_MAIPGH_DEFAULT ) ; enc28j60WriteReg ( interface , ENC28J60_MACLCON2 , ENC28J60_MACLCON2_COLWIN_DEFAULT <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_PHCON1 , ENC28J60_PHCON1_PDPXMD <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( interface , ENC28J60_PHCON1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC28J60_PHCON2 , ENC28J60_PHCON2_HDLDIS <S2SV_ModEnd> ) ; enc28j60WritePhyReg <S2SV_ModStart> ( interface , ENC28J60_PHLCON , ENC28J60_PHLCON_LACFG_LINK | ENC28J60_PHLCON_LBCFG_TX_RX | ENC28J60_PHLCON_LFRQ_40_MS | ENC28J60_PHLCON_STRCH ) ; enc28j60WriteReg ( interface , ENC28J60_EIR , 0x00 ) ; enc28j60WriteReg ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE | ENC28J60_EIE_PKTIE | ENC28J60_EIE_LINKIE | ENC28J60_EIE_TXIE | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ; enc28j60WritePhyReg <S2SV_ModStart> ( interface , ENC28J60_PHIE , ENC28J60_PHIE_PLNKIE | ENC28J60_PHIE_PGEIE <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_RXEN <S2SV_ModEnd> ) ; enc28j60DumpReg
<S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , ENC28J60_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC28J60_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_LINKIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> } if ( enc28j60ReadReg ( interface , ENC28J60_EPKTCNT <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_PKTIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> status & ( ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ) != <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIE_TXERIE <S2SV_ModEnd> ) ; flag <S2SV_ModStart> ( interface , ENC28J60_EIE , ENC28J60_EIE_INTIE <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_MICMD <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , ENC28J60_MIRDL <S2SV_ModEnd> ) ; data <S2SV_ModStart> ( interface , ENC28J60_MIRDH <S2SV_ModEnd> ) << 8
<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint16_t status <S2SV_ModStart> uint16_t status ; uint8_t header [ 6 ] ; <S2SV_ModStart> ( interface , ENC28J60_EPKTCNT ) != 0 ) { enc28j60WriteReg ( interface , ENC28J60_ERDPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERDPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD16LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC28J60_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ERXRDPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON2 , ENC28J60_ECON2_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
<S2SV_ModStart> currentBank ) { if ( bank == BANK_0 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) ; } else if ( bank == BANK_1 ) { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else if ( bank == BANK_2 ) { <S2SV_ModEnd> enc28j60ClearBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL0 <S2SV_ModEnd> ) ; enc28j60SetBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 ) ; } else { <S2SV_ModEnd> enc28j60SetBit ( interface <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_BSEL1 | ENC28J60_ECON1_BSEL0 ) <S2SV_ModEnd> ; } context
<S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRST <S2SV_ModEnd> ) ; enc28j60ClearBit <S2SV_ModStart> ( interface , ENC28J60_EIR , ENC28J60_EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXSTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_EWRPTH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_ETXNDH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_ECON1 , ENC28J60_ECON1_TXRTS <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC28J60_EHT0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT4 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT5 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT6 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC28J60_EHT7 <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MIWRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ( interface , ENC28J60_MIWRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0
<S2SV_ModStart> ( interface , ENC624J600_EIR ) ; if ( ( status & ENC624J600_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_LINKIF <S2SV_ModEnd> ) ; value <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) ; if ( ( value & ENC624J600_ESTAT_PHYLNK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_PHSTAT3 ) ; if ( ( value & ENC624J600_PHSTAT3_SPDDPX1 <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( value & ENC624J600_PHSTAT3_SPDDPX2 <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & ENC624J600_EIR_PKTIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_PKTIF <S2SV_ModEnd> ) ; do <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHEN | ENC624J600_ECON2_STRCH <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( interface , ENC624J600_MAADR1 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR2 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_MAADR3 <S2SV_ModEnd> , temp ) <S2SV_ModStart> ( interface , ENC624J600_ERXST <S2SV_ModEnd> , ENC624J600_RX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL <S2SV_ModEnd> , ENC624J600_RX_BUFFER_STOP ) <S2SV_ModStart> ( interface , ENC624J600_ERXFCON , ENC624J600_ERXFCON_HTEN | ENC624J600_ERXFCON_CRCEN | ENC624J600_ERXFCON_RUNTEN | ENC624J600_ERXFCON_UCEN | ENC624J600_ERXFCON_BCEN ) ; enc624j600WriteReg ( interface , ENC624J600_EHT1 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_MAMXFL <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> ( interface , ENC624J600_PHANA , ENC624J600_PHANA_ADPAUS0 | ENC624J600_PHANA_AD100FD | ENC624J600_PHANA_AD100 | ENC624J600_PHANA_AD10FD | ENC624J600_PHANA_AD10 | ENC624J600_PHANA_ADIEEE_DEFAULT ) ; enc624j600WriteReg ( interface , ENC624J600_EIR <S2SV_ModEnd> , 0x0000 ) <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE | ENC624J600_EIE_LINKIE | ENC624J600_EIE_PKTIE | ENC624J600_EIE_TXIE | ENC624J600_EIE_TXABTIE <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_RXEN <S2SV_ModEnd> ) ; enc624j600DumpReg
<S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , ENC624J600_EIR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_EIR_LINKIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_LINKIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( status & ENC624J600_EIR_PKTIF <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_PKTIE <S2SV_ModEnd> ) ; interface <S2SV_ModStart> status & ( ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ) != <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; flag <S2SV_ModStart> ( interface , ENC624J600_EIE , ENC624J600_EIE_INTIE <S2SV_ModEnd> ) ; return
<S2SV_ModStart> address ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MICMD , ENC624J600_MICMD_MIIRD <S2SV_ModEnd> ) ; usleep <S2SV_ModStart> 100 ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> enc624j600WriteReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MICMD <S2SV_ModEnd> , 0x00 ) <S2SV_ModStart> ( interface , ENC624J600_MIRD <S2SV_ModEnd> ) ; }
<S2SV_ModStart> error ; uint16_t length <S2SV_ModEnd> ; uint32_t status <S2SV_ModStart> uint32_t status ; uint8_t header [ 8 ] ; <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT <S2SV_ModEnd> ) { enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_ERXRDPT <S2SV_ModEnd> , context -> <S2SV_ModStart> , ENC624J600_CMD_RRXDATA , header <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( header ) ) ; context -> nextPacket = LOAD16LE ( header ) ; length = LOAD16LE ( header + 2 ) ; status = LOAD32LE ( header + 4 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & ENC624J600_RSV_RECEIVED_OK <S2SV_ModEnd> ) != 0 <S2SV_ModStart> 0 ) { length <S2SV_ModEnd> = MIN ( <S2SV_ModStart> = MIN ( length <S2SV_ModEnd> , ETH_MAX_FRAME_SIZE ) <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> ) ; error <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> ENC624J600_RX_BUFFER_STOP ) ; <S2SV_ModStart> ( interface , ENC624J600_ERXTAIL , <S2SV_ModEnd> context -> nextPacket <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_PKTDEC <S2SV_ModEnd> ) ; } <S2SV_ModStart> -> rxBuffer , length <S2SV_ModEnd> , & ancillary
<S2SV_ModStart> ( interface , ENC624J600_ECON1 ) & ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , ENC624J600_EGPWRPT <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXST <S2SV_ModEnd> , ENC624J600_TX_BUFFER_START ) <S2SV_ModStart> ( interface , ENC624J600_ETXLEN <S2SV_ModEnd> , length ) <S2SV_ModStart> ( interface , ENC624J600_EIR , ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF <S2SV_ModEnd> ) ; enc624j600SetBit <S2SV_ModStart> ( interface , ENC624J600_ECON1 , ENC624J600_ECON1_TXRTS <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> , 0x1234 ) <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x1234 <S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_CLKRDY <S2SV_ModEnd> ) == 0 <S2SV_ModStart> ( interface , ENC624J600_ECON2 , ENC624J600_ECON2_ETHRST <S2SV_ModEnd> ) ; sleep <S2SV_ModStart> ( interface , ENC624J600_EUDAST <S2SV_ModEnd> ) != 0x0000
<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PHYDPX <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_FD <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( interface , ENC624J600_MACON2 , ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT <S2SV_ModEnd> ) ; enc624j600WriteReg <S2SV_ModStart> ( interface , ENC624J600_MABBIPG , ENC624J600_MABBIPG_BBIPG_DEFAULT_HD <S2SV_ModEnd> ) ; }
<S2SV_ModStart> data ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MIWR <S2SV_ModEnd> , data ) <S2SV_ModStart> data ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> ) ; frameCount <S2SV_ModStart> ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( interface , KSZ8851_CIDER <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1ILR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_PHY1IHR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_CIDER ) != ( KSZ8851_CIDER_FAMILY_ID_DEFAULT | KSZ8851_CIDER_CHIP_ID_DEFAULT | KSZ8851_CIDER_REV_ID_A3 ) <S2SV_ModEnd> ) { return <S2SV_ModStart> ( interface , KSZ8851_MARH <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARM <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_MARL <S2SV_ModEnd> , htons ( <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXFCE | KSZ8851_TXCR_TXPE | KSZ8851_TXCR_TXCE ) ; ksz8851WriteReg ( interface , KSZ8851_TXFDPR , KSZ8851_TXFDPR_TXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXPAFMA | KSZ8851_RXCR1_RXFCE | KSZ8851_RXCR1_RXBE | KSZ8851_RXCR1_RXME | KSZ8851_RXCR1_RXUE ) ; ksz8851WriteReg ( interface , KSZ8851_RXCR2 , KSZ8851_RXCR2_SRDBL_SINGLE_FRAME | KSZ8851_RXCR2_IUFFP | KSZ8851_RXCR2_RXIUFCEZ ) ; ksz8851WriteReg ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RXFCTE | KSZ8851_RXQCR_ADRFE ) ; ksz8851WriteReg ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI ) ; ksz8851WriteReg ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_FORCE_DUPLEX <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_P1CR , KSZ8851_P1CR_RESTART_AN <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS | KSZ8851_ISR_TXIS | KSZ8851_ISR_RXIS | KSZ8851_ISR_RXOIS | KSZ8851_ISR_TXPSIS | KSZ8851_ISR_RXPSIS | KSZ8851_ISR_TXSAIS | KSZ8851_ISR_RXWFDIS | KSZ8851_ISR_RXMPDIS | KSZ8851_ISR_LDIS | KSZ8851_ISR_EDIS | KSZ8851_ISR_SPIBEIS <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_TXIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXCR , KSZ8851_TXCR_TXE <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXCR1 , KSZ8851_RXCR1_RXE <S2SV_ModEnd> ) ; osSetEvent
<S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> ) ; ksz8851WriteReg <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , KSZ8851_ISR ) ; if ( ( isr & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_LCIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( isr & KSZ8851_ISR_TXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( isr & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ier &= ~ KSZ8851_IER_RXIE <S2SV_ModEnd> ; interface -> <S2SV_ModStart> ( interface , KSZ8851_IER <S2SV_ModEnd> , ier )
<S2SV_ModStart> ( interface , KSZ8851_RXFHSR <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( status & KSZ8851_RXFHSR_RXFV <S2SV_ModEnd> ) != 0 <S2SV_ModStart> status & ( KSZ8851_RXFHSR_RXMR | KSZ8851_RXFHSR_RXFTL | KSZ8851_RXFHSR_RXRF | KSZ8851_RXFHSR_RXCE <S2SV_ModEnd> ) ) == <S2SV_ModStart> ( interface , KSZ8851_RXFHBCR ) & KSZ8851_RXFHBCR_RXBC <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( interface , KSZ8851_RXFDPR , KSZ8851_RXFDPR_RXFPAI <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851ReadFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ancillary <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_RRXEF <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if ( <S2SV_ModStart> = htole16 ( KSZ8851_TX_CTRL_TXIC <S2SV_ModEnd> | ( context <S2SV_ModStart> frameId ++ & KSZ8851_TX_CTRL_TXFID <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851WriteFifo <S2SV_ModStart> ( interface , KSZ8851_RXQCR , KSZ8851_RXQCR_SDA <S2SV_ModEnd> ) ; ksz8851SetBit <S2SV_ModStart> ( interface , KSZ8851_TXQCR , KSZ8851_TXQCR_METFE <S2SV_ModEnd> ) ; n <S2SV_ModStart> ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMIR_TXMA <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( interface , KSZ8851_MAHTR0 , hashTable [ 0 ] ) ; ksz8851WriteReg ( interface , KSZ8851_MAHTR1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR3 <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL <S2SV_ModEnd> ; tja1100WritePhyReg (
<S2SV_ModStart> ; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT <S2SV_ModEnd> ; tja1101WritePhyReg (
<S2SV_ModStart> "." ) ) { <S2SV_ModStart> NULL ) ; } else { <S2SV_ModEnd> ftpClientFormatCommand ( context <S2SV_ModStart> path ) ; }
<S2SV_ModStart> ; if ( osStrstr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> 12 ; } } <S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> != NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_DIRECTORY ; } if ( osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> == NULL ) { <S2SV_ModStart> |= FTP_FILE_ATTR_READ_ONLY ; }
<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
<S2SV_ModStart> != '\\0' ) { <S2SV_ModStart> param ++ ; } <S2SV_ModStart> == '<S2SV_blank>' ) { <S2SV_ModStart> param ++ ; }
<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { p = osStrchr <S2SV_ModEnd> ( p +
<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> { q = osStrchr <S2SV_ModEnd> ( p +
<S2SV_ModStart> ; p = osStrchr <S2SV_ModEnd> ( context ->
<S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( context -> <S2SV_ModStart> ; q = osStrchr <S2SV_ModEnd> ( uri ,
<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( ",<S2SV_blank>\\t" , <S2SV_ModStart> n ] ) != NULL ) { break ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( line ,
<S2SV_ModStart> ; if ( osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" ,
<S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" , <S2SV_ModStart> c ) || osStrchr <S2SV_ModEnd> ( "!#$%&\'*+-.^_`|~" ,
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( token , <S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( connection ->
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( context ->
<S2SV_ModStart> MqttSnClientContext * context , systime_t duration <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( context , duration / 1000 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
<S2SV_ModStart> == 2 && osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
<S2SV_ModStart> { if ( osStrchr <S2SV_ModEnd> ( topicName , <S2SV_ModStart> == NULL && osStrchr <S2SV_ModEnd> ( topicName ,
<S2SV_ModStart> { separator = osStrchr <S2SV_ModEnd> ( token ,
<S2SV_ModStart> ; separator = osStrchr <S2SV_ModEnd> ( line ,
<S2SV_ModStart> ; s = osStrchr <S2SV_ModEnd> ( token ,
<S2SV_ModStart> ( fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) == <S2SV_ModStart> { error ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied" , path_name <S2SV_ModEnd> ) ; return
<S2SV_ModStart> msr -> msc_reqbody_spilltodisk ) && ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_ON
<S2SV_ModStart> -> pool , "ModSecurity:<S2SV_blank>Invalid<S2SV_blank>value<S2SV_blank>for<S2SV_blank>SexHashEngine:<S2SV_blank>%s" <S2SV_ModEnd> , p1 )
<S2SV_ModStart> = NOT_SET ; dcfg -> xml_external_entity = NOT_SET ;
<S2SV_ModStart> = 0 ; if ( dcfg -> xml_external_entity == NOT_SET ) dcfg -> xml_external_entity = 0 ;
<S2SV_ModStart> crypto_hash_framesrc_pm ) ; merged -> xml_external_entity = ( child -> xml_external_entity == NOT_SET ? parent -> xml_external_entity : child -> xml_external_entity ) ;
<S2SV_ModStart> error_msg ) { xmlParserInputBufferCreateFilenameFunc entity ; <S2SV_ModStart> - 1 ; if ( msr -> txcfg -> xml_external_entity == 0 ) { entity = xmlParserInputBufferCreateFilenameDefault ( xml_unload_external_entity ) ; }
<S2SV_ModStart> ) && ( m_strcasestr <S2SV_ModEnd> ( transfer_encoding ,
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> NONSTROKING ) ; send ( <S2SV_ModEnd> "<S2SV_blank>h<S2SV_blank>f" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> "<S2SV_blank>s" ) ; <S2SV_ModStart> width ) ; send ( <S2SV_ModEnd> "<S2SV_blank>h<S2SV_blank>f" ) ;
<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd> , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>c" , <S2SV_ModStart> y3 ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> ( * s <S2SV_ModEnd> ) { if <S2SV_ModStart> == '\\n' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> == '<S2SV_blank>' || <S2SV_ModStart> == '<S2SV_blank>' || s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> ] == '<S2SV_blank>' <S2SV_ModStart> ] == '<S2SV_blank>' <S2SV_ModEnd> ) { s
<S2SV_ModStart> num1 , num2 , retcode <S2SV_ModStart> , * t <S2SV_ModEnd> ; double * <S2SV_ModStart> argbuf = 0 ; retcode = - 1 <S2SV_ModStart> t ++ ; fprintf ( outfile , "\\\\axo@setObject{%s}%%\\n{%s%c}%%\\n{" , s , t , TERMCHAR ) ; <S2SV_ModStart> = outputbuffer ; nameobject = t ; while ( * t != '<S2SV_blank>' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '<S2SV_blank>' || * t == '\\t' || * t == '\\n' ) t ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> 1 ] == 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> = 1 ; fprintf ( outfile , "Axohelp<S2SV_blank>version<S2SV_blank>%d.%d.<S2SV_blank>PDF<S2SV_blank>output." <S2SV_ModEnd> , VERSION , <S2SV_ModStart> SUBVERSION ) ; goto SUCCESS ; } else { fprintf ( <S2SV_ModEnd> stderr , "%s:<S2SV_blank>Illegal<S2SV_blank>request<S2SV_blank>in<S2SV_blank>identification<S2SV_blank>string<S2SV_blank>[0]:<S2SV_blank>%s\\n" <S2SV_ModStart> nameobject ) ; goto EXIT ; } } <S2SV_ModEnd> if ( ( <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; if ( <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } else <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> == 0 ) goto EXIT <S2SV_ModEnd> ; for ( <S2SV_ModStart> argbuf ) ; argbuf = 0 ; <S2SV_ModStart> inname ) ; goto EXIT <S2SV_ModEnd> ; } } <S2SV_ModStart> inname ) ; goto EXIT ; } } SUCCESS : retcode = 0 ; EXIT : if ( argbuf ) { <S2SV_ModStart> argbuf ) ; } fprintf ( outfile , "}\\n" ) ; return ( retcode <S2SV_ModEnd> ) ; }
<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> y1 ) { sprintf ( outputbuffer <S2SV_ModEnd> , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m" , <S2SV_ModStart> y1 ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> ; exit ( <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> ; exit ( <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> ; exit ( <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> ; exit ( <S2SV_ModEnd> 1 ) ;
<S2SV_ModStart> h ) { sprintf ( outputbuffer <S2SV_ModEnd> , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>re" , <S2SV_ModStart> h ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> STROKING ) { send ( <S2SV_ModEnd> "<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>K" ) ; <S2SV_ModStart> } else { send ( <S2SV_ModEnd> "<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>0<S2SV_blank>k" ) ;
<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>K" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>k" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
<S2SV_ModStart> ( dashsize ) { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>[%12.3f]<S2SV_blank>%12.3f<S2SV_blank>d" , <S2SV_ModStart> phase ) ; sendClean ( outputbuffer ) ; } else send ( <S2SV_ModEnd> "<S2SV_blank>[]<S2SV_blank>0<S2SV_blank>d" ) ;
<S2SV_ModStart> STROKING ) { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>%12.3f<S2SV_blank>G" , <S2SV_ModStart> } else { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>%12.3f<S2SV_blank>g" , <S2SV_ModStart> ) ; } sendClean ( outputbuffer ) ;
<S2SV_ModStart> w ) { sprintf ( outputbuffer <S2SV_ModEnd> , "<S2SV_blank>%12.3f<S2SV_blank>w" , <S2SV_ModStart> w ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , "%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> y3 ) { sprintf ( outputbuffer <S2SV_ModEnd> , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>h" , <S2SV_ModStart> y3 ) ; sendClean ( outputbuffer ) ;
<S2SV_ModStart> ) ; return <S2SV_ModEnd> 1 ; } <S2SV_ModStart> ) ; return <S2SV_ModEnd> 1 ; } <S2SV_ModStart> ) ; return <S2SV_ModEnd> 1 ; } <S2SV_ModStart> ) ; return <S2SV_ModEnd> 1 ; } <S2SV_ModStart> ) return ( <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> ; exit ( <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> ; return ( <S2SV_ModEnd> 1 ) ;
<S2SV_ModStart> s ) { HTChunk * target = NULL ; <S2SV_ModStart> case HTML_TITLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> title <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_STYLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> style_block <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_SCRIPT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> script <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OBJECT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> object <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_TEXTAREA : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> textarea <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OPTION : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> option <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_MATH : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> math <S2SV_ModEnd> ; break ; <S2SV_ModStart> } } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , "BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }
<S2SV_ModStart> ; int need = 0 ; size_t have <S2SV_ModStart> screen , { if ( need > 0 ) { if ( screen -> max_combining > 0 ) need += screen -> max_combining ; need *= 6 ; } <S2SV_ModEnd> } ) ; <S2SV_ModStart> = '\\0' ; have = ( size_t ) ( lp - line ) ; if ( ( have * 2 ) < ( size_t ) need ) { scp -> data_limit = have + 1 ; line = realloc ( line , scp -> data_limit ) ; } <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> , visibleChars ( <S2SV_ModStart> ( unsigned ) have <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> data_length = have <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> "unixlogin" ) || strstr <S2SV_ModEnd> ( s -> <S2SV_ModStart> s -> name <S2SV_ModEnd> , "plain" )
<S2SV_ModStart> flags ) ; <S2SV_ModEnd> if ( msg <S2SV_ModStart> data ) ) { <S2SV_ModStart> length ) ; SKIP ( msg . f . length ) } else { READ ( data , msg . f . length ) <S2SV_ModEnd> HandleFence ( cl <S2SV_ModStart> data ) ; }
<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; }
<S2SV_ModStart> * function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
<S2SV_ModStart> -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> ; break ; <S2SV_ModStart> case OBJECT_TYPE_STRING : if ( <S2SV_ModStart> YR_OBJECT_STRING * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break ;
<S2SV_ModStart> { assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> : # line 113 <S2SV_ModEnd> "hex_grammar.y" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 126 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> "hex_grammar.y" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 205 "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> "hex_grammar.y" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> "hex_grammar.y" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> "hex_grammar.y" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> "hex_grammar.y" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> "hex_grammar.y" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> "hex_grammar.y" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> "hex_grammar.c" default :
<S2SV_ModStart> : # line 101 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 102 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 103 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 104 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 107 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 106 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> "hex_grammar.c" break ; <S2SV_ModStart> : # line 105 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "hex_grammar.c" break ;
<S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; yyterminate
<S2SV_ModStart> ] == EOF || text [ 1 ] == 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 2 ] ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( ! isxdigit ( <S2SV_ModStart> [ 3 ] ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> "<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x" ) ; assert_regexp_syntax_error ( "\\\\x0" ) ; assert_regexp_syntax_error ( "\\\\x" ) ; assert_regexp_syntax_error ( "\\\\xxy" ) ;
<S2SV_ModStart> 2 ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> { count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array -> <S2SV_ModStart> * 2 ; while ( count <= index ) count *= 2 ;
<S2SV_ModStart> { assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> -> length , 0 ,
<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> # define prolog { if ( <S2SV_ModEnd> ( bytes_matched >= <S2SV_ModStart> >= max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # define <S2SV_ModStart> ( e ) { <S2SV_ModStart> 4 ; } } <S2SV_ModStart> RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> input_incr ; } else { <S2SV_ModStart> ) yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT ) <S2SV_ModStart> RE_SCAN_LIMIT ) ; } <S2SV_ModStart> ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> match = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; action <S2SV_ModStart> == 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = TRUE <S2SV_ModStart> = TRUE ; } <S2SV_ModStart> >= max_bytes_matched ) { <S2SV_ModStart> = TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input - <S2SV_ModStart> input - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> ) kill = input_backwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> else kill = input_backwards_size > 0 <S2SV_ModEnd> || ( bytes_matched <S2SV_ModStart> & RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( size_t <S2SV_ModStart> next_fiber ; } <S2SV_ModEnd> } input +=
<S2SV_ModStart> input_data , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int flags <S2SV_ModStart> ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr =
<S2SV_ModStart> target ) , 0 ,
<S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> offset , offset , <S2SV_ModEnd> flags , NULL <S2SV_ModStart> , data + offset , data_size -
<S2SV_ModStart> "a\\0x\\0x\\0b\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\ta\\0b\\0c\\0" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\ta\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0x\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0b\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "abc" ) ; <S2SV_ModStart> ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE ) <S2SV_ModStart> ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE )
<S2SV_ModStart> 1019 "grammar.y" { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } # line 2594 "grammar.c" break ; case 63 : # line 1024 "grammar.y" { <S2SV_ModStart> } # line 2628 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 64 : # line 1054 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2667 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 65 : # line 1089 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2750 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 66 : # line 1168 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2784 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 67 : # line 1198 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2837 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1247 <S2SV_ModEnd> "grammar.y" { yr_parser_emit <S2SV_ModStart> ( yyscanner , OP_OF <S2SV_ModEnd> , NULL ) <S2SV_ModStart> } # line 2847 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1253 "grammar.y" { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2857 "grammar.c" break ; case 70 : # line 1259 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2887 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 71 : # line 1285 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2927 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 72 : # line 1321 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2956 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 73 : # line 1346 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2996 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 74 : # line 1382 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3009 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 75 : # line 1391 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3022 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 76 : # line 1400 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3035 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 77 : # line 1409 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3048 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 78 : # line 1418 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3061 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 79 : # line 1427 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3074 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1436 "grammar.y" { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } # line 3082 "grammar.c" break ; case 81 : # line 1440 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3090 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1447 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> integer ) = INTEGER_SET_ENUMERATION ; } # line 3096 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1448 "grammar.y" { ( yyval . integer ) = INTEGER_SET_RANGE ; } # line 3102 "grammar.c" break ; case 84 : # line 1454 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3124 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 85 : # line 1476 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3140 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 86 : # line 1488 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line <S2SV_ModEnd> 3155 "grammar.c" break <S2SV_ModStart> break ; case 87 : # line 1503 "grammar.y" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3164 "grammar.c" break ; case 89 : # line 1509 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3175 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 92 : # line 1526 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3186 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 93 : # line 1533 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3197 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1545 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3205 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1549 "grammar.y" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } # line 3213 "grammar.c" break ; case 97 : # line 1557 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3221 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 98 : # line 1561 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3235 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 99 : # line 1571 <S2SV_ModEnd> "grammar.y" { yywarning <S2SV_ModStart> } # line 3253 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 100 : # line 1585 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3273 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 101 : # line 1601 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3287 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 102 : # line 1611 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3300 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 103 : # line 1620 <S2SV_ModEnd> "grammar.y" { SIZED_STRING <S2SV_ModStart> } # line 3329 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 104 : # line 1645 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3345 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 105 : # line 1657 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3361 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 106 : # line 1669 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3381 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 107 : # line 1685 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3397 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 108 : # line 1697 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3417 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 109 : # line 1713 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3466 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 110 : # line 1758 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3489 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 111 : # line 1777 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3511 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 112 : # line 1795 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3533 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 113 : # line 1813 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3555 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 114 : # line 1831 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3585 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 115 : # line 1857 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3607 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 116 : # line 1875 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3621 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 117 : # line 1885 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3635 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 118 : # line 1895 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3649 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 119 : # line 1905 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3663 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 120 : # line 1915 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3677 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 121 : # line 1925 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3691 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> break ; case 122 : # line 1935 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3699 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> ; # line 3703 <S2SV_ModEnd> "grammar.c" default :
<S2SV_ModStart> re_ast ) -> levels = 0 ; ( * re_ast ) ->
<S2SV_ModStart> : # line 113 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1348 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1356 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 126 <S2SV_ModEnd> "re_grammar.y" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1372 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 138 <S2SV_ModEnd> "re_grammar.y" { RE_NODE <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1392 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 157 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1400 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 161 "re_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1414 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 174 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 188 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1452 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 204 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1470 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 218 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1490 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 234 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1517 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 257 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1545 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 281 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1571 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 303 <S2SV_ModEnd> "re_grammar.y" { RE_AST <S2SV_ModStart> } # line 1598 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 326 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1606 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 330 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1616 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1626 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 342 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1636 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 348 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1646 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 357 "re_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1656 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 363 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1666 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 369 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1678 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 377 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1688 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1698 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 389 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1708 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 395 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1718 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 401 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1728 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 407 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1738 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 413 <S2SV_ModEnd> "re_grammar.y" { ( <S2SV_ModStart> } # line 1750 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> ; # line 1754 <S2SV_ModEnd> "re_grammar.c" default :
<S2SV_ModStart> : # line 104 <S2SV_ModEnd> "re_grammar.y" { yr_free <S2SV_ModStart> } # line 1053 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 105 "re_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 106 "re_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1065 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 107 "re_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1071 <S2SV_ModEnd> "re_grammar.c" break ; <S2SV_ModStart> : # line 108 "re_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1077 <S2SV_ModEnd> "re_grammar.c" break ;
<S2SV_ModStart> ++ ) { <S2SV_ModEnd> if ( bytes_matched <S2SV_ModStart> max_bytes_matched ) break ; next_input = input + i * input_incr <S2SV_ModStart> -> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
<S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2371 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 834 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> ; break ; default : assert ( FALSE ) ; <S2SV_ModStart> } # line 2409 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 872 <S2SV_ModEnd> "grammar.y" { SIZED_STRING <S2SV_ModStart> } # line 2455 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 918 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 2478 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 940 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 2491 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 949 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 2504 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 958 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 2523 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 973 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 2539 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 985 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2557 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 999 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 2574 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1012 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 2589 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1023 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> NULL ; } YYERROR ; } # line 2603 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1033 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2637 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1063 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2676 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1098 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2759 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1177 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2793 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1207 <S2SV_ModEnd> "grammar.y" { int <S2SV_ModStart> } # line 2846 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1256 <S2SV_ModEnd> "grammar.y" { yr_parser_emit <S2SV_ModStart> } # line 2856 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1262 <S2SV_ModEnd> "grammar.y" { yr_parser_emit <S2SV_ModStart> } # line 2866 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1268 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2896 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1294 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2936 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1330 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 2965 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1355 <S2SV_ModEnd> "grammar.y" { YR_FIXUP <S2SV_ModStart> } # line 3005 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1391 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3018 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1400 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3031 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1409 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3044 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1418 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3057 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1427 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3070 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1436 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3083 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1445 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3091 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1449 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3099 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1456 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3105 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1457 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3111 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1463 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3133 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1485 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3149 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1497 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3164 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1512 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3173 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1518 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3184 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1535 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3195 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1542 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3206 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1554 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3214 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1558 <S2SV_ModEnd> "grammar.y" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3222 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1566 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3230 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1570 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3244 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1580 <S2SV_ModEnd> "grammar.y" { yywarning <S2SV_ModStart> } # line 3262 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1594 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3282 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1610 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3296 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1620 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3309 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1629 <S2SV_ModEnd> "grammar.y" { SIZED_STRING <S2SV_ModStart> } # line 3338 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1654 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3354 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1666 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3370 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1678 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3390 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1694 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3406 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1706 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3426 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1722 <S2SV_ModEnd> "grammar.y" { if <S2SV_ModStart> } # line 3475 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1767 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3498 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1786 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3520 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1804 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3542 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1822 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3564 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1840 <S2SV_ModEnd> "grammar.y" { compiler <S2SV_ModStart> } # line 3594 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1866 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3616 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1884 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3630 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1894 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3644 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1904 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3658 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1914 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3672 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1924 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3686 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1934 <S2SV_ModEnd> "grammar.y" { CHECK_TYPE <S2SV_ModStart> } # line 3700 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> : # line 1944 <S2SV_ModEnd> "grammar.y" { ( <S2SV_ModStart> } # line 3708 <S2SV_ModEnd> "grammar.c" break ; <S2SV_ModStart> ; # line 3712 <S2SV_ModEnd> "grammar.c" default :
<S2SV_ModStart> U2FH_OK ) { int offs = sizeof ( nonce ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( resplen < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> dev -> cid <S2SV_ModStart> -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionInterface = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMajor = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMinor = resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> capFlags = resp [ offs ++ ] <S2SV_ModEnd> ; } else
<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
<S2SV_ModStart> cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> , & st <S2SV_ModStart> == 0 ) && <S2SV_ModEnd> S_ISREG ( st <S2SV_ModStart> { file = fdopen ( fd <S2SV_ModEnd> , "a" ) <S2SV_ModStart> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } } <S2SV_ModStart> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;
<S2SV_ModStart> authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; goto err ; } else { fd = - 1 <S2SV_ModStart> opwfile ) ; <S2SV_ModEnd> if ( fd <S2SV_ModStart> if ( fd != - 1 <S2SV_ModEnd> ) close (
<S2SV_ModStart> ; int openasuser = 0 <S2SV_ModStart> should_free_authpending_file = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> done ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> DEFAULT_AUTHFILE ) ; if ( ! openasuser ) { DBG ( "WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>" "consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration" <S2SV_ModEnd> , buf ) <S2SV_ModStart> buf ) ; } } DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; <S2SV_ModStart> ) ; } if ( ! openasuser ) { openasuser <S2SV_ModEnd> = geteuid ( <S2SV_ModStart> -> openasuser ; } <S2SV_ModStart> openasuser ) { DBG ( "Dropping<S2SV_blank>privileges" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> { if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( "could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges" <S2SV_ModEnd> ) ; retval <S2SV_ModStart> } DBG ( "Restored<S2SV_blank>privileges" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> otp_id ) ; fclose ( opwfile ) ;
<S2SV_ModStart> path ) ; unlink ( path ) ; <S2SV_ModStart> | O_CREAT | O_EXCL <S2SV_ModEnd> , 0600 )
<S2SV_ModStart> ) ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR "/abrt-tmp-debuginfo.XXXXXX" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory" ) ; log_info ( "Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; { <S2SV_ModStart> ++ ] = "--tmpdir" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( "fork" ) ; if ( pid == 0 ) { <S2SV_ModStart> ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( "waitpid" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( "Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( "Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( "Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d" , WTERMSIG ( status ) ) ; error_msg_and_die ( "Child<S2SV_blank>exit<S2SV_blank>failed" ) ; }
<S2SV_ModStart> g_tv_comment , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0
<S2SV_ModStart> dd ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> == GTK_RESPONSE_OK ) { <S2SV_ModStart> item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }
<S2SV_ModStart> O_APPEND | O_CREAT | O_NOFOLLOW
<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |
<S2SV_ModStart> ( filepath , "r" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; file = fopen_safe <S2SV_ModEnd> ( "/tmp/keepalived.json" ,
<S2SV_ModStart> ( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,
<S2SV_ModStart> FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , "w" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file
<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,
<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
<S2SV_ModStart> ) ; return 0
<S2SV_ModStart> vrrp_rx_bufs_multiples ) ; conf_write ( fp , "<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o" , global_data -> umask ) ;
<S2SV_ModStart> ; # endif install_keyword ( "umask" , & umask_handler ) ;
<S2SV_ModStart> ; # endif umask ( 022 ) ; <S2SV_ModStart> ( ) ; global_data -> umask = umask_val ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> # ifdef _MEM_CHECK_
<S2SV_ModStart> ; unsigned facility ; mode_t new_umask_val <S2SV_ModStart> 'G' } , { "umask" , required_argument , NULL , 'u' } , <S2SV_ModStart> , argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" <S2SV_ModEnd> # if defined <S2SV_ModStart> break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case
<S2SV_ModStart> "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n" ) ;
<S2SV_ModStart> NULL ; uint16_t avp_len ; uint16_t <S2SV_ModStart> uint16_t last_block_len ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len <S2SV_ModEnd> < sizeof ( <S2SV_ModStart> type ) , avp_len <S2SV_ModEnd> ) ; return <S2SV_ModStart> } attr_len = avp_len <S2SV_ModEnd> - sizeof (
<S2SV_ModStart> -> hdr . flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | ( ver & L2TP_VER_MASK ) <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> * val ; switch ( pack -> hdr . flags & L2TP_VER_MASK ) { case 2 : <S2SV_ModEnd> print ( "[L2TP<S2SV_blank>tid=%u<S2SV_blank>sid=%u" <S2SV_ModStart> ) ) ; break ; case 3 : <S2SV_ModEnd> print ( "[L2TP<S2SV_blank>cid=%u" <S2SV_ModStart> Nr ) ) ; break ; default : print ( "[L2TP<S2SV_blank>unknown<S2SV_blank>version]\\n" ) ; return
<S2SV_ModStart> pack ) { struct l2tp_hdr_t * hdr <S2SV_ModEnd> ; struct l2tp_avp_t <S2SV_ModStart> ; uint8_t * buf , * <S2SV_ModStart> ; int n , len ; buf = mempool_alloc ( buf_pool <S2SV_ModEnd> ) ; if <S2SV_ModStart> L2TP_MAX_PACKET_SIZE ) ; hdr = ( struct l2tp_hdr_t * ) buf ; ptr = ( uint8_t * ) ( hdr + 1 ) ; len = <S2SV_ModEnd> sizeof ( pack <S2SV_ModStart> ; avp -> flags = htons ( ( attr -> M ? L2TP_AVP_FLAG_M : 0 ) | ( attr -> H ? L2TP_AVP_FLAG_H : 0 ) | ( ( <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> attr -> length ) & L2TP_AVP_LEN_MASK ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) ; hdr -> flags = htons ( pack -> hdr . flags ) ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> , 0 , <S2SV_ModStart> ( n != len <S2SV_ModEnd> ) { if <S2SV_ModStart> , n , len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> secret_len ) { struct l2tp_packet_t * pack <S2SV_ModEnd> ; struct l2tp_hdr_t <S2SV_ModStart> avp ; struct l2tp_attr_t * <S2SV_ModEnd> RV = NULL <S2SV_ModStart> RV = NULL <S2SV_ModEnd> ; struct sockaddr_in <S2SV_ModStart> addr ; socklen_t addr_len ; uint16_t orig_avp_len ; void * orig_avp_val ; uint8_t * buf , * ptr ; int n , length ; * p = NULL ; if ( pkt_info ) { <S2SV_ModEnd> struct msghdr msg <S2SV_ModStart> struct msghdr msg ; struct cmsghdr * cmsg <S2SV_ModStart> 128 ] ; <S2SV_ModEnd> memset ( & <S2SV_ModStart> . msg_controllen = sizeof ( msg_control ) <S2SV_ModEnd> ; n = <S2SV_ModStart> 1 ) ; addr_len = sizeof ( addr ) ; <S2SV_ModStart> addr , & addr_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( n < sizeof ( * hdr ) <S2SV_ModEnd> ) { if <S2SV_ModStart> out_err_hdr ; } hdr -> flags = ntohs ( hdr -> flags ) ; if ( ! ( hdr -> flags & L2TP_FLAG_T ) <S2SV_ModEnd> ) goto out_err_hdr <S2SV_ModStart> goto out_err_hdr ; if ( ! ( hdr -> flags & L2TP_FLAG_L ) ) { if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(L=0)\\n" ) ; goto out_err_hdr ; } if ( ! ( hdr -> flags & L2TP_FLAG_S ) ) { if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(S=0)\\n" ) ; goto out_err_hdr ; } switch ( hdr -> flags & L2TP_VER_MASK ) { case 2 : if ( hdr -> flags & L2TP_FLAG_O ) { if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>incorrect<S2SV_blank>control<S2SV_blank>message<S2SV_blank>received<S2SV_blank>(O=1)\\n" ) ; goto out_err_hdr ; } break ; case 3 : break ; default : if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>%i<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported\\n" , hdr -> flags & L2TP_VER_MASK ) ; goto out_err_hdr ; } length = ntohs ( hdr -> length ) ; if ( length < sizeof ( * hdr ) ) { if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>short<S2SV_blank>packet<S2SV_blank>received<S2SV_blank>(%i/%zu)\\n" , length , sizeof ( * hdr ) ) ; goto out_err_hdr ; } else <S2SV_ModStart> ( n < length ) <S2SV_ModEnd> { if ( <S2SV_ModStart> , n , length ) <S2SV_ModEnd> ; goto out_err_hdr <S2SV_ModStart> out_err_hdr ; } pack = mempool_alloc ( pack_pool ) ; if ( ! pack ) { log_emerg ( "l2tp:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; goto out_err_hdr ; } memset ( pack , 0 , sizeof ( * pack ) ) ; INIT_LIST_HEAD ( & pack -> attrs ) ; memcpy ( & pack -> addr , & addr , sizeof ( addr ) ) ; memcpy ( & pack -> hdr , hdr , sizeof ( * hdr ) ) ; length -= sizeof ( * hdr ) ; while ( length > 0 ) { struct l2tp_dict_attr_t * da ; struct l2tp_attr_t * attr ; uint16_t avp_len ; if ( length < sizeof ( * avp ) <S2SV_ModEnd> ) { if <S2SV_ModStart> ) log_warn ( "l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n" ) ; goto out_err ; } <S2SV_ModEnd> avp = ( <S2SV_ModStart> ) ptr ; avp -> flags = ntohs ( avp -> flags ) ; avp_len = avp -> flags & L2TP_AVP_LEN_MASK ; if ( avp_len < sizeof ( * avp ) ) { if ( conf_verbose ) log_warn ( "l2tp:<S2SV_blank>short<S2SV_blank>avp<S2SV_blank>received\\n" ) ; goto out_err ; } else if ( length < avp_len <S2SV_ModEnd> ) { if <S2SV_ModStart> ( conf_verbose ) { <S2SV_ModStart> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) ; } if ( ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> && ! conf_avp_permissive <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> M != ! ( avp -> flags & L2TP_AVP_FLAG_M ) ) { if ( conf_verbose ) { log_warn ( "l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>M=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) , da <S2SV_ModEnd> -> M ) <S2SV_ModStart> -> M ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> - 1 && ! <S2SV_ModStart> -> H != ! ( avp -> flags & L2TP_AVP_FLAG_H ) ) { if ( conf_verbose ) { log_warn ( "l2tp:<S2SV_blank>incorrect<S2SV_blank>avp<S2SV_blank>received<S2SV_blank>(type=%i,<S2SV_blank>H=%i,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%i)\\n" , ntohs ( avp -> type ) , ! ! ( avp -> flags & L2TP_AVP_FLAG_H ) , da <S2SV_ModEnd> -> H ) <S2SV_ModStart> -> H ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( avp -> flags & L2TP_AVP_FLAG_H <S2SV_ModEnd> ) { if <S2SV_ModStart> goto out_err ; <S2SV_ModEnd> orig_avp_len = ntohs <S2SV_ModStart> { orig_avp_len = avp_len <S2SV_ModEnd> ; orig_avp_val = <S2SV_ModStart> ; } attr = mempool_alloc ( attr_pool ) ; memset ( attr , 0 , sizeof ( * attr ) ) ; attr <S2SV_ModStart> -> M = ! ! ( avp -> flags & L2TP_AVP_FLAG_M ) <S2SV_ModEnd> ; attr -> <S2SV_ModStart> ( * avp ) ; list_add_tail ( & attr -> entry , & pack -> attrs <S2SV_ModStart> : ptr += avp_len <S2SV_ModEnd> ; length -= <S2SV_ModStart> ; length -= avp_len <S2SV_ModEnd> ; } *
<S2SV_ModStart> -> len ; if ( len < 0 ) { log_ppp_warn ( "radius:packet<S2SV_blank>invalid<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>len<S2SV_blank>received\\n" ) ; goto out_err ; } if ( 2 + len > n ) { log_ppp_warn ( "radius:packet:<S2SV_blank>too<S2SV_blank>long<S2SV_blank>vendor<S2SV_blank>attribute<S2SV_blank>received<S2SV_blank>(%i,<S2SV_blank>%i)\\n" , id , len ) ; goto out_err ; }
<S2SV_ModStart> ( ) ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; }
<S2SV_ModStart> , NULL ) == 1
<S2SV_ModStart> ; # else if ( validate_hostname ( <S2SV_ModEnd> tunnel -> config <S2SV_ModStart> -> gateway_host , cert ) == MatchFound <S2SV_ModEnd> ) cert_valid =
<S2SV_ModStart> * subj ; SSL_set_verify ( tunnel -> ssl_handle , SSL_VERIFY_PEER , NULL ) ; X509 * cert = SSL_get_peer_certificate ( tunnel -> ssl_handle ) ; if ( cert == NULL ) { log_error ( "Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gateway<S2SV_blank>certificate.\\n" ) ; return 1 ; } subj = X509_get_subject_name ( cert ) ; # ifdef HAVE_X509_CHECK_HOST if ( X509_check_host ( cert , tunnel -> config -> gateway_host , 0 , 0 , NULL ) == 1 ) cert_valid = 1 ; # else <S2SV_ModStart> 1 ] ; <S2SV_ModEnd> if ( subj
<S2SV_ModStart> ; if ( len > 1024 || len < 0 ) continue ; if (
<S2SV_ModStart> <= * len && plen > 0
<S2SV_ModStart> - 2 ; if ( plen < 0 ) return 0 ;
<S2SV_ModStart> line ) - pos -
<S2SV_ModStart> ; i < hashsize ( hashtable -> order <S2SV_ModEnd> ) ; i
<S2SV_ModStart> index = hash & hashmask ( hashtable -> order <S2SV_ModEnd> ) ; bucket
<S2SV_ModStart> ; hashtable -> order <S2SV_ModEnd> ++ ; new_size <S2SV_ModStart> ; new_size = hashsize ( hashtable -> order <S2SV_ModEnd> ) ; hashtable <S2SV_ModStart> ; i < hashsize ( hashtable -> order <S2SV_ModEnd> ) ; i
<S2SV_ModStart> buckets [ hash & hashmask ( hashtable -> order <S2SV_ModEnd> ) ] ;
<S2SV_ModStart> ; hashtable -> order = 3 <S2SV_ModEnd> ; hashtable -> <S2SV_ModStart> = jsonp_malloc ( hashsize ( hashtable -> order <S2SV_ModEnd> ) * sizeof <S2SV_ModStart> ; i < hashsize ( hashtable -> order <S2SV_ModEnd> ) ; i
<S2SV_ModStart> buckets [ hash & hashmask ( hashtable -> order <S2SV_ModEnd> ) ] ;
<S2SV_ModStart> -> size >= hashsize ( hashtable -> order <S2SV_ModEnd> ) ) if <S2SV_ModStart> index = hash & hashmask ( hashtable -> order <S2SV_ModEnd> ) ; bucket
<S2SV_ModStart> return NULL ; if ( ! hashtable_seed ) { json_object_seed ( 0 ) ; }
<S2SV_ModStart> val ) ; if ( ! strcmp ( line , "HASHSEED" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; }
<S2SV_ModStart> ( conf . have_hashseed ) json_object_seed ( conf . hashseed ) ; if ( conf .
<S2SV_ModStart> ; if ( getenv ( "HASHSEED" ) ) json_object_seed ( getenv_int ( "HASHSEED" ) ) ; if (
<S2SV_ModStart> ) { free_called = <S2SV_ModEnd> 1 ; free
<S2SV_ModStart> ) { malloc_called = <S2SV_ModEnd> 1 ; return
<S2SV_ModStart> ( malloc_called != 1 <S2SV_ModEnd> || free_called != <S2SV_ModStart> || free_called != 1 <S2SV_ModEnd> ) fail (
<S2SV_ModStart> ( ) { int i ; <S2SV_ModStart> * baz ; const char * iter_keys [ 3 ] ; int have_key [ 3 ] = { 0 , 0 , 0 } ; json_t * iter_values [ 3 ] ; <S2SV_ModStart> "unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>iterator" ) ; iter_keys [ 0 ] = json_object_iter_key ( iter ) ; iter_values [ 0 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( "unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator" ) ; iter_keys [ 1 ] = json_object_iter_key ( iter ) ; iter_values [ 1 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( "unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator" ) ; iter_keys [ 2 ] = json_object_iter_key ( iter ) ; iter_values [ 2 ] = json_object_iter_value ( iter ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( "able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end" ) ; for ( i = 0 ; i < 3 ; i ++ ) { <S2SV_ModStart> ( strcmp ( iter_keys [ i ] <S2SV_ModEnd> , "a" ) <S2SV_ModStart> , "a" ) == 0 ) { if ( iter_values [ i ] <S2SV_ModEnd> != foo ) <S2SV_ModStart> ) fail ( "wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a" ) ; else have_key [ 0 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , "b" ) == 0 ) { if ( iter_values [ i ] != bar ) fail ( "wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b" ) ; else have_key [ 1 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , "c" ) == 0 ) { if ( iter_values [ i ] != baz ) fail ( "wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c" ) ; else have_key [ 2 ] = 1 ; } } for ( i = 0 ; i < 3 ; i ++ ) { if ( ! have_key [ i ] ) fail ( "a<S2SV_blank>key<S2SV_blank>wasn\'t<S2SV_blank>iterated<S2SV_blank>over" ) ; } if ( json_object_iter_at ( object , "foo" ) ) fail ( "json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key" ) ; iter = json_object_iter_at ( object , "b" ) ; if ( ! iter ) fail ( "json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key" ) ; if ( strcmp ( json_object_iter_key ( iter ) , "b" ) ) fail ( "iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( <S2SV_ModStart> "iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value" ) ; if ( json_object_iter_set ( object , iter , baz ) ) fail ( "unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator" <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) fail ( "json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()" <S2SV_ModEnd> ) ; if <S2SV_ModStart> iter ) != baz ) fail ( "json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()" ) ; if ( json_object_get ( object , "b" <S2SV_ModEnd> ) != baz <S2SV_ModStart> ) != baz <S2SV_ModEnd> ) fail (
<S2SV_ModStart> && spwd -> sp_lstchg > 0 && spwd -> sp_max >= <S2SV_ModEnd> 0 && ( <S2SV_ModStart> 86400 ) > ( spwd -> sp_lstchg + spwd -> sp_max ) ) { radlog_request ( L_AUTH , 0 , request , "[%s]:<S2SV_blank>password<S2SV_blank>has<S2SV_blank>expired" , name ) ; return RLM_MODULE_REJECT ; } if ( spwd && <S2SV_ModStart> spwd -> sp_expire > 0 && ( request -> timestamp / 86400 ) > spwd -> sp_expire <S2SV_ModStart> , request , "[%s]:<S2SV_blank>account<S2SV_blank>has<S2SV_blank>expired" <S2SV_ModEnd> , name )
<S2SV_ModStart> * channel_pool ; uint32_t frame_size ; <S2SV_ModStart> ) ) ; frame_size = amqp_d32 ( amqp_offset ( raw_frame , 3 ) ) ; if ( frame_size >= INT32_MAX ) { return AMQP_STATUS_BAD_AMQP_DATA ; } <S2SV_ModStart> -> target_size = frame_size <S2SV_ModEnd> + HEADER_SIZE +
<S2SV_ModStart> bytes ) { size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> * buffer = <S2SV_ModStart> buffer = ( uint8_t <S2SV_ModEnd> * ) dlmalloc <S2SV_ModStart> ) dlmalloc ( size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> bytes ) { size_t size = bytes + sizeof ( AllocationEntry ) ; if ( size < bytes ) { return NULL ; } <S2SV_ModStart> = dlmalloc ( size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> + bytes ; if ( size < bytes ) { return NULL ; }
<S2SV_ModStart> - 1 ; int n = 0 ; <S2SV_ModStart> ( & h <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( L , 2 <S2SV_ModEnd> , "too<S2SV_blank>many<S2SV_blank>results" ) <S2SV_ModStart> res ) ; n ++ ; <S2SV_ModStart> f ) ; n ++ ; <S2SV_ModStart> d ) ; n ++ ; <S2SV_ModStart> { if ( n == 0 || <S2SV_ModStart> ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" <S2SV_ModEnd> ) ; size <S2SV_ModStart> 1 ) ; n -- ; <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" <S2SV_ModStart> , size ) ; n ++ <S2SV_ModStart> 1 ) ; n ++ ; <S2SV_ModStart> ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , MAXALIGN
<S2SV_ModStart> int getnum ( <S2SV_ModEnd> const char * <S2SV_ModStart> ; do { <S2SV_ModEnd> a = a
<S2SV_ModStart> return getnum ( <S2SV_ModEnd> fmt , 1 <S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , sizeof
<S2SV_ModStart> 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."
<S2SV_ModStart> lua_newtable ( L ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"
<S2SV_ModStart> len ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array" ) ;
<S2SV_ModStart> len = 0 ; luaL_checkstack ( L , 3 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map" )
<S2SV_ModStart> ++ ) { luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_check" ) ;
<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_unpack_full" ) ;
<S2SV_ModStart> = server . ds_path <S2SV_ModEnd> ; if (
<S2SV_ModStart> ! server . ds_enabled <S2SV_ModEnd> || obj ->
<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) ; if <S2SV_ModStart> } server . cache_blocked_clients <S2SV_ModEnd> -- ; }
<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && listLength ( <S2SV_ModStart> ; server . cache_blocked_clients <S2SV_ModEnd> -- ; aeCreateFileEvent
<S2SV_ModStart> "hash_max_zipmap_value:%zu\\r\\n" "pubsub_channels:%ld\\r\\n" "pubsub_patterns:%u\\r\\n" "ds_enabled:%d\\r\\n" <S2SV_ModEnd> "role:%s\\r\\n" , REDIS_VERSION <S2SV_ModStart> , server . ds_enabled <S2SV_ModEnd> != 0 , <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) { lockThreadedIO <S2SV_ModStart> ( info , "cache_max_memory:%llu\\r\\n" "cache_blocked_clients:%lu\\r\\n" <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ) server . cache_max_memory <S2SV_ModEnd> , ( unsigned <S2SV_ModStart> ( unsigned long ) server . cache_blocked_clients <S2SV_ModEnd> ) ; unlockThreadedIO
<S2SV_ModStart> ; server . ds_enabled = 0 ; server . ds_path <S2SV_ModEnd> = zstrdup ( <S2SV_ModStart> = zstrdup ( "/tmp/redis.ds" ) ; server . cache_max_memory = 64LL <S2SV_ModEnd> * 1024 * <S2SV_ModStart> 1024 * 1024 ; server . cache_blocked_clients <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> ) server . <S2SV_ModStart> ( server . ds_enabled ) dsInit <S2SV_ModEnd> ( ) ;
<S2SV_ModStart> server . appendfd <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( server . ds_enabled && <S2SV_ModEnd> blockClientOnSwappedKeys ( c
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> while ( server <S2SV_ModStart> ( server . ds_enabled <S2SV_ModEnd> && zmalloc_used_memory ( <S2SV_ModStart> > server . cache_max_memory ) { cacheFreeOneEntry ( ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> 0 ) { int class = <S2SV_ModEnd> getClientTypeByName ( v <S2SV_ModStart> j ] ) ; if ( class <S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER
<S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER ) { err = "Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>" "an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits." <S2SV_ModEnd> ; goto loaderr
<S2SV_ModStart> o == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> , 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , "offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater" ) ; pos -- <S2SV_ModEnd> ; int n <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"
<S2SV_ModStart> = getnum ( L ,
<S2SV_ModStart> int getnum ( lua_State * L , <S2SV_ModStart> ; do { if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , "integral<S2SV_blank>size<S2SV_blank>overflow" ) ;
<S2SV_ModStart> return getnum ( L , <S2SV_ModStart> = getnum ( L ,
<S2SV_ModStart> tf = ( <S2SV_ModEnd> luaY_parser ) (
<S2SV_ModStart> 1 ) ; <S2SV_ModEnd> int kBufferFrameCount = <S2SV_ModStart> kBufferFrameCount = 65536 ; int bufferSize ; while ( multiplyCheckOverflow ( kBufferFrameCount , frameSize , & bufferSize ) ) kBufferFrameCount /= 2 <S2SV_ModStart> = malloc ( bufferSize <S2SV_ModEnd> ) ; AFframecount
<S2SV_ModStart> rv ; int do_read = 1 ; int <S2SV_ModStart> -> connection ) ; while ( do_read ) { do_read = 0 <S2SV_ModStart> plen ) ; do_read = 1 ; } <S2SV_ModEnd> } } }
<S2SV_ModStart> ( 02555 ) "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>" "using<S2SV_blank>read-until-close" <S2SV_ModEnd> , tenc ) <S2SV_ModStart> ) ; return APR_EINVAL <S2SV_ModEnd> ; } if <S2SV_ModStart> bb ) ; apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> BODY_CHUNK_EXT : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { rv <S2SV_ModStart> BODY_CHUNK_TRAILER ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; } <S2SV_ModStart> default : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) "Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; } }
<S2SV_ModStart> state == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> state = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> ) { return APR_EINVAL <S2SV_ModEnd> ; } else <S2SV_ModStart> = sizeof ( apr_off_t <S2SV_ModEnd> ) * 8 <S2SV_ModStart> ( c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { ctx <S2SV_ModStart> else if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> ) { int <S2SV_ModStart> { int xvalue <S2SV_ModEnd> ; if ( <S2SV_ModStart> ++ ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> else { return APR_EINVAL <S2SV_ModEnd> ; } ctx <S2SV_ModStart> | xvalue ; if ( <S2SV_ModEnd> ctx -> remaining <S2SV_ModStart> APR_ENOSPC ; } } else { return APR_EGENERAL ;
<S2SV_ModStart> ) ; } attr = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> printer , job <S2SV_ModEnd> ) ; if
<S2SV_ModStart> "localhost." ) || <S2SV_ModEnd> ! strcmp (
<S2SV_ModStart> } if ( caplentoobig ) { printf ( "\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n" "Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> fd ) ; break <S2SV_ModEnd> ; } printf
<S2SV_ModStart> ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer ,
<S2SV_ModStart> cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table ) ;
<S2SV_ModStart> cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
<S2SV_ModStart> else if ( anope_flags_compat && <S2SV_ModStart> else if ( anope_flags_compat && <S2SV_ModStart> else if ( anope_flags_compat &&
<S2SV_ModStart> in ) && ( alloc > 2 ) &&
<S2SV_ModStart> const char * cooke_domain <S2SV_ModEnd> , const char <S2SV_ModStart> const char * hostname <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ) { size_t cookie_domain_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( cooke_domain <S2SV_ModEnd> ) ; size_t <S2SV_ModStart> ) ; size_t hostname_len <S2SV_ModEnd> = strlen ( <S2SV_ModStart> = strlen ( hostname <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( hostname_len < cookie_domain_len <S2SV_ModEnd> ) return FALSE <S2SV_ModStart> return FALSE ; if ( ! Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ; }
<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0
<S2SV_ModStart> olen ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode res <S2SV_ModStart> ; CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle , <S2SV_ModStart> ( handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( res ) return NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> * olen = curlx_uztosi ( outputlen ) ; return str <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> . path ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> = "INBOX" ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> 0 , & <S2SV_ModEnd> imapc -> mailbox <S2SV_ModStart> imapc -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> . path ; return Curl_urldecode <S2SV_ModEnd> ( data , <S2SV_ModStart> , 0 , & <S2SV_ModEnd> pop3c -> mailbox <S2SV_ModStart> pop3c -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> state . path <S2SV_ModEnd> ; char localhost <S2SV_ModStart> "localhost" ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> smtpc -> domain , NULL , TRUE ) ; if ( result ) return result <S2SV_ModEnd> ; state (
<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> ui -> ft_in_start && bu
<S2SV_ModStart> , strlen ( cp <S2SV_ModEnd> ) - 1
<S2SV_ModStart> true ; } if ( att -> in_disc ) return bt_att_disc_cancel ( att , id ) ;
<S2SV_ModStart> void cancel_att_send_op ( void * data ) { <S2SV_ModStart> att_send_op * op = data ; <S2SV_ModEnd> if ( op
<S2SV_ModStart> chan ) ; <S2SV_ModEnd> if ( chan <S2SV_ModStart> att ) ; att -> in_disc = true ; queue_remove_all ( att -> req_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> ind_queue , NULL , NULL , disc_att_send_op ) ; queue_remove_all ( att -> write_queue , NULL , NULL , disc_att_send_op ) ; att -> in_disc = false ;
<S2SV_ModStart> pflags ; int hasglob ; int <S2SV_ModStart> : 0 ; hasglob = 0 ; <S2SV_ModStart> == 0 && ( hasglob = <S2SV_ModStart> ( pat ) ) == 0 || hasglob == 2 <S2SV_ModEnd> ) { int
<S2SV_ModStart> continue ; case '/' : if ( open ) open = 0 ; case <S2SV_ModStart> else if ( open && * string == '/' ) { string ++ ; continue ; } else if (
<S2SV_ModStart> int e ; # if HAVE_DECL_SETRESUID if ( setresuid ( current_user . uid , current_user . uid , current_user . uid ) < 0 ) # else <S2SV_ModStart> < 0 ) # endif <S2SV_ModStart> # endif } # if HAVE_DECL_SETRESGID if ( setresgid ( current_user . gid , current_user . gid , current_user . gid ) < 0 ) # else <S2SV_ModStart> < 0 ) # endif
<S2SV_ModStart> is_path ) { const char * const start = name ; <S2SV_ModStart> ( ( ( strncmp ( & name [ 1 ] , "ORIGIN}" , 6 ) == 0 && ( ! __libc_enable_secure || ( ( name [ 7 ] == '\\0' || ( is_path && name [ 7 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) && ( len = 7 ) != 0 ) || ( <S2SV_ModEnd> strncmp ( & <S2SV_ModStart> 1 ] , "PLATFORM}" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , "ORIGIN}" , 7 ) == 0 && <S2SV_ModEnd> ( ! __libc_enable_secure <S2SV_ModStart> ( ! __libc_enable_secure || ( ( name [ 9 ] == '\\0' || ( is_path && name [ 9 ] == ':' ) ) && ( name == start || ( is_path && name [ - 1 ] == ':' ) ) ) ) <S2SV_ModEnd> && ( len
<S2SV_ModStart> is_path ) { const char * const start = name ; <S2SV_ModStart> 1 ] , "ORIGIN}" <S2SV_ModEnd> , 6 ) <S2SV_ModStart> 1 ] , "PLATFORM}" <S2SV_ModEnd> , 8 ) <S2SV_ModStart> ? ( __libc_enable_secure && ( ( name [ len ] != '\\0' && ( ! is_path || name [ len ] != ':' ) ) || ( name != start && ( ! is_path || name [ - 1 ] != ':' ) ) )
<S2SV_ModStart> - msgoff ; if ( buf [ bufsize - 1 ] != '\\n' ) { <S2SV_ModStart> = 1 ; } <S2SV_ModStart> , iov , v - iov + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> static int done = 0 <S2SV_ModStart> ( c = 0 ; c < CHAR_SET_SIZE ; ++ c ) if ( ISALNUM ( c ) <S2SV_ModEnd> ) re_syntax_table [
<S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; n <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> , r -> qiov . size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> return ; } <S2SV_ModEnd> if ( s <S2SV_ModStart> ) ; } n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> & r -> <S2SV_ModStart> -> qiov , n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> r -> req <S2SV_ModStart> req . aiocb <S2SV_ModEnd> == NULL )
<S2SV_ModStart> ) ; uint32_t <S2SV_ModEnd> n ; if <S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> } else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> . tag , r -> qiov . size <S2SV_ModEnd> ) ; scsi_req_data <S2SV_ModStart> -> req , r -> qiov . size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bdrv_acct_start ( s
<S2SV_ModStart> SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> uint8_t * outbuf <S2SV_ModStart> uint8_t * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch (
<S2SV_ModStart> scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if
<S2SV_ModStart> req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external
<S2SV_ModStart> * req ; <S2SV_ModEnd> req = scsi_req_alloc <S2SV_ModStart> hba_private ) ; <S2SV_ModEnd> return req ;
<S2SV_ModStart> uint8_t command ; <S2SV_ModEnd> int rc ; <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; DPRINTF ( <S2SV_ModStart> scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if
<S2SV_ModStart> TRUE ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( "Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> jid_create ( to <S2SV_ModEnd> ) ; char
<S2SV_ModStart> ; stbbr_send ( "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>" <S2SV_ModEnd> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>" "<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"
<S2SV_ModStart> == 0 ) { <S2SV_ModStart> -> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> string -> space <S2SV_ModStart> string -> space * <S2SV_ModEnd> 2 ; if <S2SV_ModStart> ; if ( more_space > max_space ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n" , G_STRLOC , new_len ) ; } } <S2SV_ModEnd> string -> space <S2SV_ModStart> -> space = more_space <S2SV_ModEnd> ; } }
<S2SV_ModStart> status ) ; return ;
<S2SV_ModStart> text ; int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> ) { int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> ; if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> Resub * out , int depth <S2SV_ModStart> scratch ; int result ; int <S2SV_ModStart> Rune c ; if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> I_END : return 0 <S2SV_ModEnd> ; case I_JUMP <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> ) { * <S2SV_ModStart> scratch ; return 0 <S2SV_ModEnd> ; } pc <S2SV_ModStart> case I_PLA : result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> flags , out , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> c ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_EOL <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_WORD <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> default : return 1 <S2SV_ModEnd> ; } }
<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
<S2SV_ModStart> OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> char buf [ 100 <S2SV_ModEnd> ] ; js_Object <S2SV_ModStart> = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_ModEnd> double number =
<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
<S2SV_ModStart> client_p , "Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , "Malformed<S2SV_blank>AUTHENTICATE"
<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
<S2SV_ModStart> if ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
<S2SV_ModStart> ; if ( ( len > 12 ) && <S2SV_ModStart> else if ( ( len > 9 ) &&
<S2SV_ModStart> <S2SV_null> <S2SV_null> static gchar <S2SV_ModEnd> * base64_decode_string ( <S2SV_ModStart> enc ) { gchar * dec ; gsize len ; <S2SV_ModStart> return NULL ; dec = ( gchar * ) g_base64_decode ( enc <S2SV_ModEnd> , & len <S2SV_ModStart> len ) ; if ( dec )
<S2SV_ModStart> ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( "Cookie" ) , g_strdup ( "cockpit=d" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , "/cockpit" , headers ) ) g_assert_not_reached ( ) ;
<S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> + pkg_length ; buffer_size -= ( size_t ) pkg_length ;
<S2SV_ModStart> DEBUG ( "snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree" ) ; snmp_free_pdu ( req <S2SV_ModStart> = NULL ; <S2SV_ModEnd> sfree ( errstr <S2SV_ModStart> ; if ( <S2SV_ModEnd> status == 0
<S2SV_ModStart> ( size < 5 + 1 <S2SV_ModEnd> ) ASSERT ( <S2SV_ModStart> ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , "DEADBEEF" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , "%2.0f" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & "DEADBEEF" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
<S2SV_ModStart> . data = instance -> private_key <S2SV_ModEnd> ; hash_param . <S2SV_ModStart> . len = instance -> private_key_len <S2SV_ModEnd> ; hash_slot =
<S2SV_ModStart> == * ptr && ptr [ 1 ]
<S2SV_ModStart> -> multi_easy ) { <S2SV_ModStart> multi_easy ) ; data -> multi_easy = NULL ; }
<S2SV_ModStart> ( 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
<S2SV_ModStart> len -= cut + 1
<S2SV_ModStart> > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> 1 ) { char * rbuff = NULL ; <S2SV_ModStart> method ) ; rbuff = replace ( httpinf . url , "%" , "%25" ) ; <S2SV_ModStart> , "%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n" , rbuff <S2SV_ModEnd> , clientip , <S2SV_ModStart> fflush ( sgfpw ) ; xfree ( rbuff
<S2SV_ModStart> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
<S2SV_ModStart> : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :
<S2SV_ModStart> case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :
<S2SV_ModStart> NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> ) , got_ds64 = 0 , format_chunk <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> WaveHeader WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> , format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> if ( bytecnt >= 2 <S2SV_ModStart> byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
<S2SV_ModStart> ; uint16_t numChannels = 0 <S2SV_ModStart> numChannels < 1 || numChannels > 256 <S2SV_ModStart> ) ) { if ( ! config -> num_channels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> CAFChannelLayout * caf_channel_layout <S2SV_ModEnd> ; if ( <S2SV_ModStart> CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> } else { uint32_t <S2SV_ModEnd> bytes_to_copy = ( <S2SV_ModStart> ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 2 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> 0xff ) || dp [ 3 ] <S2SV_ModEnd> != ( ( <S2SV_ModStart> ( * dp <S2SV_ModEnd> != ( csum <S2SV_ModStart> 0xff ) || dp [ 1 ] <S2SV_ModEnd> != ( (
<S2SV_ModStart> ; uint32_t sampleRate = 0 <S2SV_ModStart> config -> num_channels || ! config -> sample_rate
<S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & bcount <S2SV_ModStart> || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line <S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , "dmmy" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !
<S2SV_ModStart> NULL ; static size_t <S2SV_ModEnd> len = 0
<S2SV_ModStart> int res ; clist * list ; <S2SV_ModStart> res = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
<S2SV_ModStart> PyExc_ValueError , "Key<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>the<S2SV_blank>null<S2SV_blank>string" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_ECB ) { PyErr_Format ( PyExc_ValueError , "ECB<S2SV_blank>mode<S2SV_blank>does<S2SV_blank>not<S2SV_blank>use<S2SV_blank>IV" ) ; return NULL ; } if ( IVlen != 0 && mode == MODE_CTR ) { PyErr_Format ( PyExc_ValueError , "CTR<S2SV_blank>mode<S2SV_blank>needs<S2SV_blank>counter<S2SV_blank>parameter,<S2SV_blank>not<S2SV_blank>IV"
<S2SV_ModStart> fs -> clusters + <S2SV_ModEnd> 1 ) get_fat
<S2SV_ModStart> ; printf ( "%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n" , ( long long ) <S2SV_ModEnd> fs -> fat_size <S2SV_ModStart> -> fat_size , ( long long )
<S2SV_ModStart> , sectors ; off_t <S2SV_ModEnd> fat_length ; unsigned <S2SV_ModStart> fat32_length ) ; if ( ! fat_length ) die ( "FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; <S2SV_ModStart> fs -> data_start ; if ( data_size < fs -> cluster_size ) die ( "Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters" )
<S2SV_ModStart> ) ) ; str_append ( path , key -> key -> key ) ; ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value <S2SV_ModEnd> , & error <S2SV_ModStart> if ( ret > <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , "Lookup:<S2SV_blank>%s<S2SV_blank>=<S2SV_blank>%s" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { <S2SV_ModStart> , AUTH_SUBSYS_DB , "Failed<S2SV_blank>to<S2SV_blank>lookup<S2SV_blank>key<S2SV_blank>%s:<S2SV_blank>%s" , str_c ( path ) <S2SV_ModEnd> , error ) <S2SV_ModStart> 1 ; } <S2SV_ModEnd> else if (
<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
<S2SV_ModStart> NULL , NULL ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> NULL ; } gss_release_buffer ( & min , & out ) ;
<S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } len_buf_pos <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) ; goto bail <S2SV_ModEnd> ; } tmpbuf_pos <S2SV_ModStart> - 2 ; bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ;
<S2SV_ModStart> } option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> endpoints ) { for ( addresses = sclone ( <S2SV_ModEnd> state -> endpoints <S2SV_ModStart> state -> endpoints ) ; <S2SV_ModEnd> ( address = <S2SV_ModStart> ) != 0 ; addresses = tok ) { <S2SV_ModEnd> mprParseSocketAddress ( address
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> { owner = ssplit <S2SV_ModEnd> ( auth , <S2SV_ModStart> } group = ssplit <S2SV_ModEnd> ( tok ,
<S2SV_ModStart> = 0 ; if ( ( <S2SV_ModStart> & value ) ) == 0 ) { continue ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> { option = ssplit <S2SV_ModEnd> ( option ,
<S2SV_ModStart> -> host , ssplit <S2SV_ModEnd> ( sclone (
<S2SV_ModStart> while ( pair <S2SV_ModEnd> ) { mprAddItem
<S2SV_ModStart> { tags = ssplit <S2SV_ModEnd> ( sclone (
<S2SV_ModStart> -> path = websValidateUriPath <S2SV_ModEnd> ( path )
<S2SV_ModStart> ; dname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> { ascii = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> ; ascii = safe_calloc <S2SV_ModEnd> ( str_len )
<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> char * header = safe_calloc ( <S2SV_ModEnd> 1024 ) ; <S2SV_ModStart> 1024 ) ; long
<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
<S2SV_ModStart> -> entries = safe_calloc ( <S2SV_ModEnd> xref -> n_entries
<S2SV_ModStart> ; daddy = safe_calloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; buf = safe_calloc <S2SV_ModEnd> ( sz +
<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> char * header <S2SV_ModEnd> = get_header ( <S2SV_ModStart> ( fp ) ; const char * c <S2SV_ModStart> ) && ( ( c + 6 ) [ 0 ] == '.' ) && isdigit ( ( c + 5 ) [ 0 ] ) && isdigit ( ( c + 7 ) [ 0 ] <S2SV_ModEnd> ) ) {
<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> * header ; if ( ! ( <S2SV_ModStart> ( fp ) ) ) return 0 ; const char * c = <S2SV_ModEnd> strstr ( header <S2SV_ModStart> , "%PDF-" ) ; const int is_pdf = c && ( ( c - header + strlen ( "%PDF-M.m" ) ) < 1024 ) <S2SV_ModEnd> ; free (
<S2SV_ModStart> , port , server -> connrec -> address ,
<S2SV_ModStart> int k ; if ( psf -> header . indx + bufsize >= psf -> header . len && psf_bump_header_allocation ( psf , bufsize ) ) return 0 ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> < psf -> <S2SV_ModStart> < psf -> header . end ) { ptr [ k ] = psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx <S2SV_ModEnd> ++ ; } <S2SV_ModStart> { psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> psf -> header . ptr [ psf -> header . indx ] ; psf -> header . indx = psf -> header . end <S2SV_ModEnd> ; } ;
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] =
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( psf -> header . indx + bytes >= <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . len && psf_bump_header_allocation ( psf , bytes <S2SV_ModStart> ) ) return count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + bytes > <S2SV_ModStart> > psf -> header . end <S2SV_ModEnd> ) { count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx <S2SV_ModEnd> ) , psf <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> + psf -> header . indx <S2SV_ModEnd> , bytes ) <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += bytes ;
<S2SV_ModStart> : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> > psf -> header . end ) psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> - psf -> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> = position ; <S2SV_ModStart> ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> + position < <S2SV_ModStart> ( psf -> header . indx >= psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position <= <S2SV_ModStart> <= psf -> header . end ) { psf -> header . indx <S2SV_ModEnd> += position ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position > <S2SV_ModStart> + position > psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; psf_fseek ( <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; break ;
<S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> ; maxlen = <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . len <S2SV_ModEnd> - maxlen ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> = strlen ( <S2SV_ModStart> psf -> header . ptr
<S2SV_ModStart> 0 , count = 0 <S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> * ) ; * intptr = 0 ; <S2SV_ModStart> int * ) ; * intptr = 0 <S2SV_ModStart> size_t ) ; memset ( charptr , 0 , count ) ; byte_count += header_read ( psf , charptr , count ) ; break ; case 'G' : charptr = va_arg ( argptr , char * ) ; count = va_arg ( argptr , size_t ) ; memset ( charptr , 0 , count ) ; if ( psf -> header . indx + count >= psf -> header . len && psf_bump_header_allocation ( psf , count ) ) return 0 ; byte_count += header_gets <S2SV_ModEnd> ( psf , <S2SV_ModStart> break ; case 'z' : psf_log_printf ( psf , "Format<S2SV_blank>conversion<S2SV_blank>\'z\'<S2SV_blank>not<S2SV_blank>implemented<S2SV_blank>yet.\\n" ) ; break ; case 'p' : <S2SV_ModEnd> count = va_arg <S2SV_ModStart> size_t ) ; header_seek ( psf , count , SEEK_SET ) ; byte_count = count ; break ; case 'j' <S2SV_ModEnd> : count = <S2SV_ModStart> , count , <S2SV_ModEnd> SEEK_CUR ) ; <S2SV_ModStart> byte_count += count <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ) ) { if ( psf -> header . indx + 16 >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 4 ; <S2SV_ModStart> psf -> header . ptr + psf -> header . indx <S2SV_ModEnd> ) ; else <S2SV_ModStart> psf -> header . ptr + psf -> header . indx ) ; psf -> header . indx <S2SV_ModEnd> += 8 ; <S2SV_ModStart> & 1 ) ; if ( psf -> header . indx + ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , 16 ) ) return count <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> - 1 ] <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; if ( psf -> <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx += size ; psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] = 0 <S2SV_ModStart> : size ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; memcpy ( & ( psf -> header . ptr [ psf -> header . indx ] ) , bindata , size ) ; psf -> header . indx += size ; count += size ; break ; case 'z' : size = va_arg ( argptr , size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; count += size ; while ( size ) { psf -> header . ptr <S2SV_ModEnd> [ psf -> <S2SV_ModStart> [ psf -> header . indx ] <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> ++ ; size <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ] ) , <S2SV_ModStart> ; psf -> header . indx <S2SV_ModEnd> += 16 ; <S2SV_ModStart> size_t ) ; if ( psf -> header . indx + ( sf_count_t ) size > psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx <S2SV_ModEnd> += size ; <S2SV_ModStart> ; if ( ( sf_count_t ) size >= psf -> header . len && psf_bump_header_allocation ( psf , size ) ) return count ; psf -> header . indx = size <S2SV_ModEnd> ; break ;
<S2SV_ModStart> psf_close_rsrc ( psf ) ; free ( psf -> header . ptr
<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> ( psf = psf_allocate ( <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> ; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
<S2SV_ModStart> + 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>map<S2SV_blank>offset.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ++ ) { if ( <S2SV_ModEnd> rsrc . type_offset <S2SV_ModStart> k * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8
<S2SV_ModStart> + 10 ; if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> ; } ; } ;
<S2SV_ModStart> size_t chanmap_size = SF_MIN ( <S2SV_ModStart> sf . channels , layout_tag & 0xffff )







<S2SV_ModStart> * cJSON_CreateFloatArray ( const float <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
<S2SV_ModStart> * cJSON_CreateIntArray ( const int <S2SV_ModEnd> * numbers , <S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> { n = cJSON_CreateNumber <S2SV_ModEnd> ( numbers [ <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }


<S2SV_ModStart> < count ; i ++ <S2SV_ModEnd> ) { n <S2SV_ModStart> ] ) ; if ( ! n ) { cJSON_Delete ( a ) ; return 0 ; }
<S2SV_ModStart> string ) ; if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> return item ;



<S2SV_ModStart> ; if ( ! ( c -> type & cJSON_StringIsConst ) &&
<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> string ) ) i ++ , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> if ( c
<S2SV_ModStart> c = array ? array -> child : 0 <S2SV_ModEnd> ; while ( <S2SV_ModStart> > 0 ) item -- , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> return c ;
<S2SV_ModStart> ( c ) i ++ , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> return i ;
<S2SV_ModStart> ) { return global_ep <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> c = object ? object -> child : 0 <S2SV_ModEnd> ; while (

<S2SV_ModStart> value ) { return cJSON_ParseWithOpts ( value , 0 , 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 , 0 , 0
<S2SV_ModStart> 0 , 1 , 0
<S2SV_ModStart> > 0 ) <S2SV_ModEnd> c = c <S2SV_ModStart> c -> next , which -- ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> string ) ) i ++ , <S2SV_ModEnd> c = c <S2SV_ModStart> -> next ; <S2SV_ModEnd> if ( c


<S2SV_ModStart> { cJSON * <S2SV_ModEnd> ref = cJSON_New_Item <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! ref ) <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '[' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == ']' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == ']' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> num ) { double n = 0 , sign = 1 , scale <S2SV_ModEnd> = 0 ; <S2SV_ModStart> 0 ; int subscale = 0 , signsubscale = 1 ; if ( * num == '-' ) sign = - 1 , num ++ ; if ( * num == '0' ) num ++ ; if ( * num >= '1' && * num <= '9' ) do n = ( n * 10.0 ) + ( * num ++ - '0' ) ; while ( * num >= '0' && * num <= '9' ) ; if ( * num == '.' && num [ 1 ] >= '0' && num [ 1 ] <= '9' ) { num ++ ; do n = ( n <S2SV_ModEnd> * 10.0 ) <S2SV_ModStart> ( * num ++ - '0' ) , <S2SV_ModEnd> scale -- ; <S2SV_ModStart> scale -- ; <S2SV_ModEnd> while ( * <S2SV_ModStart> 'E' ) { num ++ ; <S2SV_ModEnd> if ( * <S2SV_ModStart> == '+' ) num ++ ; <S2SV_ModEnd> else if ( <S2SV_ModStart> == '-' ) <S2SV_ModEnd> signsubscale = - <S2SV_ModStart> = - 1 , num ++ ; while ( * num >= '0' && * num <= '9' ) subscale = ( subscale * 10 ) + ( * num ++ - '0' ) ; } n <S2SV_ModEnd> = sign * <S2SV_ModStart> = sign * n * pow ( 10.0 , ( scale + subscale * signsubscale ) ) ; item -> valuedouble = n <S2SV_ModEnd> ; item -> <S2SV_ModStart> -> valueint = ( int64_t ) n ; <S2SV_ModEnd> item -> type
<S2SV_ModStart> char * value , const char * * ep <S2SV_ModStart> '{' ) { * ep = value ; return 0 ; <S2SV_ModEnd> } item -> <S2SV_ModStart> == '}' ) return value + 1 ; <S2SV_ModEnd> item -> child <S2SV_ModStart> cJSON_New_Item ( ) ; if ( ! item -> child ) return 0 ; <S2SV_ModEnd> value = skip <S2SV_ModStart> ( value ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> = child ; child = new_item ; <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> ':' ) { * ep = value ; return 0 ; } <S2SV_ModEnd> value = skip <S2SV_ModStart> + 1 ) , ep ) ) ; if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == '}' ) return value + 1 ; * ep = value ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> char * str , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * * ep ) { const char * ptr = str + 1 , * end_ptr = str + 1 ; char * ptr2 ; char * <S2SV_ModEnd> out ; int <S2SV_ModStart> \'\\"\' ) { * <S2SV_ModStart> = str ; return 0 ; <S2SV_ModEnd> } while ( <S2SV_ModStart> while ( * end_ptr <S2SV_ModEnd> != \'\\"\' && <S2SV_ModStart> \'\\"\' && * end_ptr <S2SV_ModEnd> && ++ len <S2SV_ModStart> ++ len ) if ( * end_ptr <S2SV_ModEnd> ++ == '\\\\' <S2SV_ModStart> == '\\\\' ) end_ptr ++ ; out = ( char * ) cJSON_malloc ( len + 1 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! out ) return 0 ; item -> valuestring <S2SV_ModEnd> = out ; <S2SV_ModStart> = out ; item -> type = cJSON_String ; ptr = str + 1 ; ptr2 = out ; while ( ptr < end_ptr ) <S2SV_ModEnd> { if ( <S2SV_ModStart> case 'u' : uc = parse_hex4 ( ptr + 1 ) ; <S2SV_ModEnd> ptr += 4 <S2SV_ModStart> += 4 ; if ( ptr >= end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModStart> == 0 ) { * ep = str ; return 0 ; } <S2SV_ModEnd> if ( uc <S2SV_ModStart> <= 0xDBFF ) { if ( ptr + 6 > end_ptr ) { * ep = str ; return 0 ; } <S2SV_ModEnd> if ( ptr <S2SV_ModStart> != 'u' ) { * ep = str ; return 0 ; } uc2 = parse_hex4 <S2SV_ModEnd> ( ptr + <S2SV_ModStart> ptr + 3 ) ; <S2SV_ModEnd> ptr += 6 <S2SV_ModStart> > 0xDFFF ) { * ep = str ; return 0 ; } <S2SV_ModEnd> uc = 0x10000 <S2SV_ModStart> uc = 0x10000 + ( <S2SV_ModEnd> ( ( uc <S2SV_ModStart> & 0x3FF ) ) <S2SV_ModStart> < 0x80 ) len = 1 ; <S2SV_ModEnd> else if ( <S2SV_ModStart> break ; } ptr ++ <S2SV_ModEnd> ; } } <S2SV_ModStart> == \'\\"\' ) ptr ++ <S2SV_ModEnd> ; return ptr
<S2SV_ModStart> char * value , const char * * ep ) { if ( ! value ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> == \'\\"\' ) { <S2SV_ModStart> item , value , ep ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> '9' ) ) { <S2SV_ModStart> value ) ; } <S2SV_ModStart> == '[' ) { <S2SV_ModStart> item , value , ep ) ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> == '{' ) { <S2SV_ModStart> item , value , ep ) ; } * ep = value ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> , int fmt , printbuffer * p <S2SV_ModStart> = 0 ; size_t tmplen = 0 ; <S2SV_ModStart> ( child ) numentries ++ , <S2SV_ModEnd> child = child <S2SV_ModStart> -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char <S2SV_ModEnd> * ) cJSON_malloc <S2SV_ModStart> ) cJSON_malloc ( 3 ) ; if ( out ) strcpy ( out , "[]" ) ; return out ; } if ( p ) { i = p -> offset ; ptr = ensure ( p , 1 ) ; if ( ! ptr ) return 0 ; * ptr = '[' ; p -> offset ++ <S2SV_ModEnd> ; child = <S2SV_ModStart> ! fail ) { <S2SV_ModEnd> print_value ( child <S2SV_ModStart> 1 , fmt , p ) ; p -> offset = update ( p ) ; if ( child -> next ) { len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; p -> offset += len ; } child = child -> next ; } ptr = ensure ( p , 2 ) ; if ( ! ptr ) return 0 ; * ptr ++ = ']' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; memset ( entries , 0 , numentries * sizeof ( char * ) ) ; child = item -> child ; while ( child && ! fail ) { ret = print_value ( child , depth + 1 , fmt , 0 <S2SV_ModStart> ! fail ) <S2SV_ModEnd> out = ( <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( fail <S2SV_ModStart> < numentries ; i ++ ) <S2SV_ModEnd> if ( entries <S2SV_ModStart> < numentries ; i ++ ) { tmplen = strlen ( <S2SV_ModEnd> entries [ i <S2SV_ModStart> ] ) ; memcpy ( ptr , entries [ i ] , tmplen ) ; ptr += tmplen ; if ( i != numentries - 1 ) { * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '<S2SV_blank>' ; * ptr = 0 ; } cJSON_free <S2SV_ModEnd> ( entries [ <S2SV_ModStart> ] ) ; <S2SV_ModEnd> } cJSON_free ( <S2SV_ModStart> cJSON_free ( entries <S2SV_ModEnd> ) ; * <S2SV_ModStart> = ']' ; * ptr ++ = 0 ; } <S2SV_ModEnd> return out ;
<S2SV_ModStart> cJSON * item , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> = item -> <S2SV_ModStart> = item -> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , "0" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , "%lld" , ( long long ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , "null" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , "%.0f" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , "%e" , d ) ; else sprintf ( str , "%f" , d ) ; } <S2SV_ModEnd> } return str
<S2SV_ModStart> , int fmt , printbuffer * p <S2SV_ModStart> = 0 ; size_t tmplen = 0 ; <S2SV_ModStart> ( child ) numentries ++ , child = child -> next ; if ( ! numentries ) { if ( p ) out = ensure ( p , fmt ? depth + 4 : 3 ) ; else out = ( char * ) cJSON_malloc ( fmt ? depth + 4 : 3 ) ; if ( ! out ) return 0 ; ptr = out ; * ptr ++ = '{' ; if ( fmt ) { * ptr ++ = '\\n' ; for ( i = 0 ; i < depth ; i ++ ) * ptr ++ = '\\t' ; } * ptr ++ = '}' ; * ptr ++ = 0 ; return out ; } if ( p ) { i = p -> offset ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; * ptr ++ = '{' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = item -> child ; depth ++ ; while ( child ) { if ( fmt ) { ptr = ensure ( p , depth ) ; if ( ! ptr ) return 0 ; for ( j = 0 ; j < depth ; j ++ ) * ptr ++ = '\\t' ; p -> offset += depth ; } print_string_ptr ( child -> string , p ) ; p -> offset = update ( p ) ; len = fmt ? 2 : 1 ; ptr = ensure ( p , len ) ; if ( ! ptr ) return 0 ; * ptr ++ = ':' ; if ( fmt ) * ptr ++ = '\\t' ; p -> offset += len ; print_value ( child , depth , fmt , p ) ; p -> offset = update ( p ) ; len = ( fmt ? 1 : 0 ) + ( child -> next ? 1 : 0 ) ; ptr = ensure ( p , len + 1 ) ; if ( ! ptr ) return 0 ; if ( child -> next ) * ptr ++ = ',' ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; p -> offset += len ; child = child -> next ; } ptr = ensure ( p , fmt ? ( depth + 1 ) : 2 ) ; if ( ! ptr ) return 0 ; if ( fmt ) for ( i = 0 ; i < depth - 1 ; i ++ ) * ptr ++ = '\\t' ; * ptr ++ = '}' ; * ptr = 0 ; out = ( p -> buffer ) + i ; } else { entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! entries ) return 0 ; names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ; if ( ! names ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; depth ++ ; if ( fmt ) len += depth ; while ( child && ! fail ) <S2SV_ModEnd> { names [ <S2SV_ModStart> child -> string , 0 <S2SV_ModStart> depth , fmt , 0 <S2SV_ModStart> ! fail ) <S2SV_ModEnd> out = ( <S2SV_ModStart> = 1 ; <S2SV_ModEnd> if ( fail <S2SV_ModStart> < numentries ; i ++ <S2SV_ModEnd> ) { if <S2SV_ModStart> + 1 ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> < numentries ; i ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> < depth ; j ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '\\t' ; tmplen = strlen ( <S2SV_ModEnd> names [ i <S2SV_ModStart> ] ) ; memcpy ( ptr , <S2SV_ModEnd> names [ i <S2SV_ModStart> [ i ] , tmplen ) ; ptr += tmplen <S2SV_ModEnd> ; * ptr <S2SV_ModStart> = ':' ; if ( fmt ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> - 1 ; i ++ ) <S2SV_ModEnd> * ptr ++ <S2SV_ModStart> = '}' ; * ptr ++ = 0 ; } <S2SV_ModEnd> return out ;
<S2SV_ModStart> cJSON * item , printbuffer * p <S2SV_ModStart> item -> valuestring , p
<S2SV_ModStart> char * str , printbuffer * p <S2SV_ModStart> * ptr ; char * ptr2 , * out ; <S2SV_ModEnd> int len = <S2SV_ModStart> len = 0 , flag = 0 ; <S2SV_ModEnd> unsigned char token <S2SV_ModStart> ! str ) { if ( p ) out = ensure ( p , 3 ) ; else out = ( char * ) cJSON_malloc ( 3 ) ; if ( ! out ) return 0 ; strcpy ( out , "\\"\\"" ) ; return out ; } for ( ptr = str ; * ptr ; ptr ++ ) flag |= ( ( * ptr > 0 && * ptr < 32 ) || ( * ptr == \'\\"\' ) || ( * ptr == '\\\\' ) ) ? 1 : 0 ; if ( ! flag ) { len = ptr - str ; if ( p ) out = ensure ( p , len + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) return 0 ; ptr2 = out ; * ptr2 ++ = \'\\"\' ; strcpy ( ptr2 , str ) ; ptr2 [ len ] = \'\\"\' ; ptr2 [ len + 1 ] = 0 ; return out ; } ptr = str ; <S2SV_ModEnd> while ( ( <S2SV_ModStart> token ) ) len ++ ; <S2SV_ModEnd> else if ( <S2SV_ModStart> += 5 ; ptr ++ ; } if ( p ) out = ensure ( p , <S2SV_ModEnd> len + 3 <S2SV_ModStart> + 3 ) ; else out = ( char * ) cJSON_malloc ( len + 3 ) ; if ( ! out ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> += 5 ; break ; } } } * ptr2 ++ = \'\\"\' ; <S2SV_ModEnd> * ptr2 ++
<S2SV_ModStart> , int fmt , printbuffer * p <S2SV_ModStart> return 0 ; if ( p ) { <S2SV_ModStart> case cJSON_NULL : { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , "null" ) ; break ; } case cJSON_False : { out = ensure ( p , 6 ) ; if ( out ) strcpy ( out , "false" ) ; break ; } case cJSON_True : { out = ensure ( p , 5 ) ; if ( out ) strcpy ( out , "true" ) ; break ; } case cJSON_Number : out = print_number ( item , p ) ; break ; case cJSON_String : out = print_string ( item , p ) ; break ; case cJSON_Array : out = print_array ( item , depth , fmt , p ) ; break ; case cJSON_Object : out = print_object ( item , depth , fmt , p ) ; break ; } } else { switch ( ( item -> type ) & 255 ) { case cJSON_NULL : <S2SV_ModStart> print_number ( item , 0 <S2SV_ModStart> print_string ( item , 0 <S2SV_ModStart> depth , fmt , 0 <S2SV_ModStart> depth , fmt , 0 ) ; break ; } <S2SV_ModEnd> } return out


<S2SV_ModStart> = j_cpu_util_total -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_user -> valuedouble <S2SV_ModEnd> ; test -> <S2SV_ModStart> = j_cpu_util_system -> valuedouble <S2SV_ModEnd> ; result_has_retransmits = <S2SV_ModStart> = j_jitter -> valuedouble <S2SV_ModEnd> ; cerror =
<S2SV_ModStart> -> mss ) cJSON_AddNumberToObject <S2SV_ModEnd> ( test -> <S2SV_ModStart> len ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( test ->
<S2SV_ModStart> "udp" ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j , <S2SV_ModStart> - 1 ) cJSON_AddNumberToObject ( j , "server_affinity" , test -> server_affinity ) ; if ( test -> duration ) cJSON_AddNumberToObject ( j , "time" , test -> duration ) ; if ( test -> settings -> bytes ) cJSON_AddNumberToObject ( j , "num" , test -> settings -> bytes ) ; if ( test -> settings -> blocks ) cJSON_AddNumberToObject ( j , "blockcount" , test -> settings -> blocks ) ; if ( test -> settings -> mss ) cJSON_AddNumberToObject ( j , "MSS" , test -> settings -> mss ) ; if ( test -> no_delay ) cJSON_AddTrueToObject ( j , "nodelay" ) ; cJSON_AddNumberToObject ( j , "parallel" , test -> num_streams ) ; if ( test -> reverse ) cJSON_AddTrueToObject ( j , "reverse" ) ; if ( test -> settings -> socket_bufsize ) cJSON_AddNumberToObject ( j , "window" , test -> settings -> socket_bufsize ) ; if ( test -> settings -> blksize ) cJSON_AddNumberToObject ( j , "len" , test -> settings -> blksize ) ; if ( test -> settings -> rate ) cJSON_AddNumberToObject ( j , "bandwidth" , test -> settings -> rate ) ; if ( test -> settings -> burst ) cJSON_AddNumberToObject ( j , "burst" , test -> settings -> burst ) ; if ( test -> settings -> tos ) cJSON_AddNumberToObject ( j , "TOS" , test -> settings -> tos ) ; if ( test -> settings -> flowlabel ) cJSON_AddNumberToObject ( j , "flowlabel" , test -> settings -> flowlabel ) ; if ( test -> title ) cJSON_AddStringToObject ( j , "title" , test -> title ) ; if ( test -> congestion ) cJSON_AddStringToObject ( j , "congestion" , test -> congestion ) ; if ( test -> get_server_output ) << << << < HEAD <S2SV_ModStart> ( j , "get_server_output" , iperf_get_test_get_server_output ( test ) ) ; == == == = cJSON_AddNumberToObject ( j , "get_server_output" , iperf_get_test_get_server_output ( test ) ) ; if ( test -> udp_counters_64bit ) cJSON_AddNumberToObject ( j , "udp_counters_64bit" , iperf_get_test_udp_counters_64bit ( test ) ) ; if ( test -> no_fq_socket_pacing ) cJSON_AddNumberToObject ( j , "no_fq_socket_pacing" , iperf_get_no_fq_socket_pacing ( test ) ) ; <S2SV_ModEnd> cJSON_AddStringToObject ( j <S2SV_ModStart> ( j , "client_version" , IPERF_VERSION ) ; >> >> >> > ed94082 ... Fix a buffer overflow / heap corruption issue that could occur if a <S2SV_ModEnd> if ( test
<S2SV_ModStart> } else { cJSON_AddNumberToObject <S2SV_ModEnd> ( j , <S2SV_ModStart> ] ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j , <S2SV_ModStart> ] ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j , <S2SV_ModStart> -> sender_has_retransmits ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j , <S2SV_ModStart> - 1 ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream , <S2SV_ModStart> id ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream , <S2SV_ModStart> bytes_transferred ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream , <S2SV_ModStart> retransmits ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream , <S2SV_ModStart> jitter ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream , <S2SV_ModStart> cnt_error ) ; cJSON_AddNumberToObject <S2SV_ModEnd> ( j_stream ,
<S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg ( <S2SV_ModStart> : j = cJSON_CreateNumber <S2SV_ModEnd> ( va_arg (
<S2SV_ModStart> LEX_ID ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , "ID:%s" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; } <S2SV_ModStart> LEX_STR ) { espruino_snprintf <S2SV_ModEnd> ( str , <S2SV_ModStart> ( str , len , "String:\'%s\'" <S2SV_ModEnd> , jslGetTokenValueAsString ( <S2SV_ModStart> jslGetTokenValueAsString ( ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 10 ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ; }
<S2SV_ModStart> } else { strcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , "undefined" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> fractionalDigits ) { assert ( len > 9 ) ; <S2SV_ModStart> val ) ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "NaN" <S2SV_ModEnd> ) ; else <S2SV_ModStart> < 0 ) strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "-Infinity" <S2SV_ModEnd> ) ; else <S2SV_ModStart> ) ; else strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "Infinity" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_ModStart> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; }
<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;
<S2SV_ModStart> len ) { assert ( len > 28 ) ; <S2SV_ModStart> case LEX_EOF : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "EOF" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_ID : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "ID" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_INT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "INT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_FLOAT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "FLOAT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "STRING" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>STRING" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "REGEX" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>REGEX" <S2SV_ModEnd> ) ; return <S2SV_ModStart> case LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> str , "UNFINISHED<S2SV_blank>COMMENT" <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) ; strcpy <S2SV_ModEnd> ( str , <S2SV_ModStart> [ p ] <S2SV_ModEnd> ) ; return <S2SV_ModStart> return ; } <S2SV_ModEnd> espruino_snprintf ( str
<S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if ( <S2SV_ModStart> { if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if (
<S2SV_ModStart> * zone ; size_t tilemap_size ; <S2SV_ModStart> . height ; tilemap_size = <S2SV_ModEnd> x_size * y_size <S2SV_ModStart> struct map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
<S2SV_ModStart> available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> -> d_memory , original_length <S2SV_ModEnd> ) ; qp
<S2SV_ModStart> if ( q < p ) { DPRINTF ( ( "Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n" , q , p ) ) ; goto out ; } if ( q
<S2SV_ModStart> + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> b ) <= ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> b ) , ss <S2SV_ModEnd> * sst -> <S2SV_ModStart> -> sst_len , ss <S2SV_ModEnd> , sst ->
<S2SV_ModStart> ( cdf_secid_t ) ( <S2SV_ModStart> * size ) / sizeof ( maxsector ) ) <S2SV_ModStart> if ( sid >= maxsector ) { DPRINTF ( ( "Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n" <S2SV_ModEnd> , sid ,
<S2SV_ModStart> if ( nelements > CDF_ELEMENT_LIMIT || nelements <S2SV_ModStart> DPRINTF ( ( "CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>%" SIZE_T_FORMAT "u\\n" , nelements <S2SV_ModEnd> ) ) ; <S2SV_ModStart> nelem ; } <S2SV_ModEnd> for ( j
<S2SV_ModStart> c . len = 20 + level <S2SV_ModEnd> ) * sizeof
<S2SV_ModStart> if ( pos + len <S2SV_ModStart> "u\\n" , pos + len
<S2SV_ModStart> count , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ( ms ) && root_storage <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime )
<S2SV_ModStart> sst , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { cdf_summary_info_header_t <S2SV_ModStart> break ; } if ( root_storage ) { <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc ) <S2SV_ModStart> - 2 ; } <S2SV_ModStart> , count , root_storage <S2SV_ModEnd> ) ; free
<S2SV_ModStart> scn , root_storage <S2SV_ModEnd> ) ) <
<S2SV_ModStart> if ( q < p || q
<S2SV_ModStart> ) { size_t tail = <S2SV_ModEnd> ( i << <S2SV_ModStart> ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail
<S2SV_ModStart> ) { size_t <S2SV_ModEnd> maxcount ; const <S2SV_ModStart> -> si_count = CDF_TOLE4 <S2SV_ModEnd> ( si -> <S2SV_ModStart> = NULL ; if ( cdf_read_property_info ( sst , h , CDF_TOLE4 ( <S2SV_ModEnd> sd -> sd_offset <S2SV_ModStart> - 1 ) <S2SV_ModEnd> return - 1 <S2SV_ModStart> - 1 ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;
<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;
<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
<S2SV_ModStart> 1 ) ; if ( nelements == 0 ) { DPRINTF ( ( "CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n" ) ) ; goto out ; } <S2SV_ModStart> j < nelements && i < sh . sh_properties ; <S2SV_ModEnd> j ++ ,
<S2SV_ModStart> buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer -> <S2SV_ModStart> , buffer -> data , buffer -> <S2SV_ModStart> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data + <S2SV_ModStart> -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
<S2SV_ModStart> ; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
<S2SV_ModStart> ) ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( "Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; side_closed ( side ) ; break ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! flatpak_run_in_transient_unit (
<S2SV_ModStart> default_command ; } flatpak_bwrap_envp_to_args ( bwrap ) ; <S2SV_ModStart> |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ; <S2SV_ModStart> FALSE ) ; g_assert ( bwrap -> envp != NULL ) ; g_assert ( bwrap -> envp [ 0 ] == NULL ) ;
<S2SV_ModStart> ) ; else if ( strcmp ( arg , "@@" ) == 0 || strcmp ( arg , "@@u" ) == 0 ) g_print ( _ ( "Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n" ) , arg ) ; else
<S2SV_ModStart> "@@" ) ) { flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( "Invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s" <S2SV_ModEnd> ) , arg <S2SV_ModStart> arg ) ; goto out ; }
<S2SV_ModStart> data -> instance_id_fd ) ; if ( data -> env_fd != - 1 ) drop_cloexec ( data -> env_fd
<S2SV_ModStart> ; gboolean devel ; g_autoptr ( GString ) env_string = g_string_new ( "" ) <S2SV_ModStart> child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd <S2SV_ModStart> i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , "--env=" ) ) { const char * var_val = extra_args [ i ] + strlen ( "--env=" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( "Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( "Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { <S2SV_ModStart> [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , "environ" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( "--env-fd=%d" , child_setup_data . env_fd
<S2SV_ModStart> val ) ; if ( var [ 0 ] == '\\0' ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , "Environment<S2SV_blank>variable<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>empty<S2SV_blank>name" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( strchr ( var , '=' ) != NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , "Environment<S2SV_blank>variable<S2SV_blank>name<S2SV_blank>cannot<S2SV_blank>contain<S2SV_blank>\'=\'" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_string_append ( env_string , var ) ; g_string_append_c ( env_string , '=' ) ; g_string_append ( env_string , val ) ; g_string_append_c ( env_string , '\\0' <S2SV_ModEnd> ) ; }
<S2SV_ModStart> else if ( g_str_has_prefix <S2SV_ModEnd> ( arg , <S2SV_ModStart> , "@@" ) <S2SV_ModEnd> ) g_print (
<S2SV_ModStart> -> array_nl = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( array_nl ) , len
<S2SV_ModStart> -> indent = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( indent ) , len
<S2SV_ModStart> -> object_nl = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( object_nl ) , len
<S2SV_ModStart> -> space_before = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( space_before ) , len
<S2SV_ModStart> -> space = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( space ) , len
<S2SV_ModStart> len ) ; memcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , ptr <S2SV_ModEnd> , len )
<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf =
<S2SV_ModStart> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
<S2SV_ModStart> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
<S2SV_ModStart> * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
<S2SV_ModStart> ; if ( s < end && <S2SV_ModStart> ++ ; if ( s < end && <S2SV_ModStart> == 'X' ) ) <S2SV_ModStart> ; while ( s < end <S2SV_ModEnd> ) { char <S2SV_ModStart> { while ( s < end && <S2SV_ModStart> ; while ( s < end && <S2SV_ModStart> ; if ( s < end &&
<S2SV_ModStart> value ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> s ) { size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> = pool_alloc ( len ) ; memcpy <S2SV_ModEnd> ( r , <S2SV_ModStart> r , s , len
<S2SV_ModStart> 1 ) ; memcpy <S2SV_ModEnd> ( m , <S2SV_ModStart> m , name , nlen + 1
<S2SV_ModStart> wpathname ) ; if ( ! ret ) invalidate_lstat_cache ( ) ;
<S2SV_ModStart> ) return ; if ( strchr ( value , '\\n' ) ) die ( "credential<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>contains<S2SV_blank>newline" , key ) ;
<S2SV_ModStart> name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> ! proto_end ) { if ( ! quiet ) warning ( _ ( "url<S2SV_blank>has<S2SV_blank>no<S2SV_blank>scheme:<S2SV_blank>%s" ) , url ) ; return - 1 ; } <S2SV_ModEnd> cp = proto_end
<S2SV_ModStart> char * decoded ; const char * next ; int has_nl ; decoded <S2SV_ModStart> url ) ; <S2SV_ModEnd> has_nl = ! <S2SV_ModStart> if ( has_nl ) return - 1 ; if ( count_leading_dotdots ( url , & next ) > 0 && * next == ':'
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> data ) { <S2SV_ModEnd> add_preferred_base_object ( name <S2SV_ModStart> |= OBJECT_ADDED ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> ( obj , name <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> , obj , name <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> object ; size_t pathlen ; <S2SV_ModStart> |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> obj , path -> buf <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> cb_data ) ; strbuf_setlen ( path , pathlen ) ;
<S2SV_ModStart> |= SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( obj , <S2SV_ModEnd> name , data <S2SV_ModStart> , show_object , & base <S2SV_ModEnd> , path ,
<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *
<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> < 0 ) <S2SV_ModEnd> bitmap_pos = ext_index_add_object <S2SV_ModStart> name ) ; <S2SV_ModEnd> bitmap_set ( base
<S2SV_ModStart> * object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void *
<S2SV_ModStart> , NULL , <S2SV_ModEnd> data ) ;
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name ) { const <S2SV_ModEnd> char * p <S2SV_ModStart> out ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> >> 2 ; if ( q + o >= e ) goto out ;
<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> ( off_t ) pos , <S2SV_ModEnd> ( ( char
<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( "bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> sst_tab ) + pos <S2SV_ModEnd> , len )
<S2SV_ModStart> ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> ) p + ofs <S2SV_ModEnd> - 2 * <S2SV_ModStart> sizeof ( uint32_t ) <S2SV_ModStart> SIZE_T_FORMAT "u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n" , i , <S2SV_ModEnd> inp [ i <S2SV_ModStart> - p , offs <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) <S2SV_ModStart> ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> <S2SV_ModStart> , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst ->
<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h )
<S2SV_ModStart> ret ) ; } if ( error == NULL ) <S2SV_ModEnd> if ( verify <S2SV_ModStart> verify ) ; <S2SV_ModEnd> } table =
<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
<S2SV_ModStart> MOV_GPMF_TRAK_SUBTYPE ) ; if ( mp4 == 0 ) { printf ( "error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> index ) ; double <S2SV_ModEnd> in = 0.0 <S2SV_ModStart> ) ) { double in = 0.0 , out = 0.0 ; <S2SV_ModStart> fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n" <S2SV_ModEnd> , PRINTF_4CC ( <S2SV_ModStart> ) , rate , in , out
<S2SV_ModStart> , uint32_t flags , double * firstsampletime , double * lastsampletime <S2SV_ModStart> rate = 0.0 ; uint32_t * payload ; uint32_t payloadsize ; int32_t ret <S2SV_ModStart> return 0.0 ; payload = GetPayload ( handle , NULL , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; { uint64_t minimumtimestamp = 0 ; uint64_t starttimestamp = 0 ; uint64_t endtimestamp = 0 ; uint32_t startsamples = 0 ; uint32_t endsamples = 0 ; double intercept = 0.0 ; while ( teststart < <S2SV_ModEnd> mp4 -> indexcount <S2SV_ModStart> mp4 -> indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) <S2SV_ModEnd> ) { teststart <S2SV_ModStart> teststart ++ ; payload = GetPayload ( handle , payload , teststart ) ; payloadsize = GetPayloadSize ( handle , teststart ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } if ( ret == GPMF_OK && payload ) { uint32_t samples = GPMF_PayloadSampleCount ( ms ) ; GPMF_stream find_stream ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) startsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) - samples ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) starttimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & find_stream ) ) ; if ( starttimestamp ) { GPMF_stream any_stream ; GPMF_Init ( & any_stream , payload , payloadsize ) ; minimumtimestamp = starttimestamp ; while ( GPMF_OK == GPMF_FindNext ( & any_stream , GPMF_KEY_TIME_STAMP , GPMF_RECURSE_LEVELS ) ) { uint64_t timestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData ( & any_stream ) ) ; if ( timestamp < minimumtimestamp ) minimumtimestamp = timestamp ; } } testend = mp4 -> indexcount ; do { <S2SV_ModStart> testend -- ; <S2SV_ModEnd> payload = GetPayload <S2SV_ModStart> ( handle , payload , testend ) ; <S2SV_ModEnd> payloadsize = GetPayloadSize <S2SV_ModStart> ( handle , testend ) ; <S2SV_ModEnd> ret = GPMF_Init <S2SV_ModStart> payloadsize ) ; } while ( testend > 0 <S2SV_ModEnd> && GPMF_OK != <S2SV_ModStart> GPMF_RECURSE_LEVELS ) ) ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TOTAL_SAMPLES , GPMF_CURRENT_LEVEL ) ) endsamples = BYTESWAP32 ( * ( uint32_t * ) GPMF_RawData ( & find_stream ) ) ; else { uint32_t i ; for ( i = teststart ; i <= testend ; i ++ ) { <S2SV_ModEnd> payload = GetPayload <S2SV_ModStart> , payload , i <S2SV_ModEnd> ) ; payloadsize <S2SV_ModStart> ( handle , i ) ; if ( GPMF_OK == <S2SV_ModEnd> GPMF_Init ( ms <S2SV_ModStart> , payloadsize ) ) if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) endsamples += GPMF_PayloadSampleCount ( ms ) ; } } if ( starttimestamp != 0 <S2SV_ModEnd> ) { uint32_t <S2SV_ModStart> ) { uint32_t last_samples = GPMF_PayloadSampleCount ( ms ) ; uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples ; double time_stamp_scale = 1000000000.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_STAMP , GPMF_CURRENT_LEVEL ) ) endtimestamp = BYTESWAP64 ( * ( uint64_t * ) GPMF_RawData <S2SV_ModEnd> ( & find_stream <S2SV_ModStart> ( & find_stream ) ) ; if ( endtimestamp ) { double approxrate = 0.0 ; if ( endsamples > startsamples ) approxrate <S2SV_ModEnd> = ( double <S2SV_ModStart> indexcount ) ; if ( approxrate == 0.0 ) approxrate <S2SV_ModEnd> = ( double <S2SV_ModStart> indexcount ) ; while ( time_stamp_scale >= 1 ) { rate = ( double ) ( totaltimestamped_samples ) / ( ( double ) ( endtimestamp - starttimestamp ) / time_stamp_scale ) ; if ( rate * 0.9 < approxrate && approxrate < rate * 1.1 ) break ; time_stamp_scale *= 0.1 ; } if ( time_stamp_scale < 1.0 ) rate = 0.0 ; intercept = ( ( ( double ) minimumtimestamp - ( double ) starttimestamp ) / time_stamp_scale ) * rate ; } } if ( rate == 0.0 ) { if ( ! ( flags & GPMF_SAMPLE_RATE_PRECISE ) ) { if ( endsamples > startsamples ) rate = ( double ) ( endsamples - startsamples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) <S2SV_ModEnd> mp4 -> indexcount <S2SV_ModStart> mp4 -> indexcount ) ; if ( rate == 0.0 ) rate = ( double ) ( samples ) / ( mp4 -> metadatalength * ( ( double ) ( testend - teststart + 1 ) ) / ( double ) mp4 -> indexcount ) ; double in , out ; if ( GPMF_OK == GetPayloadTime ( handle , teststart , & in , & out ) ) intercept = ( double ) - in * rate ; } else { uint32_t payloadpos = 0 , payloadcount = 0 ; double slope , top = 0.0 , bot = 0.0 , meanX = 0 , meanY = 0 ; uint32_t * repeatarray = malloc ( mp4 -> indexcount <S2SV_ModStart> teststart ; payloadpos <= testend ; payloadpos ++ ) { payload = GetPayload ( handle , payload , payloadpos ) ; payloadsize = GetPayloadSize ( handle , payloadpos ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; if ( ret != GPMF_OK ) goto cleanup ; if ( GPMF_OK == GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) { GPMF_stream find_stream2 ; GPMF_CopyState ( ms , & find_stream2 ) ; payloadcount ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> == GPMF_FindNext ( & find_stream2 <S2SV_ModEnd> , fourcc , <S2SV_ModStart> , fourcc , <S2SV_ModEnd> GPMF_CURRENT_LEVEL ) ) <S2SV_ModStart> repeatarray ) { double <S2SV_ModEnd> in , out <S2SV_ModStart> ) samples ; if ( GPMF_OK == <S2SV_ModStart> & out ) ) <S2SV_ModEnd> meanX += out <S2SV_ModStart> uint32_t repeat = GPMF_PayloadSampleCount <S2SV_ModEnd> ( ms ) <S2SV_ModStart> repeatarray ) { double <S2SV_ModEnd> in , out <S2SV_ModStart> ) samples ; if ( GPMF_OK == <S2SV_ModStart> & out ) ) <S2SV_ModEnd> meanX += out <S2SV_ModStart> } } } else { <S2SV_ModEnd> repeatarray [ payloadpos <S2SV_ModStart> [ payloadpos ] = 0 ; } } if ( repeatarray ) { meanY /= ( double ) payloadcount ; meanX /= ( double ) payloadcount ; for ( payloadpos = teststart ; payloadpos <= testend ; payloadpos ++ ) { double in , out ; if ( repeatarray [ payloadpos ] && GPMF_OK == GetPayloadTime ( handle , payloadpos , & in , & out ) ) { top += ( ( double ) out - meanX ) * ( ( double ) repeatarray [ payloadpos ] <S2SV_ModStart> meanX ) ; } <S2SV_ModStart> / bot ; rate = slope ; intercept = meanY - slope * meanX ; <S2SV_ModStart> # if 0 printf ( "%c%c%c%c<S2SV_blank>start<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>(%.3fms)<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f\\n" <S2SV_ModEnd> , PRINTF_4CC ( <S2SV_ModStart> intercept / slope , rate ) ; printf ( "%c%c%c%c<S2SV_blank>first<S2SV_blank>sample<S2SV_blank>at<S2SV_blank>time<S2SV_blank>%.3fms\\n" , PRINTF_4CC ( fourcc ) , - 1000.0 * intercept / slope ) ; # endif <S2SV_ModEnd> } else { <S2SV_ModStart> repeatarray ) ; } } if ( firstsampletime && lastsampletime ) { uint32_t endpayload = mp4 -> indexcount ; do { endpayload -- ; payload = GetPayload ( handle , payload , endpayload ) ; payloadsize = GetPayloadSize ( handle , endpayload ) ; ret = GPMF_Init ( ms , payload , payloadsize ) ; } while ( endpayload > 0 && GPMF_OK != GPMF_FindNext ( ms , fourcc , GPMF_RECURSE_LEVELS ) ) ; if ( endpayload > 0 && ret == GPMF_OK ) { uint32_t totalsamples = endsamples - startsamples ; float timo = 0.0 ; GPMF_CopyState ( ms , & find_stream ) ; if ( GPMF_OK == GPMF_FindPrev ( & find_stream , GPMF_KEY_TIME_OFFSET , GPMF_CURRENT_LEVEL ) ) GPMF_FormattedData ( & find_stream , & timo , 4 , 0 , 1 ) ; double first , last ; first = - intercept / rate - timo ; last = first + ( double ) totalsamples / rate ; if ( firstsampletime ) * firstsampletime = first ; if ( lastsampletime ) * lastsampletime = last ; } <S2SV_ModEnd> } } } <S2SV_ModStart> ( payload ) <S2SV_ModEnd> FreePayload ( payload <S2SV_ModStart> = NULL ; <S2SV_ModEnd> return rate ;
<S2SV_ModStart> uint32_t index , double <S2SV_ModEnd> * in , <S2SV_ModStart> * in , double <S2SV_ModEnd> * out ) <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; if ( <S2SV_ModStart> NULL ) return GPMF_ERROR_MEMORY <S2SV_ModEnd> ; * in <S2SV_ModStart> * in = <S2SV_ModEnd> ( ( double <S2SV_ModStart> * out = <S2SV_ModEnd> ( ( double <S2SV_ModStart> ) ; return GPMF_OK <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> MP4buffer ) { if ( mp4 -> filesize > mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ) { <S2SV_ModStart> mediafp ) ; mp4 -> filepos = mp4 -> metaoffsets [ index ] + mp4 -> metasizes [ index ] ; <S2SV_ModStart> return MP4buffer ; }
<S2SV_ModStart> qttag , qtsize32 ; size_t <S2SV_ModEnd> len ; int32_t <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , lastsize - <S2SV_ModStart> 8 - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE
<S2SV_ModStart> mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }
<S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; while ( <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ; } } ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; while ( <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; while ( <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; while ( <S2SV_ModStart> tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) <S2SV_ModStart> ) ; } ISOM_DECREASE_SIZE ( ptr , 1 )
<S2SV_ModStart> u8 * output ; if ( ! ctx -> opid ) return GF_NON_COMPLIANT_BITSTREAM
<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1
<S2SV_ModStart> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> ; } else break ; } else <S2SV_ModStart> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j
<S2SV_ModStart> break ; } if ( ctx -> hdr . frame_size < ctx -> hdr . hdr_size ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_PARSER , ( "[ADTSDmx]<S2SV_blank>Corrupted<S2SV_blank>ADTS<S2SV_blank>frame<S2SV_blank>header,<S2SV_blank>resyncing\\n" ) ) ; ctx -> nb_frames = 0 ; goto drop_byte ; }
<S2SV_ModStart> return GF_ISOM_INVALID_FILE ; if ( stco -> nb_entries < sampleNumber ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> co64 -> offsets ) return GF_ISOM_INVALID_FILE ; if ( co64 -> nb_entries < sampleNumber
<S2SV_ModStart> = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> "." ) ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> } else { if ( strlen ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> = 0 ; } <S2SV_ModStart> ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> , '%' ) <S2SV_ModStart> sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n" , sep ) ) ; return GF_NOT_SUPPORTED ; }
<S2SV_ModStart> ) ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf (
<S2SV_ModStart> * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> url_arg ) ; } <S2SV_ModStart> ! e ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> ( sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> gf_dm_sess_del ( sess <S2SV_ModStart> str ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; gf_term_connect (
<S2SV_ModStart> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> = 0 ; if ( strlen ( <S2SV_ModEnd> sep2 + 1 <S2SV_ModStart> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )
<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )
<S2SV_ModStart> ; if ( seig_entry &&
<S2SV_ModStart> sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> ; if ( ( vps_id < 0 ) || ( <S2SV_ModStart> vps_id >= 16 )
<S2SV_ModStart> writers , 0 ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stco ) ; gf_list_del_item ( writer -> stbl -> child_boxes , writer -> stsc
<S2SV_ModStart> GF_ISOM_BOX_TYPE_ESDS ) { extern Bool use_dump_mode ; <S2SV_ModStart> esd ) { if ( ! use_dump_mode )
<S2SV_ModStart> char * tmp_str ; Bool zfound = GF_FALSE <S2SV_ModStart> i ] ) { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> i ++ ; <S2SV_ModStart> ++ ; } if ( ! zfound ) return GF_ISOM_INVALID_FILE ; <S2SV_ModStart> j = 0 ; zfound = GF_FALSE <S2SV_ModStart> j ] ) { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> j ++ ; <S2SV_ModStart> } if ( ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> j = 0 ; zfound = GF_FALSE <S2SV_ModStart> j ] ) { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> j ++ ; <S2SV_ModStart> } if ( ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> -> size ; zfound = GF_FALSE ; <S2SV_ModStart> i ] ) { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> i ++ ; <S2SV_ModStart> } if ( ! zfound ) return GF_ISOM_INVALID_FILE ; if ( <S2SV_ModStart> -> size ; zfound = GF_FALSE ; <S2SV_ModStart> i ] ) { zfound = GF_TRUE ; break ; } <S2SV_ModEnd> i ++ ; <S2SV_ModStart> ++ ; } if ( ! zfound ) return GF_ISOM_INVALID_FILE ;
<S2SV_ModStart> if ( esd && esd -> decoderConfig
<S2SV_ModStart> ] ) ; if ( ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>constant<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n" , ( u32 ) iv_size ) ) ; ptr -> key_info [ 20 ] = 16 ; return GF_NON_COMPLIANT_BITSTREAM ; } <S2SV_ModStart> ) ; } else if ( ( iv_size != 0 ) && ( iv_size != 8 ) && ( iv_size != 16 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "[iso<S2SV_blank>file]<S2SV_blank>Invalid<S2SV_blank>IV<S2SV_blank>size<S2SV_blank>%d,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>0,<S2SV_blank>8<S2SV_blank>or<S2SV_blank>16\\n" , ( u32 ) iv_size ) ) ; return GF_NON_COMPLIANT_BITSTREAM ; }
<S2SV_ModStart> ptr -> size <S2SV_ModEnd> ; tmp_str =
<S2SV_ModStart> ( stderr , "File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD\\n" <S2SV_ModEnd> , inName )
<S2SV_ModStart> GF_PROP_PID_AUDIO_FORMAT ) ; if ( p )
<S2SV_ModStart> u8 * data = NULL <S2SV_ModStart> ; u32 pck_size = 0 <S2SV_ModStart> ; } } else { <S2SV_ModStart> pck_size ) ; }

<S2SV_ModStart> av1 -> av1_config && av1 -> av1_config -> config
<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
<S2SV_ModStart> size ) ; if ( sdp && size )
<S2SV_ModStart> dref ) { GF_Box * dref ; <S2SV_ModStart> ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; FLACHeader hdr ; if ( ctx -> in_error ) return GF_NON_COMPLIANT_BITSTREAM <S2SV_ModStart> ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( "[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>magic\\n" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM ; <S2SV_ModStart> last ) break ; } if ( ! dsi_end ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_PARSER , ( "[FLACDmx]<S2SV_blank>invalid<S2SV_blank>FLAC<S2SV_blank>header\\n" ) ) ; ctx -> in_error = GF_TRUE ; ctx -> flac_buffer_size = 0 ; if ( pck ) gf_filter_pid_drop_packet ( ctx -> ipid ) ; return GF_NON_COMPLIANT_BITSTREAM
<S2SV_ModStart> ++ ) { GF_SampleTableBox * stbl ; <S2SV_ModStart> 1 ) ; stbl = ( trak -> Media && trak -> Media -> information ) ? trak -> Media -> information -> sampleTable : NULL ; if ( ! stbl || ! stbl -> SampleSize || ! stbl -> ChunkOffset || ! stbl -> SampleToChunk ) { return GF_ISOM_INVALID_FILE ; }
<S2SV_ModStart> ) ) { if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> ; } } saio = NULL ; } <S2SV_ModStart> break ; } saiz = NULL ;
<S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; #
<S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; #
<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static inline <S2SV_ModStart> = 0 ; len - i >= 8 * 32 <S2SV_ModEnd> ; i += <S2SV_ModStart> ] ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
<S2SV_ModStart> { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
<S2SV_ModStart> shutdown ) { pthread_mutex_unlock ( & t -> cond_mutex ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( h2o_http2_conn_t <S2SV_ModStart> conn ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> parse_input ( h2o_http2_conn_t <S2SV_ModStart> ) ; } return <S2SV_ModStart> ( conn ) <S2SV_ModEnd> ; } h2o_buffer_consume <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> sock ) ; return 0 ;
<S2SV_ModStart> -> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> , cp , tgt_realm ,
<S2SV_ModStart> , krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> principal ) , tgt_realm <S2SV_ModEnd> ) ; if
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_row_idx <S2SV_ModStart> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx <S2SV_ModStart> return ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> ; if ( reader -> recursive_counter >= 10 ) return MYSOFA_INVALID_FORMAT ; else reader -> recursive_counter ++ ; if ( <S2SV_ModStart> ( "%08" PRIX64 "<S2SV_blank>%.4s<S2SV_blank>stack<S2SV_blank>%d\\n" <S2SV_ModEnd> , ( uint64_t <S2SV_ModStart> 4 , buf , reader -> recursive_counter <S2SV_ModStart> 0 ) ; reader -> recursive_counter -- ;
<S2SV_ModStart> = NULL ; reader . recursive_counter = 0 ;
<S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = x <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) {
<S2SV_ModStart> diffBlock + diffBlockLength ) { PyMem_Free ( newData ) ; PyErr_SetString ( PyExc_ValueError , "corrupt<S2SV_blank>patch<S2SV_blank>(overflow)" ) ; return NULL ; } memcpy ( newData + newpos , diffPtr , x ) ; diffPtr += x ; for ( j = 0 ; j < x ; j ++ ) if ( ( oldpos + j >= 0 ) && ( oldpos + j < origDataLength ) ) newData [ newpos + j ] += origData [ oldpos + j ] ; newpos += x ; oldpos += x ; if ( newpos + y > newDataLength <S2SV_ModStart> NULL ; } <S2SV_ModEnd> memcpy ( newData
<S2SV_ModStart> == '\\t' ) || ( index >= PAM_MAX_RESP_SIZE ) ) { break ; } <S2SV_ModEnd> else { username <S2SV_ModStart> } if ( index >= PAM_MAX_RESP_SIZE || <S2SV_ModStart> * ret_username = strdup ( username <S2SV_ModEnd> ) ) == <S2SV_ModStart> PAM_BUF_ERR ) ; <S2SV_ModEnd> return ( PAM_SUCCESS
<S2SV_ModStart> sr ) { <S2SV_ModEnd> uint16_t StructSize ; <S2SV_ModStart> ) ; } smb_ofile_flush ( sr , <S2SV_ModEnd> sr -> fid_ofile <S2SV_ModStart> sr -> fid_ofile <S2SV_ModEnd> ) ; (
<S2SV_ModStart> ) ; } smb_ofile_flush <S2SV_ModEnd> ( sr , <S2SV_ModStart> f_mutex ) ; smb_ofile_flush <S2SV_ModEnd> ( sr ,
<S2SV_ModStart> , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit (
<S2SV_ModStart> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> DefragMfIpv6Test ) ; UtRegisterTest ( "DefragTestBadProto" , DefragTestBadProto ) ;
<S2SV_ModStart> ch , seq , size << 3
<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> INTERNAL_NODE ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
<S2SV_ModStart> int * offset , int maxoffset <S2SV_ModStart> NULL , fout , maxoffset
<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> NYT , fout , maxoffset <S2SV_ModStart> NULL , fout , maxoffset
<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> node , fout , maxoffset <S2SV_ModStart> child ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }
<S2SV_ModStart> , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> oob ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> & 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> msg -> bit , msg -> cursize << 3 <S2SV_ModStart> ) ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }
<S2SV_ModStart> ( msg -> overflowed ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> { if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> & 7 ; if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> msg -> bit , msg -> maxsize << 3 <S2SV_ModStart> 8 ) ; if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; }
<S2SV_ModStart> off = offset ; uint32_t tmp ; uint32_t finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> ; struct ipmi_rs <S2SV_ModStart> size ) { memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> offset ) ; length = finish - offset ; <S2SV_ModStart> ; } } size_left_in_buffer = length ; <S2SV_ModStart> 0 ] ; if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( "<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size" ) ; return - 1 ; } <S2SV_ModStart> += tmp ; size_left_in_buffer -= tmp ;
<S2SV_ModStart> off = offset ; uint32_t tmp , finish ; uint32_t size_left_in_buffer <S2SV_ModEnd> ; struct ipmi_rs <S2SV_ModStart> size ) { memset ( frubuf + fru -> size , 0 , length - fru -> size ) ; <S2SV_ModStart> - offset ) ; length = finish - offset <S2SV_ModStart> = 16 ; size_left_in_buffer = length ; <S2SV_ModStart> 0 ] ; if ( rsp -> data_len < 1 || tmp > rsp -> data_len - 1 || tmp > size_left_in_buffer ) { printf ( "<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>buffer<S2SV_blank>size" ) ; return - 1 ; } <S2SV_ModStart> += tmp ; size_left_in_buffer -= tmp ;
<S2SV_ModStart> { jas_eprintf ( "error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( "error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(IHDR)\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> , jas_image_numcmpts ( dec -> image ) ) ) { jas_eprintf ( "error:<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> { jas_eprintf ( "error:<S2SV_blank>component<S2SV_blank>data<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>(BPCC)\\n" ) ; goto error <S2SV_ModEnd> ; } }
<S2SV_ModStart> VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load <S2SV_ModStart> out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load
<S2SV_ModStart> NULL ) { flush_cmd ( ) ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( scanned
<S2SV_ModStart> PureFileInfo * r ; char * alloca_subdir ; size_t sizeof_subdir <S2SV_ModStart> = dir ; sizeof_subdir = PATH_MAX + 1U ; if ( ( alloca_subdir = ALLOCA ( sizeof_subdir ) ) == NULL ) { goto toomany ; } <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( SNCHECK <S2SV_ModStart> ; nolist : <S2SV_ModEnd> if ( matches <S2SV_ModStart> } toomany : ALLOCA_FREE ( alloca_subdir ) ;
<S2SV_ModStart> s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; <S2SV_ModStart> , s2 , len + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else
<S2SV_ModStart> uint32_t * ifindex , int * hoplimit <S2SV_ModStart> char cbuf [ 2 * <S2SV_ModStart> cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> cmsghdr -> cmsg_type <S2SV_ModStart> cmsghdr -> cmsg_type ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> cmsghdr -> cmsg_len <S2SV_ModStart> ipi6_ifindex ; } break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; }
<S2SV_ModStart> ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."
<S2SV_ModStart> msg -> ifindex , & msg -> hoplimit <S2SV_ModStart> ( ndp , "rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d" <S2SV_ModEnd> , str_in6_addr ( <S2SV_ModStart> msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , "ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> if ( len
<S2SV_ModStart> = json_tokener_success ; if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; }
<S2SV_ModStart> k ) { static volatile int random_seed = - 1 ; if ( random_seed == - 1 ) { int seed ; while ( ( seed = json_c_get_random_seed ( ) ) == - 1 ) ; # if defined __GNUC__ __sync_val_compare_and_swap ( & random_seed , - 1 , seed ) ; # elif defined _MSC_VER InterlockedCompareExchange ( & random_seed , seed , - 1 ) ; # else # warning "racy<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>initializtion<S2SV_blank>if<S2SV_blank>used<S2SV_blank>by<S2SV_blank>multiple<S2SV_blank>threads" random_seed = seed ; # endif } return hashlittle ( <S2SV_ModEnd> ( const char <S2SV_ModStart> * ) k , strlen ( ( const char * ) k ) , random_seed ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 1 ) { if ( ! d -> iccprofile_file ) { de_warn ( c , "Bad<S2SV_blank>ICC<S2SV_blank>profile<S2SV_blank>segment" ) ; return ; }
<S2SV_ModStart> cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> "Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type" ) ; goto done ; <S2SV_ModStart> , "Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images" ) ; goto done
<S2SV_ModStart> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>image<S2SV_blank>dimensions" ) ; goto done ; }
<S2SV_ModStart> svbranch . len + 1
<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n" ) ; return - 1 ; }
<S2SV_ModStart> \'"\' ) { char * p = end = <S2SV_ModEnd> * value + <S2SV_ModStart> value + 1 ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == \'"\' ) break ; } p ++ ; end ++ ; } if ( * end != \'"\' <S2SV_ModEnd> ) { DBG <S2SV_ModStart> '\\0' ; end = ++ p <S2SV_ModEnd> ; } else
<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
<S2SV_ModStart> , valsz , "<S2SV_blank>\\\\\\"\'$`<>" <S2SV_ModEnd> ) ; fputs <S2SV_ModStart> , valsz , "\\"\\\\" ) ; fputs ( "\\"" <S2SV_ModEnd> , stdout )
<S2SV_ModStart> * tmpname , const <S2SV_ModStart> char * dir , const char * prefix <S2SV_ModStart> * localtmp ; const <S2SV_ModStart> , rc ; <S2SV_ModEnd> tmpenv = dir <S2SV_ModStart> tmpenv = dir ? dir : <S2SV_ModEnd> getenv ( "TMPDIR" <S2SV_ModStart> ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> rc = asprintf <S2SV_ModStart> , tmpenv , prefix <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ctl -> pw , ".chfn"
<S2SV_ModStart> setpwnam ( pw , ".chsh"
<S2SV_ModStart> passwd * pwd , const char * prefix <S2SV_ModStart> = NULL ; <S2SV_ModEnd> pw_init ( ) <S2SV_ModStart> & tmpname , "/etc" , prefix <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> & tmpname , "/etc" , ".vipw" <S2SV_ModEnd> ) ) ==
<S2SV_ModStart> status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode" ) ; layoutHome ( ) ; return ; }
<S2SV_ModStart> ) ; } recovery_started = false ;
<S2SV_ModStart> ( ! awaiting_character || ! recovery_started
<S2SV_ModStart> void ) { recovery_started = false ;
<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode" ) ; layoutHome ( ) ; return ; } <S2SV_ModStart> } new_mnemonic [ MAX ( 0u , strnlen ( new_mnemonic , sizeof ( new_mnemonic ) <S2SV_ModEnd> ) - 1 <S2SV_ModStart> ) - 1 )
<S2SV_ModStart> = true ; recovery_started = true ;
<S2SV_ModStart> void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "Not<S2SV_blank>in<S2SV_blank>Recovery<S2SV_blank>mode" ) ; layoutHome ( ) ; return ; }
<S2SV_ModStart> msg_tiny_flag ) { msg_read_tiny ( msg , len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> len > 0 && len < 256 <S2SV_ModStart> ) ; return <S2SV_ModEnd> ( uint8_t ) <S2SV_ModStart> uint8_t ) len <S2SV_ModEnd> ; } return
<S2SV_ModStart> constr1 ) ; <S2SV_ModEnd> confirm ( ButtonRequestType_ButtonRequest_ConfirmOutput
<S2SV_ModStart> goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else
<S2SV_ModStart> code == gcode && wordlist [ key ] . index >= 0
<S2SV_ModStart> ; } } if ( * state != CCS_START )
<S2SV_ModStart> len , group <S2SV_ModEnd> ; Node * <S2SV_ModStart> * * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ) goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;
<S2SV_ModStart> OP_EXACT1 ) ; <S2SV_ModEnd> DATA_ENSURE ( 1 <S2SV_ModStart> ++ ; s <S2SV_ModEnd> ++ ; MOP_OUT
<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
<S2SV_ModStart> CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> ONIG_INFINITE_DISTANCE ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> low ) ; }
<S2SV_ModStart> , then_len , else_len , <S2SV_ModStart> then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r <S2SV_ModStart> ) ) { <S2SV_ModEnd> else_len = compile_length_tree <S2SV_ModStart> , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> . addr = SIZE_OP_ATOMIC_END + <S2SV_ModStart> ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r =
<S2SV_ModStart> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> tlen = compile_length_tree
<S2SV_ModStart> { if ( t >= tend ) return 0 ; if (
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> s } ; uECC_word_t * initial_Z = 0 ; <S2SV_ModStart> curve ) ; if ( g_rng_function ) { if ( ! uECC_generate_random_int ( k2 [ carry ] , curve -> p , num_words ) ) { return 0 ; } initial_Z = k2 [ carry ] ; } <S2SV_ModStart> carry ] , initial_Z <S2SV_ModEnd> , num_n_bits +
<S2SV_ModStart> val ) { int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> ; int i <S2SV_ModStart> ; ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; }
<S2SV_ModStart> fnp ; char * aacFileName = NULL ; char * audioFileName = NULL ; char * adtsFileName = NULL <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> = 1 ; audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , "Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n" ) ; return 1 ; } <S2SV_ModStart> = 1 ; adtsFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( adtsFileName == NULL ) { faad_fprintf ( stderr , "Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>adtsFileName.\\n" ) ; return 1 ; } <S2SV_ModStart> } # endif aacFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( argv [ optind ] ) + 1 ) ) ; if ( aacFileName == NULL ) { faad_fprintf ( stderr , "Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>aacFileName.\\n" ) ; return 1 ; } <S2SV_ModStart> outfile_set ) { audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aacFileName ) + strlen ( file_ext [ format ] ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , "Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n" ) ; return 1 ; } <S2SV_ModStart> ) ; } if ( audioFileName != NULL ) free ( audioFileName ) ; if ( adtsFileName != NULL ) free ( adtsFileName ) ; <S2SV_ModStart> ) ; } if ( aacFileName != NULL ) free ( aacFileName ) ;
<S2SV_ModStart> & 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
<S2SV_ModStart> 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
<S2SV_ModStart> = 0 ; last_name = 0 ;
<S2SV_ModStart> ( isspace ( ( unsigned char )
<S2SV_ModStart> , * q <S2SV_ModEnd> ; Clp_Parser * <S2SV_ModStart> ; printf ( "Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> 0 ) { set_lenIV ( line <S2SV_ModEnd> ) ; } <S2SV_ModStart> "string<S2SV_blank>currentfile" ) ) ) { set_cs_start ( line ) <S2SV_ModEnd> ; } } <S2SV_ModStart> && isdigit ( ( unsigned char ) <S2SV_ModStart> && isdigit ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char )
<S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> && isspace ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char ) <S2SV_ModStart> && isxdigit ( ( unsigned char )
<S2SV_ModStart> ( isspace ( ( unsigned char )
<S2SV_ModStart> ; printf ( "Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )
<S2SV_ModStart> ; isspace ( ( unsigned char ) <S2SV_ModStart> ! isspace ( ( unsigned char )
<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
<S2SV_ModStart> ( EBADF , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>for<S2SV_blank>graphics<S2SV_blank>transmission<S2SV_blank>with<S2SV_blank>error:<S2SV_blank>[%d]<S2SV_blank>%s" <S2SV_ModEnd> , errno ,
<S2SV_ModStart> ) { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG )
<S2SV_ModStart> ( LOG_DEBUG , "server[%lu]<S2SV_blank>{<S2SV_blank>addr=%s,<S2SV_blank>key=\'********\'<S2SV_blank>}" <S2SV_ModEnd> , n , <S2SV_ModStart> -> ai_addr ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> krb5_key_data * key_data = NULL ; if ( n_key_data < <S2SV_ModEnd> 0 ) return <S2SV_ModStart> ; if ( key_data <S2SV_ModEnd> == NULL ) <S2SV_ModStart> = 0 ; ret [ i ] != NULL <S2SV_ModEnd> ; i ++ <S2SV_ModStart> i ++ ) <S2SV_ModEnd> free ( ret
<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : "" ;
<S2SV_ModStart> if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
<S2SV_ModStart> krb5_data null_server ; krb5_data d ; <S2SV_ModStart> retval ) ; d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq ( inbuf , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> if ( appl_version != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq ( inbuf , d ) <S2SV_ModEnd> ) { problem
<S2SV_ModStart> if ( REMAIN == 0 || REMAIN
<S2SV_ModStart> , & rlen , 0
<S2SV_ModStart> , & len , 0
<S2SV_ModStart> , & len , 0
<S2SV_ModStart> size_t * rlen_out , int recursion <S2SV_ModStart> return ASN1_MISMATCH_INDEF ; if ( recursion >= 32 ) return ASN1_OVERFLOW ; <S2SV_ModStart> , & len , recursion + 1
<S2SV_ModStart> , & rlen , 0
<S2SV_ModStart> , & rlen , 0
<S2SV_ModStart> gr_token ) ; <S2SV_ModEnd> ret_freegc ( AUTH_FAILED <S2SV_ModStart> gd -> checksum <S2SV_ModEnd> ) ; if
<S2SV_ModStart> errout ; } <S2SV_ModEnd> gr -> gr_ctx <S2SV_ModStart> . value = "xxxx" ; <S2SV_ModEnd> gr -> gr_ctx <S2SV_ModStart> -> gr_ctx . length = 4 <S2SV_ModEnd> ; gr ->
<S2SV_ModStart> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
<S2SV_ModStart> princ ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> params <S2SV_ModStart> params . realm ) && data_eq_string ( * c1 , "kadmin" ) && ! data_eq_string ( * c2 , "history" ) ; <S2SV_ModEnd> fail_princ : if
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> errmsg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; kadm5_server_handle_t handle <S2SV_ModStart> errmsg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> return ( &
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> char * prime_arg1 = NULL , * prime_arg2 = NULL <S2SV_ModEnd> ; gss_buffer_desc client_name <S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : free ( prime_arg1 ) ; free ( prime_arg2 ) ; gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
<S2SV_ModStart> ( kdc_active_realm , client . princ <S2SV_ModEnd> , request ->
<S2SV_ModStart> objp ) ; * objp = NULL ;
<S2SV_ModStart> tl2 ; } * tl_data_head = NULL ;
<S2SV_ModStart> out_buf ) ; <S2SV_ModEnd> XDR_DESTROY ( &
<S2SV_ModStart> ret , last_pwd , n_new_keys <S2SV_ModStart> keyblocks ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> -> context , n_new_keys <S2SV_ModEnd> , kdb ->
<S2SV_ModStart> = create_spnego_ctx ( 0
<S2SV_ModStart> = create_spnego_ctx ( 0
<S2SV_ModStart> = create_spnego_ctx ( 1
<S2SV_ModStart> ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> KADM5_POLICY ) && entry -> policy == NULL <S2SV_ModEnd> ) return KADM5_BAD_MASK <S2SV_ModStart> ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart> ) return KADM5_BAD_MASK <S2SV_ModEnd> ; ret =
<S2SV_ModStart> ; if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> KADM5_POLICY ) && entry -> policy == NULL <S2SV_ModEnd> ) return KADM5_BAD_MASK <S2SV_ModStart> ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK <S2SV_ModEnd> ; if (
<S2SV_ModStart> ; if ( password == NULL ||
<S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } vno <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req <S2SV_ModStart> ) ; goto bailout <S2SV_ModEnd> ; } ap_req
<S2SV_ModStart> if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> goto cleanup ; <S2SV_ModStart> cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ;
<S2SV_ModStart> ; } } if ( ! <S2SV_ModEnd> xdr_opaque ( xdrs <S2SV_ModStart> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE
<S2SV_ModStart> iakerb_ctx_id_t * pctx , int initiate <S2SV_ModStart> = 0 ; ctx -> initiate = initiate ; ctx -> established = 0 ;
<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
<S2SV_ModStart> NULL ; char <S2SV_ModEnd> * strval [ <S2SV_ModStart> FALSE ; krb5_boolean <S2SV_ModEnd> establish_links = FALSE <S2SV_ModStart> TRUE ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> ntrees ) ; <S2SV_ModStart> ( st ) <S2SV_ModEnd> goto cleanup ;
<S2SV_ModStart> = KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
<S2SV_ModStart> * config ; <S2SV_ModEnd> armor_key = cb <S2SV_ModStart> respond = respond ; rs -> enc_tkt_reply = enc_tkt_reply
<S2SV_ModStart> ( arg , EINVAL <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( arg , EINVAL <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !
<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (
<S2SV_ModStart> , j ; * md_out = NULL ; md = calloc ( 1 , sizeof ( <S2SV_ModEnd> * md ) <S2SV_ModStart> goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> subject_dn <S2SV_ModStart> md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name ( <S2SV_ModStart> cert ) , & <S2SV_ModEnd> md -> issuer_dn <S2SV_ModStart> md -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret = crypto_retrieve_X509_sans
<S2SV_ModStart> errcode != 0 && state -> status == NULL ) state -> status = "UNKNOWN_REASON" <S2SV_ModEnd> ; au_state ->
<S2SV_ModStart> ; cleanup : if ( status == NULL ) status = "UNKNOWN_REASON" <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_FOR_USER" ; return code ; } <S2SV_ModEnd> code = verify_for_user_checksum
<S2SV_ModStart> ) ) { * status = "INVALID_S4U2PROXY_OPTIONS" ; <S2SV_ModStart> ) ) { * status = "EVIDENCE_TICKET_MISMATCH" ;
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_S4U_X509_USER" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
<S2SV_ModStart> ) ) { int len <S2SV_ModEnd> ; char * <S2SV_ModStart> if ( ! ( hdr -> filename = fn ) ) <S2SV_ModEnd> return MSPACK_ERR_NOMEMORY ; <S2SV_ModStart> return MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( hdr <S2SV_ModStart> { if ( ( len = <S2SV_ModStart> , 9 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> ; if ( ( len = <S2SV_ModStart> , 4 ) ) < 2 <S2SV_ModEnd> ) return MSPACK_ERR_READ <S2SV_ModStart> ; i < len <S2SV_ModEnd> ; i ++ <S2SV_ModStart> ; i ++ ) if ( ! ( * fn ++ <S2SV_ModEnd> = buf [ <S2SV_ModStart> ) break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + 1 <S2SV_ModStart> i + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) return <S2SV_ModStart> ) return MSPACK_ERR_SEEK ; fn --
<S2SV_ModStart> = 1 ; if ( bits_left == 0 ) <S2SV_ModStart> ( 16 ) <S2SV_ModEnd> ; bits_left =
<S2SV_ModStart> { if ( name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> 0 ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . control <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . spaninfo <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . <S2SV_ModEnd> rtable = fi <S2SV_ModStart> = fi ; <S2SV_ModEnd> } fi ->
<S2SV_ModStart> chm -> index_root >= <S2SV_ModEnd> chm -> num_chunks <S2SV_ModStart> goto chunk_end ; if ( name_len == 0 ) goto chunk_end ;
<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * create_output_name <S2SV_ModStart> * create_output_name ( <S2SV_ModEnd> char * fname <S2SV_ModStart> char * fname ) { char * out , * p <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; if ( ( out = malloc ( strlen ( fname ) + 1 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> while ( * <S2SV_ModStart> * fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname ++ <S2SV_ModStart> fname ++ ; strcpy ( out , ( * fname ) ? fname : "x" ) ; for ( p = out ; * p ; p ++ ) <S2SV_ModEnd> { if ( <S2SV_ModStart> { if ( p [ 0 ] == '.' && p [ 1 ] == '.' && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } } return out <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> = create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
<S2SV_ModStart> goto chunk_end ; <S2SV_ModEnd> name = p <S2SV_ModStart> ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
<S2SV_ModStart> ; if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } if (
<S2SV_ModStart> ) _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> , "archive_write_data" ) ; if ( s > max_write ) s = max_write
<S2SV_ModStart> 0 ; size_t <S2SV_ModEnd> mbs_length = len <S2SV_ModStart> -> length + len <S2SV_ModEnd> + 1 ) <S2SV_ModStart> 0 ) { # if HAVE_MBRTOWC r = mbrtowc ( wcs , mbs , mbs_length , & shift_state ) ; # else r = mbtowc ( wcs , mbs , mbs_length ) ; # endif if ( r == ( size_t ) - 1 || r == ( size_t ) - 2 ) { ret_val = - 1 ; break ; } if ( r == 0 || r > mbs_length ) break ; wcs ++ ; mbs += r ; mbs_length -= r ; } <S2SV_ModEnd> dest -> length <S2SV_ModStart> = L'\\0' ; <S2SV_ModEnd> return ( ret_val
<S2SV_ModStart> = LOGICAL_BLOCK_SIZE * ( int64_t ) <S2SV_ModStart> = LOGICAL_BLOCK_SIZE * ( int64_t )
<S2SV_ModStart> -> length + max ( <S2SV_ModStart> len * 2 , ( size_t ) MB_CUR_MAX )
<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Path<S2SV_blank>is<S2SV_blank>absolute" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
<S2SV_ModStart> ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; assert ( 0 == unlink ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( "Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here." ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ;
<S2SV_ModStart> bid , best_bid , n <S2SV_ModStart> ; for ( n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> ) { number_bidders <S2SV_ModStart> ; } } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding" ) ; return ( ARCHIVE_FATAL ) ;
<S2SV_ModStart> case kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> break ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> numFiles * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> * p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
<S2SV_ModStart> ; if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Too<S2SV_blank>many<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> p ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> != ARCHIVE_WARN ) { <S2SV_ModStart> ppmd7_context ) ; rar -> start_new_table = 1 ; }
<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
<S2SV_ModStart> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;
<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = check_symlinks_fsobj <S2SV_ModEnd> ( a -> <S2SV_ModStart> name , & error_number , & error_string , a -> flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , "%s" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string ) ; <S2SV_ModStart> = NULL ; return rc ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> a ) { struct archive_string error_string ; int error_number ; int rc ; archive_string_init ( & error_string ) ; rc = cleanup_pathname_fsobj ( <S2SV_ModEnd> a -> name <S2SV_ModStart> a -> name , & error_number , & error_string , a -> flags ) <S2SV_ModStart> ; if ( rc != ARCHIVE_OK <S2SV_ModEnd> ) { archive_set_error <S2SV_ModStart> -> archive , error_number , "%s" , error_string . s <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } archive_string_free ( & error_string <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int r ; char * linkname_copy ; struct archive_string error_string ; int error_number ; <S2SV_ModStart> ; # else archive_string_init ( & error_string ) ; linkname_copy = strdup ( linkname ) ; if ( linkname_copy == NULL ) { return ( EPERM ) ; } r = cleanup_pathname_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , "%s" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } r = check_symlinks_fsobj ( linkname_copy , & error_number , & error_string , a -> flags ) ; if ( r != ARCHIVE_OK ) { archive_set_error ( & a -> archive , error_number , "%s" , error_string . s ) ; free ( linkname_copy ) ; return ( EPERM ) ; } free ( linkname_copy ) ;
<S2SV_ModStart> outbuff ) - 128 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
<S2SV_ModStart> . start ; if ( args [ cnt ] . end < end ) { <S2SV_ModStart> k ) ; } else { assert ( q == end ) ; pwr = k ; q = p ; }
<S2SV_ModStart> ) ) { if ( w -> linebreak || w == text_info -> glyphs ) text_info -> n_lines -- ; if ( w != text_info -> glyphs )
<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , "Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n" ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> ; if ( temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue ; <S2SV_ModStart> if ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> else if ( temp_buffer >= 0x120 &&
<S2SV_ModStart> ; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret
<S2SV_ModStart> '[' ) { size_t <S2SV_ModEnd> len ; if <S2SV_ModStart> } len = <S2SV_ModEnd> ( cp - <S2SV_ModStart> ( len > <S2SV_ModEnd> sizeof ( buf
<S2SV_ModStart> u8 label_len ; <S2SV_ModEnd> GET8 ( label_len <S2SV_ModStart> - 1 ; if ( j + label_len > length ) return - 1 ;
<S2SV_ModStart> base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = base_name <S2SV_ModStart> : 1 ; <S2SV_ModEnd> for ( dom
<S2SV_ModStart> ) ) return "" <S2SV_ModEnd> ; for (
<S2SV_ModStart> size_t len ; if ( ! strlen ( text ) ) return "empty<S2SV_blank>string" ;
<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Short<S2SV_blank>MakerNote" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteCanon" , "Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..." , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifMnoteCanon" , "Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteCanon" , "Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)" , ( unsigned ) <S2SV_ModEnd> ( dataofs + <S2SV_ModStart> dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , "ExifMnoteCanon" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteDataFuji" , "Short<S2SV_blank>MakerNote" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteDataFuji" , "Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..." , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifMnoteDataFuji" , "Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteDataFuji" , "Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>" "buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , "ExifMnoteDataFuji" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
<S2SV_ModStart> ; if ( CHECKOVERFLOW ( o2 , buf_size , 10 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o2 , buf_size , 4 <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o2 , buf_size , 12 <S2SV_ModEnd> ) ) return <S2SV_ModStart> } if ( CHECKOVERFLOW ( o2 , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteOlympus" , "Short<S2SV_blank>MakerNote" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteOlympus" , "Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..." , n -> entries [ tcount ] . tag , mnote_olympus_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifMnoteOlympus" , "Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> if ( dataofs > ( buf_size - s ) <S2SV_ModEnd> && n -> <S2SV_ModStart> } if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteOlympus" , "Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , "ExifMnoteOlympus" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 8 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteDataPentax" , "Short<S2SV_blank>MakerNote" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o + 0 , n -> order ) + base ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , "ExifMnotePentax" , "Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..." , n -> entries [ tcount ] . tag , mnote_pentax_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifMnoteDataPentax" , "Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)" , exif_format_get_size ( n -> entries [ tcount ] . format ) , n -> entries [ tcount ] . components <S2SV_ModEnd> ) ; break <S2SV_ModStart> break ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , "ExifMnoteDataPentax" , "Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>" "of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , "ExifMnoteDataPentax" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , unsigned int recursion_cost <S2SV_ModEnd> ) { ExifLong <S2SV_ModStart> ; if ( recursion_cost > 170 <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifData" , "Deep/expensive<S2SV_blank>recursion<S2SV_blank>detected!" <S2SV_ModEnd> ) ; return <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break <S2SV_ModStart> , o , recursion_cost + level_cost ( n ) <S2SV_ModEnd> ) ; break
<S2SV_ModStart> offset > ds - 6 <S2SV_ModEnd> ) { exif_log
<S2SV_ModStart> ; if ( doff >= size ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , "ExifData" , "Tag<S2SV_blank>starts<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)" , doff , size ) ; return 0 ; } if ( <S2SV_ModEnd> s > size <S2SV_ModStart> s > size - doff <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifData" , "Tag<S2SV_blank>data<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)" <S2SV_ModEnd> , doff +
<S2SV_ModStart> { if ( o >= ds <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , "ExifData" , "Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)." , o ) ; return ; } if ( s > ds - o ) { exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , "ExifData" , "Bogus<S2SV_blank>thumbnail<S2SV_blank>size<S2SV_blank>(%u),<S2SV_blank>max<S2SV_blank>would<S2SV_blank>be<S2SV_blank>%u." , s , ds - o <S2SV_ModEnd> ) ; return
<S2SV_ModStart> o , datao ; long failsafe_size = 0 <S2SV_ModStart> ) ; } failsafe_size += mnote_canon_entry_count_values ( & n -> entries [ tcount ] ) ; if ( failsafe_size > FAILSAFE_SIZE_MAX ) { exif_mem_free ( ne -> mem , n -> entries [ tcount ] . data ) ; exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , "ExifMnoteCanon" , "Failsafe<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>(%lu<S2SV_blank>><S2SV_blank>%ld)" , failsafe_size , FAILSAFE_SIZE_MAX ) ; break ; }
<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ;
<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteFujiEntry ) ) ;
<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteOlympusEntry ) ) ;
<S2SV_ModStart> size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnotePentaxEntry ) ) ;
<S2SV_ModStart> j ) { if ( i < CSD_BUF_SIZE * 8 ) { <S2SV_ModStart> j ; } else { ret = - 1 ; break ; } }
<S2SV_ModStart> bits == TGA_BPP_32 && <S2SV_ModEnd> tga -> alphabits
<S2SV_ModStart> ; # endif if ( ! ( <S2SV_ModEnd> ( tga -> <S2SV_ModStart> tga -> bits == TGA_BPP_24 && tga -> alphabits == 0 ) || ( tga -> bits == TGA_BPP_32 && tga -> alphabits == 8 ) ) ) { gd_error_ex ( GD_WARNING , "gd-tga:<S2SV_blank>%u<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>alpha<S2SV_blank>bits<S2SV_blank>not<S2SV_blank>supported\\n" , <S2SV_ModEnd> tga -> bits <S2SV_ModStart> tga -> bits , tga -> alphabits <S2SV_ModStart> return - 1 <S2SV_ModEnd> ; } tga
<S2SV_ModStart> NULL ; } if ( color < 0 || ( ! gdImageTrueColor ( im ) && color >= gdImageColorsTotal ( im ) ) <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } match = 1 ; for ( y = 0 ; match && y < height ; y ++ ) { for ( x = 0 ; match && x < width ; x ++ ) { match = ( gdColorMatch ( im , color , gdImageGetPixel ( im , x , y ) , threshold ) ) > 0 ; } } if ( y == height - 1 ) { return NULL ; }
<S2SV_ModStart> tmp_im ) { gdImageDestroy <S2SV_ModEnd> ( tmp_im )
<S2SV_ModStart> -> dp ; if ( dp -> pos < 0 || dp -> pos >= dp -> realSize ) { return 0 ; } <S2SV_ModStart> remain ; } if ( dp -> pos + rlen > dp -> realSize ) { rlen = dp -> realSize - dp -> pos ; }
<S2SV_ModStart> char buf [ 1024 <S2SV_ModEnd> ] ; int
<S2SV_ModStart> } } } gdCtxPuts ( out , "#define<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_width<S2SV_blank>" ) ; <S2SV_ModStart> ( out , "%d\\n" <S2SV_ModEnd> , gdImageSX ( <S2SV_ModStart> ) ) ; gdCtxPuts ( out , "#define<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_height<S2SV_blank>" ) ; <S2SV_ModStart> ( out , "%d\\n" <S2SV_ModEnd> , gdImageSY ( <S2SV_ModStart> ) ) ; gdCtxPuts ( out , "static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_bits[]<S2SV_blank>=<S2SV_blank>{\\n<S2SV_blank><S2SV_blank>" <S2SV_ModEnd> ) ; free <S2SV_ModStart> p ) { gdCtxPuts <S2SV_ModEnd> ( out , <S2SV_ModStart> ) ) { gdCtxPuts <S2SV_ModEnd> ( out , <S2SV_ModStart> } } } gdCtxPuts <S2SV_ModEnd> ( out ,
<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
<S2SV_ModStart> if ( remain <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> { if ( buffer_caret + pixel_block_size > rle_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } if (
<S2SV_ModStart> ( ) { check_file ( "heap_overflow_1.tga" ) ; check_file ( "heap_overflow_2.tga" <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * res ; size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> u < line_length <S2SV_ModStart> u ++ ) <S2SV_ModEnd> { res -> <S2SV_ModStart> ) gdMalloc ( weights_size ) ; if ( <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> int i ; <S2SV_ModEnd> for ( i <S2SV_ModStart> 0 ; i < <S2SV_ModEnd> u ; i
<S2SV_ModStart> ; int iSrc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; } } <S2SV_ModEnd> res -> ContribRow <S2SV_ModStart> u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
<S2SV_ModStart> } } } <S2SV_ModEnd> dst -> interlace <S2SV_ModStart> styleLength ) ; dst -> stylePos = src -> stylePos ;
<S2SV_ModStart> ) > image_block_size || buffer_caret + pixel_block_size > rle_size <S2SV_ModStart> ) > image_block_size || buffer_caret + ( encoded_pixels * pixel_block_size ) > rle_size
<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
<S2SV_ModStart> void ) { <S2SV_ModEnd> test_checkout_fails ( "refs/heads/git_tilde1" <S2SV_ModStart> ".git/foobar" ) ; test_checkout_fails ( "refs/heads/git_tilde1" , "git~1/foobar" ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
<S2SV_ModStart> ) ) ; cl_assert_equal_b ( false , git_path_isvalid ( NULL , ".gitmodules<S2SV_blank>.<S2SV_blank>.::$DATA" , S_IFLNK , GIT_PATH_REJECT_DOT_GIT_NTFS ) ) ;
<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , "%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file" , filename ) ; goto error ; }
<S2SV_ModStart> ENOTSUP , "%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry" , filename , page_size , off ) ; goto error ; } if ( off + page_size > h -> size ) { SET_ERRNO ( ENOTSUP , "%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>extends<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file,<S2SV_blank>bad<S2SV_blank>registry"
<S2SV_ModStart> filename ) { <S2SV_ModEnd> char * * <S2SV_ModStart> 0 ] ; free ( lines ) ;
<S2SV_ModStart> IDN2_OK ) { size_t len = strlen ( ( char * ) output_u8 ) ; if ( len > 63 ) { free ( output_u8 ) ; return IDN2_TOO_BIG_DOMAIN ; } <S2SV_ModStart> output , ( <S2SV_ModEnd> char * )
<S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" <S2SV_ModEnd> , __func__ )
<S2SV_ModStart> = 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <S2SV_ModEnd> = 0 ; <S2SV_ModStart> ; do { while ( ptr < buf + len && ( * ptr == '<S2SV_blank>' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; } <S2SV_ModEnd> if ( * <S2SV_ModStart> break ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <S2SV_ModEnd> } } while
<S2SV_ModStart> filestats ) ; if ( filestats . st_size < 8 ) { printf ( "ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n" ) ; return - 1 ; }
<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
<S2SV_ModStart> ) ; } else if ( idx >= 255 && shape -> useVersion == SWF_SHAPE1 ) { SWF_error ( "Too<S2SV_blank>many<S2SV_blank>fills<S2SV_blank>for<S2SV_blank>SWFShape<S2SV_blank>V1.\\n" "Use<S2SV_blank>a<S2SV_blank>higher<S2SV_blank>SWFShape<S2SV_blank>version\\n" ) ; }
<S2SV_ModStart> ; if ( number &&
<S2SV_ModStart> maxn ) { <S2SV_ModEnd> # ifdef DEBUG <S2SV_ModStart> endif switch ( OpCode ( actions , n , maxn ) <S2SV_ModEnd> ) { case
<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( "Received<S2SV_blank>Notify(%d):<S2SV_blank>%s" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u" , fromname <S2SV_ModStart> ) ; return STF_FAIL +
<S2SV_ModStart> np ) , finite_states [ smc -> state ] <S2SV_ModEnd> -> name )
<S2SV_ModStart> = 0 ; unsigned <S2SV_ModStart> = NULL ; unsigned <S2SV_ModStart> 5 ) { uint32_t reason = 0 ; struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr ++ ; _libssh2_get_u32 ( & buf , & reason ) ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; if ( session -> ssh_msg_disconnect ) { LIBSSH2_DISCONNECT ( session , reason , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) language , <S2SV_ModEnd> language_len ) ; <S2SV_ModStart> 6 ) { struct string_buf buf ; buf . data = ( unsigned <S2SV_ModEnd> char * ) <S2SV_ModStart> * ) data ; buf . dataptr = buf . data ; buf . len = datalen ; buf . dataptr += 2 ; _libssh2_get_string ( & buf , & message , & message_len ) ; _libssh2_get_string ( & buf , & language , & language_len ) ; } if ( session -> ssh_msg_debug ) { LIBSSH2_DEBUG ( session , always_display , ( const <S2SV_ModEnd> char * ) <S2SV_ModStart> char * ) message , message_len , ( const char * ) <S2SV_ModEnd> language , language_len <S2SV_ModStart> ; if ( ( len <= ( UINT_MAX - 6 ) ) && ( <S2SV_ModStart> 6 + len )
<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> ( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> ) ; } else strcpy ( mode , "" ) ;
<S2SV_ModStart> , - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error
<S2SV_ModStart> { if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( <S2SV_ModStart> 0 ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> 0 ) { if ( data_size > ( ( record_data_size - 4 ) - record_data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> ( record_data [ record_data_offset <S2SV_ModEnd> ] ) ,
<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length
<S2SV_ModStart> , CONST_STR_LEN ( "%2f?" ) , CONST_STR_LEN ( "/?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f?" ) , CONST_STR_LEN ( "//?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
<S2SV_ModStart> * file ; int ret = - 1 ; <S2SV_ModStart> 0 ) ) goto secure_wipe_keys <S2SV_ModEnd> ; header = <S2SV_ModStart> != AT91_SECURE_MAGIC ) goto secure_wipe_keys <S2SV_ModEnd> ; file = <S2SV_ModStart> header ) ; ret = <S2SV_ModEnd> secure_decrypt ( file <S2SV_ModStart> 1 ) ; secure_wipe_keys : wipe_keys ( ) ; return ret ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> { at91_aes_key_size_t key_size <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> - 1 ; # if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ; # elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ; # elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ; # else # error "bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size" # endif <S2SV_ModEnd> at91_aes_init ( ) <S2SV_ModStart> ( ) ; <S2SV_ModEnd> return rc ;
<S2SV_ModStart> ; if ( ! consttime_memequal <S2SV_ModEnd> ( cmac ,
<S2SV_ModStart> , g -> allgc <S2SV_ModEnd> , g ->
<S2SV_ModStart> <= CSTACKERR ) { luaE_exitCcall <S2SV_ModEnd> ( L ) <S2SV_ModStart> L ) ; luaE_enterCcall ( L ) ; }
<S2SV_ModStart> = inuse + BASIC_STACK_SIZE <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> hookmask ; const Proto * p = ci_func ( ci ) -> p ; int counthook ; int oldpc = ( L -> oldpc < p -> sizecode ) ? L -> oldpc : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> LUA_MASKLINE ) { <S2SV_ModEnd> int npci = <S2SV_ModStart> || pc <= invpcRel ( oldpc , p ) <S2SV_ModEnd> || changedline ( <S2SV_ModStart> ( p , oldpc <S2SV_ModEnd> , npci ) <S2SV_ModStart> -> oldpc = npci <S2SV_ModEnd> ; } if
<S2SV_ModStart> NULL ; } <S2SV_ModEnd> L -> hook
<S2SV_ModStart> * p = ci_func ( ci <S2SV_ModEnd> ) -> p <S2SV_ModStart> isLua ( ci = ci <S2SV_ModStart> -> oldpc = pcRel ( ci <S2SV_ModEnd> -> u . <S2SV_ModStart> l . savedpc , ci_func ( ci ) -> p )
<S2SV_ModStart> = 0 ; L -> oldpc = 0 ;
<S2SV_ModStart> -> oldpc = <S2SV_ModEnd> 1 ; }
<S2SV_ModStart> g ) { g -> gcstate = GCSswpallgc ;
<S2SV_ModStart> ) ) ; if ( g -> gckind == KGC_INC )
<S2SV_ModStart> * uv ; lua_assert ( ! isold ( thread ) || thread -> openupval == NULL ) ; <S2SV_ModStart> next ) { lua_assert ( getage ( uv ) <= getage ( thread ) ) ;
<S2SV_ModStart> L ) ; g -> gcstate = GCSswpallgc ;
<S2SV_ModStart> newpc ) { if ( p -> lineinfo == NULL ) return 0 ;
<S2SV_ModStart> CallInfo * ci ; checkstackGCp ( L , LUA_MINSTACK , func ) ; L -> ci = ci <S2SV_ModStart> next_ci ( L <S2SV_ModEnd> ) ; ci <S2SV_ModStart> func = func <S2SV_ModEnd> ; lua_assert ( <S2SV_ModStart> CallInfo * ci <S2SV_ModEnd> ; Proto * <S2SV_ModStart> -> maxstacksize ; checkstackGCp <S2SV_ModEnd> ( L , <S2SV_ModStart> fsize , func ) ; L -> ci = ci = next_ci ( L <S2SV_ModStart> default : { checkstackGCp <S2SV_ModEnd> ( L ,
<S2SV_ModStart> = nextra ; luaD_checkstack <S2SV_ModEnd> ( L ,
<S2SV_ModStart> = nextra ; checkstackGCp <S2SV_ModEnd> ( L ,
<S2SV_ModStart> b ++ ; checkstackGCp <S2SV_ModEnd> ( L ,
<S2SV_ModStart> val ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , "Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting." ) ; return false ; } <S2SV_ModEnd> char * url <S2SV_ModStart> 256 ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> = ( char <S2SV_ModStart> ( val , <S2SV_ModEnd> 1 ) ) <S2SV_ModStart> -> stratum_port ; snprintf ( address , sizeof ( address ) <S2SV_ModEnd> , "%s:%s" ,
<S2SV_ModStart> return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }
<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free
<S2SV_ModStart> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> ( job_id ) <S2SV_ModStart> ( job_id ) ; free ( coinbase1 ) ; <S2SV_ModEnd> free ( coinbase2
<S2SV_ModStart> -> stratum_port ; snprintf ( address , 254 <S2SV_ModEnd> , "%s:%s" ,
<S2SV_ModStart> -> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> -> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ( szFileName , pszFileName , <S2SV_ModStart> ) - 5 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> = - 1 <S2SV_ModStart> 1 , ret <S2SV_ModEnd> ; bool grab_newname <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , getpid <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } fd <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , pid <S2SV_ModStart> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>" "user<S2SV_blank>IDs:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> setns ( fd <S2SV_ModStart> ( fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( fd <S2SV_ModStart> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>" "the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> if ( ! ifindex ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( "Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n" , ret , <S2SV_ModEnd> oldname , * <S2SV_ModStart> * newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> [ IFNAMSIZ ] ; char <S2SV_ModEnd> * namep = <S2SV_ModStart> ) ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } * <S2SV_ModStart> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> setns ( ofd <S2SV_ModStart> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>" "of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> ofd ) ; <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; r = safe_mount <S2SV_ModEnd> ( "cgroup_root" , <S2SV_ModStart> MS_RELATIME , "size=10240k,mode=755" , root
<S2SV_ModStart> ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> NULL ) !=
<S2SV_ModStart> } ret = safe_mount ( path , destpath , "none" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , "%r/proc/sys/net" , "%r/proc/tty" <S2SV_ModEnd> , NULL , <S2SV_ModStart> , LXC_AUTO_PROC_MIXED , "%r/proc/tty" <S2SV_ModEnd> , "%r/proc/sys/net" , <S2SV_ModStart> ; r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ; saved_errno
<S2SV_ModStart> } if ( safe_mount <S2SV_ModEnd> ( "none" , <S2SV_ModStart> 0 , "size=100000,mode=755" , rootfs -> path ? rootfs -> mount : NULL
<S2SV_ModStart> , int optional , const char * rootfs <S2SV_ModStart> endif if ( safe_mount <S2SV_ModEnd> ( fsname , <S2SV_ModStart> MS_REMOUNT , data , rootfs <S2SV_ModStart> , data ) < 0
<S2SV_ModStart> mntent , path , rootfs -> mount
<S2SV_ModStart> char * path , const char * rootfs <S2SV_ModStart> mntdata , optional , rootfs
<S2SV_ModStart> mntent , path , rootfs
<S2SV_ModStart> mntent -> mnt_dir , NULL
<S2SV_ModStart> } if ( safe_mount ( console -> name , path , "none" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) ) {
<S2SV_ModStart> } if ( safe_mount ( console -> name , lxcpath , "none" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , <S2SV_ModEnd> console -> name <S2SV_ModStart> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , "%s/console" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( "lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console" ) ; return - 1 ; } INFO ( "console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s" , lxcpath ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> : if ( safe_mount <S2SV_ModEnd> ( "proc" , <S2SV_ModStart> 0 , NULL , rootfs ) < 0 <S2SV_ModEnd> ) return -
<S2SV_ModStart> -> ipc_socket ; int procfd = payload -> procfd ; <S2SV_ModStart> & LXC_ATTACH_LSM ) && init_ctx -> lsm_label <S2SV_ModStart> int on_exec ; <S2SV_ModEnd> on_exec = options <S2SV_ModStart> : 0 ; if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> init_ctx -> lsm_label <S2SV_ModStart> init_ctx -> lsm_label ) <S2SV_ModEnd> < 0 ) <S2SV_ModStart> } } } close ( procfd ) ;
<S2SV_ModStart> 2 ] ; int procfd ; <S2SV_ModStart> ) ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> exec_payload = exec_payload , . procfd = procfd
<S2SV_ModStart> = strlen ( "/lxc/lock/" <S2SV_ModEnd> ) + strlen <S2SV_ModStart> , len , "%s/lxc/lock/%s" <S2SV_ModEnd> , rundir , <S2SV_ModStart> 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , "%s/lxc/lock/%s/.%s" , rundir , p , n ) ; free ( rundir <S2SV_ModEnd> ) ; if <S2SV_ModStart> dest ) ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> pathname = RUNTIME_PATH "/lxc/lock/var/lib/lxc/" <S2SV_ModEnd> ; ret =
<S2SV_ModStart> -> ipc_socket ; <S2SV_ModEnd> lxc_attach_options_t * options <S2SV_ModStart> int fd ; int lsm_labelfd ; <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; shutdown <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>" "that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> "privileges." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> ( "PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>" "gainable<S2SV_blank>privileges." ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> int on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> ( lsm_set_label_at ( lsm_labelfd <S2SV_ModEnd> , on_exec , <S2SV_ModStart> 0 ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> } if ( <S2SV_ModStart> "Loading<S2SV_blank>seccomp<S2SV_blank>policy" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> lxc_proc_put_context_info ( init_ctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> rexit ( payload
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec <S2SV_ModStart> * lsm_label ) { int fret <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; const char <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ( write ( lsm_labelfd <S2SV_ModEnd> , command , <S2SV_ModStart> { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s." , command ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , command ) ; } else if ( strcmp ( name , "SELinux" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label" ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , lsm_label ) ; } else <S2SV_ModEnd> { ERROR ( <S2SV_ModStart> name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free <S2SV_ModStart> ; if ( lsm_labelfd <S2SV_ModEnd> != - 1 <S2SV_ModStart> ) close ( lsm_labelfd <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> signed long personality <S2SV_ModStart> pid ) { int procfd = - 1 ; <S2SV_ModStart> cleanup_error ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc." <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( status ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } <S2SV_ModStart> ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>" "from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>" "initialization<S2SV_blank>(2):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; goto <S2SV_ModStart> cleanup_error ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> ; cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> |= CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = lxc_attach_to_ns <S2SV_ModStart> = exec_payload , <S2SV_ModEnd> } ; pid
<S2SV_ModStart> -> pid , fc -> uid ,
<S2SV_ModStart> pid_t tpid , uid_t tuid , <S2SV_ModStart> { if ( ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> cred . pid <S2SV_ModStart> . pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , "%d" , ( int ) cred . pid )
<S2SV_ModStart> nextcg ) { <S2SV_ModEnd> bool answer = <S2SV_ModStart> ; char * c2 = get_pid_cgroup ( pid , contrl ) ; char * linecmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! c2 ) return false <S2SV_ModEnd> ; prune_init_slice ( <S2SV_ModStart> ( nextcg ) { <S2SV_ModStart> cg ) ; } <S2SV_ModStart> = true ; out : free ( c2 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> , * controller , * next = NULL <S2SV_ModStart> if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> ; goto out <S2SV_ModStart> if ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> cgdir ) ; free ( next ) ;
<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( <S2SV_ModStart> O_RDONLY ) ) <S2SV_ModEnd> return - EACCES
<S2SV_ModStart> , * controller , * next = NULL <S2SV_ModStart> out ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> , cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> ) ) { <S2SV_ModStart> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> cgdir ) ; free ( next ) ;
<S2SV_ModStart> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> tmp ) { goto softfail <S2SV_ModEnd> ; } case <S2SV_ModStart> ) ) { goto softfail <S2SV_ModEnd> ; } state <S2SV_ModStart> end ) ; softfail : state -> offset = 0 ;
<S2SV_ModStart> 3 * len + 8
<S2SV_ModStart> char * to = g . inf , * sufx = "" ; size_t pre = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> g . decode ) { if ( <S2SV_ModEnd> ( g . <S2SV_ModStart> NULL ) { pre = justname ( g . inf ) - g . inf ; to = justname ( <S2SV_ModEnd> g . hname <S2SV_ModStart> g . hname ) <S2SV_ModStart> = strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( to <S2SV_ModStart> , ".tgz" ) == 0 ) sufx = ".tar" ; } else sufx = g . sufx ; <S2SV_ModEnd> g . outf <S2SV_ModStart> = MALLOC ( pre + len + strlen ( sufx ) <S2SV_ModEnd> + 1 ) <S2SV_ModStart> . outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g . <S2SV_ModStart> . outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx ) ;
<S2SV_ModStart> return MS_FALSE ; if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , "Invalid<S2SV_blank>time<S2SV_blank>filter." , "msPostGISLayerSetTimeFilter()" ) ; return MS_FALSE ; }
<S2SV_ModStart> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ; jpc_pchg_t
<S2SV_ModStart> int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> v = 0
<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
<S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd <S2SV_ModStart> i ] ) ) <S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd <S2SV_ModStart> ] ) ) )
<S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl ->
<S2SV_ModStart> if ( roishift < 0 ) { jas_eprintf ( "warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>" "(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> mask = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps )
<S2SV_ModStart> numlvls > 0 && jas_seq2d_size ( a )
<S2SV_ModStart> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> actualnumcolors = hdr
<S2SV_ModStart> = 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( image <S2SV_ModStart> ( image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ i <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad = <S2SV_ModStart> EOF ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> i ) { if ( ! ( <S2SV_ModStart> image ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize = <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> EOF ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> char * buf <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ) ) ) && bufsize

<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
<S2SV_ModStart> m ; int hstartrow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( buf = jas_alloc3 <S2SV_ModEnd> ( bufsize , <S2SV_ModStart> ( bufsize , JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> 2 ) { hstartrow <S2SV_ModEnd> = ( numrows <S2SV_ModStart> = numrows - hstartrow <S2SV_ModEnd> ; n = <S2SV_ModStart> & a [ hstartrow <S2SV_ModEnd> * stride ]
<S2SV_ModStart> ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
<S2SV_ModStart> long n ; image = 0 ; info = 0 ; <S2SV_ModStart> "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; goto error <S2SV_ModEnd> ; } JAS_DBGLOG <S2SV_ModStart> 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>" "mincolors<S2SV_blank>%ld\\n" , JAS_CAST ( long <S2SV_ModEnd> , info -> <S2SV_ModStart> info -> len ) , JAS_CAST ( long <S2SV_ModStart> info -> width ) , JAS_CAST ( long <S2SV_ModStart> info -> height ) , JAS_CAST ( long <S2SV_ModStart> info -> numplanes ) , JAS_CAST ( long , <S2SV_ModEnd> info -> depth <S2SV_ModStart> info -> depth ) , JAS_CAST ( long <S2SV_ModStart> info -> enctype ) , JAS_CAST ( long <S2SV_ModStart> info -> siz ) , JAS_CAST ( long <S2SV_ModStart> info -> hres ) , JAS_CAST ( long <S2SV_ModStart> info -> vres ) , JAS_CAST ( long , <S2SV_ModEnd> info -> numcolors <S2SV_ModStart> info -> numcolors ) , JAS_CAST ( long <S2SV_ModStart> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; goto error ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error ; } <S2SV_ModStart> info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> image ) ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> inmem ) ? jas_stream_memopen2 <S2SV_ModEnd> ( 0 ,
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble" ) ; }
<S2SV_ModStart> bufsize ) { char * new_buf ; size_t new_bufsize <S2SV_ModEnd> ; JAS_DBGLOG ( <S2SV_ModStart> ; if ( bufsize < 0 ) { jas_deprecated ( "negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen" ) ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( "Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n" ) ; jas_deprecated ( "A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>" "jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n" ) ; } <S2SV_ModEnd> if ( bufsize <S2SV_ModStart> 0 ) { new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { new_bufsize <S2SV_ModEnd> = bufsize ; <S2SV_ModStart> = bufsize ; new_buf = buf ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write" ) ; }
<S2SV_ModStart> cnt ) { ssize_t <S2SV_ModEnd> n ; assert
<S2SV_ModStart> * m , size_t <S2SV_ModEnd> bufsize ) { <S2SV_ModStart> * buf ; <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( "mem_resize(%p,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , m , <S2SV_ModStart> ) ) ; if ( ! bufsize ) { jas_eprintf ( "mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n" "This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n" ) ; }
<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG
<S2SV_ModStart> cnt ) { size_t <S2SV_ModEnd> n ; int <S2SV_ModStart> ) obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; assert <S2SV_ModStart> newpos ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( "new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n" ) ) ; <S2SV_ModEnd> return - 1 <S2SV_ModStart> ; } } JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }
<S2SV_ModStart> char * fmtname ; int debug <S2SV_ModStart> = 0 ; debug = 0 ; <S2SV_ModStart> break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> ; } } jas_setdbglevel ( debug ) ; <S2SV_ModStart> ) ) { jas_stream_close ( instream ) ;
<S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> 0 ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>" "mincolors<S2SV_blank>%d\\n" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;
<S2SV_ModStart> v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 )
<S2SV_ModStart> 101 , ( "jas_malloc(%zu)\\n" <S2SV_ModEnd> , size )
<S2SV_ModStart> 101 , ( "jas_realloc(%x,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , ptr ,
<S2SV_ModStart> int i ; size_t size ; matrix = 0 ; <S2SV_ModStart> 0 ) { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } matrix <S2SV_ModStart> -> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } } <S2SV_ModStart> return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
<S2SV_ModStart> -> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )
<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( pirlvl <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )

<S2SV_ModStart> pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl -> <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> x % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx ) <S2SV_ModStart> ) % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy ) <S2SV_ModStart> y % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy )

<S2SV_ModStart> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n" ) ; return - 1 ; } if (

<S2SV_ModStart> info = boxinfo <S2SV_ModEnd> ; box -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" <S2SV_ModStart> ( tmpstream ) ; box -> ops = & boxinfo -> ops
<S2SV_ModStart> size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> 0 ] ; max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> break ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> ) ; } snprintf ( optstr , sizeof ( optstr ) , "max_samples=%-zu" , max_samples ) ; <S2SV_ModStart> , fmtid , optstr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ( ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( "format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> 0 ; } printf ( "%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n" , fmtname <S2SV_ModEnd> , numcmpts , <S2SV_ModStart> , depth , JAS_CAST ( long , <S2SV_ModEnd> jas_image_rawsize ( image <S2SV_ModStart> jas_image_rawsize ( image )
<S2SV_ModStart> size_t j ; jas_uchar <S2SV_ModEnd> * dp ;
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if <S2SV_ModStart> - JAS_CAST ( jas_longlong <S2SV_ModEnd> , ( ( <S2SV_ModStart> : JAS_CAST ( jas_longlong <S2SV_ModEnd> , tmp )
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> * val ) <S2SV_ModStart> int c ; jas_ulonglong <S2SV_ModEnd> v ; v
<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,
<S2SV_ModStart> int n , jas_longlong <S2SV_ModEnd> val ) { <S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; tmp
<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
<S2SV_ModStart> long decode_twos_comp ( jas_ulong <S2SV_ModEnd> c , int
<S2SV_ModStart> <S2SV_null> static inline jas_ulong <S2SV_ModEnd> encode_twos_comp ( long <S2SV_ModStart> prec ) { jas_ulong <S2SV_ModEnd> result ; assert
<S2SV_ModStart> size_t size ; JAS_DBGLOG ( 100 , ( "jas_image_cmpt_create(%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%ld,<S2SV_blank>%d,<S2SV_blank>%d,<S2SV_blank>%d)\\n" , JAS_CAST ( long , tlx ) , JAS_CAST ( long , tly ) , JAS_CAST ( long , hstep ) , JAS_CAST ( long , vstep ) , JAS_CAST ( long , width ) , JAS_CAST ( long , height ) , JAS_CAST ( int , depth ) , sgnd , inmem ) ) ; <S2SV_ModStart> tly , height , 0 ) ) { goto error ; } if ( ! jas_safe_intfast32_mul3 ( width , height , depth <S2SV_ModStart> if ( ! jas_safe_size_mul3 <S2SV_ModEnd> ( cmpt -> <S2SV_ModStart> cmpt -> height_ <S2SV_ModEnd> , cmpt ->
<S2SV_ModStart> ; image -> <S2SV_ModEnd> cmprof_ = 0
<S2SV_ModStart> * image ; size_t <S2SV_ModEnd> rawsize ; uint_fast32_t <S2SV_ModStart> * cmptparm ; image = 0 ; JAS_DBGLOG ( 100 , ( "jas_image_create(%d,<S2SV_blank>%p,<S2SV_blank>%d)\\n" , numcmpts , cmptparms , clrspc ) ) ; <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } image <S2SV_ModStart> = numcmpts ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ) { goto error <S2SV_ModEnd> ; } for <S2SV_ModStart> 0 ; } # if 0 <S2SV_ModStart> JAS_IMAGE_INMEMTHRESH ) ; # endif <S2SV_ModStart> cmptparm ) { if ( ! jas_safe_size_mul3 ( cmptparm -> width , cmptparm -> height , ( cmptparm -> prec + 7 ) , & rawsize ) ) { goto error ; } rawsize /= 8 ; inmem = ( rawsize < JAS_IMAGE_INMEMTHRESH ) ; <S2SV_ModStart> ) ) { goto error ; } ++ image -> numcmpts_ ; } jas_image_setbbox ( image ) ; return image ; error : if ( image ) { <S2SV_ModStart> image ) ; } <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> bool s ; jas_ulong <S2SV_ModEnd> tmp ; assert
<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if
<S2SV_ModStart> maxval ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * data ; jas_matind_t <S2SV_ModEnd> rowstep ; if
<S2SV_ModStart> mat1 ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; if
<S2SV_ModStart> * y ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; y
<S2SV_ModStart> * jas_matrix_create ( jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> numcols ) { <S2SV_ModStart> * matrix ; jas_matind_t <S2SV_ModEnd> i ; size_t
<S2SV_ModStart> n ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
<S2SV_ModStart> * matrix , jas_matind_t numrows , jas_matind_t <S2SV_ModEnd> numcols ) { <S2SV_ModStart> numcols ) { jas_matind_t size ; jas_matind_t <S2SV_ModEnd> i ; size
<S2SV_ModStart> val ) { jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t <S2SV_ModStart> * rowstart ; jas_matind_t <S2SV_ModEnd> rowstep ; jas_seqent_t
<S2SV_ModStart> * s1 , jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {
<S2SV_ModStart> * y ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; y
<S2SV_ModStart> * jas_seq2d_create ( jas_matind_t xstart , jas_matind_t ystart , jas_matind_t xend , jas_matind_t <S2SV_ModEnd> yend ) {
<S2SV_ModStart> * matrix ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; long <S2SV_ModStart> long x ; jas_matind_t numrows ; jas_matind_t numcols ; jas_matind_t xoff ; jas_matind_t yoff ; long tmp_xoff ; long tmp_yoff ; long tmp_numrows ; long tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , "%ld<S2SV_blank>%ld" , & tmp_xoff , & tmp_yoff <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } xoff = tmp_xoff ; yoff = tmp_yoff <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( in , "%ld<S2SV_blank>%ld" , & tmp_numcols , & tmp_numrows <S2SV_ModEnd> ) != 2 <S2SV_ModStart> != 2 ) { return 0 ; } numrows = tmp_numrows ; numcols = tmp_numcols <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ) { return 0 ; } <S2SV_ModEnd> if ( jas_matrix_numrows
<S2SV_ModStart> define MAXLINELEN 80 jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; jas_seqent_t
<S2SV_ModStart> = JAS_CAST ( jas_uchar <S2SV_ModEnd> * , buf
<S2SV_ModStart> tmr ) { double t0 ; double t1 ; t0 = ( ( double ) tmr -> start . tv_sec ) + ( ( double ) tmr -> start . tv_usec ) / 1e6 ; t1 = ( ( double ) tmr -> stop . tv_sec ) + ( ( double ) tmr -> stop . tv_usec ) / 1e6 ; return t1 - t0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> tmr ) { if ( gettimeofday ( & tmr -> start , 0 ) ) { abort ( ) ; }
<S2SV_ModStart> tmr ) { if ( gettimeofday ( & tmr -> stop , 0 ) ) { abort ( ) ; }
<S2SV_ModStart> long n ; bmp_dec_importopts_t opts ; size_t num_samples ; image = 0 ; info = 0 ; if ( bmp_dec_parseopts ( optstr , & opts ) ) { goto error <S2SV_ModEnd> ; } jas_eprintf <S2SV_ModStart> jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; goto error ; } if ( ! jas_safe_size_mul3 ( info -> width , info -> height , info -> numplanes , & num_samples ) ) { jas_eprintf ( "image<S2SV_blank>size<S2SV_blank>too<S2SV_blank>large\\n" ) ; goto error ; } if ( opts . max_samples > 0 && num_samples > opts . max_samples ) { jas_eprintf ( "maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>pixels<S2SV_blank>exceeded<S2SV_blank>(%zu)\\n" , opts . max_samples
<S2SV_ModStart> int i ; jas_uchar <S2SV_ModEnd> buf [ 2
<S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> != JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> : JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> >= JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts ( <S2SV_ModStart> < JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_image_numcmpts (
<S2SV_ModStart> ( JAS_CAST ( jas_ulong <S2SV_ModEnd> , jas_stream_tell (
<S2SV_ModStart> ( JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_stream_read (
<S2SV_ModStart> ( JAS_CAST ( jas_uint <S2SV_ModEnd> , jas_stream_write (
<S2SV_ModStart> * streams ; jas_uchar <S2SV_ModEnd> * dataptr ;
<S2SV_ModStart> = JAS_CAST ( jas_uchar <S2SV_ModEnd> * , jas_strdup
<S2SV_ModStart> ; opts -> max_samples = 64 * JAS_MEBI <S2SV_ModEnd> ; if ( <S2SV_ModStart> : opts -> max_samples <S2SV_ModEnd> = atoi (
<S2SV_ModStart> opts ; size_t num_samples ; JAS_DBGLOG ( 100 , ( "jpg_decode(%p,<S2SV_blank>\\"%s\\")\\n" , in , optstr ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( opts <S2SV_ModStart> ( opts . max_samples > 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> if ( ! jas_safe_size_mul3 ( cinfo . image_width , cinfo . image_height , cinfo . num_components , & num_samples <S2SV_ModEnd> ) ) { <S2SV_ModStart> } if ( num_samples <S2SV_ModEnd> > opts . <S2SV_ModStart> > opts . max_samples <S2SV_ModEnd> ) { jas_eprintf <S2SV_ModStart> { jas_eprintf ( "image<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%zu<S2SV_blank>><S2SV_blank>%zu)\\n" , num_samples , opts . max_samples <S2SV_ModEnd> ) ; goto <S2SV_ModStart> ; } } JAS_DBGLOG ( 10 , ( "jpeg_start_decompress(%p)\\n" , & cinfo ) ) ; ret = jpeg_start_decompress ( & cinfo ) ; JAS_DBGLOG ( 10 , ( "jpeg_start_decompress<S2SV_blank>return<S2SV_blank>value<S2SV_blank>%d\\n" , ret ) ) ; JAS_DBGLOG ( 10 , ( "header:<S2SV_blank>output_width<S2SV_blank>%d;<S2SV_blank>output_height<S2SV_blank>%d;<S2SV_blank>output_components<S2SV_blank>%d\\n" , cinfo . output_width , cinfo . output_height , cinfo . output_components ) ) ;
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ JPG_MAGICLEN
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> magicbuf [ MIF_MAGICLEN
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ MIF_MAGICLEN
<S2SV_ModStart> int c ; jas_uchar <S2SV_ModEnd> buf [ 2
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ PGX_MAGICLEN
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2
<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ RAS_MAGICLEN
<S2SV_ModStart> 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }
<S2SV_ModStart> * cmpt ; size_t size ; <S2SV_ModStart> tileheight ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> numhtiles <S2SV_ModStart> dec -> numhtiles , <S2SV_ModEnd> dec -> numvtiles <S2SV_ModStart> dec -> numvtiles , & size <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( "numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }
<S2SV_ModStart> jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" <S2SV_ModStart> 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" ) ; return - 1 ; }
<S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> error ; } jas_tvparser_destroy ( tvp ) ;
<S2SV_ModStart> len = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) <S2SV_ModStart> ) ) { box -> ops = & jp2_boxinfo_unk . ops ;
<S2SV_ModStart> { jas_eprintf ( "got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n" <S2SV_ModEnd> , box ->
<S2SV_ModStart> ( box = jp2_box_create0 ( <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 0 ; } <S2SV_ModEnd> box -> type
<S2SV_ModStart> ( box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( jp2_getuint32 <S2SV_ModStart> 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>" "type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%" PRIuFAST32 "\\n" <S2SV_ModEnd> , \'"\' , <S2SV_ModStart> 1 ) { JAS_DBGLOG ( 10 , ( "big<S2SV_blank>length\\n" ) ) ;
<S2SV_ModStart> ) ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ;
<S2SV_ModStart> unsigned int i ; bpcc -> bpcs = 0
<S2SV_ModStart> unsigned int channo ; cdef -> ents = 0
<S2SV_ModStart> unsigned int i ; cmap -> ents = 0
<S2SV_ModStart> = 0 ; pclr -> bpc = 0 ;
<S2SV_ModStart> -> prcwidthexpn + <S2SV_ModEnd> picomp -> numrlvls <S2SV_ModStart> -> prcheightexpn + <S2SV_ModEnd> picomp -> numrlvls
<S2SV_ModStart> uint_fast8_t tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( "reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( "tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( "number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( "XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( "YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( "XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( "YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) + BIN_MAX_EXTLEN + 1 <S2SV_ModStart> binary_header ) , extlen > BIN_MAX_EXTLEN ? BIN_MAX_EXTLEN :
<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , "get<S2SV_blank>" ) && strcmp ( ptr , "gets<S2SV_blank>" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont = el
<S2SV_ModStart> int res ; int num_allocs = 0 ; <S2SV_ModStart> rsize ) { if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ;
<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if
<S2SV_ModStart> && ntokens >= 4 <S2SV_ModEnd> && settings . <S2SV_ModStart> && ntokens >= 4 <S2SV_ModEnd> && settings .
<S2SV_ModStart> } if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , "get<S2SV_blank>" , 4 ) && strncmp <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ptr , "gets<S2SV_blank>" , 5 )
<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
<S2SV_ModStart> , val ) ; if ( ! val ) continue
<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
<S2SV_ModStart> } while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ] == '\\n' )
<S2SV_ModStart> * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
<S2SV_ModStart> 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> n ) ; if ( n == 0 ) { <S2SV_ModStart> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;
<S2SV_ModStart> "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; * pp = p -> next ;
<S2SV_ModStart> 3 ; } if ( desc == NULL ) desc = "" ;
<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> = act_code ; if ( npix > 0 ) <S2SV_ModStart> = casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - stackp <S2SV_ModStart> - stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -= (
<S2SV_ModStart> ) ; } usleep ( 1000 ) ; <S2SV_ModStart> 2 : 0 ) ; usleep ( 1000
<S2SV_ModStart> == MD_LINE_TEXT && off < ctx -> size && ISANYOF2 ( off , <S2SV_ModEnd> _T ( '=' <S2SV_ModStart> ( '=' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ctx -> code_indent_offset && off < ctx -> size <S2SV_ModEnd> && off >= <S2SV_ModStart> off >= hr_killer && ISANYOF ( off , _T ( "-_*" ) ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> -> n_containers && ISANYOF2_ <S2SV_ModStart> container . ch , <S2SV_ModEnd> _T ( '.' <S2SV_ModStart> ( '.' ) , <S2SV_ModEnd> _T ( ')' <S2SV_ModStart> -> code_indent_offset && off < ctx -> size && <S2SV_ModStart> } if ( off < ctx -> size && ISANYOF2 ( off , _T ( '`' ) , _T ( '~' ) ) ) { if ( md_is_opening_code_fence ( ctx , off , & off ) ) { line -> type = MD_LINE_FENCEDCODE ; line -> data = 1 ; break ; } } if ( off < ctx -> size && <S2SV_ModStart> == _T ( <S2SV_ModEnd> '<' ) && <S2SV_ModStart> type == MD_LINE_TEXT && off < ctx -> size && ISANYOF3 ( off , <S2SV_ModEnd> _T ( '|' <S2SV_ModStart> ( '|' ) , <S2SV_ModEnd> _T ( '-' <S2SV_ModStart> ( '-' ) , <S2SV_ModEnd> _T ( ':' <S2SV_ModStart> ':' ) ) && <S2SV_ModEnd> n_parents == ctx
<S2SV_ModStart> base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> } else { # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> return HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif
<S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , option_ext , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left = <S2SV_ModStart> } else { if ( sn_coap_parser_add_u16_limit ( option_number , 269 , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> * message_left =
<S2SV_ModStart> 1 ; } if ( sn_coap_parser_add_u16_limit ( option_number , previous_option_number , & option_number ) != 0 ) { return - 1 ; } <S2SV_ModEnd> option_parse_result = parse_ext_option <S2SV_ModStart> case COAP_OPTION_ETAG : if ( dst_coap_msg_ptr -> options_list_ptr -> etag_ptr ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_ETAG<S2SV_blank>exists!" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_LOCATION_QUERY : if ( dst_coap_msg_ptr -> options_list_ptr -> location_query_ptr ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_LOCATION_QUERY<S2SV_blank>exists!" ) ; return - 1 ; } <S2SV_ModStart> case COAP_OPTION_URI_PATH : if ( dst_coap_msg_ptr -> uri_path_ptr ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>COAP_OPTION_URI_PATH<S2SV_blank>exists!" ) ; return - 1 ; }
<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , "." ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
<S2SV_ModStart> + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
<S2SV_ModStart> Lut ) ; Lut = NULL ; <S2SV_ModStart> ; Error : if ( Lut != NULL )
<S2SV_ModStart> len - o - 4
<S2SV_ModStart> "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test59.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ;
<S2SV_ModStart> "$ref" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> "$id" ) ; }
<S2SV_ModStart> ( sr -> uri_processed <S2SV_ModEnd> ) < 0
<S2SV_ModStart> ; sr -> fd_is_fdt = MK_FALSE ; sr ->
<S2SV_ModStart> 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
<S2SV_ModStart> = hash ; sr -> fd_is_fdt = MK_TRUE ;
<S2SV_ModStart> mb ) { MonoReferenceQueue * queue ; MonoMethod * handle ; DynamicMethodReleaseData * release_data ; <S2SV_ModStart> int i ; if ( mono_runtime_is_shutting_down ( ) ) mono_raise_exception ( mono_get_exception_invalid_operation ( "" ) ) ; if ( ! ( queue = dynamic_method_queue ) ) { mono_loader_lock ( ) ; if ( ! ( queue = dynamic_method_queue ) ) queue = dynamic_method_queue = mono_gc_reference_queue_new ( free_dynamic_method ) ; mono_loader_unlock ( ) ; } <S2SV_ModStart> -> mhandle = handle = <S2SV_ModStart> rmb , sig ) ; release_data = g_new ( DynamicMethodReleaseData , 1 ) ; release_data -> handle = handle ; release_data -> domain = mono_object_get_domain ( ( MonoObject * ) mb ) ; if ( ! mono_gc_reference_queue_add ( queue , ( MonoObject * ) mb , release_data ) ) g_free ( release_data
<S2SV_ModStart> NULL ) ; mono_reflection_shutdown ( ) ;
<S2SV_ModStart> ; # endif reference_queue_proccess_all ( ) ;
<S2SV_ModStart> finalizer_mutex ) ; DeleteCriticalSection ( & reference_queue_mutex ) ;
<S2SV_ModStart> ( & finalizer_mutex ) ; InitializeCriticalSection ( & reference_queue_mutex
<S2SV_ModStart> ) ; } if ( ! mono_verifier_is_method_valid_generic_instantiation ( inflated ) ) mono_raise_exception ( mono_get_exception_argument ( "typeArguments" , "Invalid<S2SV_blank>generic<S2SV_blank>arguments" ) ) ;
<S2SV_ModStart> exit_mf ; } size_t fname_avail = <S2SV_ModEnd> strlen ( filename <S2SV_ModStart> ) + 32 ; char * fname = talloc_size ( mf , fname_avail <S2SV_ModStart> } # endif const char * f = filename ; int MAXDIGS = 3 , nspec = 0 , bad_spec = 0 , c ; while ( nspec < 2 && ( c = * f ++ ) ) { if ( c != '%' ) continue ; if ( * f != '%' ) { nspec ++ ; if ( * f == '.' ) f ++ ; for ( int ndig = 0 ; mp_isdigit ( * f ) && ndig < MAXDIGS ; ndig ++ , f ++ ) ; if ( * f != 'd' ) { bad_spec ++ ; break ; } } f ++ ; } if ( bad_spec || nspec != 1 ) { mp_err ( log , "unsupported<S2SV_blank>expr<S2SV_blank>format:<S2SV_blank>\'%s\'\\n" , filename ) ; goto exit_mf ; } <S2SV_ModStart> 5 ) { if ( snprintf ( fname , fname_avail <S2SV_ModEnd> , filename , <S2SV_ModStart> count ++ ) >= fname_avail ) { mp_err ( log , "format<S2SV_blank>result<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>\'%s\'\\n" , filename ) ; goto exit_mf ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
<S2SV_ModStart> -> c ; enum mrb_fiber_state status ; <S2SV_ModStart> , c ) ; status = c -> status <S2SV_ModStart> ( resume && <S2SV_ModEnd> status == MRB_FIBER_TRANSFERRED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_RUNNING <S2SV_ModStart> == MRB_FIBER_RUNNING || <S2SV_ModEnd> status == MRB_FIBER_RESUMED <S2SV_ModStart> } if ( <S2SV_ModEnd> status == MRB_FIBER_TERMINATED <S2SV_ModStart> ) ; } old_c <S2SV_ModEnd> -> status = <S2SV_ModStart> root_c ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == MRB_FIBER_CREATED <S2SV_ModStart> * e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = c <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( vmexec
<S2SV_ModStart> orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> mrb_io_alloc ( mrb <S2SV_ModEnd> ) ; DATA_TYPE
<S2SV_ModStart> ) ; # if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ; # endif #
<S2SV_ModStart> watchdog = 0 <S2SV_ModEnd> ; int err <S2SV_ModStart> shutdown_wants_write ) { int <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ; <S2SV_ModStart> break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , "SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , "SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( "SSL_shutdown" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , "SSL_shutdown" ) ) break ; <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , "SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> sock_can_wr ) { ssize_t <S2SV_ModStart> sock_can_rd ) { ssize_t <S2SV_ModStart> ) ) { int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> switch ( err <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ) <S2SV_ModStart> break ; case SSL_ERROR_SSL : sslerror ( "SSL_write" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> : if ( parse_socket_error ( c , "SSL_write" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , "SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , "SSL_read<S2SV_blank>returned<S2SV_blank>0" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , "SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , "SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , "SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying" ) ; break ; case SSL_ERROR_SSL : sslerror ( "SSL_read" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ( LOG_INFO , "TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)" <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , "SSL_read" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; default :
<S2SV_ModStart> = section ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L if ( section -> security_level >= 0 ) { SSL_CTX_set_security_level ( section -> ctx , section -> security_level ) ; s_log ( LOG_INFO , "User-specified<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d" , section -> security_level ) ; } else if ( SSL_CTX_get_security_level ( section -> ctx ) < DEFAULT_SECURITY_LEVEL ) { SSL_CTX_set_security_level ( section -> ctx , DEFAULT_SECURITY_LEVEL ) ; s_log ( LOG_INFO , "stunnel<S2SV_blank>default<S2SV_blank>security<S2SV_blank>level<S2SV_blank>set:<S2SV_blank>%d" , DEFAULT_SECURITY_LEVEL ) ; } else { s_log ( LOG_INFO , "OpenSSL<S2SV_blank>security<S2SV_blank>level<S2SV_blank>is<S2SV_blank>used:<S2SV_blank>%d" , SSL_CTX_get_security_level ( section -> ctx ) ) ; } # endif <S2SV_ModStart> return 1 ; # ifndef OPENSSL_NO_TLSEXT <S2SV_ModStart> . client ) <S2SV_ModEnd> SSL_CTX_set_tlsext_servername_callback ( section <S2SV_ModStart> ; # endif <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ] = { 0xCF , 0x9F , 0x3A , 0x9C , 0xC5 , 0xA5 , 0x89 , 0x27 , 0x6D , 0x2C , 0x2C , 0xF3 , 0xA6 , 0x00 , 0xD2 , 0x7C , 0xEA , 0xFA , 0xF2 , 0x43 , 0x4F , 0x49 , 0x0A , 0xFC , 0xA6 , 0xE7 , 0x75 , 0xCA , 0x07 , 0xDC , 0xA5 , 0xF2 , 0x83 , 0x4E , 0x5A , 0xA0 , 0xA0 , 0xF5 , 0x9C , 0xFD , 0x02 , 0xE6 , 0x9E , 0xFC , 0x01 , 0x59 , 0xD7 , 0xB6 , 0xC1 , 0x4E , 0xC0 , 0xB6 , 0x71 , 0x49 , 0xF0 , 0xC7 , 0xD5 , 0x2F , 0x8D , 0xDF , 0xD3 , 0xF1 , 0x82 , 0x82 , 0x23 , 0x33 , 0x13 , 0x93 , 0xEB , 0x50 , 0x29 , 0xFD , 0x1B , 0x5A , 0x2F , 0xD5 , 0x08 , 0x99 , 0x64 , 0xE9 , 0x7B , 0x1A , 0xDD , 0x68 , 0x16 , 0x08 , 0xD0 , 0x13 , 0x82 , 0xB6 , 0x86 , 0x62 , 0x76 , 0xAA , 0x16 , 0x14 , 0xCC , 0x86 , 0x72 , 0x26 , 0x45 , 0x8E , 0x2A , 0x82 , 0x5B , 0x6F , 0xC1 , 0xDF , 0xAA , 0x18 , 0x43 , 0xB8 , 0xAD , 0x84 , 0x52 , 0xF2 , 0xD9 , 0x9C , 0xC0 , 0x47 , 0x52 , 0x1B , 0x8E , 0x42 , 0xC4 , 0xD3 , 0x61 , 0x7B , 0x65 , 0xA7 , 0x69 , 0x03 , 0xB5 , 0xD4 , 0x6C , 0x83 , 0x6A , 0x46 , 0x73 , 0xAF , 0x76 , 0x77 , 0x70 , 0xC2 , 0xD0 , 0x74 , 0xFE , 0x78 , 0xF5 , 0x75 , 0x3B , 0xCE , 0xE2 , 0xB6 , 0xA0 , 0x25 , 0xE9 , 0xE8 , 0x4B , 0xA2 , 0xF1 , 0x20 , 0x88 , 0x13 , 0x07 , 0xED , 0x66 , 0xBC , 0x46 , 0xA1 , 0xB3 , 0x44 , 0xAF , 0x2C , 0xED , 0x73 , 0x75 , 0x3D , 0x14 , 0x6E , 0x43 , 0x92 , 0x40 , 0x99 , 0xB0 , 0xD1 , 0xBF , 0x2C , 0x4D , 0x0F , 0x2A , 0x63 , 0xF4 , 0x85 , 0x7B , 0x1B , 0x0E , 0x48 , 0x5A , 0x06 , 0x02 , 0xA6 , 0x3D , 0x9E , 0x78 , 0x05 , 0xA8 , 0x7C , 0xAD , 0x54 , 0x49 , 0xDE , 0x7A , 0xE6 , 0x36 , 0x5C , 0x50 , 0xFC , 0x09 <S2SV_ModEnd> , 0x81 , <S2SV_ModStart> , 0x81 , 0x9E , 0x83 , 0x53 , 0x8C <S2SV_ModEnd> , 0x42 , <S2SV_ModStart> , 0x42 , 0xEF , 0x12 , 0x36 , 0x4F , 0x22 , 0x16 , 0x2A , 0x15 , 0x88 , 0x83 , 0xA9 , 0x00 , 0x66 , 0x9E , 0xD1 , 0xDC , 0x0F , 0x54 , 0xC0 , 0x32 , 0x5C , 0x4C , 0x5E , 0xE2 , 0x3D , 0xBC , 0x56 , 0x89 , 0x75 , 0x28 , 0xA3 <S2SV_ModEnd> } ; static
<S2SV_ModStart> ] ) ; <S2SV_ModEnd> log_mode = new_mode
<S2SV_ModStart> ( CMD_INITIALIZE , & new_global_options , <S2SV_ModStart> eof ) { <S2SV_ModEnd> errstr = parse_service_option
<S2SV_ModStart> , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; memset ( & new_global_options , 0 <S2SV_ModStart> ) ) ; memset ( & new_service_options , 0 , sizeof ( SERVICE_OPTIONS ) ) ;
<S2SV_ModStart> NULL , NULL , NULL <S2SV_ModStart> parse_global_option ( CMD_PRINT_DEFAULTS , NULL
<S2SV_ModStart> ( CMD_SET_DEFAULTS , & new_global_options ,
<S2SV_ModStart> ( CMD_SET_VALUE , & new_global_options ,
<S2SV_ModStart> void options_free ( int current ) { GLOBAL_OPTIONS * global = current ? & global_options : & new_global_options ; SERVICE_OPTIONS * service = current ? & service_options : & new_service_options ; <S2SV_ModEnd> parse_global_option ( CMD_FREE <S2SV_ModStart> parse_global_option ( CMD_FREE , global <S2SV_ModStart> NULL ) ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; while ( service ) { SERVICE_OPTIONS * tmp = service ; service = service -> next ; tmp -> next = NULL ; service_free ( tmp ) ; } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ;
<S2SV_ModStart> & section ) || <S2SV_ModEnd> init_section ( 1 <S2SV_ModStart> section ) ) { s_log ( LOG_ERR , "Configuration<S2SV_blank>failed" ) ; options_free ( 0 ) ; <S2SV_ModStart> return 1 ; }
<S2SV_ModStart> ( CMD cmd , GLOBAL_OPTIONS * options <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> chroot_dir = NULL <S2SV_ModStart> : tmp = options -> chroot_dir ; options -> <S2SV_ModEnd> chroot_dir = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> chroot_dir = str_dup <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> compression = COMP_NONE <S2SV_ModStart> "deflate" ) ) options -> <S2SV_ModEnd> compression = COMP_DEFLATE <S2SV_ModStart> "zlib" ) ) options -> <S2SV_ModEnd> compression = COMP_ZLIB <S2SV_ModStart> # ifdef EGD_SOCKET options -> <S2SV_ModEnd> egd_sock = EGD_SOCKET <S2SV_ModStart> ; # else options -> <S2SV_ModEnd> egd_sock = NULL <S2SV_ModStart> : tmp = options -> egd_sock ; options -> <S2SV_ModEnd> egd_sock = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> egd_sock = str_dup <S2SV_ModStart> # ifdef USE_FIPS options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> . fips = FIPS_mode ( ) ? 1 : <S2SV_ModStart> ) break ; if ( ! strcasecmp ( arg , "yes" ) ) { <S2SV_ModStart> # ifdef USE_FIPS options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> = 1 ; # else return "FIPS<S2SV_blank>support<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available" ; # endif } else <S2SV_ModEnd> if ( ! <S2SV_ModStart> "no" ) ) { # ifdef USE_FIPS if ( FIPS_mode ( ) ) return "Failed<S2SV_blank>to<S2SV_blank>override<S2SV_blank>system-wide<S2SV_blank>FIPS<S2SV_blank>mode" ; options -> <S2SV_ModEnd> option . fips <S2SV_ModStart> = 0 ; # endif } else { <S2SV_ModEnd> return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; <S2SV_ModStart> return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; } <S2SV_ModEnd> return NULL ; <S2SV_ModStart> ; case CMD_PRINT_DEFAULTS <S2SV_ModEnd> : # ifdef <S2SV_ModStart> ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "fips" , FIPS_mode ( ) ? "yes" : "no" ) ; # endif break ; case CMD_PRINT_HELP : # ifdef USE_FIPS s_log ( LOG_NOTICE , <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 0 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 1 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 1 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> ) ) { options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> = 0 ; options -> <S2SV_ModEnd> option . log_stderr <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_ACTIVE <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_ACTIVE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_ERROR <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_ERROR <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> icon [ ICON_IDLE <S2SV_ModStart> ( ! ( options -> <S2SV_ModEnd> icon [ ICON_IDLE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_APPEND <S2SV_ModStart> "append" ) ) options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_APPEND <S2SV_ModStart> "overwrite" ) ) options -> <S2SV_ModEnd> log_file_mode = FILE_MODE_OVERWRITE <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> output_file = NULL <S2SV_ModStart> : tmp = options -> output_file ; options -> <S2SV_ModEnd> output_file = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> output_file = str_dup <S2SV_ModStart> if ( ! options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> . foreground && options -> output_file && options -> <S2SV_ModEnd> output_file [ 0 <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> : tmp = options -> pidfile ; options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> 0 ] ) options -> <S2SV_ModEnd> pidfile = str_dup <S2SV_ModStart> ) ; else options -> <S2SV_ModEnd> pidfile = NULL <S2SV_ModStart> if ( ! options -> <S2SV_ModEnd> option . foreground <S2SV_ModStart> . foreground && options -> pidfile && options -> <S2SV_ModEnd> pidfile [ 0 <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> random_bytes = RANDOM_BYTES <S2SV_ModStart> * tmp_str ; options -> <S2SV_ModEnd> random_bytes = ( <S2SV_ModStart> # ifdef RANDOM_FILE options -> <S2SV_ModEnd> rand_file = str_dup <S2SV_ModStart> ; # else options -> <S2SV_ModEnd> rand_file = NULL <S2SV_ModStart> : tmp = options -> rand_file ; options -> <S2SV_ModEnd> rand_file = NULL <S2SV_ModStart> ) break ; options -> <S2SV_ModEnd> rand_file = str_dup <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> "yes" ) ) options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> "no" ) ) options -> <S2SV_ModEnd> option . rand_write <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> "yes" ) ) options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> "no" ) ) options -> <S2SV_ModEnd> option . log_syslog <S2SV_ModStart> case CMD_SET_DEFAULTS : options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> "yes" ) ) options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> "no" ) ) options -> <S2SV_ModEnd> option . taskbar <S2SV_ModStart> case CMD_FREE : memset ( options , 0 , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_ModStart> ( ssl_configure ( options <S2SV_ModEnd> ) ) return
<S2SV_ModStart> = 1 ; if ( section == & service_options ) s_log ( LOG_ERR , "INTERNAL<S2SV_blank>ERROR:<S2SV_blank>Initializing<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults" ) ; else if ( section == & new_service_options ) s_log ( LOG_INFO , "Initializing<S2SV_blank>inetd<S2SV_blank>mode<S2SV_blank>configuration" ) ; else s_log ( LOG_INFO , "Initializing<S2SV_blank>service<S2SV_blank>[%s]" , section -> servname ) ; <S2SV_ModStart> == & service_options ) s_log ( LOG_DEBUG , "Deallocating<S2SV_blank>deployed<S2SV_blank>section<S2SV_blank>defaults" ) ; else if ( <S2SV_ModEnd> section == & <S2SV_ModStart> ( LOG_DEBUG , "Deallocating<S2SV_blank>temporary<S2SV_blank>section<S2SV_blank>defaults" <S2SV_ModEnd> ) ; else <S2SV_ModStart> break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> security_level = - 1 ; break ; case CMD_SET_COPY : section -> security_level = new_service_options . security_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "securityLevel" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 5 ) return "Illegal<S2SV_blank>security<S2SV_blank>level" ; section -> security_level = tmp_int ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d" , "securityLevel" , DEFAULT_SECURITY_LEVEL ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>set<S2SV_blank>the<S2SV_blank>security<S2SV_blank>level" , "securityLevel" ) ; break ; } # endif <S2SV_ModStart> "verify" ) ; <S2SV_ModEnd> break ; } <S2SV_ModStart> == & service_options || section == & new_service_options
<S2SV_ModStart> bio ) { BIO_free <S2SV_ModEnd> ( b64 )
<S2SV_ModStart> 'S' } ; static const uint8_t gss_request [ 8 ] = { 0 , 0 , 0 , 8 , 0x04 , 0xd2 , 0x16 , 0x30 } ; static const uint8_t gss_response [ 62 ] = { 'E' , 0 , 0 , 0 , 61 , 'S' , 'E' , 'R' , 'R' , 'O' , 'R' , 0 , 'C' , 'X' , 'X' , '0' , '0' , '0' , 0 , 'M' , 'S' , 'S' , 'L' , '<S2SV_blank>' , 'e' , 'x' , 'p' , 'e' , 'c' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'u' , 't' , '<S2SV_blank>' , 'n' , 'o' , 't' , '<S2SV_blank>' , 'r' , 'e' , 'q' , 'u' , 'e' , 's' , 't' , 'e' , 'd' , '<S2SV_blank>' , 'b' , 'y' , '<S2SV_blank>' , 'c' , 'l' , 'i' , 'e' , 'n' , 't' , 0 , 0 } ; <S2SV_ModStart> ) return NULL ; s_log ( LOG_DEBUG , "Started<S2SV_blank>server-side<S2SV_blank>psql<S2SV_blank>protcol<S2SV_blank>negotiation" ) <S2SV_ModStart> ; if ( ! <S2SV_ModStart> ( buffer , gss_request , sizeof gss_request <S2SV_ModEnd> ) ) { <S2SV_ModStart> { s_log ( LOG_INFO , "GSSAPI<S2SV_blank>encryption<S2SV_blank>requested,<S2SV_blank>rejecting<S2SV_blank>gracefully" ) ; <S2SV_ModEnd> s_write ( c <S2SV_ModStart> . fd , gss_response , sizeof gss_response ) ; throw_exception ( c , 2 ) ; } if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , "PostgreSQL<S2SV_blank>client<S2SV_blank>did<S2SV_blank>not<S2SV_blank>request<S2SV_blank>TLS,<S2SV_blank>rejecting" ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_DEBUG , "SSLRequest<S2SV_blank>received" ) ; s_write ( c , c -> local_wfd . fd ,
<S2SV_ModStart> , "session<S2SV_blank>authenticated" , cb_new_auth <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT
<S2SV_ModStart> endif log_flush ( LOG_MODE_BUFFER <S2SV_ModEnd> ) ; log_close
<S2SV_ModStart> int cmdline_status ; log_flush ( LOG_MODE_BUFFER ) ; <S2SV_ModStart> ( cmdline_status ) { log_flush ( LOG_MODE_ERROR ) ; return cmdline_status ; } options_free ( 1 ) <S2SV_ModEnd> ; options_apply ( <S2SV_ModStart> ( ) ) { unbind_ports ( ) ; options_free ( 1 ) ; options_defaults ( ) ; options_apply ( ) ; log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifdef HAVE_CHROOT <S2SV_ModStart> ( ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # endif if <S2SV_ModStart> 1 ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> if ( log_open <S2SV_ModStart> SINK_OUTFILE ) ) { log_flush ( LOG_MODE_ERROR ) ; return 1 ; } <S2SV_ModEnd> # ifndef USE_FORK
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT <S2SV_ModStart> 1 ) ; for ( <S2SV_ModEnd> opt = service_options <S2SV_ModStart> . next ; opt ; opt = opt -> next <S2SV_ModEnd> ) { unsigned <S2SV_ModStart> 0 ; } <S2SV_ModEnd> s_log ( LOG_DEBUG <S2SV_ModStart> servname ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> callback_ctx ) ) return 1 ; if ( c -> opt -> option . client || c -> opt -> protocol ) return 0 ; if ( c -> opt -> redirect_addr . names ) <S2SV_ModStart> , index_session_authenticated , NULL <S2SV_ModEnd> ) ; SSL_SESSION_free <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ) { # if defined ( USE_SSL ) if ( ! idata -> conn -> ssf ) { if ( option ( OPTSSLFORCETLS ) || ( query_quadoption ( OPT_SSLSTARTTLS , _ ( "Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?" ) ) != MUTT_NO ) ) { mutt_error _ ( "Encrypted<S2SV_blank>connection<S2SV_blank>unavailable" ) ; mutt_sleep ( 1 ) ; goto err_close_conn ; } } # endif
<S2SV_ModStart> } else { if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) { fprintf ( stderr , "ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" ) ; return 1 ; }
<S2SV_ModStart> FN_REFLEN ] ; memset ( buff , 0 , sizeof ( buff ) ) ;
<S2SV_ModStart> ; puts ( "Copyright<S2SV_blank>(c)<S2SV_blank>2011,<S2SV_blank>2015,<S2SV_blank>Oracle<S2SV_blank>and/or<S2SV_blank>its<S2SV_blank>affiliates.<S2SV_blank>" <S2SV_ModEnd> "All<S2SV_blank>rights<S2SV_blank>reserved.\\n" ) ;
<S2SV_ModStart> char query [ NAME_LEN + 100 <S2SV_ModEnd> ] ; MYSQL_FIELD <S2SV_ModStart> ) ) { my_snprintf <S2SV_ModEnd> ( query , <S2SV_ModStart> ( query , sizeof ( query ) ,
<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> opt_count ) { my_snprintf ( query , sizeof ( query ) <S2SV_ModEnd> , "select<S2SV_blank>count(*)<S2SV_blank>from<S2SV_blank>`%s`" , <S2SV_ModStart> ) ; } len = sizeof ( query ) ; len -= my_snprintf ( query , len , "show<S2SV_blank>/*!32332<S2SV_blank>FULL<S2SV_blank>*/<S2SV_blank>columns<S2SV_blank>from<S2SV_blank>`%s`" , table <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , "<S2SV_blank>like<S2SV_blank>\'" , <S2SV_ModStart> opt_show_keys ) { my_snprintf ( query , sizeof ( query ) , "show<S2SV_blank>keys<S2SV_blank>from<S2SV_blank>`%s`" , table <S2SV_ModEnd> ) ; if
<S2SV_ModStart> char query [ NAME_LEN + 100 ] ; int len <S2SV_ModEnd> ; MYSQL_RES * <S2SV_ModStart> MYSQL_ROW row ; len = sizeof ( query ) ; len -= my_snprintf ( query , len , "show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`%s`" , db <S2SV_ModEnd> ) ; if <S2SV_ModStart> [ 0 ] && len ) strxnmov ( query + strlen ( query ) , len <S2SV_ModEnd> , "<S2SV_blank>like<S2SV_blank>\'" ,
<S2SV_ModStart> char query [ NAME_LEN + 100 <S2SV_ModEnd> ] , rows <S2SV_ModStart> 1 ) { my_snprintf <S2SV_ModEnd> ( query , <S2SV_ModStart> ( query , sizeof ( query ) ,
<S2SV_ModStart> * f ; snprintf ( buf , sizeof ( buf ) <S2SV_ModEnd> , "%s.conf" , <S2SV_ModStart> } printf ( "\\\n<S2SV_blank><S2SV_blank><S2SV_blank>\\n\\n" <S2SV_ModEnd> , set ,
<S2SV_ModStart> my_regex_t re ; snprintf ( efbuf , sizeof ( efbuf ) <S2SV_ModEnd> , "REG_%s" ,
<S2SV_ModStart> ; break ; # include < sslopt - case . h >
<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> if ( opt_protocol
<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql_connection ) ; <S2SV_ModEnd> if ( opt_protocol
<S2SV_ModStart> opt_local_file ) ; SSL_SET_OPTIONS ( mysql ) ; <S2SV_ModEnd> if ( opt_protocol
<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> if ( opt_protocol
<S2SV_ModStart> NullS ) ; SSL_SET_OPTIONS ( & mysql ) ; <S2SV_ModEnd> if ( opt_protocol
<S2SV_ModStart> -> ssl_crlpath ) || ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) <S2SV_ModStart> . use_ssl = TRUE <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( mysql -> options . extension && mysql -> options . extension -> ssl_enforce ) { DBUG_ASSERT ( mysql -> options . use_ssl ) ; if ( ! ( mysql -> server_capabilities & CLIENT_SSL ) ) { set_mysql_extended_error ( mysql , CR_SSL_CONNECTION_ERROR , unknown_sqlstate , ER ( CR_SSL_CONNECTION_ERROR ) , "SSL<S2SV_blank>is<S2SV_blank>required<S2SV_blank>but<S2SV_blank>the<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>" "support<S2SV_blank>it" ) ; goto error ; } } if ( ( mysql -> server_capabilities & CLIENT_SSL ) && mysql -> options . use_ssl <S2SV_ModEnd> ) { struct <S2SV_ModStart> long ssl_error ; if ( ! mysql -> options . ssl_cipher ) { SET_OPTION ( ssl_cipher , default_ssl_cipher ) ; }
<S2SV_ModStart> exit_waiting ; } if ( self -> packetSize <= bufPos ) goto exit_error ;
<S2SV_ModStart> "wrong<S2SV_blank>wire<S2SV_blank>type" ) ; if ( ! allocate_field ( stream , field -> pField , field -> data_size , ( size_t ) ( * size + 1 ) ) ) return false ; field -> pData = * ( char * * ) field -> pField + field -> data_size * ( * size ) ; <S2SV_ModStart> size ) ++ <S2SV_ModEnd> ; initialize_pointer_field (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static SockState <S2SV_ModEnd> ChunkedDecode ( Request <S2SV_ModStart> * chunkStart ; SockState result = SOCK_READY <S2SV_ModEnd> ; NS_NONNULL_ASSERT ( <S2SV_ModStart> "\\r\\n" ) ; long chunkLength <S2SV_ModEnd> ; if ( <S2SV_ModStart> "ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>end-of-line" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> = '\\0' ; chunkLength = <S2SV_ModEnd> strtol ( chunkStart <S2SV_ModStart> ; if ( chunkLength < 0 ) { Ns_Log ( Warning , "ChunkedDecode:<S2SV_blank>negative<S2SV_blank>chunk<S2SV_blank>length" ) ; result = SOCK_BADREQUEST ; break ; } * p = '\\r' ; if ( <S2SV_ModStart> + 2 + chunkLength <S2SV_ModEnd> > end ) <S2SV_ModStart> "ChunkedDecode:<S2SV_blank>chunk<S2SV_blank>length<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer" ) ; result = SOCK_MORE <S2SV_ModEnd> ; break ; <S2SV_ModStart> + 2 , ( size_t ) chunkLength <S2SV_ModEnd> ) ; reqPtr <S2SV_ModStart> -> chunkWriteOff += ( size_t ) chunkLength <S2SV_ModEnd> ; * ( <S2SV_ModStart> ( writeBuffer + chunkLength <S2SV_ModEnd> ) = '\\0' <S2SV_ModStart> + 4u + ( size_t ) chunkLength <S2SV_ModEnd> ; chunkStart = <S2SV_ModStart> ; } return result <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; Ns_Log ( Debug <S2SV_ModEnd> , "===<S2SV_blank>length<S2SV_blank><<S2SV_blank>avail<S2SV_blank>(length<S2SV_blank>%" PRIuz <S2SV_ModStart> 0u ) { SockState chunkState <S2SV_ModEnd> ; size_t currentContentLength <S2SV_ModStart> size_t currentContentLength ; chunkState <S2SV_ModEnd> = ChunkedDecode ( <S2SV_ModStart> if ( ( chunkState == SOCK_MORE <S2SV_ModEnd> ) || ( <S2SV_ModStart> SOCK_MORE ; } else if ( chunkState != SOCK_READY ) { return chunkState ; }
<S2SV_ModStart> * s && ( <S2SV_ModStart> s != \'\\"\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> ) * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )
<S2SV_ModStart> , s + 2 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n" )
<S2SV_ModStart> [ LONG_STRING ] = "" <S2SV_ModStart> ( line , "%1023s<S2SV_blank>" <S2SV_ModEnd> ANUM "<S2SV_blank>" ANUM <S2SV_ModStart> ANUM "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%8191[^\\n]" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , "Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n" , line ) ; <S2SV_ModStart> return 0 ; }
<S2SV_ModStart> ) ) { if ( dlen < 2 ) break ; <S2SV_ModStart> dlen -= 2 <S2SV_ModEnd> ; * pt
<S2SV_ModStart> buf + 2 , sizeof ( obuf )
<S2SV_ModStart> buf + 2 , sizeof ( buf2 ) <S2SV_ModStart> buf + 2 , sizeof ( buf2 )
<S2SV_ModStart> char * in , size_t olen <S2SV_ModStart> += 4 ; if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ; <S2SV_ModStart> '=' ) { if ( len == olen ) return len ;
<S2SV_ModStart> ENCBASE64 ) { const int olen = <S2SV_ModEnd> 3 * len <S2SV_ModStart> 4 + 1 ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> out , it , olen
<S2SV_ModStart> buffer , encoded , sizeof ( buffer )
<S2SV_ModStart> out2 , out1 , sizeof ( out2 ) <S2SV_ModStart> out2 , out1 , sizeof ( out2 )
<S2SV_ModStart> 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
<S2SV_ModStart> ImapMbox mx ; size_t len = 0 ; <S2SV_ModStart> errstr ) ; len = <S2SV_ModStart> mbox ) , "%smailboxes<S2SV_blank>" <S2SV_ModEnd> , subscribe ? <S2SV_ModStart> "" : "un" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len , path , true <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data )
<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
<S2SV_ModStart> ) { goto bail <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } # <S2SV_ModStart> return 0 ; bail <S2SV_ModEnd> : imap_close_connection ( <S2SV_ModStart> adata ) ; <S2SV_ModEnd> FREE ( &
<S2SV_ModStart> char ) ) ; if ( fc . messages == NULL ) return - 1
<S2SV_ModStart> ; dlen -= 3 <S2SV_ModEnd> ; for (
<S2SV_ModStart> account . user , false <S2SV_ModStart> account . pass , false
<S2SV_ModStart> list . name , true
<S2SV_ModStart> p . str , false <S2SV_ModStart> ) , delim , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false
<S2SV_ModStart> dlen , buf , false
<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *
<S2SV_ModStart> return 1 ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ++ <S2SV_ModEnd> ) = '\\0'
<S2SV_ModStart> int rc ; if ( flags & IMAP_CMD_SINGLE ) { if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ; } <S2SV_ModStart> adata ) ; if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ;
<S2SV_ModStart> , "STARTTLS" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ; } mutt_socket_empty ( conn ) ;
<S2SV_ModStart> ) ) ; mutt_socket_empty ( adata -> conn ) ;
<S2SV_ModStart> rc = smtp_get_resp ( conn ) ; mutt_socket_empty
<S2SV_ModStart> ) return ; <S2SV_ModEnd> DEBUGMSGTL ( ( <S2SV_ModStart> add_mibfile ( entry <S2SV_ModEnd> , NULL )
<S2SV_ModStart> ; if ( <S2SV_ModEnd> Prefix != NULL
<S2SV_ModStart> dirname ) { <S2SV_ModEnd> const char * <S2SV_ModStart> , i ; <S2SV_ModEnd> DEBUGMSGTL ( ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> filename_count = scan_directory <S2SV_ModStart> 0 ) { <S2SV_ModEnd> for ( i <S2SV_ModStart> , '/' ) <S2SV_ModEnd> ) == 0 <S2SV_ModStart> File = oldFile <S2SV_ModEnd> ; free (
<S2SV_ModStart> char * d_name <S2SV_ModEnd> ) { FILE <S2SV_ModStart> tmpstr ) ; <S2SV_ModEnd> fclose ( fp
<S2SV_ModStart> NULL ; } sptr = find_sec_mod ( newpdu -> securityModel ) ; if ( sptr && sptr -> pdu_clone ) { ret = sptr -> pdu_clone ( pdu , newpdu <S2SV_ModEnd> ) ; if <S2SV_ModStart> NULL ; } <S2SV_ModEnd> } return newpdu
<S2SV_ModStart> ; def -> pdu_clone = usm_clone ; def ->
<S2SV_ModStart> struct usmStateReference * ref = <S2SV_ModEnd> old ; if <S2SV_ModStart> ; if ( ! ref ) return ; if ( -- ref -> refcnt > 0 ) return ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_name ) <S2SV_ModStart> usr_name ) ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_engine_id ) <S2SV_ModStart> usr_engine_id ) ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_auth_protocol ) <S2SV_ModStart> usr_auth_protocol ) ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_priv_protocol ) <S2SV_ModStart> ; if ( ref <S2SV_ModEnd> -> usr_auth_key_length && <S2SV_ModStart> -> usr_auth_key_length && ref <S2SV_ModEnd> -> usr_auth_key ) <S2SV_ModStart> { SNMP_ZERO ( ref <S2SV_ModEnd> -> usr_auth_key , <S2SV_ModStart> -> usr_auth_key , ref <S2SV_ModEnd> -> usr_auth_key_length ) <S2SV_ModStart> ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_auth_key ) <S2SV_ModStart> } if ( ref <S2SV_ModEnd> -> usr_priv_key_length && <S2SV_ModStart> -> usr_priv_key_length && ref <S2SV_ModEnd> -> usr_priv_key ) <S2SV_ModStart> { SNMP_ZERO ( ref <S2SV_ModEnd> -> usr_priv_key , <S2SV_ModStart> -> usr_priv_key , ref <S2SV_ModEnd> -> usr_priv_key_length ) <S2SV_ModStart> ; SNMP_FREE ( ref <S2SV_ModEnd> -> usr_priv_key ) <S2SV_ModStart> ) ; } SNMP_FREE ( ref <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> usmStateReference * retval ; retval = <S2SV_ModEnd> calloc ( 1 <S2SV_ModStart> ) ) ; if ( retval ) retval -> refcnt = 1 ;
<S2SV_ModStart> ] ; # if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> switch ( action
<S2SV_ModStart> break ; # if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> case MODE_SET_RESERVE1 : <S2SV_ModStart> } } # if ! defined ( NETSNMP_NO_WRITE_SUPPORT ) && ENABLE_EXTEND_WRITE_ACCESS <S2SV_ModEnd> if ( need_to_validate
<S2SV_ModStart> "setregid" ) ; <S2SV_ModEnd> char * arg <S2SV_ModStart> 0 ] = "/bin/sh" <S2SV_ModEnd> ; arg [
<S2SV_ModStart> fp ) ; unlink ( RUN_LIB_FILE ) ;
<S2SV_ModStart> # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> save_cpu ( ) <S2SV_ModStart> rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <S2SV_ModEnd> FILE * rj
<S2SV_ModStart> ) ) { char t <S2SV_ModEnd> = from_hex ( <S2SV_ModStart> [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> "Flooding<S2SV_blank>was<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>this<S2SV_blank>HTTP/2<S2SV_blank>session,<S2SV_blank>and<S2SV_blank>it<S2SV_blank>must<S2SV_blank>be<S2SV_blank>" "closed" ; case NGHTTP2_ERR_TOO_MANY_SETTINGS : return "SETTINGS<S2SV_blank>frame<S2SV_blank>contained<S2SV_blank>more<S2SV_blank>than<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>entries" ;
<S2SV_ModStart> + 1 ; if ( iframe -> max_niv - 1 > session -> max_settings ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , "SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; }
<S2SV_ModStart> { return NGHTTP2_ERR_INVALID_ARGUMENT ; } if ( settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH > session -> max_settings ) { return NGHTTP2_ERR_TOO_MANY_SETTINGS
<S2SV_ModStart> = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; ( * session_ptr ) -> max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS ; <S2SV_ModStart> max_outbound_ack ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS ) && option -> max_settings ) { ( * session_ptr ) -> max_settings = option -> max_settings ; }
<S2SV_ModStart> ( pSuite , "session_too_many_settings" , test_nghttp2_session_too_many_settings ) || ! CU_add_test ( pSuite ,
<S2SV_ModStart> break ; } if ( session -> obq_flood_counter_ >= session -> max_outbound_ack && ! ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) ) { return NGHTTP2_ERR_FLOODED ; }
<S2SV_ModStart> yday ; ngx_uint_t <S2SV_ModEnd> sec , min <S2SV_ModStart> , leap ; if ( t < 0 ) { t = 0 ; } days = t <S2SV_ModEnd> / 86400 ; <S2SV_ModStart> / 86400 ; sec = t % 86400 ; <S2SV_ModStart> % 7 ; hour = sec <S2SV_ModEnd> / 3600 ; <S2SV_ModStart> / 3600 ; sec <S2SV_ModEnd> %= 3600 ; <S2SV_ModStart> ; min = sec <S2SV_ModEnd> / 60 ; <S2SV_ModStart> 60 ; sec %= <S2SV_ModEnd> 60 ; days
<S2SV_ModStart> % 86400 ; if ( days > 2932896 ) { days = 2932896 ; sec = 86399 ; }
<S2SV_ModStart> ) ; } r -> expect_tested = 1 ; if ( ngx_http_discard_request_body ( r ) != NGX_OK ) { r -> keepalive = 0 ; }
<S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
<S2SV_ModStart> . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> inverse_db_table [ y & 255 <S2SV_ModStart> inverse_db_table [ y & 255
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> ++ r ; if <S2SV_ModEnd> ( pow ( <S2SV_ModStart> , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int <S2SV_ModStart> dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r
<S2SV_ModStart> ; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> 1 ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> -> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } else <S2SV_ModStart> g -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ) + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )
<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
<S2SV_ModStart> xfr_cmd , fname <S2SV_ModEnd> ) ; free
<S2SV_ModStart> int fd , const char * cmd , const char * args_extra <S2SV_ModEnd> ) { pid_t <S2SV_ModStart> long fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> ; term_remove ( <S2SV_ModStart> STO ) ; argc = 0 ; r = split_quoted <S2SV_ModEnd> ( cmd , <S2SV_ModStart> ( cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>command\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , "No<S2SV_blank>command<S2SV_blank>given\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , "$<S2SV_blank>%s<S2SV_blank>%s\\n" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> fd_printf ( STDERR_FILENO <S2SV_ModStart> ( STDERR_FILENO , "exec:<S2SV_blank>%s\\n" , strerror ( errno ) <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ; exit ( RUNCMD_EXEC_FAIL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , j ; if ( * rdnSeqBuf_offset >= rdnSeqBuf_len ) { # ifdef DEBUG_TLS printf ( "[TLS]<S2SV_blank>%s()<S2SV_blank>[buffer<S2SV_blank>capacity<S2SV_blank>reached][%u]\\n" , __FUNCTION__ , rdnSeqBuf_len ) ; # endif return - 1 ; }
<S2SV_ModStart> , rdnSeqBuf [ 2048 <S2SV_ModEnd> ] = {
<S2SV_ModStart> += len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; <S2SV_ModStart> 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload
<S2SV_ModStart> ; diff = <S2SV_ModEnd> packet -> payload_packet_len <S2SV_ModStart> payload_packet_len - a1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ) { diff = ndpi_min ( diff , sizeof ( flow -> initial_binary_bytes ) ) ;
<S2SV_ModStart> , packet -> content_disposition_line . ptr = NULL , packet -> content_disposition_line . len = 0 , packet ->
<S2SV_ModStart> client_hash ) { u_int32_t <S2SV_ModEnd> offset = 22 <S2SV_ModStart> ] ) ; if ( len > UINT32_MAX - 4 - offset ) goto invalid_payload ; <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = ';' ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; if <S2SV_ModStart> ] ) ; offset += 4 ; <S2SV_ModStart> client_hash ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> += len ; } if ( len > UINT32_MAX - offset ) goto invalid_payload ; offset += <S2SV_ModEnd> len ; #
<S2SV_ModStart> = 0 ; int16_t ovpn_payload_len = <S2SV_ModEnd> packet -> payload_packet_len <S2SV_ModStart> packet -> payload_packet_len ; if ( ovpn_payload_len <S2SV_ModStart> ovpn_payload += 2 , ovpn_payload_len -= 2 ; <S2SV_ModStart> dest ) , ovpn_payload_len <S2SV_ModEnd> ) ; # <S2SV_ModStart> ( ( ( ovpn_payload_len <S2SV_ModEnd> == 112 ) <S2SV_ModStart> || ( ( ovpn_payload_len <S2SV_ModEnd> == 80 ) <S2SV_ModStart> 0 ) { u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET ( hmac_size ) ; <S2SV_ModStart> = ovpn_payload [ offset <S2SV_ModEnd> ] ; if <S2SV_ModStart> 0 ) { offset += <S2SV_ModEnd> 1 + alen <S2SV_ModStart> ; if ( ( offset + 8 ) <= ovpn_payload_len ) { session_remote = & ovpn_payload [ offset ] ; if ( <S2SV_ModStart> 1 ; } } else failed = 1 ;
<S2SV_ModStart> ( packet -> payload_packet_len >= 3 && packet ->
<S2SV_ModStart> ( out , "[URL:<S2SV_blank>%s][StatusCode:<S2SV_blank>%u]" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , "[Content-Type:<S2SV_blank>%s]" <S2SV_ModEnd> , flow -> <S2SV_ModStart> ( out , "[User-Agent:<S2SV_blank>%s]" <S2SV_ModEnd> , flow ->
<S2SV_ModStart> == 1719 ) { if ( ( packet -> payload_packet_len >= 5 ) && <S2SV_ModEnd> ( packet -> <S2SV_ModStart> ] == 0x16 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x80 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> ] == 0x06 ) && ( <S2SV_ModEnd> packet -> payload <S2SV_ModStart> == 0x00 ) )
<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "stats<S2SV_blank>%s<S2SV_blank>unrecognized" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized" , filegen_file ) ; continue ; }
<S2SV_ModStart> protostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> cryptostats ) ; <S2SV_ModEnd> filegen_register ( statsdir <S2SV_ModStart> timingstats ) ; <S2SV_ModEnd> step_callback = &
<S2SV_ModStart> { char prefix <S2SV_ModEnd> ; char * <S2SV_ModStart> char * type ; switch ( <S2SV_ModEnd> ( yyvsp [ <S2SV_ModStart> . String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> + 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> ) ] . <S2SV_ModStart> String ) ) ) ; } break ; case 235 : # line 1082 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 "ntp_parser.y" { ( yyval <S2SV_ModEnd> . Queue ) <S2SV_ModStart> . Queue ) <S2SV_ModEnd> = enqueue_in_new_queue ( <S2SV_ModStart> = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] . <S2SV_ModStart> break ; case <S2SV_ModEnd> 238 : # <S2SV_ModStart> : # line 1092 <S2SV_ModEnd> "ntp_parser.y" { if <S2SV_ModStart> : # line 1100 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1101 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1105 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1116 <S2SV_ModEnd> "ntp_parser.y" { cfgt <S2SV_ModStart> : # line 1130 <S2SV_ModEnd> "ntp_parser.y" { old_config_style <S2SV_ModStart> : # line 1134 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1135 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1139 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1140 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1144 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1145 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1150 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1154 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1158 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1162 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1163 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1168 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1172 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1173 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1178 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1180 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1182 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1184 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> : # line 1186 <S2SV_ModEnd> "ntp_parser.y" { ( <S2SV_ModStart> ; # line 3836 <S2SV_ModEnd> "ntp_parser.c" default :
<S2SV_ModStart> ) & utf8str ) ; if ( 0 != ret ) return LOG_RTERR ( pCborCtxt , ret
<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
<S2SV_ModStart> fmt ) { return bad_format_check ( "^" SAFE_STRING "%s" SAFE_STRING "%lu" SAFE_STRING "%lu" SAFE_STRING "$" , fmt <S2SV_ModEnd> ) ; }
<S2SV_ModStart> else if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> { if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
<S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; }
<S2SV_ModStart> im ) ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int bad_format_imginfo ( <S2SV_ModStart> fmt ) { return bad_format_check ( "^" SAFE_STRING "%s" SAFE_STRING "%lu" SAFE_STRING "%lu" SAFE_STRING "$" , fmt <S2SV_ModEnd> ) ; }
<S2SV_ModStart> else if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> { if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
<S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; } <S2SV_ModStart> : if ( bad_format_axis ( optarg ) ) { <S2SV_ModEnd> return ; }
<S2SV_ModStart> im ) ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> } else { struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; }
<S2SV_ModStart> = NULL ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;
<S2SV_ModStart> vlen ) { VALUE v ; <S2SV_ModStart> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_type_val , Qnil ) ) ) { <S2SV_ModStart> ) ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , rb_str_new ( val , vlen ) ) ; rb_hash_aset ( hh , content_type_val , a ) ; } <S2SV_ModStart> ) ) { if ( Qnil == ( v = rb_hash_lookup2 ( hh , content_length_val , Qnil ) ) ) { <S2SV_ModStart> ) ) ; } else { rb_raise ( rb_eArgError , "Multiple<S2SV_blank>Content-Length<S2SV_blank>headers." ) ; } <S2SV_ModStart> vlen ) ; volatile VALUE kval ; <S2SV_ModStart> ; } } kval = <S2SV_ModEnd> rb_str_new ( hkey <S2SV_ModStart> + 5 ) ; if ( Qnil == ( v = rb_hash_lookup2 ( hh , kval , Qnil ) ) ) { rb_hash_aset ( hh , kval <S2SV_ModStart> ) ; } else { volatile VALUE a = rb_ary_new ( ) ; rb_ary_push ( a , v ) ; rb_ary_push ( a , sval ) ; rb_hash_aset ( hh , kval , a ) ; } }
<S2SV_ModStart> ( env , remote_addr_val , req_remote_addr ( req ) ) ; rb_hash_aset ( env , server_port_val , req_server_port ( req ) ) ; rb_hash_aset ( env , <S2SV_ModStart> server_name_val , req_server_name <S2SV_ModEnd> ( req )
<S2SV_ModStart> ( req_class , "remote_addr" , remote_addr , 0 ) ; rb_define_method ( req_class , <S2SV_ModStart> ( & rack_version_val ) ; remote_addr_val = rb_str_new_cstr ( "REMOTE_ADDR" ) ; rb_gc_register_address ( & remote_addr_val
<S2SV_ModStart> & agoo_con_cat , "Server<S2SV_blank>with<S2SV_blank>pid<S2SV_blank>%d<S2SV_blank>accepted<S2SV_blank>connection<S2SV_blank>%llu<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>[%d]<S2SV_blank>from<S2SV_blank>%s" <S2SV_ModEnd> , getpid ( <S2SV_ModStart> con -> sock , con -> remote
<S2SV_ModStart> -> up ; memcpy ( c -> req -> remote , c -> remote , sizeof ( c -> remote ) ) ;
<S2SV_ModStart> { if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) && <S2SV_ModStart> ) if ( ( data -> schemata [ cid ] + len <= data -> schemadatalen ) &&
<S2SV_ModStart> multipart_media ; struct range_data * r = & clt -> clt_ranges ; struct range * range <S2SV_ModEnd> ; size_t content_length <S2SV_ModStart> ; size_t content_length = 0 <S2SV_ModStart> nranges , ret <S2SV_ModEnd> ; char content_range <S2SV_ModStart> if ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , st <S2SV_ModStart> st -> st_size ) ) < 1 <S2SV_ModEnd> ) { code <S2SV_ModStart> path ) ; r -> range_media = media ; <S2SV_ModEnd> if ( nranges <S2SV_ModStart> 1 ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> goto abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu\\r\\n" "Content-Type:<S2SV_blank>%s/%s\\r\\n" "Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret + <S2SV_ModEnd> range -> end <S2SV_ModStart> + 1 ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu--\\r\\n" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto abort <S2SV_ModStart> ; content_length += ret <S2SV_ModEnd> ; ( void <S2SV_ModStart> media_subtype ) , "byteranges;<S2SV_blank>boundary=%llu" , clt -> clt_boundary <S2SV_ModEnd> ) ; media <S2SV_ModStart> multipart_media ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret = <S2SV_ModStart> case 0 : close ( fd ) ; <S2SV_ModStart> break ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event" ; <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt -> <S2SV_ModStart> EV_WRITE ) ; <S2SV_ModEnd> bufferevent_free ( clt <S2SV_ModStart> ; abort : <S2SV_ModEnd> if ( fd
<S2SV_ModStart> sshd_hostkey_sign ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> void ) { <S2SV_ModEnd> struct monitor * <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return mon ;
<S2SV_ModStart> comp -> type <S2SV_ModEnd> ) ) !=
<S2SV_ModStart> ( r = <S2SV_ModEnd> sshbuf_put_cstring ( b
<S2SV_ModStart> ( r = <S2SV_ModEnd> sshbuf_put_stringb ( m
<S2SV_ModStart> ssh ) { int r <S2SV_ModEnd> ; debug ( <S2SV_ModStart> = 0 ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> ( r = ssh_packet_enable_delayed_compress <S2SV_ModEnd> ( ssh ) <S2SV_ModStart> return r ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ( r = <S2SV_ModEnd> ssh_packet_set_postauth ( ssh
<S2SV_ModStart> . compression ? "zlib@openssh.com,none" : "none,zlib@openssh.com" <S2SV_ModEnd> ; myproposal [
<S2SV_ModStart> "none" ; } <S2SV_ModEnd> if ( options
<S2SV_ModStart> pmonitor ) ; <S2SV_ModEnd> while ( waitpid
<S2SV_ModStart> goto nextline ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } if (
<S2SV_ModStart> sshbuf * b = NULL <S2SV_ModStart> char * pkalg = NULL <S2SV_ModStart> u_char * pkblob = NULL <S2SV_ModStart> , * sig = NULL <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> r ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done <S2SV_ModStart> b ) ; <S2SV_ModEnd> auth2_record_key ( authctxt <S2SV_ModStart> ) ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } <S2SV_ModStart> ca_s ) ; free ( sig ) ;
<S2SV_ModStart> REG_EXTENDED | REG_NOSUB ; int ret <S2SV_ModStart> 0 ) ; ret = <S2SV_ModEnd> regexec ( & <S2SV_ModStart> , 0 ) ; regfree ( & preg ) ; if ( ret
<S2SV_ModStart> ( peerkey && <S2SV_ModEnd> EVP_PKEY_cmp ( peerkey <S2SV_ModStart> , localkey ) != 1
<S2SV_ModStart> , av , "cDdksE:a:P:t:" <S2SV_ModEnd> ) ) != <S2SV_ModStart> : k_flag ++ ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( "-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> ; if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ( pledge ( "stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec" <S2SV_ModEnd> , NULL )
<S2SV_ModStart> stderr , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" ) ;
<S2SV_ModStart> } if ( mailfrom && maddr -> user [ 0 ] == '\\0' && maddr -> domain [ 0 ] == '\\0' ) return ( 1 ) ; if ( maddr -> user [ 0 ] == '\\0' || <S2SV_ModStart> -> user ) ) return ( 0 ) ; if ( maddr -> domain [ 0 ] == '\\0' ) { ( void ) strlcpy ( maddr -> domain , domain , sizeof ( maddr -> domain ) ) ; } if ( <S2SV_ModEnd> ! valid_domainpart ( <S2SV_ModStart> domain ) ) return ( 0 ) ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> & O_ACCMODE ) != O_RDONLY <S2SV_ModEnd> || ( flags <S2SV_ModStart> ( flags & ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ; int r , dontmax = 0 <S2SV_ModStart> return SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;
<S2SV_ModStart> options . disable_forwarding || ! use_privsep
<S2SV_ModStart> options . disable_forwarding && use_privsep
<S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
<S2SV_ModStart> ) return ; if ( ensure_cloned_binary ( ) < 0 ) bail ( "could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>we<S2SV_blank>are<S2SV_blank>a<S2SV_blank>cloned<S2SV_blank>binary" ) ;
<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
<S2SV_ModStart> ; epoll_t * file <S2SV_ModEnd> = _cast_epoll ( <S2SV_ModStart> ; if ( ! file || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( <S2SV_ModStart> & ret , file <S2SV_ModEnd> -> host_fd , <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> 0 ; size_t canonnamelen_in <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; size_t canonnamelen_out = 0 ; struct oe_addrinfo p_out ; memset ( & p_out , 0 , sizeof ( struct oe_addrinfo ) ) ; <S2SV_ModEnd> if ( oe_syscall_getaddrinfo_read_ocall <S2SV_ModStart> handle , & p_out . <S2SV_ModEnd> ai_flags , & <S2SV_ModStart> ai_flags , & p_out . <S2SV_ModEnd> ai_family , & <S2SV_ModStart> ai_family , & p_out . <S2SV_ModEnd> ai_socktype , & <S2SV_ModStart> ai_socktype , & p_out . ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> ai_addrlen , & p_out . <S2SV_ModEnd> ai_addrlen , NULL <S2SV_ModStart> , NULL , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ) ; } switch ( p_out . ai_family ) { case OE_AF_INET : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; case OE_AF_INET6 : case OE_AF_INET6_WIN : case OE_AF_UNSPEC : if ( p_out . ai_addrlen != sizeof ( struct oe_sockaddr_in6 ) ) { ret = OE_EAI_FAIL ; goto done ; } break ; default : ret = OE_EAI_FAIL ; goto done ; } if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( p_out . <S2SV_ModEnd> ai_addrlen && ! <S2SV_ModStart> ( 1 , p_out . <S2SV_ModEnd> ai_addrlen ) ) <S2SV_ModStart> } if ( canonnamelen_out <S2SV_ModEnd> && ! ( <S2SV_ModStart> ( 1 , canonnamelen_out <S2SV_ModEnd> ) ) ) <S2SV_ModStart> done ; } canonnamelen_in = canonnamelen_out ; <S2SV_ModStart> -> ai_protocol , p_out . <S2SV_ModEnd> ai_addrlen , & <S2SV_ModStart> -> ai_addr , canonnamelen_in , & canonnamelen_out <S2SV_ModEnd> , p -> <S2SV_ModStart> } if ( ( p -> ai_flags != p_out . ai_flags ) || ( p -> ai_family != p_out . ai_family ) || ( p -> ai_socktype != p_out . ai_socktype ) || ( p -> ai_protocol != p_out . ai_protocol ) || ( p -> ai_addrlen != p_out . ai_addrlen ) || ( canonnamelen_out != canonnamelen_in ) || ( canonnamelen_out && p -> ai_canonname [ canonnamelen_out - 1 ] != '\\0' ) ) { ret = OE_EAI_FAIL ; goto done ; } if ( tail ) { tail -> ai_next = p ; tail = p ; } else { head = p ; tail = p ; } p = NULL ; } if ( handle ) { int retval = - 1 <S2SV_ModEnd> ; if (
<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! addr || ! addrlen <S2SV_ModStart> OE_EINVAL ) ; <S2SV_ModEnd> addrlen_in = * <S2SV_ModStart> = * addrlen ; if ( addrlen_in < 0 ) OE_RAISE_ERRNO ( OE_EINVAL ) <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ;
<S2SV_ModStart> = 0 ; oe_socklen_t addrlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! addr || ! addrlen ) OE_RAISE_ERRNO ( OE_EINVAL ) ; addrlen_in = * addrlen ; if ( addrlen_in < 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> oe_syscall_getsockname_ocall ( & <S2SV_ModStart> -> host_fd , <S2SV_ModEnd> addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen_in >= addrlen_out ) * addrlen = addrlen_out ;
<S2SV_ModStart> = 0 ; oe_socklen_t optlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! optval || ! optlen <S2SV_ModStart> OE_EINVAL ) ; <S2SV_ModEnd> optlen_in = * <S2SV_ModStart> , optlen_in , & optlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( optlen_out > optlen_in ) optlen_out = optlen_in ; * optlen = optlen_out ;
<S2SV_ModStart> = 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ( ret > ( ssize_t ) ( data_size ) ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret >
<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> ; oe_socklen_t addrlen_in = 0 ; oe_socklen_t addrlen_out <S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( src_addr && <S2SV_ModEnd> addrlen ) addrlen_in <S2SV_ModStart> , flags , <S2SV_ModEnd> src_addr , addrlen_in <S2SV_ModStart> , addrlen_in , & addrlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( src_addr && addrlen ) { if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; * addrlen = addrlen_out ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> msg_namelen , & namelen_out <S2SV_ModEnd> , buf , <S2SV_ModStart> msg_controllen , & controllen_out <S2SV_ModEnd> , flags ) <S2SV_ModStart> } if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ! buf ) || count > OE_SSIZE_MAX <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
<S2SV_ModStart> size_t * buf_size_out , size_t * data_size_out <S2SV_ModStart> ; if ( data_size_out ) * data_size_out = 0 ; if ( <S2SV_ModStart> || ! buf_size_out || ! data_size_out <S2SV_ModStart> buf_size_out = buf_size ; * data_size_out = data_size <S2SV_ModStart> = buf_size ; * data_size_out = data_size ;
<S2SV_ModStart> buf || src + src_size < src || src + src_size
<S2SV_ModStart> int flags , <S2SV_ModEnd> struct oe_sockaddr *
<S2SV_ModStart> ) arg4 ; <S2SV_ModEnd> struct oe_sockaddr * <S2SV_ModStart> * dest_add = ( <S2SV_ModEnd> struct oe_sockaddr *
<S2SV_ModStart> * r ; <S2SV_ModEnd> ngx_http_core_main_conf_t * cmcf <S2SV_ModStart> * cmcf ; int pr_not_chunked = 0 ; <S2SV_ModStart> = body ; <S2SV_ModEnd> } else if <S2SV_ModStart> 0 ) { sr -> request_body = NULL ; } else { if ( ! r -> headers_in . chunked ) { pr_not_chunked = 1 ; } if ( sr -> request_body && sr -> request_body -> temp_file ) { if ( ngx_http_lua_copy_in_file_request_body ( sr ) <S2SV_ModEnd> != NGX_OK ) <S2SV_ModStart> NGX_ERROR ; } } } <S2SV_ModEnd> if ( ngx_http_lua_copy_request_headers <S2SV_ModStart> sr , r , pr_not_chunked <S2SV_ModStart> return NGX_ERROR ; <S2SV_ModEnd> } sr ->
<S2SV_ModStart> , ngx_http_request_t * pr , int pr_not_chunked <S2SV_ModEnd> ) { ngx_table_elt_t <S2SV_ModStart> { ngx_table_elt_t * clh , * <S2SV_ModStart> ; ngx_uint_t i ; u_char * p ; off_t len ; dd ( "before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> NGX_ERROR ; } if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> -> headers_in . <S2SV_ModStart> headers_in . headers ) ; if ( clh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> { return NGX_ERROR <S2SV_ModStart> NGX_ERROR ; } clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , "%O" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( "sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( "Content-Length" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) "Content-Length" , sizeof ( "Content-Length" ) - 1 ) == 0 ) { continue ; } dd ( "sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> "after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d" , ( <S2SV_ModStart> ( int ) pr <S2SV_ModEnd> -> headers_in .
<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , "." ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
<S2SV_ModStart> = 0 ; ( void ) <S2SV_ModEnd> utimes ( vect <S2SV_ModStart> ] , tv <S2SV_ModEnd> ) ; }
<S2SV_ModStart> struct stat stb <S2SV_ModEnd> ; BUF * <S2SV_ModStart> , targisdir , wrerr <S2SV_ModEnd> ; char ch <S2SV_ModStart> ; wrerr = 0 <S2SV_ModEnd> ; statbytes = <S2SV_ModStart> { if ( ! wrerr <S2SV_ModEnd> ) { if <S2SV_ModStart> count ) { note_err ( "%s:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> != 0 && ! wrerr <S2SV_ModEnd> && atomicio ( <S2SV_ModStart> count ) { note_err ( "%s:<S2SV_blank>%s" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr <S2SV_ModEnd> && ( ! <S2SV_ModStart> != 0 ) note_err <S2SV_ModEnd> ( "%s:<S2SV_blank>truncate:<S2SV_blank>%s" , <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( pflag <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> { # endif note_err <S2SV_ModEnd> ( "%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s" , <S2SV_ModStart> errno ) ) <S2SV_ModEnd> ; } } <S2SV_ModStart> - 1 ) note_err ( np , "%s:<S2SV_blank>close:<S2SV_blank>%s" , np , strerror ( errno ) ) ; <S2SV_ModEnd> ( void ) <S2SV_ModStart> ( setimes && ! wrerr <S2SV_ModEnd> ) { setimes <S2SV_ModStart> 1 ) { note_err <S2SV_ModEnd> ( "%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s" , <S2SV_ModStart> ) ) ; } } if ( note_err ( NULL ) == 0 ) <S2SV_ModEnd> ( void ) <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> } done :
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> while ( sshbuf_len <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } switch <S2SV_ModStart> "lifetime<S2SV_blank>already<S2SV_blank>set" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> "confirm<S2SV_blank>already<S2SV_blank>set" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } * <S2SV_ModStart> "maxsign<S2SV_blank>not<S2SV_blank>valid<S2SV_blank>here" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> "maxsign<S2SV_blank>already<S2SV_blank>set" ) ; r = SSH_ERR_INVALID_FORMAT ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto out <S2SV_ModEnd> ; } break <S2SV_ModStart> ( r = parse_key_constraint_extension ( m , sk_providerp ) ) != 0 ) goto out ; break ; default : error_f ( <S2SV_ModEnd> "Unknown<S2SV_blank>constraint<S2SV_blank>%d" , ctype <S2SV_ModStart> ctype ) ; r = SSH_ERR_FEATURE_UNSUPPORTED ; goto out ; } } r = 0 ; out : return r <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;
<S2SV_ModStart> ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
<S2SV_ModStart> 128 ] ; <S2SV_ModEnd> OBJ_obj2txt ( obj_txt <S2SV_ModStart> 0 ) ; BIO_printf <S2SV_ModEnd> ( bio , <S2SV_ModStart> ( bio , "%s\\n" , obj_txt <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rrec ) ; if ( <S2SV_ModStart> ( s ) < 0 ) return - 1 <S2SV_ModStart> listen ) { if ( <S2SV_ModStart> rr -> seq_num ) < 0 ) return - 1 ; dtls1_record_bitmap_update ( s , bitmap <S2SV_ModStart> again ; } dtls1_record_bitmap_update ( s , bitmap ) ;
<S2SV_ModStart> 0 ) ; if ( <S2SV_ModStart> . seq_num ) < 0 ) return - 1
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free
<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
<S2SV_ModStart> } if ( data_body == NULL && in_bio == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; goto err ; } if ( <S2SV_ModStart> } if ( <S2SV_ModEnd> in_bio != NULL <S2SV_ModStart> != NULL ) <S2SV_ModEnd> { bio =
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , sig_len ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_ECDSA_SIG ( s , & der ) ; if ( derlen != sig_len || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
<S2SV_ModStart> ) { BIGNUM * a , * c , * d , * <S2SV_ModEnd> e ; int <S2SV_ModStart> ; int i , ret = 0 ; a = BN_new ( ) ; c = BN_new ( ) ; d = BN_new ( ) ; e = BN_new ( ) ; if ( a == NULL || c == NULL || d == NULL || e == NULL ) { goto err ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> { BN_bntest_rand ( <S2SV_ModEnd> a , 40 <S2SV_ModStart> ) ; a -> <S2SV_ModEnd> neg = rand_neg <S2SV_ModStart> ; BN_sqr ( c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ( bp , <S2SV_ModEnd> c ) ; <S2SV_ModStart> } BN_div ( d , e , c , <S2SV_ModEnd> a , ctx <S2SV_ModStart> ; BN_sub ( d , d , <S2SV_ModEnd> a ) ; <S2SV_ModStart> ! BN_is_zero ( <S2SV_ModEnd> d ) || <S2SV_ModStart> ! BN_is_zero ( e ) ) { fprintf ( stderr , "Square<S2SV_blank>test<S2SV_blank>failed!\\n" ) ; goto err ; } } BN_hex2bn ( & a , "80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , "<S2SV_blank>*<S2SV_blank>" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , "<S2SV_blank>-<S2SV_blank>" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , "\\n" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( stderr , "Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>" "different<S2SV_blank>results!\\n" ) ; goto err ; } BN_hex2bn ( & a , "80000000000000000000000080000001FFFFFFFE000000000000000000000000" ) ; BN_sqr ( c , a , ctx ) ; if ( bp != NULL ) { if ( ! results ) { BN_print ( bp , a ) ; BIO_puts ( bp , "<S2SV_blank>*<S2SV_blank>" ) ; BN_print ( bp , a ) ; BIO_puts ( bp , "<S2SV_blank>-<S2SV_blank>" ) ; } BN_print ( bp , c ) ; BIO_puts ( bp , "\\n" ) ; } BN_mul ( d , a , a , ctx ) ; if ( BN_cmp ( c , d ) ) { fprintf ( stderr , "Square<S2SV_blank>test<S2SV_blank>failed:<S2SV_blank>BN_sqr<S2SV_blank>and<S2SV_blank>BN_mul<S2SV_blank>produce<S2SV_blank>" "different<S2SV_blank>results!\\n" ) ; goto err ; } ret = 1 ; err : if ( a != NULL ) BN_free ( a ) ; if ( c != NULL ) BN_free ( c ) ; if ( d != NULL ) BN_free ( d ) ; if ( e != NULL ) BN_free ( e <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al =
<S2SV_ModStart> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )
<S2SV_ModStart> , * tmpin = NULL , * tmpout <S2SV_ModStart> = dcont ; if ( ! ( flags & SMIME_BINARY ) && dcont ) { tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } <S2SV_ModStart> ( cms , tmpout ) ; if ( ! cmsbio ) goto err ; SMIME_crlf_copy ( dcont , cmsbio , flags & ~ SMIME_TEXT ) ; if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } } else { cmsbio = CMS_dataInit ( cms , <S2SV_ModStart> goto err ; } <S2SV_ModStart> : if ( ! ( flags & SMIME_BINARY ) && dcont ) { do_free_upto ( cmsbio , tmpout ) ; if ( tmpin != dcont ) BIO_free ( tmpin ) ; } else { if ( <S2SV_ModStart> cmsbio ) ; } if ( tmpout && out != tmpout ) BIO_free_all ( tmpout ) ;
<S2SV_ModStart> BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } <S2SV_ModEnd> if ( flags <S2SV_ModStart> CMS_TEXT ) { <S2SV_ModEnd> if ( !
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> -> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
<S2SV_ModStart> i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( "YYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYMMDDHHMMSS+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( "YYYYMMDDHHMMZ" ) - 1 ; int max_length = sizeof ( "YYYYMMDDHHMMSS.fff+hhmm" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> ) { boolean_t is_attr <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> . dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data . <S2SV_ModStart> pcwszFilePath ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( "PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( "PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> : return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; case CERT_E_UNTRUSTEDROOT : return "The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted." ; case TRUST_E_NOSIGNATURE : return "Not<S2SV_blank>digitally<S2SV_blank>signed." ; case TRUST_E_EXPLICIT_DISTRUST : return "One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."
<S2SV_ModStart> kw ) { PyUnicodeObject <S2SV_ModEnd> * logical = <S2SV_ModStart> base = FRIBIDI_TYPE_RTL <S2SV_ModEnd> ; int clean <S2SV_ModStart> , "base_direction" , <S2SV_ModEnd> "clean" , "reordernsm" <S2SV_ModStart> , kw , "U|iii" <S2SV_ModEnd> , kwargs , <S2SV_ModStart> base , & <S2SV_ModEnd> clean , & <S2SV_ModStart> reordernsm ) ) { <S2SV_ModStart> return NULL ; } <S2SV_ModStart> FRIBIDI_TYPE_ON ) ) { <S2SV_ModStart> base ) ; } return unicode_log2vis <S2SV_ModEnd> ( logical , <S2SV_ModStart> reordernsm ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; buffer -> buffer = ( char * ) fbh -> data ; imp_sth -> stmt -> bind [ i ] . buffer_length = fbh -> length ; imp_sth -> stmt -> bind [ i ] .
<S2SV_ModStart> # endif int <S2SV_ModEnd> prepare_retval ; MYSQL_BIND <S2SV_ModStart> ( stderr , "ERROR:<S2SV_blank>Trying<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>new<S2SV_blank>stmt<S2SV_blank>while<S2SV_blank>we<S2SV_blank>have<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>already<S2SV_blank>not<S2SV_blank>closed<S2SV_blank>one<S2SV_blank>\\n" <S2SV_ModEnd> ) ; imp_sth <S2SV_ModStart> imp_xxh ) , "\\t\\tERROR:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>return<S2SV_blank>MYSQL_STMT<S2SV_blank>structure<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>from<S2SV_blank>mysql_stmt_init():<S2SV_blank>ERROR<S2SV_blank>NO:<S2SV_blank>%d<S2SV_blank>ERROR<S2SV_blank>MSG:%s\\n" <S2SV_ModEnd> , mysql_errno ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> imp_sth -> bind <S2SV_ModStart> ++ ) { bind -> buffer_type = MYSQL_TYPE_STRING <S2SV_ModEnd> ; bind ->
<S2SV_ModStart> 1 ; char * err_msg <S2SV_ModEnd> ; D_imp_xxh ( <S2SV_ModStart> ) ) { err_msg = SvPVX ( sv_2mortal ( newSVpvf ( <S2SV_ModEnd> "Binding<S2SV_blank>non-numeric<S2SV_blank>field<S2SV_blank>%d,<S2SV_blank>value<S2SV_blank>%s<S2SV_blank>as<S2SV_blank>a<S2SV_blank>numeric!" , param_num <S2SV_ModStart> value , 0 ) )
<S2SV_ModStart> ) ) { if ( imp_dbh -> pmysql )
<S2SV_ModStart> ; int result ; int fresh = 0 <S2SV_ModStart> pmysql ) { fresh = 1 ; <S2SV_ModStart> ; if ( fresh && <S2SV_ModStart> ! result ) { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <S2SV_ModStart> pmysql ) ; imp_dbh -> pmysql = NULL ; }
<S2SV_ModStart> : if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> ; client -> <S2SV_ModEnd> pool = get_pool
<S2SV_ModStart> if ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> ; if ( <S2SV_ModEnd> size_left < 4
<S2SV_ModStart> uint32_t id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> out ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image , <S2SV_ModStart> ( image , fg , out <S2SV_ModEnd> ) ; }
<S2SV_ModStart> NULL ) ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <S2SV_ModEnd> ) ) { <S2SV_ModStart> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; }
<S2SV_ModStart> entry . uncompressed_filesize || read <= 8
<S2SV_ModStart> TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
<S2SV_ModStart> { char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> ( ! eof && vars -> str . c != vars -> ptr
<S2SV_ModStart> long elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , "Bad<S2SV_blank>unserialize<S2SV_blank>data" ) ; return - 1 ; } <S2SV_ModStart> ) ; return - 1 <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; # line 501 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE <S2SV_ModStart> : # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { return <S2SV_ModStart> } # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : <S2SV_ModStart> ; # line 869 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref <S2SV_ModStart> } # line 612 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : <S2SV_ModStart> ; # line 717 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> } # line 795 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : <S2SV_ModStart> ; # line 704 "ext/standard/var_unserializer.re" { long elements ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements <S2SV_ModEnd> ) ; } <S2SV_ModStart> } # line 833 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : <S2SV_ModStart> ; # line 683 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : <S2SV_ModStart> ; # line 648 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 931 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : <S2SV_ModStart> ; # line 615 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 985 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : <S2SV_ModStart> ; # line 605 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1083 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : <S2SV_ModStart> ; # line 590 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1157 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : <S2SV_ModStart> ; # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1211 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : <S2SV_ModStart> ; # line 556 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1226 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 : <S2SV_ModStart> ; # line 549 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1236 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : <S2SV_ModStart> ; # line 526 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1282 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : <S2SV_ModStart> ; # line 505 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1326 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } # <S2SV_ModStart> } # line 877 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0
<S2SV_ModStart> ; # line 576 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE <S2SV_ModStart> 'O' : goto yy4 <S2SV_ModEnd> ; case 'N' <S2SV_ModStart> 'R' : goto yy6 <S2SV_ModEnd> ; case 'S' <S2SV_ModStart> 'S' : goto yy7 <S2SV_ModEnd> ; case 'a' <S2SV_ModStart> 'a' : goto yy8 <S2SV_ModEnd> ; case 'b' <S2SV_ModStart> 'b' : goto yy9 <S2SV_ModEnd> ; case 'd' <S2SV_ModStart> 'd' : goto yy10 <S2SV_ModEnd> ; case 'i' <S2SV_ModStart> 'i' : goto yy11 <S2SV_ModEnd> ; case 'o' <S2SV_ModStart> 'r' : goto yy13 <S2SV_ModEnd> ; case 's' <S2SV_ModStart> 's' : goto yy14 <S2SV_ModEnd> ; case '}' <S2SV_ModStart> '}' : goto yy15 <S2SV_ModEnd> ; default : <S2SV_ModStart> default : goto yy2 ; } yy2 : ++ YYCURSOR <S2SV_ModEnd> ; yy3 : <S2SV_ModStart> : # line 951 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { return <S2SV_ModStart> } # line 636 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : <S2SV_ModStart> ':' ) goto yy17 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ';' ) goto yy19 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy21 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy22 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy23 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy24 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy25 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy26 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy27 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> ':' ) goto yy28 <S2SV_ModEnd> ; goto yy3 <S2SV_ModStart> yy3 ; yy14 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy29 ; goto yy3 ; yy15 <S2SV_ModStart> ; # line 945 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref <S2SV_ModStart> } # line 689 "ext/standard/var_unserializer.c" <S2SV_ModEnd> yy17 : yych <S2SV_ModStart> ) { goto yy31 <S2SV_ModEnd> ; } if <S2SV_ModStart> '+' ) goto yy30 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : ++ YYCURSOR ; # line 629 "ext/standard/var_unserializer.re" { * p = YYCURSOR ; ZVAL_NULL ( rval ) ; return 1 ; } # line 707 "ext/standard/var_unserializer.c" yy21 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy33 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; } yy22 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy36 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; goto yy18 ; yy23 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy39 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; goto yy18 ; yy24 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '1' ) goto yy42 ; goto yy18 ; yy25 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy43 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy44 ; if ( yych <= '.' ) goto yy45 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy46 ; if ( yych <= 'H' ) goto yy18 ; goto yy48 ; } else { if ( yych == 'N' ) goto yy49 ; goto yy18 ; } } yy26 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy50 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy50 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; goto yy18 ; } yy27 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy53 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy53 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; goto yy18 ; } yy28 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy56 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy56 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; goto yy18 ; } yy29 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy59 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; goto yy18 ; yy30 <S2SV_ModEnd> : yych = <S2SV_ModStart> ) { goto yy31 ; } goto yy18 ; yy31 <S2SV_ModEnd> : ++ YYCURSOR <S2SV_ModStart> ) { goto yy31 <S2SV_ModEnd> ; } if <S2SV_ModStart> if ( yych <= ':' ) goto yy62 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych == <S2SV_ModEnd> ';' ) goto <S2SV_ModStart> ';' ) goto yy63 ; goto yy18 ; yy36 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy37 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy37 ; if ( yych <= ':' ) goto yy65 ; goto yy18 ; yy39 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy40 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy40 ; if ( yych <= ':' ) goto yy66 ; goto yy18 ; yy42 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy67 ; goto yy18 ; yy43 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy45 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; yy44 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { <S2SV_ModEnd> if ( yych <S2SV_ModStart> ( yych != '.' ) goto yy18 ; } else { if ( yych <= '9' ) goto yy46 ; if ( yych == 'I' ) goto yy48 ; goto yy18 ; } yy45 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy69 ; goto yy18 ; yy46 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy69 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy46 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy71 ; if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy48 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy74 ; goto yy18 ; yy49 : yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy75 ; goto yy18 ; yy50 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy51 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy51 ; if ( yych == ';' ) goto yy76 ; goto yy18 ; yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy54 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy54 ; if ( yych <= ':' ) goto yy78 ; goto yy18 ; yy56 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy57 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy57 ; if ( yych == ';' ) goto yy79 ; goto yy18 ; yy59 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy60 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy60 ; if ( yych <= ':' ) goto yy81 ; goto yy18 ; yy62 : yych = * ++ YYCURSOR ; if ( yych == <S2SV_ModStart> \'"\' ) goto yy82 ; goto yy18 ; yy63 : <S2SV_ModEnd> ++ YYCURSOR ; <S2SV_ModStart> ; # line 580 "ext/standard/var_unserializer.re" { zend_long id ; * p = YYCURSOR <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 0 ; id = parse_iv <S2SV_ModEnd> ( start + <S2SV_ModStart> + 2 ) - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } if ( Z_ISREF_P ( rval_ref ) ) { ZVAL_COPY ( rval , rval_ref ) ; } else { ZVAL_NEW_REF ( rval_ref , rval_ref ) ; ZVAL_COPY ( rval , rval_ref ) ; } return 1 ; } # line 982 "ext/standard/var_unserializer.c" yy65 : yych = * ++ YYCURSOR ; if ( yych == \'"\' ) goto yy84 ; goto yy18 ; yy66 : yych = * ++ YYCURSOR ; if ( yych == '{' ) goto yy86 ; goto yy18 ; yy67 : ++ YYCURSOR ; # line 635 "ext/standard/var_unserializer.re" <S2SV_ModEnd> { * p <S2SV_ModStart> * p = YYCURSOR ; ZVAL_BOOL ( rval , parse_iv ( <S2SV_ModStart> start + 2 ) ) ; return 1 <S2SV_ModEnd> ; } # <S2SV_ModStart> } # line 999 "ext/standard/var_unserializer.c" yy69 <S2SV_ModEnd> : ++ YYCURSOR <S2SV_ModStart> YYCURSOR ) < 4 <S2SV_ModEnd> ) YYFILL ( <S2SV_ModStart> ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { <S2SV_ModEnd> if ( yych <S2SV_ModStart> '9' ) goto yy69 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy73 ; } else { if ( yych == 'e' ) goto yy73 ; goto yy18 ; } } yy71 : <S2SV_ModEnd> ++ YYCURSOR ; <S2SV_ModStart> ; # line 683 "ext/standard/var_unserializer.re" { # if SIZEOF_ZEND_LONG == 4 use_double : # endif * p = YYCURSOR ; ZVAL_DOUBLE ( rval , zend_strtod ( ( const char * ) <S2SV_ModEnd> start + 2 <S2SV_ModStart> start + 2 , NULL ) ) ; return 1 <S2SV_ModEnd> ; } # <S2SV_ModStart> } # line 1028 "ext/standard/var_unserializer.c" yy73 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { <S2SV_ModEnd> if ( yych <S2SV_ModStart> '+' ) goto yy88 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy88 <S2SV_ModEnd> ; if ( <S2SV_ModStart> '9' ) goto yy89 ; goto yy18 ; } yy74 : yych = * ++ YYCURSOR ; if ( yych == 'F' ) goto yy91 ; goto yy18 ; yy75 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy91 ; goto yy18 ; yy76 : <S2SV_ModEnd> ++ YYCURSOR ; <S2SV_ModStart> ; # line 641 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1076 "ext/standard/var_unserializer.c" yy78 : yych = * ++ YYCURSOR ; if ( yych == \'"\' ) goto yy92 ; goto yy18 ; yy79 : <S2SV_ModEnd> ++ YYCURSOR ; <S2SV_ModStart> ; # line 605 "ext/standard/var_unserializer.re" { zend_long id ; <S2SV_ModEnd> * p = <S2SV_ModStart> = YYCURSOR ; if ( ! var_hash ) return 0 ; id = <S2SV_ModEnd> parse_iv ( start <S2SV_ModStart> + 2 ) - 1 ; if ( id == - 1 || ( rval_ref = var_access ( var_hash , id ) ) == NULL ) { return 0 ; } if ( rval_ref == rval ) { return 0 ; } if ( Z_ISUNDEF_P ( rval_ref ) || ( Z_ISREF_P ( rval_ref ) && Z_ISUNDEF_P ( Z_REFVAL_P ( rval_ref ) ) ) ) { return 0 ; } ZVAL_COPY ( rval , rval_ref <S2SV_ModStart> } # line 1107 "ext/standard/var_unserializer.c" yy81 : yych = * ++ YYCURSOR ; if ( yych == \'"\' ) goto yy94 ; goto yy18 ; yy82 <S2SV_ModEnd> : ++ YYCURSOR <S2SV_ModStart> ; # line 793 "ext/standard/var_unserializer.re" { size_t len , len2 , len3 , maxlen ; zend_long elements ; char * str ; zend_string * class_name ; zend_class_entry * ce ; int incomplete_class = 0 ; int custom_object = 0 ; zval user_func ; zval retval ; zval args [ 1 ] <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } len2 = len = parse_uiv <S2SV_ModEnd> ( start + <S2SV_ModStart> + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { <S2SV_ModEnd> * p = <S2SV_ModStart> * p = <S2SV_ModEnd> start + 2 <S2SV_ModStart> start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'"\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( str , "0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = zend_string_init ( str , len , 0 ) ; do { if ( ! unserialize_allowed_class ( class_name , classes ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } BG ( serialize_lock ) ++ ; ce = zend_lookup_class ( class_name ) ; if ( ce ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } ZVAL_STRING ( & user_func , PG ( unserialize_callback_func ) ) ; ZVAL_STR_COPY ( & args [ 0 ] , class_name ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , & user_func , & retval , 1 , args , 0 , NULL ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } php_error_docref ( NULL , E_WARNING , "defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & retval ) ; if ( EG ( exception ) ) { zend_string_release ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; return 0 ; } BG ( serialize_lock ) ++ ; if ( ( ce = zend_lookup_class ( class_name ) ) == NULL ) { php_error_docref ( NULL , E_WARNING , "Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for" , Z_STRVAL ( user_func ) ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } BG ( serialize_lock ) -- ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & args [ 0 ] ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( elements < 0 ) { zend_string_release ( class_name ) ; return 0 ; } if ( incomplete_class ) { php_store_class_name ( rval , ZSTR_VAL ( class_name ) , len2 ) ; } zend_string_release ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1266 "ext/standard/var_unserializer.c" yy84 : ++ YYCURSOR ; # line 724 "ext/standard/var_unserializer.re" { size_t len , maxlen ; zend_string * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'"\' ) { zend_string_free ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; <S2SV_ModEnd> return 0 ; <S2SV_ModStart> 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STR ( rval , str <S2SV_ModEnd> ) ; return <S2SV_ModStart> 1 ; } # line 1303 "ext/standard/var_unserializer.c" yy86 : ++ YYCURSOR ; # line 758 "ext/standard/var_unserializer.re" { zend_long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } array_init_size <S2SV_ModEnd> ( rval , <S2SV_ModStart> ( rval , elements ) ; if ( elements ) { zend_hash_real_init ( Z_ARRVAL_P ( rval ) , 0 ) ; } if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_P ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } # line 1330 "ext/standard/var_unserializer.c" yy88 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy96 ; goto yy18 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy89 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; if ( yych == ';' ) goto yy71 ; goto yy18 ; yy91 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy97 ; goto yy18 ; yy92 : ++ YYCURSOR ; # line 782 "ext/standard/var_unserializer.re" { zend_long elements ; if ( ! var_hash ) return 0 ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 || elements >= HT_MAX_SIZE ) { return 0 ; } return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } # line 1366 "ext/standard/var_unserializer.c" yy94 : ++ YYCURSOR ; # line 692 "ext/standard/var_unserializer.re" { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'"\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; ZVAL_STRINGL <S2SV_ModEnd> ( rval , <S2SV_ModStart> ( rval , str , len ) ; <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } # line 1401 "ext/standard/var_unserializer.c" yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy89 ; goto yy18 ; yy97 : ++ YYCURSOR ; # line 667 "ext/standard/var_unserializer.re" { * p = YYCURSOR ; if ( ! strncmp ( ( char * ) start + 2 , "NAN" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , "INF" , 3 ) ) { ZVAL_DOUBLE ( rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( ( char * ) start + 2 , "-INF" , 4 ) ) { ZVAL_DOUBLE ( rval , - php_get_inf ( ) ) ; } else { ZVAL_NULL ( rval ) ; } return 1 ; } # line 1425 "ext/standard/var_unserializer.c" } # line 953 "ext/standard/var_unserializer.re" return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> 0 ; } <S2SV_ModEnd> var_push_dtor ( var_hash <S2SV_ModStart> data ) ; <S2SV_ModEnd> zval_dtor ( &
<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive" ) ; RETURN_FALSE ; }
<S2SV_ModStart> = 1 ; apr_brigade_cleanup ( brigade ) ;
<S2SV_ModStart> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException
<S2SV_ModStart> + 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> = p ; const <S2SV_ModStart> p ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , "Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>" MYSQLND_SZ_T_SPEC "<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }
<S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP <S2SV_ModEnd> ( var2 ) <S2SV_ModStart> ( var2 ) != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> ; convert_to_double ( & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> var2 ) ; <S2SV_ModStart> var2 ) ; } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> ( float ) <S2SV_ModStart> ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { <S2SV_ModEnd> RETURN_FALSE ; } <S2SV_ModStart> ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
<S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; affine <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
<S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; x <S2SV_ModStart> ; x = Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> tmp ) ; } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; y <S2SV_ModStart> ; y = Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> tmp ) ; }
<S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; m1 <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> case IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; m2 <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default
<S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; convert_to_long <S2SV_ModStart> ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> var ) ; } <S2SV_ModStart> SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; convert_to_long <S2SV_ModStart> ; convert_to_long ( & lval <S2SV_ModEnd> ) ; points <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> ; } } }
<S2SV_ModStart> -> socket_mode = 0660 <S2SV_ModEnd> ; if (
<S2SV_ModStart> get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
<S2SV_ModStart> out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return NULL ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> out ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image , <S2SV_ModStart> ( image , fg , out <S2SV_ModEnd> ) ; }
<S2SV_ModStart> return NULL ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> Z_LVAL_P ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> } if ( <S2SV_ModEnd> * p == <S2SV_ModStart> ; } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; } hash
<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
<S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
<S2SV_ModStart> ; # line 496 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { YYCTYPE <S2SV_ModStart> : # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { return <S2SV_ModStart> } # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 : <S2SV_ModStart> ; # line 855 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { php_error_docref <S2SV_ModStart> } # line 607 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 : <S2SV_ModStart> ; # line 708 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 785 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 : <S2SV_ModStart> ; # line 699 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { if <S2SV_ModStart> } # line 819 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 : <S2SV_ModStart> ; # line 678 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 : <S2SV_ModStart> ; # line 643 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 917 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 : <S2SV_ModStart> ; # line 610 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { size_t <S2SV_ModStart> } # line 971 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 : <S2SV_ModStart> ; # line 600 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1069 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 : <S2SV_ModStart> ; # line 585 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1143 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 : <S2SV_ModStart> ; # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { # <S2SV_ModStart> } # line 1197 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 : <S2SV_ModStart> ; # line 551 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1212 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 : <S2SV_ModStart> ; # line 544 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { * <S2SV_ModStart> } # line 1222 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 : <S2SV_ModStart> ; # line 521 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1268 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 : <S2SV_ModStart> ; # line 500 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { long <S2SV_ModStart> } # line 1312 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } # <S2SV_ModStart> } # line 863 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return 0
<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
<S2SV_ModStart> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( cidx == NULL ) { goto fail1 ; }
<S2SV_ModStart> border < 0 || color < 0 <S2SV_ModStart> { return ; } if ( ! im -> trueColor ) { if ( ( color > ( im -> colorsTotal - 1 ) ) || ( border > ( im -> colorsTotal - 1 ) ) ) { return ; }
<S2SV_ModStart> border < 0 || color < 0
<S2SV_ModStart> php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> * * tmp ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
<S2SV_ModStart> php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> q = p ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
<S2SV_ModStart> = U_ZERO_ERROR ; buflen ++ ;
<S2SV_ModStart> { char * start , * <S2SV_ModStart> 0 ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> = memchr ( start <S2SV_ModEnd> , '&' , <S2SV_ModStart> -> end - start <S2SV_ModEnd> ) ; if <S2SV_ModStart> eof ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> end ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> ( exception_ce , "%s" ,
<S2SV_ModStart> classes = NULL ; zval * retval <S2SV_ModStart> ; } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY
<S2SV_ModStart> ; if ( zend_hash_find <S2SV_ModEnd> ( ht ,
<S2SV_ModStart> # ifdef HAVE_IPV6 <S2SV_ModEnd> if ( * <S2SV_ModStart> 1 ) { char * <S2SV_ModStart> - 2 ) , * e = NULL <S2SV_ModStart> * portno = strtol <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> colon ) { char * e = NULL ; <S2SV_ModStart> * portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( str <S2SV_ModStart> ) ; } } <S2SV_ModEnd> if ( get_err <S2SV_ModStart> NULL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM ( <S2SV_ModStart> old_bin_num ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> return ptr ; }
<S2SV_ModStart> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
<S2SV_ModStart> var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept ;
<S2SV_ModStart> ( ! offset || ! ht
<S2SV_ModStart> ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
<S2SV_ModStart> ) ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> -> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;
<S2SV_ModStart> int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long <S2SV_ModStart> id_table ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table . <S2SV_ModStart> . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> xattr_id_table_start <S2SV_ModStart> ( id_table ) ) ) ) { ERROR ( "read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ) + ( ( long long )
<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( "parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
<S2SV_ModStart> { long long table_start ; if ( sBlk . s . xattr_id_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . xattr_id_table_start >= sBlk . s . bytes_used ) { ERROR ( "read_filesystem_tables:<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_xattrs_from_disk <S2SV_ModStart> == 0 ) goto corrupted ; } else table_start = sBlk . s . bytes_used ; if ( sBlk . s . id_table_start >= table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>id<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } if ( sBlk . s . no_ids == 0 ) { ERROR ( "read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } if ( sBlk . s . no_ids > ( sBlk . s . inodes * 2L ) ) { ERROR ( "read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>id<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } if ( read_id_table <S2SV_ModEnd> ( & table_start <S2SV_ModStart> == FALSE ) goto corrupted ; if ( sBlk . s . lookup_table_start != SQUASHFS_INVALID_BLK ) { if ( sBlk . s . lookup_table_start >= table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>lookup<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } <S2SV_ModEnd> if ( parse_exports_table <S2SV_ModStart> == FALSE ) goto corrupted ; } if ( sBlk . s . fragments != 0 ) { if ( sBlk . s . fragment_table_start >= table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } if ( sBlk . s . fragments > sBlk . s . inodes ) { ERROR ( "read_filesystem_tables:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_fragment_table <S2SV_ModStart> read_fragment_table ( & table_start ) == FALSE ) goto corrupted ; } else { if ( sBlk . s . fragment_table_start != table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>fragment<S2SV_blank>table<S2SV_blank>start<S2SV_blank>invalid<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } } if ( sBlk . s . directory_table_start >= table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>directory<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } if ( read_directory_table ( sBlk . s . directory_table_start , table_start ) == FALSE ) goto corrupted ; if ( sBlk . s . inode_table_start >= sBlk . s . directory_table_start ) { ERROR ( "read_filesystem_tables:<S2SV_blank>inode<S2SV_blank>table<S2SV_blank>start<S2SV_blank>too<S2SV_blank>large<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; goto corrupted ; } <S2SV_ModEnd> if ( read_inode_table <S2SV_ModStart> == FALSE ) goto corrupted <S2SV_ModEnd> ; if ( <S2SV_ModStart> return TRUE ; corrupted : ERROR ( "File<S2SV_blank>system<S2SV_blank>corruption<S2SV_blank>detected\\n" ) ; return FALSE ;
<S2SV_ModStart> long long * table_start <S2SV_ModEnd> ) { int <S2SV_ModStart> , i ; long long <S2SV_ModEnd> bytes = SQUASHFS_FRAGMENT_BYTES <S2SV_ModStart> = SQUASHFS_FRAGMENT_BYTES ( ( long long ) <S2SV_ModStart> = SQUASHFS_FRAGMENT_INDEXES ( ( long long ) sBlk . s . fragments ) ; int length = SQUASHFS_FRAGMENT_INDEX_BYTES ( ( long long ) sBlk . s . fragments ) ; long long * fragment_table_index ; if ( length != ( * table_start - sBlk . s . fragment_table_start ) ) { ERROR ( "read_fragment_table:<S2SV_blank>Bad<S2SV_blank>fragment<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return FALSE ; } <S2SV_ModEnd> TRACE ( "read_fragment_table:<S2SV_blank>%d<S2SV_blank>fragments,<S2SV_blank>reading<S2SV_blank>%d<S2SV_blank>fragment<S2SV_blank>indexes<S2SV_blank>" <S2SV_ModStart> fragment_table_start ) ; fragment_table_index = alloc_index_table ( indexes ) ; <S2SV_ModEnd> fragment_table = malloc <S2SV_ModStart> . fragment_table_start , length <S2SV_ModEnd> , fragment_table_index ) <S2SV_ModStart> ) ; * table_start <S2SV_ModEnd> = fragment_table_index [
<S2SV_ModStart> NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
<S2SV_ModStart> / 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
<S2SV_ModStart> ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;
<S2SV_ModStart> ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
<S2SV_ModStart> pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> } num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )
<S2SV_ModStart> charlen ; } if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;
<S2SV_ModStart> pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> = 0 ; check_stack_depth ( ) ;
<S2SV_ModStart> ) ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> ; int size ; int base_size <S2SV_ModStart> ++ ; } base_size = sizeof ( path -> <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) * npts ; size = offsetof ( PATH , <S2SV_ModEnd> p [ 0 <S2SV_ModStart> 0 ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; path =
<S2SV_ModStart> size ; int base_size ; int <S2SV_ModStart> ) ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ] ) + base_size ; if ( base_size / npts != <S2SV_ModStart> 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; poly =
<S2SV_ModStart> query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) )
<S2SV_ModStart> ( & state ) ; StaticAssertStmt ( MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP , "possible<S2SV_blank>overflow<S2SV_blank>in<S2SV_blank>txid_current_snapshot()"
<S2SV_ModStart> int i ; <S2SV_ModEnd> txid xmin , <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> if ( nxip <S2SV_ModStart> || nxip > TXID_SNAPSHOT_MAX_NXIP <S2SV_ModEnd> ) goto bad_format
<S2SV_ModStart> VARBITLEN ( arg2 ) ; if ( bitlen1 > VARBITMAXLEN - bitlen2 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , VARBITMAXLEN ) )
<S2SV_ModStart> slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }
<S2SV_ModStart> slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }
<S2SV_ModStart> [ MAXDATELEN + MAXDATEFIELDS <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( str ) > MAXDATELEN <S2SV_ModEnd> ) { errno
<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
<S2SV_ModStart> ] = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart> nf ++ ; <S2SV_ModEnd> } * numfields
<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> ) { errno <S2SV_ModStart> = PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_ModEnd> free ( result <S2SV_ModStart> NULL ; } <S2SV_ModEnd> errno = 0
<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ) != 0 <S2SV_ModEnd> ) { errno
<S2SV_ModStart> { # line 62 <S2SV_ModEnd> "dt_test2.pgc" date date1 <S2SV_ModStart> ; # line 63 <S2SV_ModEnd> "dt_test2.pgc" timestamp ts1 <S2SV_ModStart> ; # line 64 <S2SV_ModEnd> "dt_test2.pgc" char * <S2SV_ModStart> ; # line 65 <S2SV_ModEnd> "dt_test2.pgc" interval * <S2SV_ModStart> ; # line 66 <S2SV_ModEnd> "dt_test2.pgc" date * <S2SV_ModStart> ; # line 67 <S2SV_ModEnd> "dt_test2.pgc" int i
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> size_t pathlen ; <S2SV_ModStart> '\\0' ; } res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( PR_LOG_WARNING <S2SV_ModStart> ( PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno = EPERM
<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( "No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( "pci<S2SV_blank>deinit<S2SV_blank>%s\\n"
<S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( "No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pr_notice ( "pci<S2SV_blank>init<S2SV_blank>%s\\r\\n" <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; bzero ( <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; bzero ( <S2SV_ModStart> mr ) ; if ( error != 0 ) goto pci_emul_init_fail <S2SV_ModEnd> ; return 0 <S2SV_ModStart> fi_name ) ; if ( ! ops ) { pr_warn ( "No<S2SV_blank>driver<S2SV_blank>for<S2SV_blank>device<S2SV_blank>[%s]\\n" , fi -> fi_name ) ; continue ; } <S2SV_ModEnd> pci_emul_deinit ( ctx
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> modify_bar_registration ( struct <S2SV_ModStart> ) ; return 0 <S2SV_ModStart> break ; } return error <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> bus ) { <S2SV_ModEnd> return ( pci_businfo
<S2SV_ModStart> ; } } <S2SV_ModEnd> dsdt_line ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"
<S2SV_ModStart> case PCIBAR_MEMHI64 : <S2SV_ModEnd> mask = ~ <S2SV_ModStart> ; default : pr_err ( "%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n" , __func__ , dev -> bar [ idx ] . type ) ; return <S2SV_ModEnd> ; } pci_set_cfgdata32
<S2SV_ModStart> uint16_t sts ; <S2SV_ModEnd> reallen = roundup2
<S2SV_ModStart> msicap msicap ; return <S2SV_ModStart> , 0 ) || <S2SV_ModEnd> pci_emul_add_capability ( dev
<S2SV_ModStart> msixcap msixcap ; if ( msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( "%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>entries!\\n" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> tab_size = msgnum <S2SV_ModStart> msgnum ) ; if ( <S2SV_ModStart> , msgnum ) != 0 ) return - 1
<S2SV_ModStart> , bar ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> case PCIBAR_MEM64 : if ( idx + 1 > PCI_BARMAX ) { pr_err ( "%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>MEM64<S2SV_blank>type\\n" , __func__ , idx ) ; return - 1 ; } <S2SV_ModStart> ; default : pr_err <S2SV_ModEnd> ( "%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n" , <S2SV_ModStart> type ) ; return - 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> PCIBAR_MEM64 ) { <S2SV_ModEnd> pdi -> bar
<S2SV_ModStart> uint64_t base ; if <S2SV_ModEnd> ( ( size <S2SV_ModStart> 1 ) ) != 0 ) { pr_err ( "%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>%lld<S2SV_blank>resource\\n" , __func__ , size ) ; return - 1 ; } <S2SV_ModEnd> base = roundup2
<S2SV_ModStart> nextoff ; } <S2SV_ModEnd> if ( offset
<S2SV_ModStart> ; default : pr_err ( "%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n" , __func__ , dev -> bar [ i ] . type ) ; return <S2SV_ModEnd> ; } }
<S2SV_ModStart> opts ) { <S2SV_ModEnd> struct pci_emul_dummy * <S2SV_ModStart> 0x02 ) ; return <S2SV_ModEnd> pci_emul_add_msicap ( dev <S2SV_ModStart> , PCI_EMUL_MSI_MSGS ) || <S2SV_ModEnd> pci_emul_alloc_bar ( dev <S2SV_ModStart> , DIOSZ ) || <S2SV_ModEnd> pci_emul_alloc_bar ( dev <S2SV_ModStart> , DMEMSZ ) || <S2SV_ModEnd> pci_emul_alloc_bar ( dev <S2SV_ModStart> DMEMSZ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) arg2 ; if ( addr + size > <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . addr + <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . size ) { pr_err ( "%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range\\n" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> offset = addr
<S2SV_ModStart> 0 ] ; if ( bi == NULL ) return NULL <S2SV_ModEnd> ; si =
<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( "%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &
<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( "%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &
<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( "%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &
<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( "%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> si = &
<S2SV_ModStart> bus ] ; if ( bi == NULL ) { pr_err ( "%s:<S2SV_blank>pci<S2SV_blank>[%s]<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>bus<S2SV_blank>%d<S2SV_blank>info!\\n" , __func__ , dev -> name , dev -> bus ) ; return ; } <S2SV_ModEnd> ii = & <S2SV_ModStart> dev ) ; <S2SV_ModEnd> if ( ii <S2SV_ModStart> pirq_alloc_pin ( dev <S2SV_ModEnd> ) ; dev
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> pci_msix_table_init ( struct <S2SV_ModStart> i , table_size <S2SV_ModEnd> ; table_size = <S2SV_ModStart> table_size ) ; if ( ! <S2SV_ModEnd> dev -> msix <S2SV_ModStart> msix . table ) { pr_err ( "%s:<S2SV_blank>Cannot<S2SV_blank>alloc<S2SV_blank>memory!\\n" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> for ( i <S2SV_ModStart> |= PCIM_MSIX_VCTRL_MASK ; return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> pci_populate_msicap ( struct <S2SV_ModStart> int mmc ; if ( <S2SV_ModEnd> ( ( msgnum <S2SV_ModStart> 1 ) ) != 0 ) || msgnum < 1 || msgnum > 32 ) { pr_err ( "%s:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>msi<S2SV_blank>messages!\\n" , __func__ ) ; return - 1 ; } <S2SV_ModEnd> mmc = ffs <S2SV_ModStart> 1 ) ; return 0 ;
<S2SV_ModStart> msix_tab_size ) { <S2SV_ModEnd> bzero ( msixcap
<S2SV_ModStart> ; default : pr_err ( "%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n" , __func__ , type ) ; return <S2SV_ModEnd> ; } if
<S2SV_ModStart> ) arg2 ; if ( addr + size > <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . addr + <S2SV_ModEnd> pdi -> bar <S2SV_ModStart> bidx ] . size ) { printf ( "%s,<S2SV_blank>Out<S2SV_blank>of<S2SV_blank>emulated<S2SV_blank>memory<S2SV_blank>range.\\n" , __func__ ) ; return - ESRCH ; } <S2SV_ModEnd> offset = addr
<S2SV_ModStart> ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if (
<S2SV_ModStart> mode_t old_umask ; const <S2SV_ModEnd> char * base_path <S2SV_ModStart> ; base_path = "/tmp" ; <S2SV_ModEnd> __debug__ ( (
<S2SV_ModStart> + 1 ; if ( kmax > 0 && xsize > SIZE_MAX / kmax ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize * kmax > SIZE_MAX / sizeof ( float ) ) return ( Imaging ) ImagingError_MemoryError ( ) ; <S2SV_ModStart> ( ! kk ) return ( Imaging ) ImagingError_MemoryError ( ) ; if ( xsize > SIZE_MAX / ( 2 * sizeof ( int ) )
<S2SV_ModStart> ; if ( ( state -> xsize * state -> bits + 7 ) / 8 <S2SV_ModEnd> > state -> <S2SV_ModStart> state -> bytes <S2SV_ModEnd> ) { state <S2SV_ModStart> 1 ; } ptr = buf ; for ( ; ; ) { if ( bytes < 1 ) return ptr - buf ; if ( ( * ptr & 0xC0 ) == 0xC0 ) { if ( bytes < 2 ) return ptr - buf ; n = ptr [ 0 ] & 0x3F ; while ( n > 0 ) { if ( state -> x >= state -> bytes ) { state -> errcode = IMAGING_CODEC_OVERRUN ; break ; } state -> buffer [ state -> x ++ ] = ptr [ 1 ] ; n -- ; } ptr += 2 ; bytes -= 2 ; } else { state -> buffer [ state -> x ++ ] = ptr [ 0 ] ; ptr ++ ; bytes -- ; } if ( state -> x >= state -> bytes ) { if ( state -> bytes % state -> xsize && state -> bytes > state -> xsize ) { int bands = state -> bytes / state -> xsize ; int stride = state -> bytes / bands ; int i ; for ( i = 1 ; i < bands ; i ++ ) { memmove ( & state -> buffer [ i * state -> xsize ] , & state -> buffer [ i * stride ] , state -> xsize ) ; } } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y + state -> yoff ] + state -> xoff * im -> pixelsize , state -> buffer , state -> xsize ) ; state -> x = 0 ; if ( ++ state -> y >= state -> ysize ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> 1 ; } <S2SV_ModEnd> } } }
<S2SV_ModStart> memcpy ( buf <S2SV_ModEnd> , data ,
<S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state <S2SV_ModStart> ; out += 3 <S2SV_ModEnd> ; } state
<S2SV_ModStart> self ) { <S2SV_ModEnd> PyMemoTable * new <S2SV_ModStart> } for ( size_t
<S2SV_ModStart> ; if ( SIZE_MAX / 3 >= self -> mt_used && <S2SV_ModEnd> self -> mt_used <S2SV_ModStart> mt_used * 3 < self -> mt_allocated <S2SV_ModEnd> * 2 ) <S2SV_ModStart> * 2 ) { <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; } size_t desired_size = <S2SV_ModEnd> ( self -> <S2SV_ModStart> self -> mt_used ; return _PyMemoTable_ResizeTable ( self , desired_size
<S2SV_ModStart> * new_memo ; size_t new_memo_size = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ; for ( size_t <S2SV_ModStart> new_memo_size ) { for ( size_t i = new_memo_size - 1 ; i != SIZE_MAX ; i -- <S2SV_ModEnd> ) { Py_XDECREF
<S2SV_ModStart> size_t mask = <S2SV_ModEnd> self -> mt_mask
<S2SV_ModStart> * self , size_t <S2SV_ModEnd> min_size ) { <S2SV_ModStart> * newentry ; size_t <S2SV_ModEnd> new_size = MT_MINSIZE <S2SV_ModStart> = MT_MINSIZE ; size_t <S2SV_ModEnd> to_process ; assert <S2SV_ModStart> 0 ) ; if ( min_size > PY_SSIZE_T_MAX ) { PyErr_NoMemory ( ) ; return - 1 ; } <S2SV_ModStart> new_size < min_size ) { new_size <<= <S2SV_ModEnd> 1 ; }
<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx ) { <S2SV_ModStart> { if ( <S2SV_ModEnd> idx >= self
<S2SV_ModStart> * self , size_t <S2SV_ModEnd> idx , PyObject
<S2SV_ModStart> * self , size_t <S2SV_ModEnd> new_size ) { <S2SV_ModStart> new_size ) { size_t <S2SV_ModEnd> i ; assert
<S2SV_ModStart> self ) { <S2SV_ModEnd> PyMemoTable * memo <S2SV_ModStart> ; for ( size_t
<S2SV_ModStart> self ) { size_t <S2SV_ModEnd> i ; PyObject
<S2SV_ModStart> , 0 ) <S2SV_ModEnd> ) ; char <S2SV_ModStart> errstr ) { const
<S2SV_ModStart> int k ; const
<S2SV_ModStart> ; node * n ; if ( feature_version >= 7 ) iflags |= PyPARSE_ASYNC_ALWAYS ;
<S2SV_ModStart> d ; } abort ( <S2SV_ModEnd> ) ; #
<S2SV_ModStart> ; # endif if ( * flags & PyPARSE_ASYNC_ALWAYS ) tok -> async_always = 1 ;
<S2SV_ModStart> ; len = ( a != NULL && b != NULL ) ? <S2SV_ModStart> b - a : 0 <S2SV_ModStart> ; err_ret -> expected = NOTEQUAL <S2SV_ModEnd> ; err_ret -> <S2SV_ModStart> if ( a != NULL && a <S2SV_ModStart> -> line_start ) { <S2SV_ModStart> int ) ; } else { <S2SV_ModEnd> col_offset = - <S2SV_ModStart> - 1 ; }
<S2SV_ModStart> # ifndef PGEN <S2SV_ModEnd> fd = _Py_dup <S2SV_ModStart> fd ) ; <S2SV_ModEnd> # else fd
<S2SV_ModStart> { buf = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
<S2SV_ModStart> { bufobj = _PyObject_CallNoArg <S2SV_ModEnd> ( tok -> <S2SV_ModStart> tok -> decoding_readline <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * bufobj = _PyObject_CallNoArg ( readline <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * tok ) <S2SV_ModEnd> { tok -> <S2SV_ModStart> inp ; return ERRORTOKEN <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ( altcol / ALTTABSIZE <S2SV_ModEnd> + 1 ) <S2SV_ModStart> + 1 ) * ALTTABSIZE <S2SV_ModEnd> ; } else <S2SV_ModStart> ] ) { return <S2SV_ModEnd> indenterror ( tok <S2SV_ModStart> ( tok ) ; <S2SV_ModEnd> } } else <S2SV_ModStart> ] ) { return <S2SV_ModEnd> indenterror ( tok <S2SV_ModStart> ( tok ) ; <S2SV_ModEnd> } tok -> <S2SV_ModStart> ] ) { return <S2SV_ModEnd> indenterror ( tok <S2SV_ModStart> ( tok ) ; <S2SV_ModEnd> } } } <S2SV_ModStart> { if ( tok -> async_always ||
<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
<S2SV_ModStart> 1 ) ; if ( newtok == NULL ) { Py_DECREF ( u ) ; tok -> done = E_NOMEM ; return EOF ; }
<S2SV_ModStart> PyModule_Create ( & _astmodule <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ! empty_tuple || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__fields <S2SV_ModEnd> , empty_tuple ) <S2SV_ModStart> < 0 || _PyDict_SetItemId <S2SV_ModEnd> ( d , <S2SV_ModStart> ( d , & PyId__attributes <S2SV_ModEnd> , empty_tuple )
<S2SV_ModStart> i , result <S2SV_ModEnd> ; PyObject *
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } switch
<S2SV_ModStart> o ) { Py_RETURN_NONE <S2SV_ModEnd> ; } result
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ast_clear ( AST_object <S2SV_ModStart> dict ) ; return 0 ;
<S2SV_ModStart> self ) { PyObject_GC_UnTrack ( self ) ;
<S2SV_ModStart> kw ) { <S2SV_ModEnd> Py_ssize_t i , <S2SV_ModStart> * fields ; if ( lookup_attr_id <S2SV_ModEnd> ( ( PyObject <S2SV_ModStart> , & PyId__fields , & fields ) < 0 ) { goto cleanup ; } <S2SV_ModEnd> if ( fields <S2SV_ModStart> ; if ( numfields < <S2SV_ModStart> ( args ) <S2SV_ModEnd> ) { PyErr_Format <S2SV_ModStart> ( PyExc_TypeError , "%.400s<S2SV_blank>constructor<S2SV_blank>takes<S2SV_blank>at<S2SV_blank>most<S2SV_blank>" <S2SV_ModEnd> "%zd<S2SV_blank>positional<S2SV_blank>argument%s" , Py_TYPE <S2SV_ModStart> ) -> tp_name <S2SV_ModEnd> , numfields , <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> if ( kw
<S2SV_ModStart> unused ) { <S2SV_ModEnd> _Py_IDENTIFIER ( __dict__ <S2SV_ModStart> PyObject * dict ; if ( lookup_attr_id <S2SV_ModEnd> ( self , <S2SV_ModStart> , & PyId___dict__ , & dict ) < 0 ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> dict ) { return Py_BuildValue ( "O()N" <S2SV_ModEnd> , Py_TYPE ( <S2SV_ModStart> , dict ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> num_fields ) { _Py_IDENTIFIER ( __module__ ) ; _Py_IDENTIFIER ( _ast3 ) ; <S2SV_ModStart> & PyType_Type , "s(O){OOOO}" <S2SV_ModEnd> , type , <S2SV_ModStart> , base , _PyUnicode_FromId ( & PyId__fields ) <S2SV_ModEnd> , fnames , <S2SV_ModStart> , fnames , _PyUnicode_FromId ( & PyId___module__ ) , _PyUnicode_FromId ( & PyId__ast3 ) <S2SV_ModEnd> ) ; Py_DECREF
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"name\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>alias" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_asname , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; asname = NULL ; } else { int res ; <S2SV_ModStart> tmp , & asname <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"arg\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & annotation <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"lineno\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"col_offset\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) <S2SV_ModEnd> ; } *
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"args\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { arg_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_vararg , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; vararg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & vararg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_kwonlyargs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"kwonlyargs\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { arg_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_kw_defaults , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"kw_defaults\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_kwarg , & tmp ) < 0 ) { <S2SV_ModEnd> return 1 ; <S2SV_ModStart> } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; kwarg = NULL ; } else { int res ; res = obj2ast_arg ( tmp , & kwarg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_defaults , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"defaults\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arguments" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = arguments ( args , vararg , kwonlyargs , kw_defaults , kwarg , defaults , arena ) ; return 0 ; failed : Py_XDECREF ( tmp <S2SV_ModEnd> ) ; return <S2SV_ModStart> 1 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_iter , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"iter\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ifs , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ifs\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_is_async , & tmp ) < 0 ) { return 1 ; } <S2SV_ModEnd> if ( tmp <S2SV_ModStart> == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"is_async\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
<S2SV_ModStart> } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"lineno\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"col_offset\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>excepthandler" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } isinstance <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_type , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; name = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExceptHandler" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = ExceptHandler ( type , name , body , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> "expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>excepthandler,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R" , obj
<S2SV_ModStart> } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"lineno\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"col_offset\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>expr" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & col_offset <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } isinstance <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"op\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_boolop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"values\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BoolOp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_left , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"left\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"op\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_right , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"right\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>BinOp" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & right <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"op\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_unaryop ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_operand , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"operand\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>UnaryOp" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & operand <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"args\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_arguments ( tmp , & args , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Lambda" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"test\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>IfExp" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & orelse , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = IfExp ( test , body , orelse , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Dict_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * keys ; asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_keys , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"keys\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"values\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Dict" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Dict ( keys , values , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Set_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * elts ; if ( lookup_attr_id ( obj , & PyId_elts , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elts\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Set" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_elt , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elt\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"generators\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ListComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { comprehension_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_elt , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elt\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"generators\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>SetComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { comprehension_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_key , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"key\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & key , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & value <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"generators\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>DictComp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { comprehension_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_elt , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elt\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & elt , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_generators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"generators\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>GeneratorExp" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { comprehension_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Await" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>YieldFrom" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_left , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"left\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & left , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_ops , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ops\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { cmpop_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_comparators , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"comparators\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Compare" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_func , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"func\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & func , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"args\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"keywords\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Call" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { keyword_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_n , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"n\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Num" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_object <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_s , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"s\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Str" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } if <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FormattedValue" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_conversion , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; conversion = 0 ; } else { int res ; res = obj2ast_int ( tmp , & conversion , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_format_spec , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; format_spec = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & format_spec , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FormattedValue ( value , conversion , format_spec , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) JoinedStr_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * values ; if ( lookup_attr_id ( obj , & PyId_values , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"values\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>JoinedStr" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_s , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"s\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Bytes" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_bytes <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>NameConstant" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_singleton <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Constant" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_constant <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_attr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"attr\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & attr <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Attribute" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_slice , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"slice\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript" ) ; return 1 ; } else { int res ; res = obj2ast_slice ( tmp , & slice <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Subscript" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Starred" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_id , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"id\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & id , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Name" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_elts , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elts\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>List" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr_context <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_elts , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"elts\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_ctx , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ctx\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Tuple" ) ; return 1 ; } else { int res ; res = obj2ast_expr_context ( tmp , & ctx , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Tuple ( elts , ctx , lineno , col_offset , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , "expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>expr,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R" , obj <S2SV_ModEnd> ) ; failed
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; arg = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>keyword" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_ignores , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"type_ignores\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { type_ignore_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Module ( body , type_ignores , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Interactive_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"argtypes\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"returns\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } * out = Suite ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> "expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>mod,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R" , obj
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lower , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; lower = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_upper , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; upper = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_step , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; step = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( lookup_attr_id ( obj , & PyId_dims , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"dims\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ExtSlice" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { slice_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Index" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ) ; } * out = Index ( value , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } PyErr_Format <S2SV_ModEnd> ( PyExc_TypeError , <S2SV_ModStart> ( PyExc_TypeError , <S2SV_ModEnd> "expected<S2SV_blank>some<S2SV_blank>sort<S2SV_blank>of<S2SV_blank>slice,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>%R" , obj
<S2SV_ModStart> } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"lineno\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"col_offset\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>stmt" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & col_offset <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } isinstance <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"name\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"args\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"decorator_list\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"name\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_args , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"args\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef" ) ; return 1 ; } else { int res ; res = obj2ast_arguments ( tmp , & args <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"decorator_list\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFunctionDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; returns = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_name , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"name\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & name , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_bases , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"bases\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_keywords , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"keywords\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { keyword_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_decorator_list , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"decorator_list\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ClassDef" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"targets\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Delete" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_targets , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"targets\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { expr_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assign" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; <S2SV_ModEnd> Py_CLEAR ( tmp <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_op , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"op\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign" ) ; return 1 ; } else { int res ; res = obj2ast_operator ( tmp , & op , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AugAssign" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & value <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"annotation\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & annotation <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; value = NULL ; } else { int res ; res = obj2ast_expr ( tmp , & value , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_simple , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { <S2SV_ModEnd> PyErr_SetString ( PyExc_TypeError <S2SV_ModStart> ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"simple\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AnnAssign" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & simple <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"iter\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>For" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_target , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_iter , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"iter\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor" ) ; return 1 ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & iter <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> Py_ssize_t len ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncFor" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"test\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>While" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"test\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>If" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"items\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>With" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_items , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"items\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { withitem_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>AsyncWith" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_string <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_exc , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; exc = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & exc , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_cause , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; cause = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & cause <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_handlers , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"handlers\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { excepthandler_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_orelse , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"orelse\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_finalbody , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"finalbody\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Try" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { stmt_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_test , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"test\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Assert" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & test , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_msg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; msg = NULL ; } else { int res <S2SV_ModEnd> ; res = <S2SV_ModStart> tmp , & msg <S2SV_ModEnd> , arena ) <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"names\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Import" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_module , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; module = NULL ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_identifier ( tmp , & module , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> obj , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"names\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>ImportFrom" ) ; return 1 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { alias_ty val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } if ( lookup_attr_id ( obj , & PyId_level , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; level = 0 ; } else { <S2SV_ModEnd> int res ; <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_int <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"names\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Global" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_names , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"names\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Nonlocal" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> ; Py_ssize_t i <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) { identifier val <S2SV_ModEnd> ; res = <S2SV_ModStart> ) , & val <S2SV_ModEnd> , arena ) <S2SV_ModStart> , i , val <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } * <S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_value , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"value\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expr" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; <S2SV_ModEnd> res = obj2ast_expr <S2SV_ModStart> ( tmp ) <S2SV_ModEnd> ; } *
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"lineno\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>TypeIgnore" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } * out = TypeIgnore ( <S2SV_ModEnd> lineno , arena <S2SV_ModStart> ; if ( * out == NULL <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ; if ( lookup_attr_id <S2SV_ModEnd> ( obj , <S2SV_ModStart> , & PyId_context_expr , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"context_expr\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem" ) ; return 1 ; } else <S2SV_ModEnd> { int res <S2SV_ModStart> int res ; res = obj2ast_expr ( tmp , & context_expr , arena ) ; if ( res != 0 <S2SV_ModEnd> ) goto failed <S2SV_ModStart> goto failed ; Py_CLEAR ( tmp ) ; } if ( lookup_attr_id ( obj , & PyId_optional_vars , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; optional_vars = NULL ; } else { int res ; <S2SV_ModStart> tmp , & optional_vars <S2SV_ModEnd> , arena ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> * out =
<S2SV_ModStart> state ) ; state -> fmode = 1 ; <S2SV_ModStart> } assert ( <S2SV_ModEnd> literal == NULL
<S2SV_ModStart> ; if ( ! state -> fmode ) { assert ( ! <S2SV_ModStart> expr_list . size ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> goto error ; <S2SV_ModEnd> return JoinedStr (
<S2SV_ModStart> = NULL ; state -> fmode = 0 ;
<S2SV_ModStart> ; c . <S2SV_ModEnd> c_feature_version = feature_version <S2SV_ModStart> c_normalize ) ; <S2SV_ModEnd> } return res
<S2SV_ModStart> ; if ( ! str ) return NULL ; if (
<S2SV_ModStart> return NULL ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD <S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD
<S2SV_ModStart> 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , "async" ) == 0 <S2SV_ModEnd> ) ; REQ <S2SV_ModStart> ( c , n <S2SV_ModEnd> , decorator_seq , <S2SV_ModStart> , decorator_seq , true <S2SV_ModEnd> ) ; }
<S2SV_ModStart> 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , "async" ) == 0 <S2SV_ModEnd> ) ; switch <S2SV_ModStart> ( c , n <S2SV_ModEnd> , NULL , <S2SV_ModStart> , NULL , true <S2SV_ModEnd> ) ; case <S2SV_ModStart> ( c , n , true <S2SV_ModEnd> ) ; case <S2SV_ModStart> ( c , n , true <S2SV_ModEnd> ) ; default
<S2SV_ModStart> ( c , STR ( ch ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , expr_ty func , bool allowgen <S2SV_ModStart> nargs , nkeywords <S2SV_ModEnd> ; int ndoublestars <S2SV_ModStart> = 0 ; <S2SV_ModEnd> for ( i <S2SV_ModStart> == comp_for ) { nargs ++ ; if ( ! allowgen ) { ast_error ( c , ch , "invalid<S2SV_blank>syntax" ) ; return NULL ; } if ( NCH ( n ) > 1 ) { ast_error ( c , ch , "Generator<S2SV_blank>expression<S2SV_blank>must<S2SV_blank>be<S2SV_blank>parenthesized" ) ; return NULL ; } } <S2SV_ModEnd> else if ( <S2SV_ModStart> ; } } args = _Ta3_asdl_seq_new ( nargs <S2SV_ModEnd> , c ->
<S2SV_ModStart> ) , dummy , false
<S2SV_ModStart> * for_ch ; node * sync_n ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 <S2SV_ModEnd> ) { is_async <S2SV_ModStart> = 1 ; REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , "async" ) == 0 ) ; sync_n = CHILD ( n , 1 ) ; } else { sync_n = CHILD ( n , 0 ) ; } REQ ( sync_n , sync_comp_for ) ; <S2SV_ModEnd> if ( is_async <S2SV_ModStart> = CHILD ( sync_n , 1 <S2SV_ModEnd> ) ; t <S2SV_ModStart> , CHILD ( sync_n , 3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( NCH ( sync_n ) == 5 <S2SV_ModEnd> ) { int <S2SV_ModStart> = CHILD ( sync_n , 4 <S2SV_ModEnd> ) ; n_ifs
<S2SV_ModStart> ) , name_expr , true
<S2SV_ModStart> const node * n0 , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
<S2SV_ModStart> , decorator_seq , false <S2SV_ModEnd> ) ; }
<S2SV_ModStart> const node * n0 <S2SV_ModEnd> , asdl_seq * <S2SV_ModStart> * decorator_seq , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
<S2SV_ModStart> ) , left_expr , true
<S2SV_ModStart> const node * n0 , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
<S2SV_ModStart> = 0 ; count_comp_for : <S2SV_ModEnd> n_fors ++ ; <S2SV_ModStart> ; if ( NCH ( n ) == 2 ) { REQ ( CHILD ( n , 0 ) , NAME ) ; assert ( strcmp ( STR ( CHILD ( n , 0 ) ) , "async" ) == 0 ) ; n = CHILD ( n , 1 ) ; } else if ( NCH ( n ) == 1 ) { n = CHILD ( n , 0 ) ; } else { goto error <S2SV_ModEnd> ; } if <S2SV_ModStart> == ( 5 <S2SV_ModEnd> ) ) { <S2SV_ModStart> n , 4 <S2SV_ModEnd> ) ; } <S2SV_ModStart> n_fors ; } error :
<S2SV_ModStart> len ) { const char * first_invalid_escape ; PyObject * result = _PyBytes_DecodeEscape <S2SV_ModEnd> ( s , <S2SV_ModStart> 0 , NULL , & first_invalid_escape ) ; if ( result == NULL ) return NULL ; if ( first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_DECREF ( result ) ; return NULL ; } } return result <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> { PyObject * v , * <S2SV_ModStart> char * end ; const char * first_invalid_escape <S2SV_ModStart> ; if ( s >= end || <S2SV_ModStart> p += 5 ; if ( s >= end ) break <S2SV_ModStart> - buf <= PyBytes_GET_SIZE <S2SV_ModEnd> ( u ) <S2SV_ModStart> = buf ; v = _PyUnicode_DecodeUnicodeEscape ( s , len , NULL , & first_invalid_escape ) ; if ( v != NULL && first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_XDECREF ( u ) ; Py_DECREF ( v ) ; return NULL ; } } Py_XDECREF ( u ) ; return v <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; default : abort ( ) <S2SV_ModEnd> ; } }
<S2SV_ModStart> ; if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> , "__debug__" ) <S2SV_ModEnd> ) { ast_error <S2SV_ModStart> { if ( _PyUnicode_EqualToASCIIString <S2SV_ModEnd> ( name , <S2SV_ModStart> * p ) <S2SV_ModEnd> ) { ast_error
<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , "f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , "<fstring>" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
<S2SV_ModStart> const char * s = * str ; const char * literal_start = s <S2SV_ModEnd> ; int result <S2SV_ModStart> NULL ) ; while ( s < end ) { char ch = * s ++ <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( ! raw && ch == '\\\\' && s < end ) { ch = * s ++ ; if ( ch == 'N' ) { if ( s < end && * s ++ == '{' ) { while ( s < end && * s ++ != <S2SV_ModEnd> '}' ) { <S2SV_ModStart> '}' ) { } continue ; } break ; } if ( ch == '{' && warn_invalid_escape_sequence ( c , n , ch ) < 0 ) { return - 1 ; } } <S2SV_ModEnd> if ( ch <S2SV_ModStart> { if ( s < end && * s == ch ) { * str = s + 1 <S2SV_ModEnd> ; result = <S2SV_ModStart> '}' ) { * str = s - 1 ; <S2SV_ModStart> ; } } s -- ; <S2SV_ModStart> ; } } * str = s <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> <= end ) <S2SV_ModStart> ; assert ( s <S2SV_ModEnd> == end || <S2SV_ModStart> end || * s <S2SV_ModEnd> == '{' || <S2SV_ModStart> '{' || * s <S2SV_ModEnd> == '}' ) <S2SV_ModStart> ( literal_start != s <S2SV_ModEnd> ) { if <S2SV_ModStart> ( literal_start , s <S2SV_ModEnd> - literal_start , <S2SV_ModStart> , literal_start , s <S2SV_ModEnd> - literal_start )
<S2SV_ModStart> ; if ( <S2SV_ModEnd> TYPE ( CHILD
<S2SV_ModStart> return 0 ; <S2SV_ModEnd> return 1 ;
<S2SV_ModStart> * id2 ; PyObject * form ; PyObject * args [ 2 ] ; _Py_IDENTIFIER ( NFKC ) ; <S2SV_ModStart> NULL ; } form = _PyUnicode_FromId ( & PyId_NFKC ) ; if ( form == NULL ) { Py_DECREF ( id ) ; return NULL ; } args [ 0 ] = form ; args [ 1 ] = id ; id2 = _PyObject_FastCall <S2SV_ModEnd> ( c -> <S2SV_ModStart> -> c_normalize , args , 2 ) ; Py_DECREF ( id ) ; if ( ! id2 ) return NULL ; if ( ! PyUnicode_Check ( id2 ) ) { PyErr_Format ( PyExc_TypeError , "unicodedata.normalize()<S2SV_blank>must<S2SV_blank>return<S2SV_blank>a<S2SV_blank>string,<S2SV_blank>not<S2SV_blank>" "%.200s" , Py_TYPE ( id2 ) -> tp_name ) ; Py_DECREF ( id2 ) ; return NULL ; } <S2SV_ModEnd> id = id2
<S2SV_ModStart> ; } } abort ( ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> 1 ) ; if ( dup == NULL ) { return PyErr_NoMemory ( ) ; }
<S2SV_ModStart> ; if ( i < NCH ( n ) &&
<S2SV_ModStart> ; if ( i < NCH ( n ) &&
<S2SV_ModStart> ; if ( i < NCH ( n ) &&
<S2SV_ModStart> ; if ( i < NCH ( n ) &&
<S2SV_ModStart> ch ) ; if ( ch_type == suite && TYPE ( tree ) == funcdef ) { ch_type = func_body_suite ; }
<S2SV_ModStart> dfa * d1 ; if ( nt == func_body_suite && ! ( ps -> p_flags & PyCF_TYPE_COMMENTS ) ) { D ( printf ( "<S2SV_blank>[switch<S2SV_blank>func_body_suite<S2SV_blank>to<S2SV_blank>suite]" ) ) ; nt = suite ; } d1 <S2SV_ModStart> ( printf ( "<S2SV_blank>Push<S2SV_blank>\'%s\'\\n" , d1 -> d_name <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; }
<S2SV_ModStart> NULL ; } if ( * flags & PyPARSE_TYPE_COMMENTS ) { tok -> type_comments = 1 ; }
<S2SV_ModStart> , end_col_offset ; growable_int_array type_ignores ; if ( ! growable_int_array_init ( & type_ignores , 10 ) ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } <S2SV_ModStart> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; if ( * flags & PyPARSE_TYPE_COMMENTS ) ps -> p_flags |= PyCF_TYPE_COMMENTS <S2SV_ModStart> } if ( type == TYPE_IGNORE ) { if ( ! growable_int_array_add ( & type_ignores , tok -> lineno ) ) { err_ret -> error = E_NOMEM ; break ; } continue ; } if ( <S2SV_ModStart> p_tree = NULL ; if ( n -> n_type == file_input ) { int num ; node * ch ; size_t i ; num = NCH ( n ) ; ch = CHILD ( n , num - 1 ) ; REQ ( ch , ENDMARKER ) ; for ( i = 0 ; i < type_ignores . num_items ; i ++ ) { PyNode_AddChild ( ch , TYPE_IGNORE , NULL , type_ignores . items [ i ] , 0 , type_ignores . items [ i ] , 0 ) ; } } growable_int_array_deallocate ( & type_ignores )
<S2SV_ModStart> '#' ) { const char * prefix , * p , * type_start ; <S2SV_ModStart> tok ) ; } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , "ignore" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } }
<S2SV_ModStart> ; # endif tok -> type_comments = 0 ;
<S2SV_ModStart> expr_ty value , string type_comment , <S2SV_ModStart> ; p -> v . Assign . type_comment = type_comment ; p ->
<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment
<S2SV_ModStart> expr_ty returns , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> returns = returns ; p -> v . AsyncFunctionDef . type_comment = type_comment
<S2SV_ModStart> * body , string type_comment , <S2SV_ModStart> ; p -> v . AsyncWith . type_comment = type_comment ; p ->
<S2SV_ModStart> * orelse , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> orelse = orelse ; p -> v . For . type_comment = type_comment
<S2SV_ModStart> expr_ty returns , string type_comment , <S2SV_ModStart> returns = returns ; p -> v . FunctionDef . type_comment = type_comment
<S2SV_ModStart> asdl_seq * body , asdl_seq * type_ignores <S2SV_ModStart> = body ; p -> v . Module . type_ignores = type_ignores ;
<S2SV_ModStart> "Expression" , "Interactive" , "FunctionType" <S2SV_ModStart> && mode <= 3 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; if ( PyModule_AddIntMacro ( m , PyCF_TYPE_COMMENTS ) < 0 ) return NULL ; if ( <S2SV_ModStart> ( d , "FunctionType" , ( PyObject * ) FunctionType_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , <S2SV_ModStart> * ) withitem_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , "type_ignore" , ( PyObject * ) type_ignore_type ) < 0 ) return NULL ; if ( PyDict_SetItemString ( d , "TypeIgnore" , ( PyObject * ) TypeIgnore_type
<S2SV_ModStart> * body , string type_comment , <S2SV_ModStart> ; p -> v . With . type_comment = type_comment ; p ->
<S2SV_ModStart> expr_ty annotation , string type_comment , <S2SV_ModStart> ; p -> type_comment = type_comment ; p ->
<S2SV_ModStart> ; value = ast2obj_string ( o -> type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value =
<S2SV_ModStart> value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case
<S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ;
<S2SV_ModStart> , Module_fields , 2 ) ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( "Interactive" , mod_type , Interactive_fields , <S2SV_ModStart> if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( "Expression" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , Expression_fields , <S2SV_ModEnd> 1 ) ; <S2SV_ModStart> if ( ! Expression_type ) return 0 ; FunctionType_type = make_type ( "FunctionType" <S2SV_ModEnd> , mod_type , <S2SV_ModStart> , mod_type , FunctionType_fields , 2 ) ; if ( ! FunctionType_type <S2SV_ModEnd> ) return 0 <S2SV_ModStart> , FunctionDef_fields , 6 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( "AsyncFunctionDef" , stmt_type , AsyncFunctionDef_fields , 6 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( "ClassDef" , stmt_type , ClassDef_fields , <S2SV_ModStart> if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( "Return" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( "Delete" , stmt_type , Delete_fields , 1 ) ; if ( ! Delete_type ) return 0 ; Assign_type = make_type ( "Assign" , stmt_type , Assign_fields , 3 ) ; if ( ! Assign_type ) return 0 ; AugAssign_type = make_type ( "AugAssign" , stmt_type , AugAssign_fields , 3 ) ; if ( ! AugAssign_type ) return 0 ; AnnAssign_type = make_type ( "AnnAssign" , stmt_type , AnnAssign_fields , 4 ) ; if ( ! AnnAssign_type ) return 0 ; For_type = make_type ( "For" , stmt_type , For_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! For_type ) return 0 ; AsyncFor_type = make_type ( "AsyncFor" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncFor_fields <S2SV_ModEnd> , 5 ) <S2SV_ModStart> if ( ! AsyncFor_type ) return 0 ; While_type = make_type ( "While" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , While_fields , 3 ) ; if ( ! While_type ) return 0 ; If_type = make_type ( "If" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , If_fields , 3 ) ; if ( ! If_type ) return 0 ; With_type = make_type ( "With" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , With_fields , 3 ) ; if ( ! With_type ) return 0 ; AsyncWith_type = make_type ( "AsyncWith" <S2SV_ModEnd> , stmt_type , <S2SV_ModStart> , stmt_type , AsyncWith_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , arg_fields , 3 <S2SV_ModEnd> ) ; if <S2SV_ModStart> return 0 ; type_ignore_type = make_type ( "type_ignore" , & AST_type , NULL , 0 ) ; if ( ! type_ignore_type ) return 0 ; if ( ! add_attributes ( type_ignore_type , NULL , 0 ) ) return 0 ; TypeIgnore_type = make_type ( "TypeIgnore" , type_ignore_type , TypeIgnore_fields , 1 ) ; if ( ! TypeIgnore_type ) return 0 ;
<S2SV_ModStart> expr_ty annotation ; string type_comment ; <S2SV_ModStart> , & annotation , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModStart> , annotation , type_comment ,
<S2SV_ModStart> asdl_seq * body ; asdl_seq * type_ignores <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId <S2SV_ModEnd> ( obj , <S2SV_ModStart> ( obj , & PyId_type_ignores <S2SV_ModEnd> , & tmp <S2SV_ModStart> ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"type_ignores\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Module" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ( PyExc_TypeError , "Module<S2SV_blank>field<S2SV_blank>\\"type_ignores\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s" <S2SV_ModEnd> , tmp -> <S2SV_ModStart> tmp ) ; type_ignores <S2SV_ModEnd> = _Py_asdl_seq_new ( <S2SV_ModStart> ; if ( type_ignores <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ++ ) { type_ignore_ty <S2SV_ModEnd> val ; res <S2SV_ModStart> ; res = obj2ast_type_ignore <S2SV_ModEnd> ( PyList_GET_ITEM ( <S2SV_ModStart> ( PyExc_RuntimeError , "Module<S2SV_blank>field<S2SV_blank>\\"type_ignores\\"<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> } asdl_seq_SET ( type_ignores <S2SV_ModEnd> , i , <S2SV_ModStart> * out = Module ( body , type_ignores <S2SV_ModEnd> , arena ) <S2SV_ModStart> PyObject * ) Interactive_type <S2SV_ModEnd> ) ; if <S2SV_ModStart> isinstance ) { asdl_seq * <S2SV_ModEnd> body ; if <S2SV_ModStart> ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Interactive" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ( PyExc_TypeError , "Interactive<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s" <S2SV_ModEnd> , tmp -> <S2SV_ModStart> ( PyExc_RuntimeError , "Interactive<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration" ) ; goto failed ; } asdl_seq_SET ( body , i , val ) ; } Py_CLEAR ( tmp ) ; } * out = Interactive ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Expression_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Expression" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & body , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = Expression ( body , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) FunctionType_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * argtypes ; expr_ty returns ; if ( _PyObject_LookupAttrId ( obj , & PyId_argtypes , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"argtypes\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , "FunctionType<S2SV_blank>field<S2SV_blank>\\"argtypes\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; argtypes = _Py_asdl_seq_new ( len , arena ) ; if ( argtypes == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { expr_ty val ; res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , "FunctionType<S2SV_blank>field<S2SV_blank>\\"argtypes\\"<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration" ) ; goto failed ; } asdl_seq_SET ( argtypes , i , val ) ; } Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_returns , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"returns\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>FunctionType" ) ; return 1 ; } else { int res ; res = obj2ast_expr ( tmp , & returns , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } * out = FunctionType ( argtypes , returns , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Suite_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; if ( _PyObject_LookupAttrId ( obj , & PyId_body , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>Suite" ) ; return 1 ; } else { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , "Suite<S2SV_blank>field<S2SV_blank>\\"body\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Py_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty val ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & val , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError ,
<S2SV_ModStart> ; expr_ty returns ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , returns , type_comment , <S2SV_ModStart> ; expr_ty returns ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , returns , type_comment , <S2SV_ModStart> expr_ty value ; string type_comment ; <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , value , type_comment , <S2SV_ModStart> asdl_seq * orelse ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , orelse , type_comment , <S2SV_ModStart> asdl_seq * orelse ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , orelse , type_comment , <S2SV_ModStart> * body ; string type_comment ; <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> items , body , type_comment <S2SV_ModStart> asdl_seq * body ; string type_comment <S2SV_ModStart> ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_ModStart> , body , type_comment ,
<S2SV_ModStart> = NULL ; asdl_seq * type_ignores = NULL ; <S2SV_ModStart> res = NULL ; asdl_seq * argtypes = NULL ; expr_ty ret , arg <S2SV_ModStart> } } } ch = CHILD ( n , NCH ( n ) - 1 ) ; REQ ( ch , ENDMARKER ) ; num = NCH ( ch ) ; type_ignores = _Py_asdl_seq_new ( num , arena ) ; if ( ! type_ignores ) goto out ; for ( i = 0 ; i < num ; i ++ ) { type_ignore_ty ti = TypeIgnore ( LINENO ( CHILD ( ch , i ) ) , arena ) ; if ( ! ti ) goto out ; asdl_seq_SET ( type_ignores , i , ti ) ; } <S2SV_ModStart> Module ( stmts , type_ignores <S2SV_ModStart> } break ; case func_type_input : n = CHILD ( n , 0 ) ; REQ ( n , func_type ) ; if ( TYPE ( CHILD ( n , 1 ) ) == typelist ) { ch = CHILD ( n , 1 ) ; num = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { num ++ ; } } argtypes = _Py_asdl_seq_new ( num , arena ) ; if ( ! argtypes ) goto out ; j = 0 ; for ( i = 0 ; i < NCH ( ch ) ; i ++ ) { if ( TYPE ( CHILD ( ch , i ) ) == test ) { arg = ast_for_expr ( & c , CHILD ( ch , i ) ) ; if ( ! arg ) goto out ; asdl_seq_SET ( argtypes , j ++ , arg ) ; } } } else { argtypes = _Py_asdl_seq_new ( 0 , arena ) ; if ( ! argtypes ) goto out ; } ret = ast_for_expr ( & c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! ret ) goto out ; res = FunctionType ( argtypes , ret , arena ) ; break ;
<S2SV_ModStart> , annotation , NULL ,
<S2SV_ModStart> ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> n ) && ( <S2SV_ModStart> ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) <S2SV_ModStart> += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , "bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment" ) ; return NULL ; } <S2SV_ModStart> ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } <S2SV_ModEnd> if ( i <S2SV_ModStart> ; i += 2 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 <S2SV_ModEnd> ; break ;
<S2SV_ModStart> expr_stmt ) ; int num = <S2SV_ModEnd> NCH ( n <S2SV_ModStart> ( n ) ; if ( num <S2SV_ModStart> { int i , nch_minus_type , has_type_comment <S2SV_ModStart> expr_ty expression ; string type_comment ; <S2SV_ModStart> EQUAL ) ; has_type_comment = TYPE ( CHILD ( n , num - 1 ) ) == TYPE_COMMENT ; nch_minus_type = num - has_type_comment ; <S2SV_ModStart> = _Py_asdl_seq_new ( nch_minus_type <S2SV_ModEnd> / 2 , <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ( n , nch_minus_type <S2SV_ModEnd> - 1 ) <S2SV_ModStart> return NULL ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , nch_minus_type ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; <S2SV_ModStart> , expression , type_comment ,
<S2SV_ModStart> , end_col_offset ; int has_type_comment ; string type_comment ; <S2SV_ModStart> , for_stmt ) ; has_type_comment = TYPE ( CHILD ( n , 5 ) ) == TYPE_COMMENT <S2SV_ModStart> ) == 9 + has_type_comment <S2SV_ModStart> n , 8 + has_type_comment <S2SV_ModStart> n , 5 + has_type_comment <S2SV_ModStart> } if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , 5 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , seq , type_comment , <S2SV_ModStart> suite_seq , seq , type_comment
<S2SV_ModStart> , end_col_offset ; node * tc ; string type_comment = NULL ; <S2SV_ModStart> 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; if ( ! type_comment ) return NULL ; name_i += 1 ; } <S2SV_ModStart> ; if ( NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) { if ( type_comment != NULL ) { ast_error ( c , n , "Cannot<S2SV_blank>have<S2SV_blank>two<S2SV_blank>type<S2SV_blank>comments<S2SV_blank>on<S2SV_blank>def" ) ; return NULL ; } type_comment = NEW_TYPE_COMMENT ( tc ) ; if ( ! type_comment ) return NULL ; } } if ( <S2SV_ModStart> decorator_seq , returns , type_comment <S2SV_ModStart> , returns , type_comment ,

<S2SV_ModStart> * ch ; if ( TYPE ( n ) != func_body_suite ) { <S2SV_ModStart> suite ) ; } <S2SV_ModStart> } else { i = 2 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) { i += 2 ; REQ ( CHILD ( n , 2 ) , NEWLINE ) ; } for ( <S2SV_ModEnd> ; i <
<S2SV_ModStart> , n_items , nch_minus_type , has_type_comment , <S2SV_ModStart> * body ; string type_comment ; <S2SV_ModStart> with_stmt ) ; has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; <S2SV_ModStart> n_items = ( nch_minus_type <S2SV_ModEnd> - 2 ) <S2SV_ModStart> ; i < nch_minus_type <S2SV_ModEnd> - 2 ; <S2SV_ModStart> ; if ( has_type_comment ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; if ( ! type_comment ) return NULL ; } else type_comment = NULL ; if ( <S2SV_ModStart> , body , type_comment , <S2SV_ModStart> items , body , type_comment

<S2SV_ModStart> , annotation , NULL , <S2SV_ModStart> ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 <S2SV_ModEnd> ; break ;
<S2SV_ModStart> case suite : case func_body_suite : <S2SV_ModStart> ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 <S2SV_ModEnd> ; for ( <S2SV_ModStart> ; for ( <S2SV_ModEnd> ; i <

<S2SV_ModStart> Py_eval_input , Py_single_input , Py_func_type_input <S2SV_ModStart> PyCF_DONT_IMPLY_DEDENT | PyCF_ONLY_AST | PyCF_TYPE_COMMENTS <S2SV_ModStart> 2 ; else if ( strcmp ( mode , "func_type" ) == 0 ) { if ( ! ( flags & PyCF_ONLY_AST ) ) <S2SV_ModStart> ( PyExc_ValueError , "compile()<S2SV_blank>mode<S2SV_blank>\'func_type\'<S2SV_blank>requires<S2SV_blank>flag<S2SV_blank>PyCF_ONLY_AST" ) ; goto error ; } compile_mode = 3 ; } else { const char * msg ; if ( flags & PyCF_ONLY_AST ) msg = "compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'exec\',<S2SV_blank>\'eval\',<S2SV_blank>\'single\'<S2SV_blank>or<S2SV_blank>\'func_type\'" ; else msg = "compile()<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>be<S2SV_blank>\'exec\',<S2SV_blank>\'eval\'<S2SV_blank>or<S2SV_blank>\'single\'" ; PyErr_SetString ( PyExc_ValueError , msg <S2SV_ModEnd> ) ; goto
<S2SV_ModStart> |= PyPARSE_BARRY_AS_BDFL ; if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ;
<S2SV_ModStart> = stellaris_enet_properties ; dc -> vmsd = & vmstate_stellaris_enet ;
<S2SV_ModStart> s ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> dev ) ; <S2SV_ModEnd> memory_region_destroy ( &
<S2SV_ModStart> ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> uint8_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
<S2SV_ModStart> uint32_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
<S2SV_ModStart> uint16_t val ; if ( addr + sizeof ( val ) > vdev -> config_len ) { return ( uint32_t ) - 1 ; } <S2SV_ModStart> -> config ) <S2SV_ModEnd> ; val =
<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev
<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stl_p ( vdev
<S2SV_ModStart> if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stw_p ( vdev
<S2SV_ModStart> 0 ; } iov_from_buf <S2SV_ModEnd> ( elem . <S2SV_ModStart> elem . in_sg , elem . in_num , 0 <S2SV_ModEnd> , buf ,
<S2SV_ModStart> { pid_t child <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( mount <S2SV_ModStart> ( "/proc/self/fd" , "/proc" <S2SV_ModEnd> , NULL , <S2SV_ModStart> ( FUSE_LOG_ERR , "mount(/proc/self/fd,<S2SV_blank>MS_BIND):<S2SV_blank>%m\\n" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> = open ( "/proc" <S2SV_ModEnd> , O_PATH ) <S2SV_ModStart> ( FUSE_LOG_ERR , "open(/proc,<S2SV_blank>O_PATH):<S2SV_blank>%m\\n" ) ; exit ( 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> == 1 ) { <S2SV_ModStart> return 8 ; } <S2SV_ModStart> 4 ) ; if ( dlen > ( 1 << 20 ) ) { error_report ( "vnc:<S2SV_blank>client_cut_text<S2SV_blank>msg<S2SV_blank>payload<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>bytes" "<S2SV_blank>which<S2SV_blank>exceeds<S2SV_blank>our<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB." , dlen ) ; vnc_client_error ( vs ) ; break ; } <S2SV_ModStart> > 0 ) { <S2SV_ModStart> + dlen ; }
<S2SV_ModStart> ; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL
<S2SV_ModStart> case 'l' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> 0 ) ; } <S2SV_ModStart> case 'i' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> 0 ) ; }
<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> = 0 ; ( i + 3 ) <S2SV_ModEnd> < sec -> <S2SV_ModStart> = 0 ; ( i + 7 ) <S2SV_ModEnd> < sec ->
<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; }
<S2SV_ModStart> pos + 8 + 8 <S2SV_ModStart> size ; } const <S2SV_ModStart> 4 ) ) ; const int <S2SV_ModEnd> max_val = (
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> . name ) { continue ; } <S2SV_ModEnd> if ( values
<S2SV_ModStart> || obuf_len < 1 <S2SV_ModEnd> ) { return <S2SV_ModStart> } break ; # if 0 <S2SV_ModStart> ; break ; # endif <S2SV_ModStart> length ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; } <S2SV_ModStart> 1 ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ut8 ) ; }

<S2SV_ModStart> 1 ; } int len = to - from ; <S2SV_ModStart> = calloc ( len <S2SV_ModEnd> , 1 ) <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ; while <S2SV_ModStart> ) > 5 + rc <S2SV_ModStart> bool is_wide32 = ( <S2SV_ModStart> 2 < to ) && ( <S2SV_ModEnd> ! w [ <S2SV_ModStart> [ 4 ] )
<S2SV_ModStart> , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> ; if (
<S2SV_ModStart> 0 ) { if ( dbg_data_len < 20 ) { eprintf ( "Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n" ) ; return 0 ; } SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModEnd> ; init_cv_nb10_header ( <S2SV_ModStart> age ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> 1 ) ; }
<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> > 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , "%d<S2SV_blank>" ,
<S2SV_ModStart> sh_info && ( end - <S2SV_ModStart> * ) defs > i <S2SV_ModEnd> ) ; ++ <S2SV_ModStart> vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> > end || end - vstart < <S2SV_ModEnd> sizeof ( Elf_ <S2SV_ModStart> Verdaux ) ) <S2SV_ModEnd> ) { sdb_free
<S2SV_ModStart> == '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = strchr <S2SV_ModStart> off ) ) { <S2SV_ModStart> ) ; } } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> "Unknown<S2SV_blank>filesystem<S2SV_blank>type\\n" ) ; } <S2SV_ModStart> offset ) ) { <S2SV_ModStart> input ) ; }
<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , "invalid<S2SV_blank>extent" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> "something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
<S2SV_ModStart> buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = (
<S2SV_ModStart> c ) { char * fpath = grub_malloc ( <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> ) + 1 ) ; char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> grub_strlen ( currpath <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> while ( * <S2SV_ModStart> currfound = currnode ; free ( fpath ) <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> ( grub_errno ) { free ( fpath ) ; <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> oldnode , c ) ; free ( fpath <S2SV_ModStart> c ) ; free ( fpath ) ; <S2SV_ModStart> = type ; free ( fpath ) ; <S2SV_ModStart> next ; } free ( fpath ) ;
<S2SV_ModStart> -> device ) { <S2SV_ModStart> disk ) ; }
<S2SV_ModStart> { if ( ! disk ) { eprintf ( "oops.<S2SV_blank>no<S2SV_blank>disk\\n" ) ; return 1 ; } <S2SV_ModEnd> const int blocksize <S2SV_ModStart> blocksize = 512 <S2SV_ModEnd> ; RIOBind * <S2SV_ModStart> ( bio ) { <S2SV_ModStart> = bio ; } if ( <S2SV_ModEnd> iob -> read_at <S2SV_ModStart> * blocksize ) <S2SV_ModEnd> == - 1 <S2SV_ModStart> - 1 ) { <S2SV_ModStart> 1 ; } <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> end ) { if ( * begin > strlen ( str ) ) { return TT_EOF ; } <S2SV_ModStart> ( begin && str [ * begin ] && <S2SV_ModStart> TT_EOF ; } <S2SV_ModEnd> if ( isalpha <S2SV_ModStart> ( end && str [ * end ] && <S2SV_ModStart> TT_WORD ; } <S2SV_ModEnd> if ( isdigit
<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;

<S2SV_ModStart> ( ! data || len < 2 ) { <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; }
<S2SV_ModStart> ; } } return - 1 ;
<S2SV_ModStart> 0 ) { char * filename = grub_malloc ( <S2SV_ModEnd> dirent . namelen <S2SV_ModStart> namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * <S2SV_ModStart> = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc <S2SV_ModStart> ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; <S2SV_ModEnd> grub_free ( fdiro <S2SV_ModStart> closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos
<S2SV_ModStart> < INDIRECT_BLOCKS ) { <S2SV_ModStart> ] ) ; }
<S2SV_ModStart> - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> object -> list
<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
<S2SV_ModStart> 0 ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> ; j < minsz <S2SV_ModEnd> ; j ++ <S2SV_ModStart> ++ ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ j <S2SV_ModStart> + idx ] ; r_cons_printf ( "%02x" , ch <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> val ) ; } <S2SV_ModStart> != UT64_MAX ) { <S2SV_ModStart> ptr ) ; } <S2SV_ModStart> - 1 ) { <S2SV_ModStart> refptr ) ; }
<S2SV_ModStart> if ( argReg > <S2SV_ModEnd> regsz ) { <S2SV_ModStart> regsz ) { return ;
<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; }
<S2SV_ModStart> ; if ( len > 1 ) { if ( <S2SV_ModStart> <= 127 ) { <S2SV_ModStart> -> size ; } else { <S2SV_ModEnd> op -> jump <S2SV_ModStart> -> size ; } } else { op -> jump = addr ; }
<S2SV_ModStart> count ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> < count && txtLen <S2SV_ModEnd> + 10 < <S2SV_ModStart> ++ ) { snprintf ( txt , txtLeft <S2SV_ModEnd> , "%d<S2SV_blank>" , <S2SV_ModStart> ] ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> } snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , "%d" ,
<S2SV_ModStart> ( buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> len ) ; }
<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (
<S2SV_ModStart> sts ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> -> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ; if ( bin -> dyld_info ) { if ( <S2SV_ModStart> "Cannot<S2SV_blank>parse<S2SV_blank>dyldinfo\\n" ) ; R_FREE <S2SV_ModEnd> ( bin -> <S2SV_ModStart> ; } } }
<S2SV_ModStart> < 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free
<S2SV_ModStart> ) { i ++ <S2SV_ModEnd> ; } if
<S2SV_ModStart> = NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 count <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> ) ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } ptr <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> -> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> i < len && len < buflen <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ) { goto beach <S2SV_ModEnd> ; } ut32 <S2SV_ModStart> return ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false
<S2SV_ModStart> header . types_size <S2SV_ModEnd> ) { continue
<S2SV_ModStart> [ 0 ] % 6 <S2SV_ModStart> = 0x8b ; data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> | 0x5 ; } <S2SV_ModStart> >> 24 ; } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> } if ( op -> operands [ 1 ] . regs [ 1 ] != X86R_UNDEFINED <S2SV_ModEnd> ) { data <S2SV_ModStart> ++ ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> op -> operands <S2SV_ModStart> << 3 | <S2SV_ModEnd> op -> operands
<S2SV_ModStart> 24 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> 8 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i" , <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#04hx" , <S2SV_ModStart> # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i" , <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>class+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>field+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%" PFMT64x <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>thing+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" ) <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>class+%i" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>method+%i" ,
<S2SV_ModStart> -> has_va ; <S2SV_ModEnd> char * arch <S2SV_ModStart> * arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 bits <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpu && * <S2SV_ModStart> cpu && * <S2SV_ModEnd> cpu ) { <S2SV_ModStart> , "anal.cpu" , <S2SV_ModEnd> cpu ) ; <S2SV_ModStart> r , binfile ) ; free ( cpu ) ; free ( arch
<S2SV_ModStart> + i ; size_t vstart_off = i ; <S2SV_ModStart> < 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { sdb_free <S2SV_ModStart> ; } vstart += vdaux ; vstart_off <S2SV_ModStart> . vda_next ; vstart_off += aux . vda_next ;
<S2SV_ModStart> -> opt ; <S2SV_ModEnd> int res = <S2SV_ModStart> 0 ; } char * abspath_to_file = r_str_newf ( "%s%s%s%s%s%s%s" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , opt -> dbg_file ) ; if ( r_file_exists ( abspath_to_file ) ) { eprintf ( "File<S2SV_blank>already<S2SV_blank>downloaded.\\n" ) ; free ( abspath_to_file ) ; return 1 ; } if ( checkExtract ( ) || opt -> extract == 0 ) { char * extractor_cmd = NULL ; char * archive_name = strdup ( opt -> dbg_file ) ; archive_name [ strlen ( archive_name ) <S2SV_ModEnd> - 1 ] <S2SV_ModStart> = '_' ; char * abspath_to_archive = r_str_newf ( "%s%s%s%s%s%s%s" , opt -> symbol_store_path , R_SYS_DIR , opt -> dbg_file , R_SYS_DIR , opt -> guid , R_SYS_DIR , archive_name ) ; eprintf ( "Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>compressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\n" , abspath_to_archive ) ; char * abs_arch_esc = r_str_escape_sh ( abspath_to_archive ) ; # if __WINDOWS__ char * abs_file_esc = r_str_escape_sh ( abspath_to_file ) ; extractor_cmd <S2SV_ModEnd> = r_str_newf ( <S2SV_ModStart> = r_str_newf ( "expand<S2SV_blank>\\"%s\\"<S2SV_blank>\\"%s\\"" , abs_arch_esc , abs_file_esc ) ; free ( abs_file_esc <S2SV_ModEnd> ) ; # <S2SV_ModStart> ; # else <S2SV_ModEnd> char * abspath_to_dir <S2SV_ModStart> abspath_to_archive ) ; char * abs_dir_esc = r_str_escape_sh ( abspath_to_dir ) ; <S2SV_ModStart> = r_str_newf ( "cabextract<S2SV_blank>-d<S2SV_blank>\\"%s\\"<S2SV_blank>\\"%s\\"" , abs_arch_esc , abs_dir_esc ) ; free ( abs_dir_esc ) ; free <S2SV_ModEnd> ( abspath_to_dir ) <S2SV_ModStart> ; # endif free ( abs_arch_esc ) ; res = download_and_write ( opt , archive_name <S2SV_ModEnd> ) ; if <S2SV_ModStart> extract > 0 && res ) { eprintf ( "Attempting<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>pdb\\n" ) ; if ( res && <S2SV_ModEnd> ( ( cmd_ret <S2SV_ModStart> ) ; } free ( archive_name ) ; free ( abspath_to_archive <S2SV_ModEnd> ) ; } <S2SV_ModStart> "Falling<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uncompressed<S2SV_blank>pdb\\n" ) ; <S2SV_ModEnd> eprintf ( "Attempting<S2SV_blank>to<S2SV_blank>download<S2SV_blank>uncompressed<S2SV_blank>pdb<S2SV_blank>in<S2SV_blank>%s\\n" <S2SV_ModStart> abspath_to_file ) ; res = download_and_write ( opt , opt -> dbg_file ) ; } free ( abspath_to_file <S2SV_ModEnd> ) ; return
<S2SV_ModStart> eprintf ( "Can\'t<S2SV_blank>find<S2SV_blank>debug<S2SV_blank>filename\\n" ) ; return 1 ; } if ( ! is_valid_guid ( info -> guid ) ) { eprintf ( "Invalid<S2SV_blank>GUID<S2SV_blank>for<S2SV_blank>file\\n"
<S2SV_ModStart> rlen ) { return socket_http_get_recursive ( url , code , rlen , SOCKET_HTTP_MAX_REDIRECTS <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; return socket_http_answer <S2SV_ModEnd> ( s , <S2SV_ModStart> code , rlen , 0
<S2SV_ModStart> = p + 3 <S2SV_ModEnd> ; } #
<S2SV_ModStart> ; mu_run_test ( test_r_str_escape_sh ) ; mu_run_test (
<S2SV_ModStart> ret ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> hdr . startaddr , ( ut8 * ) image_infos , sz <S2SV_ModStart> ; dyld_vmbase = r_buf_read64le <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> = liboff ; int pfo = <S2SV_ModEnd> image_infos [ idx <S2SV_ModStart> ] . pathFileOffset ; if ( pfo < 0 || pfo <S2SV_ModStart> { eprintf ( "corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n" , pfo <S2SV_ModEnd> ) ; free <S2SV_ModStart> } libname = r_buf_read_string <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , pfo , 64 <S2SV_ModEnd> ) ; data
<S2SV_ModStart> r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||
<S2SV_ModStart> '=' : case \'"\' : case '\\\\' : case
<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
<S2SV_ModStart> { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\"\\n" <S2SV_ModEnd> , module , <S2SV_ModStart> { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s\\"\\n" <S2SV_ModEnd> , module ,
<S2SV_ModStart> parameters_size ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> . string ; if ( name > 1024 ) { <S2SV_ModStart> ) ; } else { eprintf ( "Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n" , name ) ; } }
<S2SV_ModStart> continue ; } char op0 = 0 ; <S2SV_ModStart> q ) { op0 = * q ; <S2SV_ModStart> cmd = p <S2SV_ModEnd> ; } else <S2SV_ModStart> * p = op0 <S2SV_ModEnd> ; cmd =
<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
<S2SV_ModStart> } if ( strlen ( token ) > 4 &&
<S2SV_ModStart> int i ; struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set ( <S2SV_ModStart> 0 ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ++ ) { ut32 delta = <S2SV_ModEnd> i * sizeof <S2SV_ModStart> struct minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> ) ) ; if ( r ) { <S2SV_ModStart> ( obj , & <S2SV_ModStart> entry ) ; }
<S2SV_ModStart> filter ) ) ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> "}\\n" ) ; dot_filename = g_strdup_printf ( "/tmp/rs-filter-graph.%u" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( "%s.%u.png" , dot_filename , g_random_int ( ) ) ; g_file_set_contents ( dot_filename <S2SV_ModEnd> , str -> <S2SV_ModStart> NULL ) ; command_line = g_strdup_printf ( "dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s" , png_filename , dot_filename ) ; <S2SV_ModStart> != system ( command_line <S2SV_ModEnd> ) ) g_warning <S2SV_ModStart> "Calling<S2SV_blank>dot<S2SV_blank>failed" ) ; g_free ( command_line ) ; command_line = g_strdup_printf ( "gnome-open<S2SV_blank>%s" , png_filename ) ; <S2SV_ModStart> != system ( command_line <S2SV_ModEnd> ) ) g_warning <S2SV_ModStart> g_warning ( "Calling<S2SV_blank>gnome-open<S2SV_blank>failed." ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename
<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
<S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width &&
<S2SV_ModStart> * data ; struct stream packet = * s ; <S2SV_ModStart> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } if (
<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p (
<S2SV_ModStart> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> * next_order ; struct stream packet = * s ; <S2SV_ModStart> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( "process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream" , & packet ) ; }
<S2SV_ModStart> s ) { <S2SV_ModEnd> int i ; <S2SV_ModStart> int i ; uint16 num_updates <S2SV_ModEnd> ; in_uint16_le ( <S2SV_ModStart> ++ ) { process_bitmap_data ( s <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , len_combined_caps ; struct stream packet = * s ; <S2SV_ModStart> len_combined_caps ) ; if ( ! s_check_rem ( s , len_src_descriptor ) ) { rdp_protocol_error ( "rdp_demand_active(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>source<S2SV_blank>descriptor<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> * pout ; struct stream packet = * s ; if ( ( in_len < 0 ) || ( ( uint32 ) in_len >= ( RD_UINT32_MAX / 2 ) ) ) { logger ( Protocol , Error , "rdp_in_unistr(),<S2SV_blank>length<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." ) ; abort ( ) ; } if ( ! s_check_rem ( s , in_len ) ) { rdp_protocol_error ( "rdp_in_unistr(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>unicode<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> uint16 pakid ; struct stream packet = * s ; <S2SV_ModStart> g_client_id ) ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "rdpdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>g_client_id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>did<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> STREAM out ; struct stream packet = * in ; if ( ! s_check_rem ( in , 4 ) ) { rdp_protocol_error ( "rdpsnd_process_training(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>training<S2SV_blank>data<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> * buf ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "rdpsnddbg_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , s ) ; }
<S2SV_ModStart> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "seamless_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> len ++ ; if ( ( size_t ) len >= sizeof ( icon_buf ) ) { logger ( Protocol , Warning , "seamless_process_line(),<S2SV_blank>icon<S2SV_blank>data<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>icon_buf" ) ; break ; }
<S2SV_ModStart> length ) { if ( length <= 0 ) return ;
<S2SV_ModStart> STREAM s ; struct stream packet ; <S2SV_ModStart> NULL ) { packet = * s ; <S2SV_ModStart> FASTPATH_OUTPUT_ENCRYPTED ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( "sec_recv(),<S2SV_blank>consume<S2SV_blank>fastpath<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> SEC_ENCRYPT ) { if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( "sec_recv(),<S2SV_blank>consume<S2SV_blank>encrypt<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> uint8 swapbyte ; if ( ! s_check_rem ( s , 8 ) ) { rdp_protocol_error ( "sec_recv(),<S2SV_blank>consume<S2SV_blank>redirect<S2SV_blank>signature<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> addlen ) ; assert ( newlen > len ) ; <S2SV_ModStart> sdsHdrSize ( type ) ; assert ( hdrlen + newlen + 1 > len
<S2SV_ModStart> * fp ; assert ( initlen + hdrlen + 1 > initlen ) ;
<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
<S2SV_ModStart> size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ;
<S2SV_ModStart> int result = RLC_ERR ; bn_t t ; RLC_TRY { bn_null ( t ) ; bn_new ( t ) ; switch ( operation ) { case RSA_ENC : case RSA_SIG : case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> * p_len = <S2SV_ModStart> if ( pad == <S2SV_ModEnd> RSA_PAD ) { <S2SV_ModStart> { result = RLC_OK <S2SV_ModEnd> ; } bn_mod_2b <S2SV_ModStart> 8 ) ; }
<S2SV_ModStart> , result = RLC_ERR <S2SV_ModEnd> ; bn_t t <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> * p_len = <S2SV_ModStart> if ( pad == <S2SV_ModEnd> RSA_PUB ) { <S2SV_ModStart> RSA_PUB ) { <S2SV_ModEnd> do { m_len <S2SV_ModStart> 8 ) ; result = ( m_len > <S2SV_ModEnd> 0 ? RLC_OK <S2SV_ModStart> RLC_ERR ) ; } } break ; case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len - len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , 8 * len ) ; bn_read_bin ( t , id , len ) ; bn_add ( m , m , t ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_SIG_HASH : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PRV ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PAD ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_VER : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( bn_is_zero ( t ) ) { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PRV ) { int counter = 0 ; do { counter ++ ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad == RSA_PAD && m_len > 0 ) ; id = hash_id ( MD_MAP , & len ) ; m_len -= len ; bn_rsh ( t , m , m_len * 8 ) ; int r = 0 ; for ( int i = 0 ; i < len ; i ++ ) { pad = ( uint8_t ) t -> dp [ 0 ] ; r |= pad ^ id [ len - i - 1 ] ; bn_rsh ( t , t , 8 ) ; } * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; if ( r && m_len > 0 && counter >= 8 ) { result = RLC_OK ; } } } <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> m_len -- ; <S2SV_ModStart> if ( pad == <S2SV_ModEnd> RSA_PRV ) { <S2SV_ModStart> RSA_PRV ) { int counter = 0 ; do { counter ++ ; <S2SV_ModEnd> m_len -- ; <S2SV_ModStart> while ( pad == RSA_PAD <S2SV_ModEnd> && m_len > <S2SV_ModStart> 0 ) ; * p_len = k_len - m_len ; bn_mod_2b ( m , m , m_len * 8 ) ; <S2SV_ModStart> if ( m_len > 0 && counter >= 8 <S2SV_ModEnd> ) { result <S2SV_ModStart> { result = RLC_OK ; } } } <S2SV_ModEnd> break ; }
<S2SV_ModStart> int result = RLC_ERR <S2SV_ModEnd> ; bn_t t <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> t ) ; result = RLC_OK ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> bn_is_zero ( t <S2SV_ModStart> ) ) { <S2SV_ModEnd> m_len -= RLC_MD_LEN <S2SV_ModStart> [ i ] ^ <S2SV_ModEnd> h2 [ i <S2SV_ModStart> ] ; } bn_mod_2b ( m , m , 8 * m_len ) ; * p_len = bn_size_bin ( m ) ; ( * p_len ) -- ; bn_rsh ( t , m , * p_len * 8 ) ; if ( pad == 0 && bn_cmp_dig ( t , 1 ) == RLC_EQ ) { result = RLC_OK <S2SV_ModEnd> ; } bn_mod_2b <S2SV_ModStart> , m , * p_len * 8 ) ; * p_len = k_len - * p_len ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> 8 ) ; result = RLC_OK ; <S2SV_ModStart> ) ; } result = RLC_OK ; <S2SV_ModStart> 8 ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad == RSA_PSS ) { int r = 1 ; for ( int i = m_len ; i < 8 * k_len ; i ++ ) { if ( bn_get_bit ( m , i ) != 0 ) { r = 0 <S2SV_ModEnd> ; } } <S2SV_ModStart> } if ( r == 1 && <S2SV_ModEnd> bn_is_zero ( m <S2SV_ModStart> { result = RLC_OK <S2SV_ModEnd> ; } bn_read_bin
<S2SV_ModStart> += RRFIXEDSZ ; if ( aptr + rr_len > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; }
<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , ".." ) || strchr ( name , '/'
<S2SV_ModStart> charset ) ; else if ( strcmp ( filetype [ i ] . ext , ".SVG" ) == 0 ) { rsprintf ( "Content-Type:<S2SV_blank>%s\\r\\n" , filetype [ i ] . type ) ; if ( strrchr ( file_name , '/' ) ) strlcpy ( str , strrchr ( file_name , '/' ) + 1 , sizeof ( str ) ) ; else strlcpy ( str , file_name , sizeof ( str ) ) ; if ( str [ 6 ] == '_' && str [ 13 ] == '_' ) rsprintf ( "Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\"%s\\"\\r\\n" , str + 14 ) ; else rsprintf ( "Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\"%s\\"\\r\\n" , str ) ; }
<S2SV_ModStart> "value" ) ) { strencode2 ( str , getparam ( "value" ) , sizeof ( str ) ) ; <S2SV_ModStart> ( loc ( str ) ) ; } <S2SV_ModEnd> s = loc
<S2SV_ModStart> ; time_t then ; if ( strlen ( stamp ) != 2 ) return SRS_ETIMESTAMPOUTOFDATE
<S2SV_ModStart> == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , "/dev/null/" , 2 ) ; # else <S2SV_ModStart> 2 ) ; # endif
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> , rpmpsm psm , int exclusive <S2SV_ModStart> ( dest , exclusive ? "wx.ufdio" : "a.ufdio" <S2SV_ModEnd> ) ; umask <S2SV_ModStart> old_umask ) ; if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; }
<S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 1 , <S2SV_ModStart> , psm , 0 ,
<S2SV_ModStart> , psm , 0 ,
<S2SV_ModStart> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static rpmTagVal <S2SV_ModEnd> headerMergeLegacySigs ( Header <S2SV_ModStart> , Header sigh , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> ; struct rpmtd_s <S2SV_ModStart> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> td . tag <S2SV_ModStart> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> td . tag <S2SV_ModStart> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! headerPut <S2SV_ModEnd> ( h , <S2SV_ModStart> ( h , <S2SV_ModEnd> & td , <S2SV_ModStart> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , "invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> goto exit ; if ( <S2SV_ModStart> h , sigh , & msg ) ) goto exit <S2SV_ModEnd> ; applyRetrofits (
<S2SV_ModStart> , rpmfi fi , const struct stat * fsb <S2SV_ModStart> ) ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> fpath , fi , & sb
<S2SV_ModStart> int iNew ; int bHaveUnprocessed ; DEFiRet ; do { bHaveUnprocessed = 0 ; for ( iStart = 0 ; iStart < pBatch -> nElem && pBatch -> pElem [ iStart ] . state == BATCH_STATE_DISC ; ++ iStart ) ; if ( iStart == pBatch -> nElem ) break ; <S2SV_ModEnd> CHKiRet ( batchInit <S2SV_ModStart> -> pbShutdownImmediate ; currRuleset = batchElemGetRuleset ( pBatch , iStart ) ; iNew = 0 ; for ( i = iStart ; i < pBatch -> nElem ; ++ i ) { if ( batchElemGetRuleset ( pBatch , i ) == currRuleset ) { snglRuleBatch . pElem [ iNew ] . pUsrp = pBatch -> pElem [ i ] . pUsrp ; snglRuleBatch . pElem [ iNew ] . state = pBatch -> pElem [ i ] . state ; ++ iNew ; pBatch -> pElem [ i ] . state = BATCH_STATE_DISC ; } else { bHaveUnprocessed = 1 ; } } snglRuleBatch . nElem = iNew ; batchSetSingleRuleset ( & snglRuleBatch , 1 ) ; processBatch ( & snglRuleBatch ) ; batchFree ( & snglRuleBatch ) ; } while ( bHaveUnprocessed == 1 <S2SV_ModEnd> ) ; finalize_it
<S2SV_ModStart> "auth_tag_len" ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> char * name <S2SV_ModEnd> ; name = <S2SV_ModStart> , NULL , NULL <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> ( ( plen < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> ) || (
<S2SV_ModStart> if ( plen < sizeof ( struct sctp_paramhdr ) <S2SV_ModEnd> ) { break <S2SV_ModStart> ) ; } if ( plen < sizeof ( struct sctp_asconf_addrv4_param ) ) { return ( - 101 ) ; }
<S2SV_ModStart> ) ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> cb1 = (
<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; free
<S2SV_ModStart> if ( ! valid_hex ( job_id ) || ! valid_hex ( prev_hash ) || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) || ! valid_hex ( bbversion ) || ! valid_hex ( nbit ) || ! valid_hex ( ntime ) ) { free <S2SV_ModEnd> ( job_id ) <S2SV_ModStart> ( job_id ) ; free ( coinbase1 ) ; <S2SV_ModEnd> free ( coinbase2
<S2SV_ModStart> -> stratum_port ; snprintf ( address , 254 <S2SV_ModEnd> , "%s:%s" ,
<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
<S2SV_ModStart> KEEP_NIS_AT_END && ( ( NULL == <S2SV_ModEnd> ptr -> line <S2SV_ModStart> -> line ) || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> != ptr -> <S2SV_ModStart> 0 ] ) <S2SV_ModEnd> ) ) # <S2SV_ModStart> KEEP_NIS_AT_END if ( NULL != ptr <S2SV_ModEnd> ) { nis
<S2SV_ModStart> prefix , struct manager_ctx * manager , struct <S2SV_ModStart> server -> password ) ; if ( server -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , server -> method ) ; else if ( manager -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , manager -> method <S2SV_ModStart> ( server -> <S2SV_ModEnd> plugin ) fprintf
<S2SV_ModStart> BUF_SIZE ] ; int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> ; build_config ( <S2SV_ModStart> ( working_dir , manager , server ) <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , BUF_SIZE , "%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf" <S2SV_ModEnd> , executable , <S2SV_ModStart> , executable , <S2SV_ModEnd> manager -> manager_address <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port , working_dir <S2SV_ModStart> , working_dir , <S2SV_ModEnd> port ) ;
<S2SV_ModStart> } } } else <S2SV_ModEnd> { warn ( <S2SV_ModStart> { warn ( "[http]<S2SV_blank>Ignorning<S2SV_blank>broken<S2SV_blank>multipart/form-data" ) ; break ; } } if ( lastPart ) { warn (
<S2SV_ModStart> , scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off
<S2SV_ModStart> * gr ; # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> char * errstr = NULL ; # else int status ; # endif <S2SV_ModEnd> if ( ( <S2SV_ModStart> errstr ) ; if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> sscanf ( s <S2SV_ModStart> gid ) ; if ( status != 1 <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; # endif
<S2SV_ModStart> * pw ; # if ! defined ( __linux__ ) && ! defined ( __NetBSD__ ) <S2SV_ModStart> char * errstr = NULL ; # else int status ; # endif <S2SV_ModEnd> if ( ( <S2SV_ModStart> errstr ) ; if ( errstr ) return - 1 ; # else status = <S2SV_ModEnd> sscanf ( s <S2SV_ModStart> uid ) ; if ( status != 1 <S2SV_ModEnd> ) return - <S2SV_ModStart> - 1 ; # endif
<S2SV_ModStart> EXIT_FAILURE ) ; \\\n} <S2SV_ModEnd> while ( 0 <S2SV_ModStart> ) ; # else # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresgid ( target_pw -> pw_gid , target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , "setresgid" ) ; # else if ( setregid ( target_pw -> pw_gid , target_pw -> pw_gid ) == - 1 ) err ( 1 , "setregid" ) ; # endif if ( initgroups ( target_pw -> pw_name , target_pw -> pw_gid ) == - 1 ) err ( 1 , "initgroups" ) ; # if defined ( __linux__ ) || defined ( __FreeBSD__ ) || defined ( __NetBSD__ ) if ( setresuid ( target , target , target ) == - 1 ) err ( 1 , "setresuid" ) ; # else if ( setreuid ( target , target ) == - 1 ) err ( 1 , "setreuid" ) ; # endif # <S2SV_ModStart> = cwdpath ; <S2SV_ModEnd> syslog ( LOG_AUTHPRIV
<S2SV_ModStart> snap_name ) { <S2SV_ModEnd> char tmpdir [ <S2SV_ModStart> ( "/tmp/" , 0 , 0 <S2SV_ModEnd> ) < 0
<S2SV_ModStart> LOW_FREQUENCY ) ; # if BOOT_TO_DFU flash_option_bytes_init ( 1 ) ; # else flash_option_bytes_init ( 0 ) ; # endif <S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; FLASH -> CR |= FLASH_CR_OBL_LAUNCH ; while ( true <S2SV_ModEnd> ) ; }
<S2SV_ModStart> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; xmlDocPtr doc ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , "11" , & document , & parse_options ) ; Data_Get_Struct ( document , xmlDoc , doc ) ; doc = doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( "ParseOptions" ) ) , rb_intern ( "DEFAULT_SCHEMA" ) ) ; } <S2SV_ModEnd> ctx = xmlRelaxNGNewDocParserCtxt <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , "@parse_options" , parse_options ) ;
<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
<S2SV_ModStart> VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; xmlRelaxNGParserCtxtPtr ctx ; xmlRelaxNGPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , "11" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( "ParseOptions" ) ) , rb_intern ( "DEFAULT_SCHEMA" ) ) ; } ctx <S2SV_ModEnd> = xmlRelaxNGNewMemParserCtxt ( <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> rb_ary_new ( ) <S2SV_ModEnd> ; xmlSetStructuredErrorFunc ( <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , "@parse_options" , parse_options ) ;
<S2SV_ModStart> VALUE from_document ( int argc , VALUE * argv , VALUE klass ) { VALUE document ; VALUE parse_options ; int parse_options_int ; <S2SV_ModEnd> xmlDocPtr doc ; <S2SV_ModStart> VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , "11" , & document , & parse_options ) ; <S2SV_ModStart> doc -> doc ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( "ParseOptions" ) ) , rb_intern ( "DEFAULT_SCHEMA" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( "to_i" ) , 0 ) ) <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , "@parse_options" , parse_options ) ;
<S2SV_ModStart> , read_memory , - <S2SV_ModStart> , from_document , -
<S2SV_ModStart> VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; int parse_options_int ; xmlSchemaParserCtxtPtr ctx ; <S2SV_ModEnd> xmlSchemaPtr schema ; <S2SV_ModStart> xmlSchemaPtr schema ; VALUE errors ; VALUE rb_schema ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , "11" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( "ParseOptions" ) ) , rb_intern ( "DEFAULT_SCHEMA" ) ) ; } parse_options_int = ( int ) NUM2INT ( rb_funcall ( parse_options , rb_intern ( "to_i" ) , 0 ) ) ; <S2SV_ModEnd> ctx = xmlSchemaNewMemParserCtxt <S2SV_ModStart> ( content ) ) ; <S2SV_ModEnd> errors = rb_ary_new <S2SV_ModStart> errors ) ; rb_iv_set ( rb_schema , "@parse_options" , parse_options ) ;
<S2SV_ModStart> pSelect ) { pSelect -> selFlags &= ~ SF_View ; <S2SV_ModStart> & sParse , <S2SV_ModEnd> pSelect , 0
<S2SV_ModStart> p ) { if ( p -> selFlags & SF_View ) return WRC_Prune ;
<S2SV_ModStart> 0 ) { Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> = & sParse ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View
<S2SV_ModStart> pSelect -> pSrc ; if ( pSelect -> selFlags & SF_View ) return WRC_Prune
<S2SV_ModStart> ; if ( p -> selFlags & SF_View ) return WRC_Prune ; if (
<S2SV_ModStart> . pTab ) || ( p -> selFlags & SF_Distinct ) != 0
<S2SV_ModStart> } assert ( pExpr -> y . pTab != 0 ) ; assert ( <S2SV_ModStart> iTable ) ; if ( pExpr -> y . pTab -> tabFlags & TF_HasGenerated ) { Column * pCol = pExpr -> y . pTab -> aCol + pExpr -> iColumn ; if ( pCol -> colFlags & COLFLAG_GENERATED ) n = BMS - 1 ; }
<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = "" ;
<S2SV_ModStart> ; int aff ; if ( pExpr -> y . pTab ) { aff <S2SV_ModStart> iColumn ) ; } else { aff = pExpr -> affExpr ; }
<S2SV_ModStart> iTabCol ) { assert ( pExpr -> y . pTab != 0 ) ; pExpr -> affExpr = sqlite3TableColumnAffinity ( pExpr -> y . pTab , pExpr -> iColumn ) ;
<S2SV_ModStart> 0 ) ; assert ( pDup == 0 || ! ExprHasProperty ( pDup , EP_MemToken ) ) ; <S2SV_ModStart> | EP_IsFalse ) ; pDup -> u . zToken = 0
<S2SV_ModStart> } if ( pParse -> nErr ) goto multi_select_end ; if (
<S2SV_ModStart> CollSeq * p4 ; if ( pParse -> nErr ) return 0
<S2SV_ModStart> ) { return sqlite3ErrorToParser ( db , SQLITE_NOMEM ) <S2SV_ModEnd> ; } p <S2SV_ModStart> ) ; } if ( rc && pParse -> nErr == 0 ) { assert ( pParse -> db -> mallocFailed ) ; return sqlite3ErrorToParser ( pParse -> db , SQLITE_NOMEM ) ; }
<S2SV_ModStart> iSrc ] ; Table * pTab = <S2SV_ModStart> ) iCol ; if ( pTab -> tabFlags & TF_HasGenerated ) { Column * pColumn = pTab -> aCol + iCol ; if ( pColumn -> colFlags & COLFLAG_GENERATED ) { testcase ( pTab -> nCol == 63 ) ; testcase ( pTab -> nCol == 64 ) ; if ( pTab -> nCol >= 64 ) { pItem -> colUsed = ALLBITS ; } else { pItem -> colUsed = MASKBIT ( pTab -> nCol ) - 1 ; } } } else { <S2SV_ModStart> ; } } }
<S2SV_ModStart> } if ( pParse -> nErr ||
<S2SV_ModStart> zName ) ; <S2SV_ModEnd> if ( zName <S2SV_ModStart> zipfile_step_out ; } nName = ( int ) strlen ( zName ) ;
<S2SV_ModStart> zFree ; nPath = ( int ) strlen ( zPath ) <S2SV_ModEnd> ; } }
<S2SV_ModStart> ) == 0 && p -> pWin == 0
<S2SV_ModStart> 3 ) ; if ( sqlite3VdbeGetOp ( v , - 1 ) -> opcode == OP_Column ) { <S2SV_ModStart> OPFLAG_TYPEOFARG ) ; }
<S2SV_ModStart> i ++ ) check_option ( argv [ i ] <S2SV_ModEnd> ) ; argv
<S2SV_ModStart> p -> tokenpos >= ( <S2SV_ModEnd> p -> tokenlen <S2SV_ModStart> p -> tokenlen - 1 )
<S2SV_ModStart> TSRMLS_DC ) { <S2SV_ModEnd> int o_name_len = <S2SV_ModStart> char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( * <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return * where
<S2SV_ModStart> ) { char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> d ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url ;
<S2SV_ModStart> ] ; int nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb <S2SV_ModStart> offset + 4 ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8
<S2SV_ModStart> ; if ( NGX_OK != <S2SV_ModEnd> ngx_http_auth_spnego_basic ( r
<S2SV_ModStart> controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus
<S2SV_ModStart> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * q ; int c ; # endif <S2SV_ModStart> * sender ; int r ; assert ( call ) ; assert ( action ) ; assert ( registry ) ; r = check_good_user ( call , good_user ) ; if ( r != 0 ) return r ; # if ENABLE_POLKIT q = hashmap_get ( * registry , call ) ; if ( q ) { int authorized , challenge ; assert ( q -> reply ) ; if ( ! streq ( q -> action , action ) || ! strv_equal ( q -> details , ( char * * ) details ) ) return - ESTALE ; if ( sd_bus_message_is_method_error ( q -> reply , NULL ) ) { const sd_bus_error * e ; e = sd_bus_message_get_error ( q -> reply ) ; if ( sd_bus_error_has_name ( e , SD_BUS_ERROR_SERVICE_UNKNOWN ) || sd_bus_error_has_name ( e , SD_BUS_ERROR_NAME_HAS_NO_OWNER ) ) return - EACCES ; sd_bus_error_copy ( ret_error , e ) ; return - sd_bus_error_get_errno ( e ) ; } r = sd_bus_message_enter_container ( q -> reply , 'r' , "bba{ss}" ) ; if ( r >= 0 ) r = sd_bus_message_read ( q -> reply , "bb" , & authorized , & challenge ) ; if ( r < 0 ) return r ; if ( authorized ) return 1 ; if ( challenge ) return sd_bus_error_set ( ret_error , SD_BUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED , "Interactive<S2SV_blank>authentication<S2SV_blank>required." ) ; return - EACCES ; } # endif r = sd_bus_query_sender_privilege ( call , capability ) ; if ( r < 0 ) return r ; else if ( r > 0 ) return 1 ; sender = sd_bus_message_get_sender ( call ) ; if ( ! sender ) return - EBADMSG ; # if ENABLE_POLKIT c = sd_bus_message_get_allow_interactive_authorization ( call ) ; if ( c < 0 ) return c ; if ( c > 0 ) interactive = true ; r = hashmap_ensure_allocated ( registry , NULL ) ; if ( r < 0 ) return r ; r = sd_bus_message_new_method_call ( call -> bus , & pk , "org.freedesktop.PolicyKit1" , "/org/freedesktop/PolicyKit1/Authority" , "org.freedesktop.PolicyKit1.Authority" , "CheckAuthorization" ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , "(sa{sv})s" , "system-bus-name" , 1 , "name" , "s" , sender , <S2SV_ModEnd> action ) ; <S2SV_ModStart> action ) ; if ( r < 0 ) return r ; r = bus_message_append_strv_key_value ( pk , details ) ; if ( r < 0 ) return r ; r = sd_bus_message_append ( pk , "us" , interactive , NULL ) ; if ( r < 0 ) return r ; q = new ( AsyncPolkitQuery , 1 ) ; if ( ! q ) return - ENOMEM ; * q = ( AsyncPolkitQuery ) { . request = sd_bus_message_ref ( call ) , } ; q -> action = strdup ( action ) ; if ( ! q -> action ) { async_polkit_query_free ( q ) ; return - ENOMEM ; } q -> details = strv_copy ( ( char * * ) details ) ; if ( ! q -> details ) { async_polkit_query_free ( q ) ; return - ENOMEM ; } r = hashmap_put ( * registry , call , q ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } q -> registry = * registry ; r = sd_bus_call_async ( call -> bus , & q -> slot , pk , async_polkit_callback , q , 0 ) ; if ( r < 0 ) { async_polkit_query_free ( q ) ; return r ; } return 0 ; # endif <S2SV_ModEnd> return - EACCES
<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> b ) ; b -> io_event_source = sd_event_source_unref ( b -> io_event_source ) ;
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) == 0
<S2SV_ModStart> ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , "Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n" , tmp_dir ) ; exit ( 1 ) ; } # endif
<S2SV_ModStart> = "/tmp" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , "/w3m-XXXXXX" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
<S2SV_ModStart> 0 , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> { if ( l == NULL ) break ; if (
<S2SV_ModStart> INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> -= INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
<S2SV_ModStart> NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> size ) { int alloc_size = TfLiteIntArrayGetSizeInBytes ( size ) ; if ( alloc_size <= 0 ) return NULL ; <S2SV_ModStart> ) malloc ( alloc_size ) ; if ( ! ret ) return ret <S2SV_ModEnd> ; ret ->
<S2SV_ModStart> ( len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" <S2SV_ModEnd> , len )
<S2SV_ModStart> = 0 ; if ( is_ipv6 ) { <S2SV_ModStart> sizeof ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . v6 <S2SV_ModStart> } else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> { u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> 2 ) ; <S2SV_ModEnd> addr_size = 4 <S2SV_ModStart> = 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = 0 <S2SV_ModStart> name_entries_valid = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> name_entries_valid = 1 <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> b , * <S2SV_ModEnd> t , c <S2SV_ModStart> t , c ; const u_char * s <S2SV_ModStart> b = ( u_char <S2SV_ModEnd> * ) malloc <S2SV_ModStart> ( s = <S2SV_ModEnd> p , t <S2SV_ModStart> i > 0 && ND_TTEST ( * s ) <S2SV_ModStart> if ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> i -- ; <S2SV_ModStart> ++ ^ 0x20 <S2SV_ModEnd> ; } *
<S2SV_ModStart> case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>?)" ) ) ; break ; }
<S2SV_ModStart> ND_TTEST2 ( * TPA <S2SV_ModEnd> ( ap ) <S2SV_ModStart> ( ndo , "who-has<S2SV_blank>" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>%s" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ( ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string ( <S2SV_ModStart> ap ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ( ndo , "who-has<S2SV_blank>" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> case ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , "at<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break <S2SV_ModStart> ( ndo , "for<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; break
<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>c<S2SV_blank>%04x" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
<S2SV_ModStart> ( dp [ 4 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank><%s>" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) ) )
<S2SV_ModStart> uint32_t ) ; ND_TCHECK <S2SV_ModEnd> ( dp [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; astat
<S2SV_ModStart> < 3 ) goto trunc ; <S2SV_ModEnd> if ( * <S2SV_ModStart> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , "Tag[%u]<S2SV_blank>" , * data ) ) ; else ND_PRINT ( ( ndo , "Tag[Unused]<S2SV_blank>" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> = 0 ; i < length && * data <S2SV_ModEnd> ; i ++
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; else <S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> , u_int length <S2SV_ModEnd> ) { if <S2SV_ModStart> { if ( ! ND_TTEST ( * p ) <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break <S2SV_ModStart> ; if ( length <S2SV_ModEnd> > 1 ) <S2SV_ModStart> , "\\n\\t" , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; return
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> 0 ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> if ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto invalid
<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
<S2SV_ModStart> ext_dp -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> - ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> case IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo , <S2SV_ModStart> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> type = "<S2SV_blank>^<S2SV_blank>" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ND_TCHECK ( * tptr <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> } trunc : ND_PRINT ( ( ndo , "[|esis]" ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> u_int tval ; u_int <S2SV_ModEnd> i ; if <S2SV_ModStart> ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u" <S2SV_ModEnd> , tval >> <S2SV_ModStart> & 0x07 ) , <S2SV_ModEnd> EXTRACT_16BITS ( tptr
<S2SV_ModStart> length ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> 4 ) ) ; if ( i + 4 + optlen > length ) return - 1
<S2SV_ModStart> 0 ; int elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> ndo -> ndo_snapend <S2SV_ModStart> ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; offset = ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , "<BAD<S2SV_blank>PTR>" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> i = * <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> continue ; } <S2SV_ModStart> += l ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> cp ++ ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> tmp ) { ND_TCHECK2 ( * tptr , alen ) ;
<S2SV_ModStart> uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t <S2SV_ModStart> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
<S2SV_ModStart> ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> dp -> ip6r_len <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
<S2SV_ModStart> >= 0 && <S2SV_ModEnd> ND_TTEST ( * <S2SV_ModStart> < ie && <S2SV_ModEnd> ND_TTEST ( *
<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
<S2SV_ModStart> case PGM_OPT_LENGTH : # define PGM_OPT_LENGTH_LEN ( 2 + 2 ) <S2SV_ModStart> ( opt_len != PGM_OPT_LENGTH_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_LENGTH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_LENGTH_LEN ) ) ; return ; } ND_PRINT ( ( ndo , "<S2SV_blank>OPTS<S2SV_blank>LEN<S2SV_blank>(extra?)<S2SV_blank>%d" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; opts_len -= PGM_OPT_LENGTH_LEN ; break ; case PGM_OPT_FRAGMENT : # define PGM_OPT_FRAGMENT_LEN ( 2 + 2 + 4 + 4 + 4 ) if ( opt_len != PGM_OPT_FRAGMENT_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_FRAGMENT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_FRAGMENT_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>FRAG<S2SV_blank>seq<S2SV_blank>%u<S2SV_blank>off<S2SV_blank>%u<S2SV_blank>len<S2SV_blank>%u" , seq , offset , len ) ) ; opts_len -= PGM_OPT_FRAGMENT_LEN ; break ; case PGM_OPT_NAK_LIST : bp += 2 ; opt_len -= 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>NAK<S2SV_blank>LIST" ) ) ; while ( opt_len ) { if ( opt_len < 4 ) { ND_PRINT ( ( ndo , "[Option<S2SV_blank>length<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4]" ) ) ; return ; } ND_TCHECK2 ( * bp , 4 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; opt_len -= 4 <S2SV_ModEnd> ; opts_len -= <S2SV_ModStart> -= 4 ; } break ; case PGM_OPT_JOIN : # define PGM_OPT_JOIN_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_JOIN_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_JOIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_JOIN_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>JOIN<S2SV_blank>%u" , seq <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; opts_len -= PGM_OPT_JOIN_LEN ; break ; case PGM_OPT_NAK_BO_IVL : # define PGM_OPT_NAK_BO_IVL_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len != PGM_OPT_NAK_BO_IVL_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NAK_BO_IVL<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_NAK_BO_IVL_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } bp += 2 ; offset = <S2SV_ModEnd> EXTRACT_32BITS ( bp <S2SV_ModStart> ( bp ) ; bp += 4 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>BACKOFF<S2SV_blank>ivl<S2SV_blank>%u<S2SV_blank>ivlseq<S2SV_blank>%u" , offset , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_IVL_LEN ; break ; case PGM_OPT_NAK_BO_RNG : # define PGM_OPT_NAK_BO_RNG_LEN ( 2 + 2 + 4 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_NAK_BO_RNG_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NAK_BO_RNG<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_NAK_BO_RNG_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; <S2SV_ModStart> ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>BACKOFF<S2SV_blank>max<S2SV_blank>%u<S2SV_blank>min<S2SV_blank>%u" , offset <S2SV_ModEnd> , seq ) <S2SV_ModStart> ; opts_len -= PGM_OPT_NAK_BO_RNG_LEN ; break ; case PGM_OPT_REDIRECT : # define PGM_OPT_REDIRECT_FIXED_LEN ( 2 + 2 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_REDIRECT_FIXED_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN ) ) ; return ; } bp += 2 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_REDIRECT<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , PGM_OPT_REDIRECT_FIXED_LEN <S2SV_ModEnd> , opt_len ) <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof ( struct in6_addr ) ; break ; default : goto trunc ; break ; } ND_PRINT ( ( ndo , "<S2SV_blank>REDIRECT<S2SV_blank>%s" , nla_buf ) ) ; break ; case PGM_OPT_PARITY_PRM : # define PGM_OPT_PARITY_PRM_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_PRM_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PARITY_PRM<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_PARITY_PRM_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>MAXTGS<S2SV_blank>%u" , len ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_PRM_LEN ; break ; case PGM_OPT_PARITY_GRP : # define PGM_OPT_PARITY_GRP_LEN ( 2 + 2 + 4 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> ( opt_len != PGM_OPT_PARITY_GRP_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PARITY_GRP<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_PARITY_GRP_LEN ) ) ; return ; } bp += 2 ; seq = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>GROUP<S2SV_blank>%u" , seq ) <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PARITY_GRP_LEN ; break ; case PGM_OPT_CURR_TGSIZE : # define PGM_OPT_CURR_TGSIZE_LEN ( 2 + 2 + 4 ) if ( opt_len != PGM_OPT_CURR_TGSIZE_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_CURR_TGSIZE<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_CURR_TGSIZE_LEN ) ) ; return ; } bp += 2 ; len = EXTRACT_32BITS ( bp ) ; bp += 4 ; ND_PRINT ( ( ndo , "<S2SV_blank>PARITY<S2SV_blank>ATGS<S2SV_blank>%u" , len ) ) ; opts_len -= PGM_OPT_CURR_TGSIZE_LEN ; break ; case PGM_OPT_NBR_UNREACH : # define PGM_OPT_NBR_UNREACH_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_NBR_UNREACH_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_NBR_UNREACH<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_NBR_UNREACH_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>NBR_UNREACH" ) ) ; opts_len -= PGM_OPT_NBR_UNREACH_LEN ; break ; case PGM_OPT_PATH_NLA : ND_PRINT ( ( ndo , "<S2SV_blank>PATH_NLA<S2SV_blank>[%d]" , opt_len ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_SYN : # define PGM_OPT_SYN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_SYN_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_SYN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_SYN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>SYN" ) ) ; opts_len -= PGM_OPT_SYN_LEN ; break ; case PGM_OPT_FIN : # define PGM_OPT_FIN_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_FIN_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_FIN<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_FIN_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>FIN" ) ) ; opts_len -= PGM_OPT_FIN_LEN ; break ; case PGM_OPT_RST : # define PGM_OPT_RST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_RST_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_RST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_RST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>RST" ) ) ; opts_len -= PGM_OPT_RST_LEN ; break ; case PGM_OPT_CR : ND_PRINT ( ( ndo , "<S2SV_blank>CR" ) ) ; bp += opt_len ; opts_len -= opt_len ; break ; case PGM_OPT_CRQST : # define PGM_OPT_CRQST_LEN ( 2 + 2 ) if ( opt_len != PGM_OPT_CRQST_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_CRQST<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u]" , opt_len , PGM_OPT_CRQST_LEN ) ) ; return ; } bp += 2 ; ND_PRINT ( ( ndo , "<S2SV_blank>CRQST" ) ) ; opts_len -= PGM_OPT_CRQST_LEN ; break ; case PGM_OPT_PGMCC_DATA : # define PGM_OPT_PGMCC_DATA_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) if ( opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 : if ( opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_DATA<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len , PGM_OPT_PGMCC_DATA_FIXED_LEN ) ) ; return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr ) ; opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN <S2SV_ModEnd> + sizeof ( <S2SV_ModStart> ( ndo , "<S2SV_blank>PGMCC<S2SV_blank>DATA<S2SV_blank>%u<S2SV_blank>%s" , offset <S2SV_ModEnd> , nla_buf ) <S2SV_ModStart> break ; case PGM_OPT_PGMCC_FEEDBACK : # define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ( 2 + 2 + 4 + 2 + 2 ) <S2SV_ModEnd> if ( opt_len <S2SV_ModStart> if ( opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>PGM_OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%u]" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN ) ) ; return ; } bp += 2 ; offset = EXTRACT_32BITS ( bp ) ; bp += 4 ; nla_afnum = EXTRACT_16BITS ( bp ) ; bp += 2 + 2 ; switch ( nla_afnum ) { case AFNUM_INET : if ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in_addr ) ) ; addrtostr ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in_addr ) ; break ; case AFNUM_INET6 <S2SV_ModEnd> : if ( <S2SV_ModStart> ( opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "[Bad<S2SV_blank>OPT_PGMCC_FEEDBACK<S2SV_blank>option,<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u<S2SV_blank>+<S2SV_blank>address<S2SV_blank>size]" , opt_len , PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> ) ) ; <S2SV_ModStart> return ; } ND_TCHECK2 ( * bp , sizeof ( struct in6_addr ) ) ; addrtostr6 ( bp , nla_buf , sizeof ( nla_buf ) ) ; bp += sizeof ( struct in6_addr <S2SV_ModEnd> ) ; opts_len <S2SV_ModStart> ; opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN <S2SV_ModEnd> + sizeof (
<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
<S2SV_ModStart> ; if ( opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> flags & TH_SYN <S2SV_ModStart> += 4 ; opt_len -= 4 ; <S2SV_ModStart> MP_DSS_a ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> += 8 ; opt_len -= 8 ; <S2SV_ModStart> } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> += 4 ; opt_len -= 4 ; <S2SV_ModStart> MP_DSS_m ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> += 8 ; opt_len -= 8 ; <S2SV_ModStart> } else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> += 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> += 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>csum<S2SV_blank>0x%x" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> == 12 && ( <S2SV_ModStart> & TH_SYN ) ) <S2SV_ModStart> == 24 && ( <S2SV_ModStart> flags & TH_ACK )
<S2SV_ModStart> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
<S2SV_ModStart> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> ; i <= sysid_len <S2SV_ModEnd> ; i ++
<S2SV_ModStart> case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
<S2SV_ModStart> u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data" ) ) ; return hexdump ; } <S2SV_ModStart> case AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> case AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; }
<S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_length <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } chassis_id_type <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } switch <S2SV_ModStart> case CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> ndo , tptr + 1 , chassis_id_length <S2SV_ModStart> 0 ) { break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ) ; goto next_tlv <S2SV_ModEnd> ; } cfm_tlv_len <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> ( ndo , "<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } mgmt_addr_length <S2SV_ModStart> cfm_tlv_len -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> cfm_tlv_len -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> cfm_tlv_len ) ; next_tlv :
<S2SV_ModStart> int hold ; if ( len < 8 ) goto trunc ; <S2SV_ModStart> char s ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ) ) ; bp += 4 ; len -= 4 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0x3 <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> , bp [ 0 <S2SV_ModEnd> ] & 0xfc <S2SV_ModStart> ) ) ; bp += 1 ; len -= 1 ; if ( len < 1 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> = bp [ 0 <S2SV_ModEnd> ] ; bp <S2SV_ModStart> ; bp += 1 ; len -= 1 <S2SV_ModEnd> ; s = <S2SV_ModStart> -- ) { if ( len < 6 ) goto trunc ;
<S2SV_ModStart> { register const <S2SV_ModEnd> struct pim * <S2SV_ModStart> * ) bp <S2SV_ModEnd> ; # ifdef <S2SV_ModStart> ; # endif ND_TCHECK ( pim -> pim_typever ) ; <S2SV_ModStart> } return ; trunc : ND_PRINT ( ( ndo , "[|pim]" ) ) ; return ;
<S2SV_ModStart> return ; } if ( len < sizeof ( struct in_addr ) ) goto trunc ; <S2SV_ModStart> ) ) ; bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ( bp [ 2 <S2SV_ModEnd> ] , 2 <S2SV_ModStart> & bp [ 2 <S2SV_ModEnd> ] ) ) <S2SV_ModStart> ; bp += 4 <S2SV_ModEnd> ; len -= <S2SV_ModStart> ; len -= 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> ; ND_TCHECK2 ( <S2SV_ModStart> -- ) { if ( len < 4 ) goto trunc ; <S2SV_ModStart> ) ) ; bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] , sizeof <S2SV_ModStart> & bp [ 0 <S2SV_ModEnd> ] ) != <S2SV_ModStart> & bp [ 0 ] ) ) ) ; bp += 4 ; len -= 4 ; if ( len < 4 ) goto trunc <S2SV_ModEnd> ; ND_TCHECK2 ( <S2SV_ModStart> ( bp [ 0 <S2SV_ModEnd> ] , 4 <S2SV_ModStart> & bp [ 0 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> & bp [ 2 <S2SV_ModEnd> ] ) ; <S2SV_ModStart> ; bp += 4 <S2SV_ModEnd> ; len -= <S2SV_ModStart> ; len -= 4 <S2SV_ModEnd> ; for ( <S2SV_ModStart> = "Prune" ; if ( len < 6 ) goto trunc ;
<S2SV_ModStart> ) { register <S2SV_ModEnd> u_char type ; <S2SV_ModStart> u_char type ; <S2SV_ModEnd> ND_TCHECK ( bp <S2SV_ModStart> -> ndo_vflag ) { if ( len < 8 ) goto trunc ; <S2SV_ModStart> 8 ) ; }
<S2SV_ModStart> * bp , u_int len , <S2SV_ModStart> pimv2_addrtype at , u_int addr_len , <S2SV_ModStart> af ; int hdrlen ; if ( addr_len == 0 ) { if ( len < 2 ) goto trunc <S2SV_ModEnd> ; ND_TCHECK ( <S2SV_ModStart> ( bp [ <S2SV_ModEnd> 1 ] ) <S2SV_ModStart> = AF_INET ; addr_len = ( u_int ) <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> = AF_INET6 ; addr_len = ( u_int ) <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> { switch ( addr_len <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } <S2SV_ModEnd> hdrlen = 0 <S2SV_ModStart> += hdrlen ; len -= hdrlen ; <S2SV_ModStart> case pimv2_unicast : if ( len < addr_len ) goto trunc ; <S2SV_ModStart> 0 ] , addr_len <S2SV_ModEnd> ) ; if <S2SV_ModStart> return hdrlen + addr_len <S2SV_ModEnd> ; case pimv2_group <S2SV_ModStart> case pimv2_source : if ( len < addr_len + 2 ) goto trunc ; <S2SV_ModStart> 0 ] , addr_len <S2SV_ModEnd> + 2 ) <S2SV_ModStart> + 2 + addr_len <S2SV_ModEnd> ; default :
<S2SV_ModStart> checksum_status cksum_status ; int pimv2_addr_len ; <S2SV_ModStart> + len ; if ( len < 2 ) goto trunc ; <S2SV_ModStart> , ",<S2SV_blank>RFC2117-encoding" ) ) ; if ( len < 4 ) goto trunc ; ND_TCHECK ( pim -> pim_cksum <S2SV_ModStart> ; } } bp += 4 ; len -= 4 ; <S2SV_ModStart> , olen ; while ( len > 0 ) { if ( len < 4 ) goto trunc ; <S2SV_ModEnd> ND_TCHECK2 ( bp <S2SV_ModStart> ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>Value:<S2SV_blank>" , tok2str ( pimv2_hello_option_values , "Unknown" , otype ) , otype , olen ) ) ; bp += 4 ; len -= 4 ; if ( len < olen ) goto trunc ; <S2SV_ModStart> 0 ] , olen ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> = bp ; u_int plen = len ; <S2SV_ModStart> , ptr , plen , pimv2_unicast , pimv2_addr_len , 0 ) ; if ( advance < 0 ) goto trunc ; ptr += advance ; plen -= <S2SV_ModEnd> advance ; } <S2SV_ModStart> ; bp += olen ; len -= <S2SV_ModStart> * ip ; if ( len < 4 ) goto trunc ; <S2SV_ModStart> ND_TCHECK2 ( * bp <S2SV_ModEnd> , PIMV2_REGISTER_FLAG_LEN ) <S2SV_ModStart> EXTRACT_32BITS ( bp <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ; bp += 4 <S2SV_ModEnd> ; len -= <S2SV_ModStart> ; len -= 4 ; if ( len == 0 ) goto trunc <S2SV_ModEnd> ; ip = <S2SV_ModStart> ) bp ; ND_TCHECK ( ip -> ip_vhl ) ; <S2SV_ModStart> case 0 : ND_TCHECK ( ip -> ip_dst ) ; <S2SV_ModStart> case PIMV2_TYPE_REGISTER_STOP : ND_PRINT ( ( ndo , "<S2SV_blank>group=" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> ; len -= <S2SV_ModStart> ; len -= advance ; ND_PRINT ( ( ndo , "<S2SV_blank>source=" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> , bp , len <S2SV_ModEnd> , pimv2_unicast , <S2SV_ModStart> , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> i , j <S2SV_ModEnd> ; if ( <S2SV_ModStart> 7 ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> } if ( len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) <S2SV_ModEnd> ; ngroup = <S2SV_ModStart> ++ ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> ; if ( len < 4 ) goto trunc ; ND_TCHECK2 ( * bp , 4 ) ; <S2SV_ModEnd> njoin = EXTRACT_16BITS <S2SV_ModStart> , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> , bp , len , pimv2_source , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> ; } } <S2SV_ModEnd> break ; } <S2SV_ModStart> , frpcnt ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; ND_PRINT ( ( ndo , "<S2SV_blank>tag=%x" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ; if ( len < 2 ) goto trunc ; ND_TCHECK ( bp [ 2 ] ) <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> += 2 ; len -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> advance ; for <S2SV_ModStart> , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> += advance ; len -= advance ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ; if ( len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> bp [ 1 <S2SV_ModStart> 1 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>FRPcnt=%d" , frpcnt = bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> ; bp += <S2SV_ModStart> ; bp += 4 ; len -= <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> += advance ; len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ; if ( len < 3 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> bp [ 2 <S2SV_ModStart> 2 ] ) ; ND_PRINT ( ( ndo , ",prio=%d" , bp [ 2 ] ) ) ; if ( len < 4 ) goto trunc <S2SV_ModEnd> ; bp += <S2SV_ModStart> += 4 ; len -= 4 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> case PIMV2_TYPE_ASSERT : ND_PRINT ( ( ndo , "<S2SV_blank>group=" ) ) ; if ( ( advance = pimv2_addr_print ( ndo , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance <S2SV_ModEnd> ; len -= <S2SV_ModStart> ; len -= advance ; ND_PRINT ( ( ndo , "<S2SV_blank>src=" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> ; if ( len < 8 ) goto trunc ; ND_TCHECK2 ( * bp , 8 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , pfxcnt ; if ( len < 1 ) goto trunc ; ND_TCHECK ( bp [ 0 ] ) <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ; if ( len < 2 ) goto trunc ; ND_TCHECK ( <S2SV_ModEnd> bp [ 1 <S2SV_ModStart> 1 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>prio=%d" , bp [ 1 ] ) ) ; if ( len < 4 ) goto trunc ; ND_TCHECK_16BITS <S2SV_ModEnd> ( & bp <S2SV_ModStart> 2 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>holdtime=" ) ) ; unsigned_relts_print ( ndo , EXTRACT_16BITS ( & bp [ 2 ] ) <S2SV_ModStart> += 4 ; len -= 4 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> advance ; for <S2SV_ModStart> , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; bp += advance ; len -= <S2SV_ModEnd> advance ; } <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> += advance ; len -= advance ; <S2SV_ModStart> , bp , len , pimv2_group , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> += advance ; len -= advance ; <S2SV_ModStart> , bp , len , pimv2_unicast , pimv2_addr_len , 0 ) ) < 0 ) goto trunc ; <S2SV_ModEnd> bp += advance <S2SV_ModStart> += advance ; len -= advance ; if ( len < 2 ) goto trunc ; ND_TCHECK_16BITS ( bp <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> return 0 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> p + offset <S2SV_ModEnd> , tim .
<S2SV_ModStart> 0 ) { if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> case IPPROTO_ROUTING : ND_TCHECK ( * cp ) ; <S2SV_ModStart> ip6 ) ; if ( advance < 0 ) return ; <S2SV_ModStart> , cp ) ; if ( advance < 0 ) return <S2SV_ModStart> padlen ) ; if ( advance < 0 ) return ;
<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( dp -> <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ] & 0xc0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> 1 ] & 0x80 ) ND_PRINT ( ( ndo , "M" ) ) ; if ( dp -> icmp6_data16 [ 1 ] &
<S2SV_ModStart> + 1 ; ND_TCHECK2 ( * s , 1 ) ;
<S2SV_ModStart> case PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> case PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> len ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) return ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; cp <S2SV_ModStart> ; tp -> bs_name <S2SV_ModEnd> = strdup ( <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
<S2SV_ModStart> static inline struct bsnamemem <S2SV_ModEnd> * lookup_bytestring ( <S2SV_ModStart> ) { struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr0 == i <S2SV_ModEnd> && tp -> <S2SV_ModStart> && tp -> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> == k && <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> ) , nlen <S2SV_ModStart> = tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> = ( u_char <S2SV_ModStart> ( tp -> bs_bytes <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> = ( struct <S2SV_ModStart> = ( struct bsnamemem <S2SV_ModEnd> * ) calloc <S2SV_ModStart> ( tp -> bs_nxt <S2SV_ModEnd> == NULL )
<S2SV_ModStart> ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; }
<S2SV_ModStart> sfsname ) { <S2SV_ModEnd> char temp [ <S2SV_ModStart> 1 ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> , sfsname , stringlen <S2SV_ModEnd> ) ; temp <S2SV_ModStart> ; temp [ stringlen <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( netdissect_options <S2SV_ModStart> * tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> * msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , "%sRPKI-RTRv%u<S2SV_blank>(unknown)" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , "(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> length ) ; <S2SV_ModEnd> hexdump = FALSE <S2SV_ModStart> pdu_len ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> case RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> case RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> * pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> , error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> encapsulated_pdu_length ) ; tlen += 4 <S2SV_ModEnd> ; error_code = <S2SV_ModStart> ) ) ; <S2SV_ModEnd> if ( encapsulated_pdu_length <S2SV_ModStart> if ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> ) ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ndo , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> + 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length ; <S2SV_ModStart> += encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length = <S2SV_ModStart> ; text_length = <S2SV_ModEnd> EXTRACT_32BITS ( tptr <S2SV_ModStart> EXTRACT_32BITS ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 ; <S2SV_ModStart> += 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , "%sError<S2SV_blank>text:<S2SV_blank>" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( * <S2SV_ModStart> * tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = TRUE <S2SV_ModStart> ; } return pdu_len ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc : <S2SV_ModStart> ; trunc : ND_PRINT ( ( ndo , "\\n\\t%s" , tstr ) ) ; return len <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
<S2SV_ModStart> EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo ,
<S2SV_ModStart> int l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> l2 ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
<S2SV_ModStart> ++ ; } ND_TCHECK ( * p ) ;
<S2SV_ModStart> _U_ ) { const struct ikev2_id * idp ; <S2SV_ModStart> * typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ND_TCHECK ( * idp <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> * tptr , 2 <S2SV_ModEnd> ) ) return
<S2SV_ModStart> case EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> * ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> , "unknown" , subtype ) , subtype <S2SV_ModEnd> ) ) ; <S2SV_ModStart> len ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> case EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> case EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
<S2SV_ModStart> , p + offset + 3 , <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ) ; offset += <S2SV_ModEnd> tim . length <S2SV_ModStart> length - 3 ; length -= <S2SV_ModEnd> tim . length <S2SV_ModStart> - 3 ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> -> caplen ; u_int <S2SV_ModEnd> hdrlen ; uint16_t <S2SV_ModStart> uint8_t seq ; <S2SV_ModEnd> uint16_t panid = <S2SV_ModStart> = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ndo , p + 2 <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> ) { case <S2SV_ModStart> ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> 0 ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> char buf [ 1024 + 1 ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> ; register u_int <S2SV_ModStart> ) ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> , lp -> <S2SV_ModStart> lp -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> ; sepstr = <S2SV_ModStart> } if ( bufp == buf <S2SV_ModEnd> ) ( void
<S2SV_ModStart> p ) { return <S2SV_ModEnd> chdlc_print ( ndo <S2SV_ModStart> , p , h -> len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> u_int proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> : if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> CHDLC_HDRLEN ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ;
<S2SV_ModStart> * obj_tptr ; u_int <S2SV_ModEnd> tlen , lmp_obj_len <S2SV_ModStart> int hexdump ; u_int offset ; u_int <S2SV_ModEnd> link_type ; union <S2SV_ModStart> ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>long)" ) ) ; tlen = len ; } <S2SV_ModStart> & 0x7f ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; return ; } <S2SV_ModStart> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_te_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( <S2SV_ModEnd> obj_tptr + 8 <S2SV_ModStart> ; break ; <S2SV_ModEnd> default : hexdump <S2SV_ModStart> case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } <S2SV_ModStart> , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]" , bittok2str ( lmp_obj_data_link_flag_values , "none" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_flag_values , "none" , <S2SV_ModStart> ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s" , tok2str ( gmpls_encoding_values , "Unknown" , * ( obj_tptr + <S2SV_ModEnd> 8 ) ) <S2SV_ModStart> ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s" , <S2SV_ModEnd> EXTRACT_16BITS ( obj_tptr <S2SV_ModStart> ( obj_tptr + 10 ) , <S2SV_ModEnd> EXTRACT_16BITS ( obj_tptr <S2SV_ModStart> ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? "<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)" : "" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps" , <S2SV_ModEnd> bw . f <S2SV_ModStart> ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr + 16 <S2SV_ModEnd> ) ) ) <S2SV_ModStart> = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u" "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; <S2SV_ModEnd> default : hexdump <S2SV_ModStart> break ; case LMP_OBJ_VERIFY_ID <S2SV_ModEnd> : switch ( <S2SV_ModStart> case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u" , EXTRACT_32BITS ( obj_tptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> break ; case LMP_OBJ_CHANNEL_STATUS <S2SV_ModEnd> : switch ( <S2SV_ModStart> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? "Allocated" : "Non-allocated" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? "Transmit" : "Receive" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_obj_channel_status_values , "Unknown" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> break ; case LMP_OBJ_CHANNEL_STATUS_REQ <S2SV_ModEnd> : switch ( <S2SV_ModStart> ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> break ; case LMP_OBJ_ERROR_CODE <S2SV_ModEnd> : switch ( <S2SV_ModStart> ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_begin_verify_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s" , bittok2str ( lmp_obj_link_summary_error_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; <S2SV_ModEnd> default : hexdump <S2SV_ModStart> break ; case LMP_OBJ_SERVICE_CONFIG <S2SV_ModEnd> : switch ( <S2SV_ModStart> ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s" <S2SV_ModEnd> , bittok2str ( <S2SV_ModStart> , bittok2str ( lmp_obj_service_config_sp_flag_values <S2SV_ModEnd> , "none" , <S2SV_ModStart> , "none" , EXTRACT_8BITS ( obj_tptr ) <S2SV_ModEnd> ) ) ) <S2SV_ModStart> , "\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u" , EXTRACT_8BITS ( obj_tptr + 1 ) <S2SV_ModEnd> ) ) ; <S2SV_ModStart> case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , "Unknown" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u" , <S2SV_ModEnd> EXTRACT_16BITS ( obj_tptr <S2SV_ModStart> EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , "none" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , "none" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s" <S2SV_ModEnd> , bittok2str ( <S2SV_ModStart> , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values <S2SV_ModEnd> , "none" , <S2SV_ModStart> , "none" , EXTRACT_8BITS ( obj_tptr + 3 ) <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( tlen < 1U +
<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
<S2SV_ModStart> ) tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> name_len <S2SV_ModStart> vtp_vlan -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> 0 ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> ; if ( len < tlv_len * 2 + 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; <S2SV_ModEnd> return ; } <S2SV_ModStart> 2 ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> break ; } }
<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> tmp ) { if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> case ISIS_SUBTLV_SPBM_SI : if ( stlv_len < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> ; subtlv_spb_mcid = <S2SV_ModStart> = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> ; break ; <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID : { while ( stlv_len <S2SV_ModEnd> >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0
<S2SV_ModStart> -> header_len ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> u_int plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> - 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> ( pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> & pptr [ 5 <S2SV_ModEnd> ] , ( <S2SV_ModStart> , "origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print (
<S2SV_ModStart> ; if ( snpal == 6 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) ND_PRINT <S2SV_ModStart> ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s" , netal , <S2SV_ModEnd> isonsap_string ( ndo
<S2SV_ModStart> , uint32_t phase _U_ <S2SV_ModStart> , int depth _U_ <S2SV_ModStart> ep ) { <S2SV_ModEnd> switch ( ntohs <S2SV_ModStart> [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) <S2SV_ModStart> ) ; } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_ModStart> ) ) ; ND_PRINT ( ( ndo , ")" ) ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; }
<S2SV_ModStart> ( ndo , "<S2SV_blank>n<S2SV_blank>len=%u" <S2SV_ModEnd> , ntohs ( <S2SV_ModStart> ; if ( ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 2 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> else if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> * ) ( <S2SV_ModEnd> ext + 1 <S2SV_ModStart> trunc ; } }
<S2SV_ModStart> ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" <S2SV_ModEnd> , len - <S2SV_ModStart> ; if ( len > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo -> ndo_vflag <S2SV_ModEnd> ) { if <S2SV_ModStart> trunc ; } }
<S2SV_ModStart> ; u_char showspi <S2SV_ModEnd> , showsomedata ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> showsomedata = 0 <S2SV_ModStart> showsomedata = 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; if ( cp < ep ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 3 <S2SV_ModEnd> || ( showsomedata <S2SV_ModStart> 30 ) ) <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> if ( showsomedata <S2SV_ModEnd> ) { if <S2SV_ModStart> goto trunc ; }
<S2SV_ModStart> length ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> 2 ) ) ; if ( i + 2 + optlen > length ) return - 1
<S2SV_ModStart> case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) ) { ND_TCHECK_8BITS ( tptr ) ;
<S2SV_ModStart> ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
<S2SV_ModStart> aodv_hello * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> goto trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u" , ep -> length ) ) ; break ; }
<S2SV_ModStart> * prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( - <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> n = EXTRACT_32BITS
<S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> 0 ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) )
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> ndo , ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> case L2TP_AVP_TIE_BREAKER : if ( len - 6 < 8 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_ASSND_SESS_ID : if ( len - 6 < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_CHALLENGE_RESP : if ( len - 6 < 16 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; break ; } <S2SV_ModStart> case L2TP_AVP_RX_CONN_SPEED : if ( len - 6 < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; break ; } <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6 <S2SV_ModStart> * ) ptr , len - 6
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> ) dat ; if ( length < 5 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , EXTRACT_16BITS ( dat <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; dat += 2 ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> , "Direction-#%u" , EXTRACT_8BITS ( ptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ) ) ; ptr ++ ; length -- ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; }
<S2SV_ModStart> uint16_t * dat , u_int length ) { if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; }
<S2SV_ModStart> length ) { if ( length < 3 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } <S2SV_ModStart> ) ) ; dat += 3 ; length -= 3 ; <S2SV_ModStart> if ( length != 0 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo , dat , length <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } <S2SV_ModStart> ; ptr ++ ; length -= 2 <S2SV_ModStart> if ( length == 0 ) return ; if ( length < <S2SV_ModEnd> 2 ) { <S2SV_ModStart> 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AVP<S2SV_blank>too<S2SV_blank>short" ) ) ; return ; } <S2SV_ModStart> ptr ++ ; length -= 2 ; <S2SV_ModEnd> if ( length <S2SV_ModStart> if ( length == 0 ) return ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ptr , length <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> tlen = len <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> int * len , int * truncated <S2SV_ModStart> * s ; <S2SV_ModEnd> s = * <S2SV_ModStart> * pptr ; for ( ; ; ) { if ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> * * pptr <S2SV_ModStart> * pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> ( * pptr <S2SV_ModStart> ) -- ; <S2SV_ModEnd> return s ;
<S2SV_ModStart> = 0 ; int truncated = 0 ; <S2SV_ModStart> , & parselen , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( lose ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|zephyr]<S2SV_blank>(%d)" , length ) ) ; return ;
<S2SV_ModStart> ] , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> pptr += BGP_VPN_RD_LEN + 4
<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> ) ) ; } return ; <S2SV_ModEnd> } sport = <S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( bp ) ;
<S2SV_ModStart> ! saw_digit ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\r' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> != '\\n' ) { bp ++ ; <S2SV_ModStart> goto invalid ; } <S2SV_ModStart> ; trunc : * endp = bp ; <S2SV_ModStart> ; invalid : * endp = bp ;
<S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> & 0xf0 ) { <S2SV_ModStart> ) ) ; } <S2SV_ModStart> += 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ) ) ; ND_TCHECK <S2SV_ModEnd> ( mh -> <S2SV_ModStart> [ 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> = IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> += 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> ; ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 ) ;
<S2SV_ModStart> return ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( eigrp_opcode_values , "unknown<S2SV_blank>(%u)" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> ) tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
<S2SV_ModStart> const u_char * ep2 <S2SV_ModEnd> ) { int <S2SV_ModStart> uint32_t t ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ] ) ; } if ( ep2 <S2SV_ModEnd> < p + <S2SV_ModStart> ) ; return ep2 <S2SV_ModEnd> + 1 ; <S2SV_ModStart> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> 2 ] ; if ( ! <S2SV_ModStart> , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } <S2SV_ModEnd> } else { <S2SV_ModStart> , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo <S2SV_ModStart> 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> + totlen ; trunc : return NULL ;
<S2SV_ModStart> const u_char * ep2 <S2SV_ModEnd> , const struct <S2SV_ModStart> , v ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> 4 ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ] ) ; } if ( ep2 <S2SV_ModEnd> < p + <S2SV_ModStart> ) ; return ep2 <S2SV_ModEnd> + 1 ; <S2SV_ModStart> 1 ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> , "value=" ) ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> ) ; else { if ( ! <S2SV_ModStart> , 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } <S2SV_ModEnd> } else { <S2SV_ModStart> , "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( ndo <S2SV_ModStart> 4 ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> + totlen ; trunc : return NULL ;
<S2SV_ModStart> , cp , ep2 <S2SV_ModEnd> , map , <S2SV_ModStart> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; }
<S2SV_ModStart> && nmap ) <S2SV_ModEnd> cp = ikev1_attrmap_print <S2SV_ModStart> , cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u:" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , "[|ripng]" ) ) ; return ;
<S2SV_ModStart> case IPOPT_LSRR : if ( <S2SV_ModStart> , option_len ) == - 1 ) goto trunc
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( netdissect_options <S2SV_ModStart> ) ; return ( 0 ) <S2SV_ModStart> , length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ) ; } return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ) + 4 ; ND_TCHECK ( cp [ 0 ] )
<S2SV_ModStart> bp2 ) { ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> trunc ; } ND_TCHECK ( bp [ 3 ] ) ;
<S2SV_ModStart> uint16_t length ; tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart> 3 ) ; <S2SV_ModEnd> type = * <S2SV_ModStart> 1 ) ; tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart> ] , length <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case BGP_AIGP_TLV : if ( length < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> EXTRACT_64BITS ( tptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ndo , tptr <S2SV_ModEnd> , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , <S2SV_ModStart> "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = 0 ; escapeHTML ( res -> outputbuffer <S2SV_ModEnd> , buf )
<S2SV_ModStart> ( ACTION ( RUNTIME <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { handle_runtime <S2SV_ModEnd> ( req , <S2SV_ModStart> { is_monit_running ( <S2SV_ModEnd> res ) ; <S2SV_ModStart> ; } else { handle_service <S2SV_ModEnd> ( req ,
<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
<S2SV_ModStart> -> outputbuffer , "<td<S2SV_blank>style=\'color:red;\'>" "<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Stop<S2SV_blank>Monit<S2SV_blank>http<S2SV_blank>server?<S2SV_blank>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'stop\'>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>" "</form>" "</td>" , res -> token ) ; StringBuffer_append ( res -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=\'_runtime\'>Force<S2SV_blank>validate<S2SV_blank>now?<S2SV_blank>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'action\'<S2SV_blank>value=\'validate\'>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>" "</form>" "</td>" , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=\'_viewlog\'>View<S2SV_blank>Monit<S2SV_blank>logfile?<S2SV_blank>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Go\'>" "</form>" "</td>" , res -> token <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=%s>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>value=\'start\'<S2SV_blank>name=action>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Start<S2SV_blank>service\'>" "</form>" "</td>" , s -> name , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=%s>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>value=\'stop\'<S2SV_blank>name=action>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Stop<S2SV_blank>service\'>" "</form>" "</td>" , s -> name , res -> token <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=%s>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>value=\'restart\'<S2SV_blank>name=action>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'Restart<S2SV_blank>service\'>" "</form>" "</td>" , s -> name , res -> token ) ; StringBuffer_append ( res -> outputbuffer , "<td>" "<form<S2SV_blank>method=POST<S2SV_blank>action=%s>" "<input<S2SV_blank>type=hidden<S2SV_blank>name=\'securitytoken\'<S2SV_blank>value=\'%s\'>" "<input<S2SV_blank>type=hidden<S2SV_blank>value=\'%s\'<S2SV_blank>name=action>" "<input<S2SV_blank>type=submit<S2SV_blank>value=\'%s\'>" "</form>" "</td>" , s -> name , res -> token <S2SV_ModEnd> , s -> <S2SV_ModStart> "Enable<S2SV_blank>monitoring" ) ; StringBuffer_append ( res -> outputbuffer , "</tr></table>" ) ;
<S2SV_ModStart> ( ) ; MD_T token ; StringBuffer_append ( data , "%ssecuritytoken=%s" , StringBuffer_length ( data ) > 0 ? "&" : "" , Util_getToken ( token ) ) ; <S2SV_ModStart> , "POST<S2SV_blank>%s<S2SV_blank>HTTP/1.0\\r\\n" "Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n" "Cookie:<S2SV_blank>securitytoken=%s\\r\\n" <S2SV_ModStart> "%s" , request , token
<S2SV_ModStart> SC_OK ) ; Util_getToken ( res -> token ) ;
<S2SV_ModStart> ) ) { set_header ( res , "Set-Cookie" , "securitytoken=%s;<S2SV_blank>Max-Age=600;<S2SV_blank>HttpOnly;<S2SV_blank>SameSite=strict%s" , res -> token , Run . httpd . flags & Httpd_Ssl ? ";<S2SV_blank>Secure" : "" ) ;
<S2SV_ModStart> ; } } if ( IS ( req -> method , METHOD_POST ) ) { const char * cookie = get_header ( req , "Cookie" ) ; const char * token = get_parameter ( req , "securitytoken" ) ; if ( ! cookie ) { LogError ( "HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>cookie\\n" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , "Invalid<S2SV_blank>CSRF<S2SV_blank>Token" ) ; return false ; } if ( ! token ) { LogError ( "HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>missing<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>parameter\\n" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , "Invalid<S2SV_blank>CSRF<S2SV_blank>Token" ) ; return false ; } if ( ! Str_startsWith ( cookie , "securitytoken=" ) ) { LogError ( "HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>no<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>in<S2SV_blank>cookie\\n" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , "Invalid<S2SV_blank>CSRF<S2SV_blank>Token" ) ; return false ; } if ( Str_compareConstantTime ( cookie + 14 , token ) ) { LogError ( "HttpRequest:<S2SV_blank>access<S2SV_blank>denied<S2SV_blank>--<S2SV_blank>client<S2SV_blank>[%s]:<S2SV_blank>CSRF<S2SV_blank>token<S2SV_blank>mismatch\\n" , NVLSTR ( Socket_getRemoteHost ( req -> S ) ) ) ; send_error ( req , res , SC_FORBIDDEN , "Invalid<S2SV_blank>CSRF<S2SV_blank>Token" ) ; return false ; } }
<S2SV_ModStart> , "Content-Type" , "%s" ,
<S2SV_ModStart> char * value , ... <S2SV_ModStart> name ) ; va_list ap ; va_start ( ap , value ) ; <S2SV_ModStart> -> value = Str_vcat ( value , ap ) ; va_end ( ap <S2SV_ModEnd> ) ; if
<S2SV_ModStart> idfile ) { ASSERT ( idfile ) ; <S2SV_ModStart> file = NULL <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { <S2SV_ModEnd> file = fopen <S2SV_ModStart> NULL ; } <S2SV_ModEnd> fprintf ( file <S2SV_ModStart> , "%s" , Util_getToken ( Run . id ) <S2SV_ModEnd> ) ; LogInfo
<S2SV_ModStart> insertpos ) = _x2c <S2SV_ModEnd> ( & buf
<S2SV_ModStart> insertpos ) = _x2c <S2SV_ModEnd> ( & buf
<S2SV_ModStart> { if ( <S2SV_ModEnd> url [ y <S2SV_ModStart> [ y ] <S2SV_ModEnd> == '+' ) <S2SV_ModStart> == '+' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } <S2SV_ModStart> ( url [ y <S2SV_ModEnd> ] == '%' <S2SV_ModStart> if ( ! url [ y <S2SV_ModEnd> + 1 ] <S2SV_ModStart> + 1 ] || ! url [ y <S2SV_ModEnd> + 2 ] <S2SV_ModStart> + 2 ] <S2SV_ModEnd> ) break ; <S2SV_ModStart> x ] = _x2c <S2SV_ModEnd> ( url + <S2SV_ModStart> y += 2 ; } else { url [ x ] = url [ y ]
<S2SV_ModStart> tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> tcp_socket = tcp_open <S2SV_ModStart> ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> g_options . only_desired_port <S2SV_ModStart> g_options . only_desired_port ) break ; <S2SV_ModEnd> desired_port ++ ; <S2SV_ModStart> = 49152 ; NOTE ( "Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ; uint16_t real_port ; if ( tcp_socket ) real_port <S2SV_ModStart> tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> stdout ) ; NOTE ( "Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable" , real_port , tcp_socket ? "" : "not<S2SV_blank>" , tcp6_socket ? "" : "not<S2SV_blank>" ) ; <S2SV_ModStart> -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> ) ; if <S2SV_ModStart> tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;
<S2SV_ModStart> { ERR ( "IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed" <S2SV_ModEnd> ) ; goto <S2SV_ModStart> = socket ( AF_INET <S2SV_ModEnd> , SOCK_STREAM , <S2SV_ModStart> { ERR ( "IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> addr ; memset <S2SV_ModStart> ; addr . sin_family = AF_INET ; addr . sin_port <S2SV_ModEnd> = htons ( <S2SV_ModStart> ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ERR ( "IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>" <S2SV_ModEnd> "Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions." ) ; <S2SV_ModStart> { ERR ( "IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket" <S2SV_ModEnd> ) ; goto
<S2SV_ModStart> } } else { <S2SV_ModStart> n ++ ; if ( n == nitems ( p ) ) { free ( copy ) ; return ; } }
<S2SV_ModStart> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family (
<S2SV_ModStart> or_circuit_t * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> circ ) ) { <S2SV_ModStart> circ ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> , end_reason , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> , END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; return <S2SV_ModStart> CIRCUIT_PURPOSE_S_REND_JOINED ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; log_info <S2SV_ModStart> , END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ; connection_free
<S2SV_ModStart> if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING ) return <S2SV_ModStart> if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING_V1_2 ) return
<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> first_rq -> tag ; fq -> orig_rq = first_rq ; hctx = q -> mq_ops -> map_queue ( q , first_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , first_rq -> tag , flush_rq )
<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
<S2SV_ModStart> { rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
<S2SV_ModStart> tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> const char * devname = kstrdup ( dev_name ( & <S2SV_ModEnd> d -> udev <S2SV_ModStart> udev -> dev ) , GFP_KERNEL ) ; const char * drvname = d -> name <S2SV_ModStart> d ) ; pr_info ( "%s:<S2SV_blank>\'%s:%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" <S2SV_ModEnd> , KBUILD_MODNAME , <S2SV_ModStart> , KBUILD_MODNAME , drvname , devname ) ; kfree ( devname <S2SV_ModEnd> ) ; }
<S2SV_ModStart> err = - <S2SV_ModEnd> EALREADY ; if <S2SV_ModStart> - EINVAL ; spin_lock ( & po -> bind_lock ) ; if ( po -> running && <S2SV_ModEnd> match -> type <S2SV_ModStart> ; } } spin_unlock ( & po -> bind_lock ) ; if ( err && ! refcount_read ( & match -> sk_ref ) ) { list_del ( & match -> list ) ; kfree ( match ) ; }
<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
<S2SV_ModStart> start = 0 ; int i <S2SV_ModStart> -> flags ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , kvm -> <S2SV_ModStart> . channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> ps ) { int i ; <S2SV_ModStart> ) ) ; for ( i = 0 ; i < 3 ; i ++ ) <S2SV_ModStart> ( kvm , i <S2SV_ModEnd> , ps -> <S2SV_ModStart> -> channels [ i <S2SV_ModEnd> ] . count
<S2SV_ModStart> ! del_item && btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { if ( <S2SV_ModStart> , fi ) != BTRFS_COMPRESS_NONE && pending_del_nr ) { err = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } pending_del_nr = 0 ; } err = truncate_inline_extent ( inode , path , & found_key , item_end , new_size ) ; if ( err ) { btrfs_abort_transaction ( trans , root , err ) ; goto error ; } } else <S2SV_ModEnd> if ( test_bit <S2SV_ModStart> state ) ) { <S2SV_ModStart> 1 - new_size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> = uid ; <S2SV_ModEnd> new -> count <S2SV_ModStart> new -> count = 0 <S2SV_ModEnd> ; spin_lock_irq ( <S2SV_ModStart> } if ( <S2SV_ModEnd> ucounts -> count <S2SV_ModStart> ucounts -> count == INT_MAX ) ucounts = NULL ; else ucounts -> count += 1 <S2SV_ModEnd> ; spin_unlock_irq (
<S2SV_ModStart> long flags ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> flags ) ; ucounts -> count -= 1 ; if ( ! ucounts -> count ) <S2SV_ModStart> -> node ) ; else ucounts = NULL <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = 0 ; unsigned int copylen ; <S2SV_ModStart> return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL <S2SV_ModStart> EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; <S2SV_ModStart> , user , copylen <S2SV_ModEnd> ) != 0
<S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
<S2SV_ModStart> ; int n ; if ( ! body -> unit_size ) break ; n
<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> umap_lock ) ; skip_mm :
<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> NULL_VM_UFFD_CTX ; } skip_mm :
<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
<S2SV_ModStart> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void sas_destruct_devices ( <S2SV_ModStart> sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry_safe (
<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> sas_revalidate_domain , [ <S2SV_ModEnd> DISCE_SUSPEND ] = <S2SV_ModStart> ] = sas_resume_devices <S2SV_ModEnd> , } ;
<S2SV_ModStart> sas_probe_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry (
<S2SV_ModStart> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> dev ) ; if <S2SV_ModEnd> ( res == <S2SV_ModStart> num_phys ) ; <S2SV_ModEnd> } return res
<S2SV_ModStart> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy
<S2SV_ModStart> gone ) ; sas_destruct_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> base ; } kfree ( clk_src ) ;
<S2SV_ModStart> vfio_irq_set hdr ; size_t size ; <S2SV_ModStart> NULL ; int max , <S2SV_ModStart> || hdr . count >= ( U32_MAX - hdr . start ) || hdr . <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> max = vfio_pci_get_irq_count <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdr . start <S2SV_ModStart> count > max ) return - EINVAL ; switch ( hdr . flags & VFIO_IRQ_SET_DATA_TYPE_MASK ) { case VFIO_IRQ_SET_DATA_NONE : size = 0 ; break ; case VFIO_IRQ_SET_DATA_BOOL : size = sizeof ( uint8_t ) ; break ; case VFIO_IRQ_SET_DATA_EVENTFD : size = sizeof ( int32_t ) ; break ; default : return - EINVAL ; } if ( size ) { if ( hdr . argsz - minsz < hdr . count * size
<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct
<S2SV_ModStart> io -> status || io -> count == 0 <S2SV_ModStart> - ECONNRESET ; io -> count ++ ; <S2SV_ModStart> ) ; } spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ;
<S2SV_ModStart> "failed<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>clock\\n" ) ; goto out_controller_put <S2SV_ModEnd> ; } temp
<S2SV_ModStart> usb_dev ; char * build <S2SV_ModEnd> ; int ret <S2SV_ModStart> ; int ret ; build = kmalloc ( ATUSB_BUILD_SIZE + 1 , GFP_KERNEL ) ; if ( ! build ) return - ENOMEM <S2SV_ModStart> ) ; } kfree ( build ) ;
<S2SV_ModStart> ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;
<S2SV_ModStart> ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; dev_dbg ( <S2SV_ModStart> , reg , buffer <S2SV_ModEnd> , 1 , <S2SV_ModStart> 1000 ) ; if ( <S2SV_ModEnd> ret >= 0 <S2SV_ModStart> ret >= 0 ) { value = buffer [ 0 ] ; kfree ( buffer ) ; return value ; } else { kfree ( buffer ) ; return <S2SV_ModEnd> ret ; } <S2SV_ModStart> ret ; } }
<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
<S2SV_ModStart> ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; if ( <S2SV_ModStart> -> nla_len > <S2SV_ModEnd> skb -> len <S2SV_ModStart> skb -> len - A
<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;
<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
<S2SV_ModStart> key ) { <S2SV_ModEnd> unsigned char key2 <S2SV_ModStart> ] ; struct crypto_cipher * tfm_des <S2SV_ModEnd> ; str_to_key ( <S2SV_ModStart> ; tfm_des = crypto_alloc_cipher ( "des" <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) ) { <S2SV_ModEnd> cifs_dbg ( VFS <S2SV_ModStart> "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; return PTR_ERR ( tfm_des ) ; } crypto_cipher_setkey <S2SV_ModEnd> ( tfm_des , <S2SV_ModStart> 8 ) ; crypto_cipher_encrypt_one ( tfm_des , out , in ) ; crypto_free_cipher <S2SV_ModEnd> ( tfm_des ) <S2SV_ModStart> tfm_des ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2
<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending
<S2SV_ModStart> acl ) { struct iattr iattr ; retval = posix_acl_update_mode ( inode , & iattr . ia_mode , & acl ) ; if ( retval <S2SV_ModEnd> ) goto err_out <S2SV_ModStart> goto err_out ; if ( ! acl ) { value = NULL ; size = 0 ; } <S2SV_ModEnd> iattr . ia_valid <S2SV_ModStart> iattr ) ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret
<S2SV_ModStart> { ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ; } break
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> inode -> i_ctime <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> ; } break
<S2SV_ModStart> ; error = posix_acl_update_mode ( inode , & inode -> i_mode , & acl ) ; if ( error ) return error <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> i_mode ) <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> { err = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err
<S2SV_ModStart> { umode_t mode ; rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( rc <S2SV_ModEnd> ) return rc <S2SV_ModStart> rc ; } <S2SV_ModEnd> } break ;
<S2SV_ModStart> { rc = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( rc ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size <S2SV_ModStart> < 0 ) <S2SV_ModEnd> goto out ;
<S2SV_ModStart> { umode_t mode ; ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; ret =
<S2SV_ModStart> { umode_t mode ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl ) ; if ( error <S2SV_ModEnd> ) { gossip_err <S2SV_ModStart> { gossip_err ( "%s:<S2SV_blank>posix_acl_update_mode<S2SV_blank>err:<S2SV_blank>%d\\n" <S2SV_ModEnd> , __func__ , <S2SV_ModStart> inode ) ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> { umode_t mode <S2SV_ModEnd> ; error = <S2SV_ModStart> ; error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & mode <S2SV_ModStart> , & mode , & acl <S2SV_ModStart> if ( error <S2SV_ModEnd> ) return error <S2SV_ModStart> return error ; <S2SV_ModEnd> error = xfs_set_mode
<S2SV_ModStart> ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
<S2SV_ModStart> = smp_processor_id ( ) ; read_lock ( & evtchn_rwlock <S2SV_ModStart> evtchn_upcall_pending ) ; read_unlock ( & evtchn_rwlock ) ;
<S2SV_ModStart> col ++ ) WRITE_ONCE ( <S2SV_ModStart> [ col ] , - 1 ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> irq ) { const struct irq_info * info = NULL ; if ( likely ( irq < nr_irqs ) ) info = info_for_irq ( irq ) ; if ( ! info <S2SV_ModEnd> ) return 0 <S2SV_ModStart> 0 ; return info <S2SV_ModEnd> -> evtchn ;
<S2SV_ModStart> 1 ; return READ_ONCE ( <S2SV_ModStart> evtchn ) ] )
<S2SV_ModStart> ) ; } WRITE_ONCE ( <S2SV_ModStart> [ col ] , irq ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> ; uint32_t backup_handle = 0 <S2SV_ModStart> ret == 0 ) { if ( <S2SV_ModEnd> res -> backup <S2SV_ModStart> goto out_unlock ; } else { backup_handle = req -> buffer_handle ; }
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
<S2SV_ModStart> ; ue -> card = card ; ue ->
<S2SV_ModStart> -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
<S2SV_ModStart> new_data ) ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> = size ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> } else { int ret = 0 ; mutex_lock ( & ue -> card -> user_ctl_lock ) ; <S2SV_ModStart> -> tlv_data ) { ret = <S2SV_ModEnd> - ENXIO ; <S2SV_ModStart> - ENXIO ; goto err_unlock ; } <S2SV_ModStart> -> tlv_data_size ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto err_unlock ; } <S2SV_ModStart> tlv_data_size ) ) ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; err_unlock : mutex_unlock ( & ue -> card -> user_ctl_lock ) ; if ( ret ) return ret ;
<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;
<S2SV_ModStart> { struct blkif_response * <S2SV_ModStart> int notify ; <S2SV_ModEnd> spin_lock_irqsave ( & <S2SV_ModStart> case BLKIF_PROTOCOL_NATIVE : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> native . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_32 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> x86_32 . rsp_prod_pvt <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BLKIF_PROTOCOL_X86_64 : resp = <S2SV_ModEnd> RING_GET_RESPONSE ( & <S2SV_ModStart> . rsp_prod_pvt ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ) ; } resp -> id = id ; resp -> operation = op ; resp -> status = st ;
<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
<S2SV_ModStart> * ace ; unsigned
<S2SV_ModStart> exit ; } if ( u_cmd . outsize != s_cmd -> outsize || u_cmd . insize != s_cmd -> insize ) { ret = - EINVAL ; goto exit ; } <S2SV_ModStart> s_cmd ) + s_cmd -> <S2SV_ModEnd> insize ) )
<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
<S2SV_ModStart> struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY ; <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> 0 ) { if ( ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_ModStart> 0 ] ; else zap = NULL ;
<S2SV_ModStart> NULL , NULL , true <S2SV_ModStart> NULL , NULL , true
<S2SV_ModStart> s_uuid , NULL , true
<S2SV_ModStart> NULL , NULL , true
<S2SV_ModStart> NULL , NULL , true
<S2SV_ModStart> NULL , NULL , true
<S2SV_ModStart> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;
<S2SV_ModStart> ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (
<S2SV_ModStart> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> ; int error = 0 <S2SV_ModStart> &= PAGE_MASK ; if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> ; prev =
<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
<S2SV_ModStart> -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf
<S2SV_ModStart> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int dev_get_valid_name (
<S2SV_ModStart> -> map = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> goto retry_rebind ; }
<S2SV_ModStart> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;
<S2SV_ModStart> ; task -> tk_rebind_retry = 2 ; task ->
<S2SV_ModStart> = 0x0 ; vcpu -> arch . pv_time_enabled = false ;
<S2SV_ModStart> -> arch ; <S2SV_ModEnd> s64 kernel_ns , <S2SV_ModStart> ; struct pvclock_vcpu_time_info <S2SV_ModEnd> guest_hv_clock ; u8 <S2SV_ModStart> ! vcpu -> pv_time_enabled <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 2 ; if ( unlikely ( kvm_read_guest_cached ( v -> kvm , & vcpu -> pv_time , & guest_hv_clock , sizeof ( guest_hv_clock ) ) ) ) return 0 <S2SV_ModEnd> ; pvclock_flags = <S2SV_ModStart> = ( guest_hv_clock . <S2SV_ModEnd> flags & PVCLOCK_GUEST_STOPPED <S2SV_ModStart> = pvclock_flags ; kvm_write_guest_cached ( v -> kvm , & vcpu -> pv_time , <S2SV_ModEnd> & vcpu -> <S2SV_ModStart> ) ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
<S2SV_ModStart> MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ; <S2SV_ModStart> ) break ; gpa_offset <S2SV_ModEnd> = data & <S2SV_ModStart> ; if ( gpa_offset <S2SV_ModEnd> & ( sizeof <S2SV_ModStart> ) break ; if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> ( vcpu -> <S2SV_ModStart> -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> ; break ;
<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;
<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
<S2SV_ModStart> BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4
<S2SV_ModStart> dst_reg ) ; coerce_reg_to_size <S2SV_ModEnd> ( & regs <S2SV_ModStart> -> dst_reg ] , 4
<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
<S2SV_ModStart> ; print_bpf_insn ( env ,
<S2SV_ModStart> void print_bpf_insn ( const struct bpf_verifier_env * env , const <S2SV_ModStart> ) == BPF_IMM && BPF_SIZE ( insn -> code ) == BPF_DW ) { u64 imm = ( ( u64 ) ( insn + 1 ) -> imm << 32 ) | ( u32 ) insn -> imm ; bool map_ptr = insn -> src_reg == BPF_PSEUDO_MAP_FD ; if ( map_ptr && ! env -> allow_ptr_leaks ) imm = 0 ; verbose ( "(%02x)<S2SV_blank>r%d<S2SV_blank>=<S2SV_blank>0x%llx\\n" , insn -> code , <S2SV_ModEnd> insn -> dst_reg <S2SV_ModStart> -> dst_reg , ( unsigned long long ) <S2SV_ModEnd> imm ) ;
<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
<S2SV_ModStart> user -> uid_keyring && user -> session_keyring
<S2SV_ModStart> hwsim_world_regdom_custom ) ) { kfree ( hwname ) ; <S2SV_ModStart> - EINVAL ; }
<S2SV_ModStart> ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> udf_pc_to_char ( struct <S2SV_ModStart> char * to , int tolen <S2SV_ModStart> = 0 ; int comp_len ; <S2SV_ModStart> p = to ; tolen -- <S2SV_ModStart> case 2 : if ( tolen == 0 ) return - ENAMETOOLONG ; <S2SV_ModStart> = '/' ; tolen -- ; break ; case 3 : if ( tolen < 3 ) return - ENAMETOOLONG ; <S2SV_ModEnd> memcpy ( p <S2SV_ModStart> += 3 ; tolen -= 3 ; <S2SV_ModStart> case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; <S2SV_ModStart> += 2 ; tolen -= 2 ; <S2SV_ModStart> case 5 : comp_len = udf_get_filename ( sb , pc -> componentIdent , pc -> lengthComponentIdent , p , tolen ) ; p += comp_len ; tolen -= comp_len ; if ( tolen == 0 ) return - ENAMETOOLONG <S2SV_ModEnd> ; * p <S2SV_ModStart> ++ = '/' ; tolen -- <S2SV_ModStart> = '\\0' ; return 0 ;
<S2SV_ModStart> b_data ; } err = <S2SV_ModStart> i_size , p , PAGE_SIZE <S2SV_ModStart> ( bh ) ; if ( err ) goto out_unlock_inode
<S2SV_ModStart> * sname , int slen , <S2SV_ModStart> * dname , int dlen <S2SV_ModEnd> ) { struct <S2SV_ModStart> , sname , slen <S2SV_ModEnd> ) ) goto <S2SV_ModStart> ( dname , dlen ,
<S2SV_ModStart> * newName , int newLen , <S2SV_ModStart> * udfName , int udfLen , <S2SV_ModEnd> uint8_t * fidName <S2SV_ModStart> ( newIndex < newLen <S2SV_ModEnd> ) newName [ <S2SV_ModStart> } maxFilenameLen = newLen - CRC_LEN <S2SV_ModEnd> - localExtIndex ; <S2SV_ModStart> ( newIndex > newLen - CRC_LEN ) newIndex = newLen - CRC_LEN <S2SV_ModEnd> ; newName [
<S2SV_ModStart> != BFA_STATUS_OK ) { kfree ( fcstats ) ; <S2SV_ModStart> return NULL ; }
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> nsops < 1 || nsops > SEMOPM
<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> ( ret ) goto err_free_prph_scratch ; <S2SV_ModEnd> prph_info = dma_alloc_coherent <S2SV_ModStart> ( ! prph_info ) { ret = - ENOMEM ; goto err_free_prph_scratch ; } ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ; if ( ! ctxt_info_gen3 ) { ret = - ENOMEM ; goto err_free_prph_info ; } ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ; ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ; ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ; ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ; ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ; ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ; ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ; ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ; ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ; ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ; trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ; trans_pcie -> prph_info = prph_info ; trans_pcie -> prph_scratch = prph_scratch ; iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ; if ( ! iml_img <S2SV_ModStart> - ENOMEM ; <S2SV_ModEnd> memcpy ( iml_img <S2SV_ModStart> return 0 ; err_free_prph_info : dma_free_coherent ( trans -> dev , sizeof ( * prph_info ) , prph_info , trans_pcie -> prph_info_dma_addr ) ; err_free_prph_scratch : dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ; return ret ;
<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> -> base ; kfree ( pool ) ;
<S2SV_ModStart> -> base ; kfree ( pool ) ;
<S2SV_ModStart> -> base ; kfree ( pool ) ;
<S2SV_ModStart> -> base ; kfree ( pool ) ;
<S2SV_ModStart> -> base ; kfree ( pool ) ;
<S2SV_ModStart> out ; } same -> dest_count = count ;
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct xfrm_dump_info <S2SV_ModStart> struct xfrm_dump_info info <S2SV_ModEnd> ; info . <S2SV_ModStart> = NLM_F_MULTI ; <S2SV_ModEnd> ( void )
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
<S2SV_ModStart> = { . start = link -> start , .
<S2SV_ModStart> dentry * upper <S2SV_ModEnd> ; int err <S2SV_ModStart> I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; <S2SV_ModStart> if ( upper == ovl_dentry_upper ( dentry ) ) { <S2SV_ModEnd> if ( is_dir <S2SV_ModStart> NULL ) ; <S2SV_ModEnd> ovl_dentry_version_inc ( dentry <S2SV_ModStart> ) ; } dput ( upper ) ; <S2SV_ModStart> dentry ) ; out_unlock :
<S2SV_ModStart> ; olddentry = lookup_one_len ( old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> . name , old_upperdir , old <S2SV_ModEnd> -> d_name . <S2SV_ModStart> = PTR_ERR ( olddentry <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( IS_ERR ( olddentry <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto out_unlock ; <S2SV_ModEnd> err = - <S2SV_ModStart> if ( olddentry != ovl_dentry_upper ( old ) ) goto out_dput_old ; newdentry = lookup_one_len ( new -> d_name . name , new_upperdir , new -> d_name . len ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out_dput_old ; err = - ESTALE ; if ( ovl_dentry_upper ( new ) ) { if ( opaquedir ) { if ( newdentry != opaquedir <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } else { if ( newdentry != ovl_dentry_upper ( new ) <S2SV_ModEnd> ) goto out_dput <S2SV_ModStart> goto out_dput ; } } else { new_create = true ; if ( ! d_is_negative ( newdentry ) && ( ! new_opaque || ! ovl_is_whiteout ( newdentry ) ) ) goto out_dput ; } <S2SV_ModStart> newdentry ) ; out_dput_old : dput ( olddentry ) ;
<S2SV_ModStart> -> length ) ; if ( err ) return - EFAULT
<S2SV_ModStart> mixer ) { if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> urb ) ; if ( mixer -> rc_urb ) <S2SV_ModStart> rc_urb ) ; mixer -> disconnected = true ;
<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
<S2SV_ModStart> while ( bytes || ! iov -> iov_len
<S2SV_ModStart> ( ) ; iov_iter_advance ( i , copied ) ; <S2SV_ModStart> again ; } <S2SV_ModEnd> pos += copied
<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
<S2SV_ModStart> ; default : kfree ( hmac_buf ) ; <S2SV_ModStart> EINVAL ; goto e_data <S2SV_ModEnd> ; } memset
<S2SV_ModStart> tp_event ) && perf_paranoid_tracepoint_raw <S2SV_ModEnd> ( ) &&
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( <S2SV_ModStart> ! head ) ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> hlist_add_head_rcu ( &
<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
<S2SV_ModStart> -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;
<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
<S2SV_ModStart> ) { struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct <S2SV_ModStart> & type ) ; if ( m -> mnt_ns -> user_ns != user_ns ) type |= CL_UNPRIVILEGED
<S2SV_ModStart> ! hdr ) goto nla_put_failure <S2SV_ModEnd> ; if (
<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
<S2SV_ModStart> head -> iov_base ; if ( hdr > head -> iov_len ) return 0
<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
<S2SV_ModStart> 0 ; } aux . tp_padding = 0 ;
<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
<S2SV_ModStart> if ( rc != KLSI_STATUSBUF_LEN ) { <S2SV_ModEnd> dev_err ( & <S2SV_ModStart> -> dev , "reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed:<S2SV_blank>%d\\n" , rc ) ; if ( rc >= 0 ) rc = - EIO ; } <S2SV_ModEnd> else { status
<S2SV_ModStart> bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
<S2SV_ModStart> int ret = proc_dointvec_minmax <S2SV_ModEnd> ( table ,
<S2SV_ModStart> , reserved_segments ; unsigned int main_segs , blocks_per_seg ; int i ; <S2SV_ModStart> 1 ; } main_segs = le32_to_cpu ( raw_super -> segment_count_main ) ; blocks_per_seg = sbi -> blocks_per_seg ; for ( i = 0 ; i < NR_CURSEG_NODE_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_node_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_node_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; } for ( i = 0 ; i < NR_CURSEG_DATA_TYPE ; i ++ ) { if ( le32_to_cpu ( ckpt -> cur_data_segno [ i ] ) >= main_segs || le16_to_cpu ( ckpt -> cur_data_blkoff [ i ] ) >= blocks_per_seg ) return 1 ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;
<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; error = - EINVAL ; goto err_free_urb ; }
<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
<S2SV_ModStart> else { return false <S2SV_ModEnd> ; } case
<S2SV_ModStart> -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
<S2SV_ModStart> tree ) ; if ( tcon )
<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {
<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
<S2SV_ModStart> ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) {
<S2SV_ModStart> dentry * dir <S2SV_ModEnd> ; int dir_has_key <S2SV_ModStart> 0 ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> dir_has_key = ( d_inode ( dir ) -> i_crypt_info <S2SV_ModEnd> != NULL )
<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
<S2SV_ModStart> struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG "%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci
<S2SV_ModStart> keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> out ; } ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING "%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> ( & keyring_key <S2SV_ModStart> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; }
<S2SV_ModStart> ) ; struct mii_ioctl_data <S2SV_ModEnd> * miidata = <S2SV_ModStart> * miidata = if_mii ( rq ) <S2SV_ModEnd> ; phy_addr = <S2SV_ModStart> ) { case SIOCGMIIPHY : miidata -> phy_id = phy_addr ; <S2SV_ModEnd> break ; case <S2SV_ModStart> break ; case SIOCGMIIREG <S2SV_ModEnd> : miidata -> <S2SV_ModStart> : miidata -> val_out <S2SV_ModEnd> = mii_read ( <S2SV_ModStart> break ; case SIOCSMIIREG : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_ModEnd> mii_write ( dev <S2SV_ModStart> , miidata -> val_in <S2SV_ModEnd> ) ; break
<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
<S2SV_ModStart> pending ) ; spin_lock ( & sta -> ps_lock ) ; <S2SV_ModStart> clear_sta_ps_flags , sta ) ; spin_unlock ( & sta -> ps_lock
<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> ctx ) { <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> spin_lock ( & ctx -> <S2SV_ModStart> cancel_lock ) ; __timerfd_remove_cancel ( ctx <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> spin_unlock ( & ctx -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> flags ) { spin_lock ( & ctx -> cancel_lock ) ; <S2SV_ModStart> } } else { __timerfd_remove_cancel <S2SV_ModEnd> ( ctx ) <S2SV_ModStart> ) ; } spin_unlock ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> pagep ) { struct address_space * mapping ; pgoff_t idx ; unsigned long size ; <S2SV_ModStart> page ) ; mapping = dst_vma -> vm_file -> f_mapping ; idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; <S2SV_ModStart> vm_shared ) { size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_nounlock <S2SV_ModEnd> ; ret = <S2SV_ModStart> ( ptl ) ; size = i_size_read ( mapping -> host ) >> huge_page_shift ( h ) ; ret = - EFAULT ; if ( idx >= size ) goto out_release_unlock
<S2SV_ModStart> & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4
<S2SV_ModStart> unsigned long flags ; if ( ! tty ) return
<S2SV_ModStart> -> chan_net = get_net ( net ) <S2SV_ModEnd> ; chan ->
<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i
<S2SV_ModStart> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
<S2SV_ModStart> ( head_skb ) ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;
<S2SV_ModStart> ) ] ; size_t size ; int tmp ; size = min ( count , sizeof ( buf ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> , buffer , size <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ip ++ ; if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;
<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
<S2SV_ModStart> tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
<S2SV_ModStart> ; if ( ( dst_group || dst_pid ) <S2SV_ModEnd> && ! netlink_capable
<S2SV_ModStart> + MIDQ_DATA_BUFF ; u16 head , tail , size ; <S2SV_ModStart> flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( mpu -> dev -> MIDQ + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , & val <S2SV_ModEnd> , 1 ) <S2SV_ModStart> 1 ) ; if ( ++ head > size ) head = 0 ; writew ( head , <S2SV_ModEnd> mpu -> dev <S2SV_ModStart> + JQS_wHead ) ; } out : <S2SV_ModEnd> spin_unlock_irqrestore ( &
<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> rc = 0 ; if ( ! scontext_len ) return - EINVAL
<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> 0 ; else ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; if ( ! ret )
<S2SV_ModStart> , } ; struct dentry * root = <S2SV_ModEnd> mount_pseudo ( fs_type <S2SV_ModStart> AIO_RING_MAGIC ) ; if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ;
<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> assign_eip_near ( struct <S2SV_ModStart> dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; <S2SV_ModStart> -> _eip ; rc = <S2SV_ModStart> , rel ) ; if ( rc != X86EMUL_CONTINUE ) return rc
<S2SV_ModStart> -> _eip ; rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break <S2SV_ModStart> case 4 : rc = assign_eip_near ( ctxt , <S2SV_ModEnd> ctxt -> src <S2SV_ModStart> src . val )
<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> == 0 ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> ) ) ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }
<S2SV_ModStart> int rc ; unsigned long eip <S2SV_ModEnd> ; rc = <S2SV_ModStart> ctxt , & eip <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_near ( ctxt , eip
<S2SV_ModStart> ; u64 msr_data , rcx , rdx <S2SV_ModStart> = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; <S2SV_ModStart> = 1 ; if ( is_noncanonical_address ( rcx ) || is_noncanonical_address ( rdx ) ) return emulate_gp ( ctxt , 0 ) ; <S2SV_ModStart> -> _eip = rdx <S2SV_ModEnd> ; * reg_write <S2SV_ModStart> VCPU_REGS_RSP ) = rcx <S2SV_ModEnd> ; return X86EMUL_CONTINUE
<S2SV_ModStart> <S2SV_null> static inline int <S2SV_ModEnd> jmp_rel ( struct <S2SV_ModStart> rel ) { return
<S2SV_ModStart> eflags ) ) rc = <S2SV_ModStart> case 0xeb : rc = <S2SV_ModStart> eflags ) ) rc =
<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }
<S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> inode ) { struct user_namespace * ns ; <S2SV_ModStart> return true ; ns = current_user_ns ( ) ; if ( ns_capable ( ns , CAP_FOWNER ) && kuid_has_mapping ( ns , inode -> i_uid <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (
<S2SV_ModStart> ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo ->
<S2SV_ModStart> ( tag == ASN1_EOC <S2SV_ModEnd> ) { if <S2SV_ModStart> <= 0x7f ) goto check_length ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> > sizeof ( len <S2SV_ModEnd> ) - 1 <S2SV_ModStart> goto data_overrun_error ; len = 0 ; for ( <S2SV_ModEnd> ; n > <S2SV_ModStart> ] ; } check_length : if ( len > datalen - dp ) goto data_overrun_error ;
<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
<S2SV_ModStart> ( struct ipv6hdr <S2SV_ModEnd> ) ; unsigned <S2SV_ModStart> while ( offset <S2SV_ModEnd> <= packet_len ) <S2SV_ModStart> packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_ModStart> offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_ModStart> -> nexthdr ; } return - EINVAL <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> ( root_uid , current_euid <S2SV_ModEnd> ( ) ) <S2SV_ModStart> } if ( in_egroup_p ( root_gid <S2SV_ModEnd> ) ) {
<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
<S2SV_ModStart> -> pctrl = devm_pinctrl_register ( & pdev -> dev , <S2SV_ModEnd> & amd_pinctrl_desc , <S2SV_ModStart> & amd_pinctrl_desc , <S2SV_ModEnd> gpio_dev ) ; <S2SV_ModStart> ( ret ) return ret <S2SV_ModEnd> ; ret = <S2SV_ModStart> gc ) ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> len < tcp_hdrlen || tcp_hdrlen < sizeof ( struct tcphdr ) <S2SV_ModStart> ; if ( tcp_hdrlen >= 15 * 4 ) return 0 ; if (
<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;
<S2SV_ModStart> == SOCK_RAW ) { if ( ! capable ( CAP_NET_RAW ) ) return - EPERM ; <S2SV_ModStart> & rawsock_raw_ops ; } else { <S2SV_ModEnd> sock -> ops <S2SV_ModStart> & rawsock_ops ; }
<S2SV_ModStart> ) ] ; struct nf_conn * ct = exp -> master ; union nf_inet_addr newaddr ; <S2SV_ModStart> unsigned int ret ; newaddr = ct -> tuplehash [ IP_CT_DIR_REPLY ] . tuple . dst . u3 <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , "all<S2SV_blank>ports<S2SV_blank>in<S2SV_blank>use" ) <S2SV_ModStart> NF_DROP ; } snprintf ( buffer , sizeof ( buffer ) , "%u<S2SV_blank>%u" , ntohl ( newaddr . ip ) , port ) ; pr_debug ( "nf_nat_irc:<S2SV_blank>inserting<S2SV_blank>\'%s\'<S2SV_blank>==<S2SV_blank>%pI4,<S2SV_blank>port<S2SV_blank>%u\\n" , buffer , & newaddr . ip , port ) ; <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , ctinfo , <S2SV_ModStart> ( skb , ct <S2SV_ModEnd> , "cannot<S2SV_blank>mangle<S2SV_blank>packet" )
<S2SV_ModStart> data ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> chunk -> chunk_end + sizeof ( sctp_chunkhdr_t ) <S2SV_ModStart> ) ) { chunk -> pdiscard = 1 ; chunk -> chunk_end = skb_tail_pointer ( chunk -> skb ) ; } else { chunk -> end_of_packet = 1 ; } pr_debug ( "+++sctp_inq_pop+++<S2SV_blank>chunk:%p[%s],<S2SV_blank>length:%d,<S2SV_blank>skb->len:%d\\n" , chunk , sctp_cname ( SCTP_ST_CHUNK ( chunk -> chunk_hdr -> type ) ) , ntohs ( chunk -> chunk_hdr -> length ) , chunk -> skb -> len ) ; return <S2SV_ModEnd> chunk ; }
<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
<S2SV_ModStart> * release , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> UNAME26 ) { const <S2SV_ModStart> rest = UTS_RELEASE ; char buf [ 65 ] = { 0 } <S2SV_ModStart> ; unsigned v ; size_t copy <S2SV_ModStart> + 40 ; copy = min ( sizeof ( buf ) , max_t ( size_t , 1 , len ) ) ; copy = scnprintf <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , copy <S2SV_ModEnd> , "2.6.%u%s" , <S2SV_ModStart> , buf , copy + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> netdev_tx_t <S2SV_ModEnd> hns_nic_net_xmit_hw ( struct <S2SV_ModStart> len ) ; netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ;
<S2SV_ModStart> - EINVAL ; kfree ( ch ) ;
<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
<S2SV_ModStart> NULL ) { struct frag_hdr fhdr ; <S2SV_ModStart> csum = 0 <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> skb ) ; } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int target_xcopy_locate_se_dev_e4 ( struct se_session * sess , <S2SV_ModStart> se_device * * _found_dev , struct percpu_ref * * _found_lun_ref <S2SV_ModEnd> ) { struct <S2SV_ModStart> ) { struct se_dev_entry * deve ; struct se_node_acl * nacl ; struct se_lun * this_lun = NULL ; struct se_device * found_dev = NULL ; if ( ! sess ) goto err_out ; pr_debug ( "XCOPY<S2SV_blank>0xe4:<S2SV_blank>searching<S2SV_blank>for:<S2SV_blank>%*ph\\n" , XCOPY_NAA_IEEE_REGEX_LEN , dev_wwn ) ; nacl = sess -> se_node_acl ; rcu_read_lock ( ) ; hlist_for_each_entry_rcu ( deve , & nacl -> lun_entry_hlist , link ) { struct se_device * this_dev ; int rc ; this_lun = rcu_dereference ( deve -> se_lun ) ; this_dev = rcu_dereference_raw ( this_lun -> lun_se_dev ) ; rc = target_xcopy_locate_se_dev_e4_iter ( this_dev , dev_wwn ) ; if ( rc ) { if ( percpu_ref_tryget_live ( & this_lun -> lun_ref ) ) found_dev = this_dev ; break ; } } rcu_read_unlock ( ) ; if ( found_dev == NULL ) goto err_out ; pr_debug ( "lun_ref<S2SV_blank>held<S2SV_blank>for<S2SV_blank>se_dev:<S2SV_blank>%p<S2SV_blank>se_dev->se_dev_group:<S2SV_blank>%p\\n" , found_dev , & found_dev -> dev_group ) ; * _found_dev = found_dev ; * _found_lun_ref = & this_lun -> lun_ref <S2SV_ModEnd> ; return 0 <S2SV_ModStart> return 0 ; err_out : <S2SV_ModEnd> pr_debug_ratelimited ( "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n" <S2SV_ModStart> EINVAL ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * se_dev , const unsigned char * dev_wwn ) { <S2SV_ModEnd> unsigned char tmp_dev_wwn <S2SV_ModStart> . emulate_3pc ) { pr_debug ( "XCOPY:<S2SV_blank>emulate_3pc<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>se_dev<S2SV_blank>%p\\n" , se_dev ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> 0 ] , <S2SV_ModEnd> dev_wwn , XCOPY_NAA_IEEE_REGEX_LEN <S2SV_ModStart> != 0 ) { pr_debug ( "XCOPY:<S2SV_blank>skip<S2SV_blank>non-matching:<S2SV_blank>%*ph\\n" , XCOPY_NAA_IEEE_REGEX_LEN , tmp_dev_wwn ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModEnd> pr_debug ( "XCOPY<S2SV_blank>0xe4:<S2SV_blank>located<S2SV_blank>se_dev:<S2SV_blank>%p\\n" <S2SV_ModStart> se_dev ) ; <S2SV_ModEnd> return 1 ;
<S2SV_ModStart> = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> dst_dev , & xop -> remote_lun_ref <S2SV_ModStart> = target_xcopy_locate_se_dev_e4 ( se_cmd -> se_sess , <S2SV_ModStart> xop -> src_dev , & xop -> remote_lun_ref
<S2SV_ModStart> xop ) { <S2SV_ModEnd> if ( xop <S2SV_ModStart> == XCOL_SOURCE_RECV_OP ) pr_debug ( "putting<S2SV_blank>dst<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n" , <S2SV_ModEnd> xop -> dst_dev <S2SV_ModStart> xop -> dst_dev ) ; else pr_debug ( "putting<S2SV_blank>src<S2SV_blank>lun_ref<S2SV_blank>for<S2SV_blank>%p\\n" , <S2SV_ModEnd> xop -> src_dev <S2SV_ModStart> xop -> src_dev ) ; percpu_ref_put ( xop -> remote_lun_ref <S2SV_ModEnd> ) ; }
<S2SV_ModStart> return mptctl_getiocinfo ( iocp , <S2SV_ModStart> return mptctl_gettargetinfo ( iocp , <S2SV_ModStart> return mptctl_readtest ( iocp , <S2SV_ModStart> return mptctl_eventquery ( iocp , <S2SV_ModStart> return mptctl_eventenable ( iocp , <S2SV_ModStart> return mptctl_eventreport ( iocp , <S2SV_ModStart> return mptctl_replace_fw ( iocp , <S2SV_ModStart> = mptctl_fw_download ( iocp , <S2SV_ModStart> = mptctl_mpt_command ( iocp , <S2SV_ModStart> = mptctl_do_reset ( iocp , <S2SV_ModStart> = mptctl_hp_hostinfo ( iocp , <S2SV_ModStart> = mptctl_hp_targetinfo ( iocp ,
<S2SV_ModStart> int mptctl_do_fw_download ( MPT_ADAPTER * iocp <S2SV_ModEnd> , char __user <S2SV_ModStart> MPT_FRAME_HDR * mf <S2SV_ModEnd> ; FWDownloadTCSGE_t * <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( mf = <S2SV_ModStart> - EAGAIN ; <S2SV_ModEnd> dctlprintk ( iocp <S2SV_ModStart> int ) fwlen <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> int mptctl_do_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> mfPtr ) { <S2SV_ModEnd> MPT_FRAME_HDR * mf <S2SV_ModStart> 0 ; int <S2SV_ModEnd> flagsLength ; int <S2SV_ModStart> = 0 ; <S2SV_ModEnd> spin_lock_irqsave ( &
<S2SV_ModStart> int mptctl_do_reset ( MPT_ADAPTER * iocp , <S2SV_ModStart> struct mpt_ioctl_diag_reset krinfo <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> int mptctl_eventenable ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_eventenable karg <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> int mptctl_eventquery ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_eventquery karg <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> int mptctl_eventreport ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_eventreport karg ; <S2SV_ModEnd> int numBytes , <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> int mptctl_fw_download ( MPT_ADAPTER * iocp , <S2SV_ModStart> return mptctl_do_fw_download ( iocp <S2SV_ModEnd> , kfwdl .
<S2SV_ModStart> int mptctl_getiocinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> * karg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> pci_dev * pdev <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ( karg ) <S2SV_ModEnd> ; } if
<S2SV_ModStart> int mptctl_gettargetinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_targetinfo karg ; <S2SV_ModEnd> VirtDevice * vdevice <S2SV_ModStart> int * pdata <S2SV_ModEnd> ; int numDevices <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> int mptctl_hp_hostinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> ) arg ; <S2SV_ModEnd> struct pci_dev * <S2SV_ModStart> ; ConfigPageHeader_t hdr <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc
<S2SV_ModStart> int mptctl_hp_targetinfo ( MPT_ADAPTER * ioc , <S2SV_ModStart> * pg3_alloc ; <S2SV_ModEnd> MPT_SCSI_HOST * hd <S2SV_ModStart> ; hp_target_info_t karg <S2SV_ModEnd> ; int data_sz <S2SV_ModStart> } if ( karg . hdr . id >= MPT_MAX_FC_DEVICES ) return - EINVAL ; dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT "mptctl_hp_targetinfo<S2SV_blank>called.\\n" , ioc -> name ) ) ; if ( ( ioc -> bus_type == SAS ) || ( ioc -> bus_type == FC ) ) return 0 ; if ( ( ioc -> spi_data . sdp0length == 0 ) || ( ioc -> sh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> NULL ) ) return 0 ; if ( ioc -> sh -> host_no != karg . hdr . host ) <S2SV_ModEnd> return - ENODEV <S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> data_sz = ioc
<S2SV_ModStart> int mptctl_mpt_command ( MPT_ADAPTER * ioc , <S2SV_ModStart> struct mpt_ioctl_command karg <S2SV_ModEnd> ; int rc <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> rc = mptctl_do_mpt_command <S2SV_ModStart> = mptctl_do_mpt_command ( ioc ,
<S2SV_ModStart> int mptctl_readtest ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_test karg ; <S2SV_ModEnd> if ( copy_from_user <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc
<S2SV_ModStart> int mptctl_replace_fw ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_replace_fw karg ; <S2SV_ModEnd> int newFwSize ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
<S2SV_ModStart> size_change ) { inode_dio_wait ( inode ) ; <S2SV_ModStart> ) goto bail_unlock <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
<S2SV_ModStart> 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> = 0 ; info -> port = NULL ;
<S2SV_ModStart> ! bin ) { v3d_job_put ( & render -> base ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> render -> base ) ; kfree ( bin
<S2SV_ModStart> cee_pg pg ; memset ( & pg , 0 , sizeof ( pg ) ) ; <S2SV_ModStart> struct cee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;
<S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> ieee_maxrate maxrate ; memset ( & maxrate , 0 , sizeof ( maxrate ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) ) <S2SV_ModStart> ieee_ets ets ; memset ( & ets , 0 , sizeof ( ets ) ) ; <S2SV_ModStart> struct ieee_pfc pfc ; memset ( & pfc , 0 , sizeof ( pfc ) )
<S2SV_ModStart> goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; <S2SV_ModStart> ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE )
<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
<S2SV_ModStart> if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++
<S2SV_ModStart> ) ) { u64 <S2SV_ModEnd> mode = ( <S2SV_ModStart> ( * ( u64 <S2SV_ModEnd> * ) valp <S2SV_ModStart> case PSR_AA32_MODE_USR : if ( ! system_supports_32bit_el0 ( ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_AA32_MODE_UND : if ( ! vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ; break ; <S2SV_ModStart> case PSR_MODE_EL1h : if ( vcpu_el1_is_32bit ( vcpu ) ) return - EINVAL ;
<S2SV_ModStart> struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;
<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;
<S2SV_ModStart> sk ) ; spin_lock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; bh_lock_sock <S2SV_ModStart> sk ) ; spin_unlock_bh ( & net -> sctp . addr_wq_lock <S2SV_ModEnd> ) ; sock_put
<S2SV_ModStart> default_auto_asconf ) { spin_lock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> do_auto_asconf = 1 ; spin_unlock ( & sock_net ( sk ) -> sctp . addr_wq_lock ) <S2SV_ModStart> ; } else { <S2SV_ModStart> = 0 ; }
<S2SV_ModStart> return 0 ; spin_lock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ; <S2SV_ModStart> 1 ; } spin_unlock_bh ( & sock_net ( sk ) -> sctp . addr_wq_lock ) ;
<S2SV_ModStart> * head ; <S2SV_ModEnd> newsk -> sk_sndbuf <S2SV_ModStart> -> sk_rcvbuf ; sctp_copy_descendant <S2SV_ModEnd> ( newsk ,
<S2SV_ModStart> ] ; int <S2SV_ModEnd> pktsz , ret <S2SV_ModStart> is_f5u011 ) { u32 * buf ; int i ; <S2SV_ModStart> "Checking<S2SV_blank>memory<S2SV_blank>size\\n" ) ; buf = kmalloc ( 4 , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto fail_free ; } * buf <S2SV_ModEnd> = 0x12345678 ; <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> 4 ) ; * buf <S2SV_ModEnd> = 0x87654321 ; <S2SV_ModStart> , 0xfa80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> , 0x7a80 , buf <S2SV_ModEnd> , 4 ) <S2SV_ModStart> ; switch ( * buf <S2SV_ModEnd> ) { case <S2SV_ModStart> break ; } kfree ( buf ) ;
<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
<S2SV_ModStart> ip_vs_timeout_user t ; memset ( & t , 0 , sizeof ( t ) ) ;
<S2SV_ModStart> "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , "invalid<S2SV_blank>sta_id<S2SV_blank>%u" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;
<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
<S2SV_ModStart> ; if ( <S2SV_ModEnd> timeout == NULL <S2SV_ModStart> ; if ( compat_get_timespec <S2SV_ModEnd> ( & ktspec <S2SV_ModStart> > 0 && compat_put_timespec <S2SV_ModEnd> ( & ktspec
<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , "invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n" ) ; break
<S2SV_ModStart> flags ) ; if ( ! vb ) { dev_dbg ( & dev -> pci -> dev , "vb<S2SV_blank>is<S2SV_blank>empty,<S2SV_blank>dropping<S2SV_blank>frame\\n" ) ; return ; } <S2SV_ModStart> vb2_buf ) ; <S2SV_ModEnd> if ( input
<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
<S2SV_ModStart> ( error ) { kmem_free ( sbuf ) ; <S2SV_ModStart> return error ; }
<S2SV_ModStart> drive ) { unsigned int new_fdc = fdc ; <S2SV_ModStart> N_DRIVE ) { new_fdc <S2SV_ModEnd> = FDC ( <S2SV_ModStart> } if ( new_fdc >= N_FDC <S2SV_ModEnd> ) { pr_info <S2SV_ModStart> return ; } fdc = new_fdc ;
<S2SV_ModStart> ) bfq_idle_slice_timer_body ( bfqd ,
<S2SV_ModStart> void bfq_idle_slice_timer_body ( struct bfq_data * bfqd , <S2SV_ModStart> bfqq ) { <S2SV_ModEnd> enum bfqq_expiration reason <S2SV_ModStart> lock , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> return ; } bfq_clear_bfqq_wait_request ( bfqq ) ;
<S2SV_ModStart> -> bInterval ; <S2SV_ModEnd> result = usb_control_msg <S2SV_ModStart> ) ) ; usb_set_intfdata ( interface , dev ) ; retval = usb_register_dev ( interface , & tower_class ) ; if ( retval ) { dev_err ( idev , "Not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>get<S2SV_blank>a<S2SV_blank>minor<S2SV_blank>for<S2SV_blank>this<S2SV_blank>device.\\n" ) ; usb_set_intfdata ( interface , NULL ) ; goto error ; } dev -> minor = interface -> minor ; dev_info ( & interface -> dev , "LEGO<S2SV_blank>USB<S2SV_blank>Tower<S2SV_blank>#%d<S2SV_blank>now<S2SV_blank>attached<S2SV_blank>to<S2SV_blank>major<S2SV_blank>" "%d<S2SV_blank>minor<S2SV_blank>%d\\n" , ( dev -> minor - LEGO_USB_TOWER_MINOR_BASE ) , USB_MAJOR , dev -> minor ) ;
<S2SV_ModStart> . timer ; mutex_lock ( & pit -> pit_state . lock ) ; <S2SV_ModStart> HRTIMER_MODE_ABS ) ; mutex_unlock ( & pit -> pit_state . lock ) ;
<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
<S2SV_ModStart> command , * largs = NULL , * <S2SV_ModStart> return - EINVAL ; if ( current != task ) return - EACCES <S2SV_ModStart> '\\0' ) { largs = args = kmalloc ( size + 1 , GFP_KERNEL ) ; if ( ! args <S2SV_ModEnd> ) return - <S2SV_ModStart> ) return - ENOMEM ; memcpy ( args , value , size ) ; args [ size ] = '\\0' ; } error = - <S2SV_ModStart> EINVAL ; args = strim ( args ) ; command = strsep ( & args , "<S2SV_blank>" ) ; if ( ! args ) goto out ; args = skip_spaces ( args ) ; if ( ! * args ) goto out ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , "current" ) == 0 ) { if ( strcmp ( command , "changehat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permhat" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , "changeprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , "permprofile" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else goto fail ; } else <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ( name , "exec" ) == 0 ) { if ( strcmp ( command , "exec" ) == 0 ) error = aa_setprocattr_changeprofile ( args , AA_ONEXEC <S2SV_ModEnd> , ! AA_DO_TEST <S2SV_ModStart> AA_DO_TEST ) ; <S2SV_ModEnd> else goto fail <S2SV_ModStart> ; } else <S2SV_ModEnd> goto fail ; <S2SV_ModStart> goto fail ; if ( ! error ) error = size ; out : kfree ( largs ) <S2SV_ModEnd> ; return error <S2SV_ModStart> . error = error = <S2SV_ModStart> NULL ) ; goto out <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
<S2SV_ModStart> ) ; struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct <S2SV_ModStart> task ) ; if ( dev_is_sata ( dev ) ) { list_move_tail ( & cmd -> eh_entry , & sas_ha -> eh_ata_q ) ; return ; }
<S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> { gctx = __perf_event_ctx_lock_double ( group_leader , ctx <S2SV_ModEnd> ) ; if <S2SV_ModStart> err_locked ; } if ( ! ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { if ( gctx != ctx ) { err = - EINVAL ; goto err_locked ; } else { perf_event_ctx_unlock ( group_leader , gctx ) ; move_group = 0 ; } } <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ( move_group ) perf_event_ctx_unlock ( group_leader , gctx <S2SV_ModEnd> ) ; mutex_unlock
<S2SV_ModStart> ; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out
<S2SV_ModStart> ; if ( <S2SV_ModEnd> addr -> l2tp_family <S2SV_ModStart> ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out_unlock ; if (
<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> = true ; spin_unlock_irq ( & i8042_lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> port_data ; spin_lock_irq ( & i8042_lock ) ; <S2SV_ModStart> exists = false ; port -> serio = NULL ; spin_unlock_irq ( & i8042_lock ) <S2SV_ModStart> I8042_KBD_IRQ ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
<S2SV_ModStart> < 0 ) { kfree ( tmp_sdma_rht ) ; <S2SV_ModStart> goto bail ; }
<S2SV_ModStart> ) ; } if ( err == 0 ) goto out_put ; if ( datagrams <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { datagrams = err ; goto out_put ; } <S2SV_ModEnd> if ( err <S2SV_ModStart> err ; } out_put : fput_light ( sock -> file , fput_needed ) ; <S2SV_ModStart> datagrams ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn
<S2SV_ModStart> 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
<S2SV_ModStart> q ) { mutex_lock ( & q -> timer_mutex ) ; <S2SV_ModStart> snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex
<S2SV_ModStart> int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> sizeof ( sllc <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ; if ( state == KEY_IS_POSITIVE && <S2SV_ModEnd> key -> type <S2SV_ModStart> ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec (
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { ret <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_inc <S2SV_ModStart> nikeys ) ; mark_key_instantiated ( key , - error <S2SV_ModEnd> ) ; now
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( keyring )
<S2SV_ModStart> long kflags = READ_ONCE ( key -> flags ) ; short state = READ_ONCE ( key -> state ) <S2SV_ModEnd> ; kenter ( <S2SV_ModStart> { if ( state < 0 ) { <S2SV_ModEnd> ctx -> result <S2SV_ModStart> = ERR_PTR ( state <S2SV_ModEnd> ) ; kleave
<S2SV_ModStart> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key
<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
<S2SV_ModStart> ! thresholds ) ; if ( ! thresholds -> primary ) goto unlock <S2SV_ModStart> ( ) ; unlock :
<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
<S2SV_ModStart> if ( keyring && link_ret == 0
<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
<S2SV_ModStart> -> actual ; bool kiocb_has_eventfd = <S2SV_ModEnd> io_data -> kiocb <S2SV_ModStart> ki_flags & IOCB_EVENTFD ; if ( io_data -> read && ret > 0 ) { use_mm ( io_data -> mm ) ; ret = copy_to_iter ( io_data -> buf , ret , & io_data -> data ) ; if ( iov_iter_count ( & io_data -> data ) ) ret = - EFAULT ; unuse_mm ( io_data -> mm ) ; } io_data -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! kiocb_has_eventfd <S2SV_ModEnd> ) eventfd_signal ( <S2SV_ModStart> -> req ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> follow_dotdot ( struct <S2SV_ModStart> old ) ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ; <S2SV_ModStart> -> d_inode ; return 0 ;
<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
<S2SV_ModStart> ; } else return
<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , "first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" "(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
<S2SV_ModStart> , ret = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> irq_srcu ) ; if <S2SV_ModEnd> ( guest_irq >= <S2SV_ModStart> irq_rt -> nr_rt_entries || hlist_empty ( <S2SV_ModEnd> & irq_rt -> <S2SV_ModStart> [ guest_irq ] ) ) { pr_warn_once ( "no<S2SV_blank>route<S2SV_blank>for<S2SV_blank>guest_irq<S2SV_blank>%u/%u<S2SV_blank>(broken<S2SV_blank>user<S2SV_blank>space?)\\n" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ]
<S2SV_ModStart> mask ) ; if ( wmm_param_ie -> vend_hdr . len + 2 > sizeof ( struct ieee_types_wmm_parameter ) ) break ;
<S2SV_ModStart> endif _end : <S2SV_ModEnd> kill_fasync ( & <S2SV_ModStart> POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;
<S2SV_ModStart> acpi_status status ; <S2SV_ModEnd> union acpi_operand_object * <S2SV_ModStart> acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node
<S2SV_ModStart> ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen
<S2SV_ModStart> ) sockaddr ; memset ( addr , 0 , sizeof ( * addr ) ) ;
<S2SV_ModStart> flush_dcache_page ( page ) ; iov_iter_advance ( ii , tmp <S2SV_ModStart> num_pages ++ ; <S2SV_ModEnd> count += tmp
<S2SV_ModStart> vmx_vpid_bitmap ) ; <S2SV_ModEnd> for ( msr <S2SV_ModStart> 0x83f ) ; <S2SV_ModEnd> if ( enable_ept
<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
<S2SV_ModStart> else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if
<S2SV_ModStart> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
<S2SV_ModStart> , unsigned long npages <S2SV_ModEnd> ) { gfn_t <S2SV_ModStart> = gfn + npages <S2SV_ModEnd> ; gfn +=
<S2SV_ModStart> struct static_key * once_key <S2SV_ModEnd> ) { static <S2SV_ModStart> ; __net_random_once_disable_jump ( once_key <S2SV_ModEnd> ) ; return
<S2SV_ModStart> work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
<S2SV_ModStart> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM
<S2SV_ModStart> ) get_block = ocfs2_lock_get_block <S2SV_ModEnd> ; else get_block <S2SV_ModStart> else get_block = ocfs2_dio_wr_get_block <S2SV_ModEnd> ; return __blockdev_direct_IO
<S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( "i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen
<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
<S2SV_ModStart> pass < 10 || image
<S2SV_ModStart> -> usb_data ) { ieee80211_free_hw ( hw ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> rtlpriv -> firmware_loading_complete ) ; kfree ( rtlpriv -> usb_data
<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }
<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> ; } } io -> io_cleanup = port_cleanup ;
<S2SV_ModStart> inode * inode , int relocated <S2SV_ModStart> de , inode , relocated
<S2SV_ModStart> inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; <S2SV_ModEnd> int result = <S2SV_ModStart> , inode , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> , inode , flags | RR_REGARD_XA <S2SV_ModEnd> ) ; }
<S2SV_ModStart> inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;
<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> ] ) ; free_uid ( fpl -> user ) ;
<S2SV_ModStart> = SCM_MAX_FD ; fpl -> user = NULL ; <S2SV_ModStart> ++ ; } if ( ! fpl -> user ) fpl -> user = get_uid ( current_user ( ) ) ;
<S2SV_ModStart> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> void unix_inflight ( struct user_struct * user , <S2SV_ModStart> ++ ; } <S2SV_ModEnd> user -> unix_inflight
<S2SV_ModStart> void unix_notinflight ( struct user_struct * user , <S2SV_ModStart> -- ; } <S2SV_ModEnd> user -> unix_inflight
<S2SV_ModStart> return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL
<S2SV_ModStart> * info ; int i ; <S2SV_ModStart> = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
<S2SV_ModStart> } else { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_ModStart> 0 ) { mutex_lock ( & ldata -> output_lock ) ; <S2SV_ModStart> b , nr ) ; mutex_unlock ( & ldata -> output_lock
<S2SV_ModStart> page ) ) <S2SV_ModEnd> SetPageDirty ( newpage <S2SV_ModStart> newpage ) ; <S2SV_ModEnd> if ( page_is_young
<S2SV_ModStart> extra_count ) { struct zone * oldzone , * newzone ; int dirty ; <S2SV_ModStart> MIGRATEPAGE_SUCCESS ; } oldzone = page_zone ( page ) ; newzone = page_zone ( newpage ) ; <S2SV_ModStart> ) ; } dirty = PageDirty ( page ) ; if ( dirty ) { ClearPageDirty ( page ) ; SetPageDirty ( newpage ) ; } <S2SV_ModStart> 1 ) ; spin_unlock ( & mapping -> tree_lock ) ; if ( newzone != oldzone ) { __dec_zone_state ( oldzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> NR_FILE_PAGES ) ; __inc_zone_state ( newzone <S2SV_ModEnd> , NR_FILE_PAGES ) <S2SV_ModStart> ; if ( PageSwapBacked ( page ) && <S2SV_ModStart> ( page ) ) { __dec_zone_state ( oldzone , NR_SHMEM ) ; __inc_zone_state ( newzone , NR_SHMEM ) ; } if ( dirty && mapping_cap_account_dirty ( mapping ) ) { __dec_zone_state ( oldzone , NR_FILE_DIRTY ) ; __inc_zone_state ( newzone , NR_FILE_DIRTY ) ; } } local_irq_enable ( <S2SV_ModEnd> ) ; return
<S2SV_ModStart> EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
<S2SV_ModStart> break ; } <S2SV_ModEnd> dst_reg -> smin_value <S2SV_ModStart> = S64_MAX ; <S2SV_ModEnd> if ( src_known
<S2SV_ModStart> ab ) { long len_max ; long len_rem ; long len_full ; long len_buf ; long len_abuf ; long len_tmp ; bool require_data ; bool encode ; unsigned int iter ; unsigned int arg ; char * buf_head ; char * buf <S2SV_ModEnd> ; const char <S2SV_ModStart> char __user * <S2SV_ModEnd> p = ( <S2SV_ModStart> -> arg_start ; char abuf [ 96 ] ; WARN_ON_ONCE ( MAX_EXECVE_AUDIT_LEN > 7500 ) ; len_max = MAX_EXECVE_AUDIT_LEN ; buf_head = kmalloc ( MAX_EXECVE_AUDIT_LEN + 1 , GFP_KERNEL ) ; if ( ! buf_head ) { audit_panic ( "out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>argv<S2SV_blank>string" ) ; return ; } buf = buf_head ; <S2SV_ModStart> argc ) ; len_rem = len_max ; len_buf = 0 ; len_full = 0 ; require_data = true ; encode = false ; iter = 0 ; arg = 0 ; do { if ( len_full == 0 ) len_full = strnlen_user ( p , MAX_ARG_STRLEN ) - 1 ; if ( require_data ) { if ( buf != buf_head ) { memmove ( buf_head , buf , len_buf ) ; buf = buf_head ; } len_tmp = strncpy_from_user ( & buf_head [ len_buf ] , p , len_max - len_buf ) ; if ( len_tmp == - EFAULT ) { send_sig ( SIGKILL , current , 0 ) ; goto out ; } else if ( len_tmp == ( len_max - len_buf ) ) { require_data = true ; encode = true ; len_full = len_full * 2 ; p += len_tmp ; } else { require_data = false ; if ( ! encode ) encode = audit_string_contains_control ( buf , len_tmp ) ; if ( len_full < len_max ) len_full = ( encode ? len_tmp * 2 : len_tmp ) ; p += len_tmp + 1 ; } len_buf += len_tmp ; buf_head [ len_buf ] = '\\0' ; len_abuf = ( encode ? len_buf * 2 : len_buf + 2 ) ; } if ( len_buf > 0 ) { if ( ( sizeof ( abuf ) + 8 ) > len_rem ) { len_rem = len_max ; audit_log_end ( * ab ) ; * ab = audit_log_start ( context , GFP_KERNEL , AUDIT_EXECVE <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! * ab ) goto out ; } len_tmp = 0 ; if ( require_data || ( iter > 0 ) || ( ( len_abuf + sizeof ( abuf ) ) > len_rem ) ) { if ( iter == 0 ) { len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d_len=%lu" , arg , len_full ) ; } len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d[%d]=" , arg , iter ++ ) ; } else len_tmp += snprintf ( & abuf [ len_tmp ] , sizeof ( abuf ) - len_tmp , "<S2SV_blank>a%d=" , arg ) ; WARN_ON ( len_tmp >= sizeof ( abuf ) ) ; abuf [ sizeof ( abuf ) - 1 ] = '\\0' ; audit_log_format ( * ab , "%s" , abuf ) ; len_rem -= len_tmp ; len_tmp = len_buf ; if ( encode ) { if ( len_abuf > len_rem ) len_tmp = len_rem / 2 ; audit_log_n_hex ( * ab , buf , len_tmp ) ; len_rem -= len_tmp * 2 ; len_abuf -= len_tmp * 2 ; } else { if ( len_abuf > len_rem ) len_tmp = len_rem - 2 ; audit_log_n_string ( * ab , buf , len_tmp ) ; len_rem -= len_tmp + 2 ; len_abuf -= len_tmp ; } len_buf -= len_tmp ; buf += len_tmp ; } if ( ( len_buf == 0 ) && ! require_data ) { arg ++ ; iter = 0 ; len_full = 0 ; require_data = true ; encode = false ; } } while ( arg <S2SV_ModEnd> < context -> <S2SV_ModStart> execve . argc ) ; out : kfree ( buf_head <S2SV_ModEnd> ) ; }
<S2SV_ModStart> inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rd_dev ) { struct rd_dev_sg_table * sg_table ; u32 <S2SV_ModEnd> sg_tables , total_sg_needed <S2SV_ModStart> ) ) ; int rc <S2SV_ModEnd> ; if ( <S2SV_ModStart> = sg_tables ; rc = rd_allocate_sgl_table ( rd_dev , sg_table , total_sg_needed , 0x00 ) ; if ( rc ) return rc ; <S2SV_ModEnd> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Built<S2SV_blank>Ramdisk<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>space<S2SV_blank>of"
<S2SV_ModStart> ) { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( "CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array
<S2SV_ModStart> DRM_DEBUG ( "clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( "execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n" , args -> num_cliprects
<S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [ <S2SV_ModStart> ) if ( ++ p <S2SV_ModEnd> != pages [
<S2SV_ModStart> < 0 ) { kfree ( partdata ) ; <S2SV_ModStart> return err ; }
<S2SV_ModStart> return err ; if ( ! <S2SV_ModEnd> attrs [ TIPC_NLA_SOCK <S2SV_ModStart> attrs [ TIPC_NLA_SOCK <S2SV_ModEnd> ] ) return <S2SV_ModStart> - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock <S2SV_ModEnd> [ TIPC_NLA_SOCK_REF ] <S2SV_ModStart> [ TIPC_NLA_SOCK_REF ] <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ;
<S2SV_ModStart> final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> & fl6 , <S2SV_ModEnd> opt , & <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> -> opt_flen + <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> opt -> opt_nflen <S2SV_ModEnd> ; inet ->
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> -> hop_limit ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> np -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( opt <S2SV_ModEnd> ) inet_csk ( <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; dccp_sync_mss (
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock ( <S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass <S2SV_ModStart> np -> tclass ) ; rcu_read_unlock (
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> opt : rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> , & final ) ; rcu_read_unlock (
<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> -> ir_v6_rmt_addr ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; <S2SV_ModStart> sk ) ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> pktopt = xchg <S2SV_ModStart> ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> ) ) ; atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; }
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
<S2SV_ModStart> len ) { struct ipv6_txoptions * opt_to_free = NULL ; <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> flowlabel ) ; txopt_put ( opt_to_free ) ;
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> final_p , final ; struct ipv6_txoptions * opt <S2SV_ModStart> -> inet_sport ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> & fl6 , <S2SV_ModEnd> opt , & <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) icsk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> -> opt_flen + <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> opt -> opt_nflen <S2SV_ModEnd> ; tp ->
<S2SV_ModStart> , fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , <S2SV_ModEnd> np -> tclass
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt <S2SV_ModStart> ) ) ; opt = rcu_dereference <S2SV_ModEnd> ( np -> <S2SV_ModStart> -> opt ) ; if ( opt ) { <S2SV_ModEnd> opt = ipv6_dup_options <S2SV_ModStart> ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } <S2SV_ModEnd> inet_csk ( newsk <S2SV_ModStart> ; if ( <S2SV_ModEnd> opt ) inet_csk <S2SV_ModStart> -> icsk_ext_hdr_len = <S2SV_ModEnd> opt -> opt_nflen <S2SV_ModStart> -> opt_nflen + <S2SV_ModEnd> opt -> opt_flen <S2SV_ModStart> opt -> opt_flen <S2SV_ModEnd> ; tcp_ca_openreq_child (
<S2SV_ModStart> ipv6_txoptions * opt = NULL ; struct ipv6_txoptions * opt_to_free <S2SV_ModStart> ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
<S2SV_ModStart> ( sk ) ; struct ipv6_txoptions * opt_to_free = NULL <S2SV_ModStart> } if ( ! opt ) { opt = txopt_get ( np ) ; opt_to_free = opt ; } <S2SV_ModEnd> if ( flowlabel <S2SV_ModStart> fl6_sock_release ( flowlabel ) ; txopt_put ( opt_to_free
<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> err ; } <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }
<S2SV_ModStart> gspca_dev ) { struct usb_interface_cache * intfc ; <S2SV_ModStart> ) gspca_dev ; intfc = <S2SV_ModEnd> gspca_dev -> dev <S2SV_ModStart> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV
<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
<S2SV_ModStart> ( ! alt ) return - ENODEV ; if ( alt -> desc . bNumEndpoints < 1
<S2SV_ModStart> vif ) { <S2SV_ModEnd> if ( netif_carrier_ok <S2SV_ModStart> ( netif_carrier_ok ( vif -> <S2SV_ModEnd> dev ) ) <S2SV_ModStart> dev ) ) xenvif_carrier_off <S2SV_ModEnd> ( vif ) <S2SV_ModStart> vif ) ; <S2SV_ModEnd> atomic_dec ( &
<S2SV_ModStart> work_to_do ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Need<S2SV_blank>more<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Too<S2SV_blank>many<S2SV_blank>frags\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> size ) { netdev_err ( vif -> dev , "Frag<S2SV_blank>is<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>frame.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> txp -> size ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> size ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "GSO<S2SV_blank>size<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>zero.\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> gso . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , "Missing<S2SV_blank>extra<S2SV_blank>info\\n" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra . type ) ; netbk_fatal_tx_err ( vif
<S2SV_ModStart> ) continue ; if ( vif -> tx . sring -> req_prod - vif -> tx . req_cons > XEN_NETIF_TX_RING_SIZE ) { netdev_err ( vif -> dev , "Impossible<S2SV_blank>number<S2SV_blank>of<S2SV_blank>requests.<S2SV_blank>" "req_prod<S2SV_blank>%d,<S2SV_blank>req_cons<S2SV_blank>%d,<S2SV_blank>size<S2SV_blank>%ld\\n" , vif -> tx . sring -> req_prod , vif -> tx . req_cons , XEN_NETIF_TX_RING_SIZE ) ; netbk_fatal_tx_err ( vif ) ; continue ; } <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> } ret = <S2SV_ModStart> 0 ) ) continue ; <S2SV_ModEnd> idx += ret <S2SV_ModStart> ) ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> size ) ; netbk_fatal_tx_err ( vif <S2SV_ModEnd> ) ; continue <S2SV_ModStart> skb ) ; <S2SV_ModEnd> continue ; }
<S2SV_ModStart> NETIF_F_HW_CSUM | NETIF_F_SG <S2SV_ModEnd> ; if ( <S2SV_ModStart> NETIF_F_HW_CSUM | NETIF_F_SG <S2SV_ModEnd> ; if (
<S2SV_ModStart> <S2SV_null> static inline bool <S2SV_ModEnd> mcryptd_check_internal ( struct <S2SV_ModStart> ) ) return false ; * type |= <S2SV_ModEnd> algt -> type <S2SV_ModStart> type & CRYPTO_ALG_INTERNAL ; * mask |= algt -> mask & <S2SV_ModEnd> CRYPTO_ALG_INTERNAL ; if <S2SV_ModStart> ; if ( * type & * <S2SV_ModEnd> mask & CRYPTO_ALG_INTERNAL <S2SV_ModStart> & CRYPTO_ALG_INTERNAL ) return true ; else return false <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int err ; if ( ! <S2SV_ModStart> & mask ) ) return - EINVAL
<S2SV_ModStart> name ) , "crypto-%s" <S2SV_ModEnd> , name )
<S2SV_ModStart> * mapping = page_file_mapping ( page ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> , mapping , page_index ( page ) <S2SV_ModEnd> , readahead_gfp_mask (
<S2SV_ModStart> * inode = page_file_mapping ( page ) <S2SV_ModEnd> -> host ; <S2SV_ModStart> = f2fs_mpage_readpages ( page_file_mapping ( page ) <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> ( sector_t ) page_index ( page ) <S2SV_ModEnd> ; last_block = <S2SV_ModStart> page ) && ( ! PageSwapCache ( page ) && <S2SV_ModStart> cleancache_get_page ( page )
<S2SV_ModStart> ) { struct <S2SV_ModEnd> inode * inode <S2SV_ModStart> * inode = page_file_mapping ( page ) <S2SV_ModEnd> -> host ; <S2SV_ModStart> ) ) SetPageUptodate ( page ) ; if ( PageSwapCache ( page ) ) return __set_page_dirty_nobuffers
<S2SV_ModStart> = false ; lock_sock ( sk ) ; spin_lock ( & po -> bind_lock ) ; rcu_read_lock ( ) ; <S2SV_ModStart> -> fanout ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out_unlock ; } <S2SV_ModEnd> if ( name
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl <S2SV_ModStart> if ( error ) return error <S2SV_ModEnd> ; } inode
<S2SV_ModStart> sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> * trap ; struct name_snapshot <S2SV_ModEnd> old_name ; trap <S2SV_ModStart> goto exit ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { release_dentry_name_snapshot ( & old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name . name <S2SV_ModEnd> , d_is_dir ( <S2SV_ModStart> old_dentry ) ; release_dentry_name_snapshot ( & <S2SV_ModEnd> old_name ) ;
<S2SV_ModStart> old_dentry ) ; <S2SV_ModEnd> struct inode * <S2SV_ModStart> -> s_max_links ; struct name_snapshot old_name ; <S2SV_ModStart> return error ; take_dentry_name_snapshot ( & old_name , old_dentry ) ; dget ( new_dentry ) ; if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) lock_two_nondirectories ( source , target ) ; else if ( target ) inode_lock ( target ) ; error = - EBUSY ; if ( is_local_mountpoint ( old_dentry ) || is_local_mountpoint ( new_dentry ) ) goto out ; if ( max_links && new_dir != old_dir ) { error = - EMLINK ; if ( is_dir && ! new_is_dir && new_dir -> i_nlink >= max_links ) goto out ; if ( ( flags & RENAME_EXCHANGE ) && ! is_dir && new_is_dir && old_dir -> i_nlink >= max_links ) goto out ; } if ( is_dir && ! ( flags & RENAME_EXCHANGE ) && target ) shrink_dcache_parent ( new_dentry ) ; if ( ! is_dir ) { error = try_break_deleg ( source , delegated_inode ) ; if ( error ) goto out ; } if ( target && ! new_is_dir ) { error = try_break_deleg ( target , delegated_inode ) ; if ( error ) goto out ; } error = old_dir -> i_op -> rename ( old_dir , old_dentry , new_dir , new_dentry , flags ) ; if ( error ) goto out ; if ( ! ( flags & RENAME_EXCHANGE ) && target ) { if ( is_dir ) target -> i_flags |= S_DEAD ; dont_mount ( new_dentry ) ; detach_mounts ( new_dentry ) ; } if ( ! ( old_dir -> i_sb -> s_type -> fs_flags & FS_RENAME_DOES_D_MOVE ) ) { if ( ! ( flags & RENAME_EXCHANGE ) ) d_move ( old_dentry , new_dentry ) ; else d_exchange ( old_dentry , new_dentry ) ; } out : if ( ! is_dir || ( flags & RENAME_EXCHANGE ) ) unlock_two_nondirectories ( source , target ) ; else if ( target ) inode_unlock ( target ) ; dput ( new_dentry ) ; if ( ! error ) { fsnotify_move ( old_dir , new_dir , old_name . name , is_dir , ! ( flags & RENAME_EXCHANGE ) ? target : NULL , old_dentry ) ; if ( flags & RENAME_EXCHANGE ) { fsnotify_move ( new_dir , old_dir , <S2SV_ModEnd> old_dentry -> d_name <S2SV_ModStart> d_name . name , new_is_dir , NULL , new_dentry ) ; } } release_dentry_name_snapshot ( & old_name <S2SV_ModEnd> ) ; return
<S2SV_ModStart> mask ) { struct name_snapshot name ; <S2SV_ModStart> |= FS_EVENT_ON_CHILD ; take_dentry_name_snapshot ( & name , dentry ) ; <S2SV_ModStart> , FSNOTIFY_EVENT_PATH , name <S2SV_ModEnd> . name , <S2SV_ModStart> , FSNOTIFY_EVENT_INODE , name <S2SV_ModEnd> . name , <S2SV_ModStart> name , 0 ) ; release_dentry_name_snapshot ( & name
<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
<S2SV_ModStart> : kfree ( req ) ; kfree (
<S2SV_ModStart> < 0 ) { kfree ( bmc ) ; <S2SV_ModStart> goto out ; }
<S2SV_ModStart> * rsize >= 18 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 75 && rdesc [ 61 ] == 0x05 && rdesc [ 62 ] == 0x08 && rdesc [ 63 ] == 0x19 && rdesc [ 64 ] == 0x08 && rdesc [ 65 ] == 0x29 && rdesc [ 66 ] == 0x0f && rdesc [ 71 ] == 0x75 && rdesc [ 72 ] == 0x08 && rdesc [ 73 ] == 0x95 && rdesc [ 74 ] == 0x01 ) { hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>Kye/Genius<S2SV_blank>Ergo<S2SV_blank>Mouse<S2SV_blank>" "report<S2SV_blank>descriptor\\n" ) ; <S2SV_ModEnd> rdesc [ 62 <S2SV_ModStart> [ 62 ] = 0x09 ; rdesc [ 64 ] = 0x04 ; rdesc [ 66 ] = 0x07 ; rdesc [ 72 ] = 0x01 ; rdesc [ 74 ] = 0x08 <S2SV_ModEnd> ; } break
<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 112 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * ctx2 ; bool more ; <S2SV_ModStart> int err ; lock_sock ( sk ) ; more = ctx -> more ; err = more ? <S2SV_ModEnd> crypto_ahash_export ( req <S2SV_ModStart> , state ) : 0 ; release_sock ( sk ) <S2SV_ModStart> -> more = more ; if ( ! more ) return err <S2SV_ModEnd> ; err =
<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
<S2SV_ModStart> & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { while ( 1 ) { <S2SV_ModStart> ] ) ; if ( ! queue ) break ; <S2SV_ModEnd> if ( free_func <S2SV_ModStart> ( free_func ) { if ( hashbin -> hb_type & HB_LOCK ) spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; free_func ( queue ) ; if ( hashbin -> hb_type & HB_LOCK ) spin_lock_irqsave ( & hashbin -> hb_spinlock , flags ) ; } <S2SV_ModEnd> } } hashbin <S2SV_ModStart> & HB_LOCK ) <S2SV_ModEnd> spin_unlock_irqrestore ( & <S2SV_ModStart> flags ) ; <S2SV_ModEnd> kfree ( hashbin
<S2SV_ModStart> iovec , compat , & iter <S2SV_ModStart> len , iovec , & iter <S2SV_ModStart> iter_op ) { ret = iter_op ( req , & iter ) ; } else { ret = rw_op ( req , iter . iov , iter . <S2SV_ModEnd> nr_segs , req
<S2SV_ModStart> iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;
<S2SV_ModStart> , bool compat , struct iov_iter * iter <S2SV_ModStart> = ret ; iov_iter_init ( iter , rw , * iovec , * nr_segs , * len ) ;
<S2SV_ModStart> nla ) ; strncpy <S2SV_ModEnd> ( algo -> <S2SV_ModStart> auth -> alg_name , sizeof ( algo -> alg_name )
<S2SV_ModStart> value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
<S2SV_ModStart> channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
<S2SV_ModStart> intf ) { <S2SV_ModEnd> if ( cdc_ncm_select_altsetting <S2SV_ModStart> - ENODEV ; return <S2SV_ModEnd> cdc_ncm_bind_common ( dev <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> construct_get_dest_keyring ( struct <S2SV_ModStart> * authkey ; int ret ; <S2SV_ModStart> } else { bool do_perm_check = true ; <S2SV_ModStart> ( dest_keyring ) { do_perm_check = false ; break ; } <S2SV_ModEnd> } case KEY_REQKEY_DEFL_THREAD_KEYRING <S2SV_ModStart> ) ; } if ( dest_keyring && do_perm_check ) { ret = key_permission ( make_key_ref ( dest_keyring , 1 ) , KEY_NEED_WRITE ) ; if ( ret ) { key_put ( dest_keyring ) ; return ret ; } } <S2SV_ModStart> ) ; return 0
<S2SV_ModStart> EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
<S2SV_ModStart> len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
<S2SV_ModStart> 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
<S2SV_ModStart> { if ( ! dev_name ||
<S2SV_ModStart> <S2SV_null> static unsigned long <S2SV_ModEnd> stack_maxrandom_size ( void <S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> max = 0 <S2SV_ModStart> ( ( - 1UL <S2SV_ModEnd> ) & STACK_RND_MASK
<S2SV_ModStart> ) { unsigned long <S2SV_ModEnd> random_variable = 0 <S2SV_ModStart> { random_variable = ( unsigned long ) <S2SV_ModStart> get_random_int ( ) ; random_variable &= <S2SV_ModEnd> STACK_RND_MASK ; random_variable
<S2SV_ModStart> ) { struct usb_serial * serial = port -> serial ; struct <S2SV_ModStart> * priv ; if ( ! serial -> port [ 1 ] || ! serial -> port [ 1 ] -> interrupt_in_urb ) { dev_err ( & port -> dev , "expected<S2SV_blank>endpoint<S2SV_blank>missing\\n" ) ; return - ENODEV ; } <S2SV_ModStart> -> read_urb = <S2SV_ModEnd> serial -> port
<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> * header ; unsigned int inode_size = EXT4_INODE_SIZE ( inode -> i_sb ) ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; int error ; if ( ( EXT4_GOOD_OLD_INODE_SIZE + ei -> i_extra_isize > inode_size ) || ( ei -> i_extra_isize & 3 ) ) { EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>extra_isize<S2SV_blank>%u<S2SV_blank>(inode<S2SV_blank>size<S2SV_blank>%u)" , ei -> i_extra_isize , EXT4_INODE_SIZE ( inode -> i_sb ) ) ; return - EFSCORRUPTED ; } if ( ( new_extra_isize < ei -> i_extra_isize ) || ( new_extra_isize < 4 ) || ( new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE ) ) return - EINVAL <S2SV_ModEnd> ; raw_inode =
<S2SV_ModStart> -> s_es ; unsigned def_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; <S2SV_ModStart> sbi -> s_inode_size == EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = 0 ; return ; } if ( sbi -> s_want_extra_isize < 4 ) { sbi -> s_want_extra_isize = def_extra_isize ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( ( sbi -> s_want_extra_isize > sbi -> s_inode_size ) || <S2SV_ModEnd> ( EXT4_GOOD_OLD_INODE_SIZE + <S2SV_ModStart> -> s_inode_size ) ) { sbi -> s_want_extra_isize = def_extra_isize <S2SV_ModEnd> ; ext4_msg (
<S2SV_ModStart> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> len < needed || len < sizeof ( nl -> dev )
<S2SV_ModStart> , int tstype , bool opt_stats <S2SV_ModStart> ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) <S2SV_ModStart> ee_info = tstype ; serr -> opt_stats = opt_stats
<S2SV_ModStart> ; bool tsonly , opt_stats = false <S2SV_ModStart> == SOCK_STREAM ) { <S2SV_ModStart> sk ) ; opt_stats = true ; } <S2SV_ModStart> sk , tstype , opt_stats
<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
<S2SV_ModStart> , attr , attr -> size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * server , struct smb_vol * vol ) { <S2SV_ModEnd> struct cifsSesInfo * <S2SV_ModStart> cifs_tcp_ses_lock ) ; list_for_each_entry ( ses <S2SV_ModEnd> , & server <S2SV_ModStart> server -> smb_ses_list , smb_ses_list ) { switch ( server -> secType ) { case Kerberos : if ( vol -> linux_uid != ses -> linux_uid ) continue ; break ; default : <S2SV_ModEnd> if ( strncmp <S2SV_ModStart> -> userName , vol -> <S2SV_ModStart> ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; }
<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ] <= max && value [ n ] - min < field -> maxusage <S2SV_ModStart> && field -> value [ n ] - min < field -> maxusage && field -> <S2SV_ModStart> <= max && value [ n ] - min < field -> maxusage &&
<S2SV_ModStart> uint64_t unpacked_lun ; <S2SV_ModEnd> int tcm_tmr ; <S2SV_ModStart> tsk_mgmt_func ) ; unpacked_lun = srpt_unpack_lun ( ( uint8_t * ) & srp_tsk -> lun , sizeof ( srp_tsk -> lun ) ) ; rc = target_submit_tmr ( & send_ioctx -> cmd , sess , NULL , unpacked_lun , srp_tsk , tcm_tmr , GFP_KERNEL <S2SV_ModEnd> , srp_tsk -> <S2SV_ModStart> srp_tsk -> task_tag <S2SV_ModEnd> , TARGET_SCF_ACK_KREF )
<S2SV_ModStart> if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
<S2SV_ModStart> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif
<S2SV_ModStart> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
<S2SV_ModStart> fq ) ; q -> fq = NULL ;
<S2SV_ModStart> svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
<S2SV_ModStart> ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
<S2SV_ModStart> ) { struct <S2SV_ModEnd> inode * inode <S2SV_ModStart> * inode = vfs_select_inode ( path -> <S2SV_ModEnd> dentry , file <S2SV_ModStart> inode ) ; file -> f_path = * path ; <S2SV_ModEnd> return do_dentry_open (
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct arpt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct arpt_entry ) && memcmp ( & e -> <S2SV_ModEnd> arp , &
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct ipt_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ipt_entry ) && memcmp ( & e -> <S2SV_ModEnd> ip , &
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> if ( ( unconditional ( e <S2SV_ModEnd> ) && ( <S2SV_ModStart> verdict < 0 <S2SV_ModEnd> ) || visited
<S2SV_ModStart> ( const struct ip6t_entry * e <S2SV_ModEnd> ) { static <S2SV_ModStart> uncond ; return e -> target_offset == sizeof ( struct ip6t_entry ) && memcmp ( & e -> <S2SV_ModEnd> ipv6 , &
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; random_ether_addr (
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
<S2SV_ModStart> = port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;
<S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( & data , 1 , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , 1 , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> __u16 size , const <S2SV_ModStart> data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; kfree ( buf ) ;
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> = p ; <S2SV_ModEnd> err = hci_uart_register_dev <S2SV_ModStart> err ) { return err ; } set_bit <S2SV_ModEnd> ( HCI_UART_PROTO_READY , <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> ) ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto <S2SV_ModStart> pte ) ) * vec = 0 <S2SV_ModEnd> ; else if <S2SV_ModStart> pte ) ; * vec = ! ! <S2SV_ModEnd> non_swap_entry ( entry <S2SV_ModStart> ( entry ) ; <S2SV_ModEnd> } vec ++
<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
<S2SV_ModStart> i2s_platform_data * i2s_pdata = NULL <S2SV_ModStart> == NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; } <S2SV_ModStart> NULL ) { r = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto failure ; <S2SV_ModStart> NULL ) { r = - ENOMEM ; goto failure <S2SV_ModEnd> ; } switch <S2SV_ModStart> ( r ) goto failure <S2SV_ModEnd> ; for ( <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>dev<S2SV_blank>to<S2SV_blank>genpd\\n" ) ; goto failure <S2SV_ModEnd> ; } } <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>ACP\\n" ) ; r = - ETIMEDOUT ; goto failure <S2SV_ModEnd> ; } udelay <S2SV_ModStart> return 0 ; failure : kfree ( i2s_pdata ) ; kfree ( adev -> acp . acp_res ) ; kfree ( adev -> acp . acp_cell ) ; kfree ( adev -> acp . acp_genpd ) ; return r ;
<S2SV_ModStart> locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> IPT_F_GOTO ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; } <S2SV_ModStart> = e ; }
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> ; if ( len < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>CALL<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModEnd> return len ; <S2SV_ModStart> return len ; } <S2SV_ModEnd> b -> opcode
<S2SV_ModStart> < 5 ) { # ifdef CONFIG_RETPOLINE WARN_ONCE ( "Failing<S2SV_blank>to<S2SV_blank>patch<S2SV_blank>indirect<S2SV_blank>JMP<S2SV_blank>in<S2SV_blank>%ps\\n" , ( void * ) addr ) ; # endif <S2SV_ModStart> return len ; }
<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> * gb_cur , version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> ; __be16 wks <S2SV_ModStart> version_length ) ; if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> lto_length ) ; if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> wks_length ) ; if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> miux_length ) ; if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; }
<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;
<S2SV_ModStart> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if (
<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (
<S2SV_ModStart> __func__ ) ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page
<S2SV_ModStart> , size - skb_out <S2SV_ModEnd> -> len ,
<S2SV_ModStart> = src_reg -> s32_min_value <S2SV_ModEnd> ; u32 umin_val <S2SV_ModStart> = src_reg -> u32_min_value <S2SV_ModEnd> ; if ( <S2SV_ModStart> = dst_reg -> u32_min_value <S2SV_ModEnd> ; dst_reg -> <S2SV_ModStart> = dst_reg -> u32_max_value <S2SV_ModEnd> ; } }
<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
<S2SV_ModStart> if ( err < 0
<S2SV_ModStart> , IEEE80211_MAX_SSID_LEN ) ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN
<S2SV_ModStart> { request_module ( "crypto-%s" <S2SV_ModEnd> , name ) <S2SV_ModStart> ) request_module ( "crypto-%s-all" <S2SV_ModEnd> , name )
<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
<S2SV_ModStart> i ; size_t bytes , <S2SV_ModStart> ++ ) { bytes <S2SV_ModEnd> = min_t ( <S2SV_ModStart> , 0 , bytes <S2SV_ModEnd> ) ; cur_len <S2SV_ModStart> copied ) ; if ( copied < bytes ) break ; <S2SV_ModStart> save_len - cur_len ; if ( ! cur_len ) { for ( i = 0 ; i < nr_pages ; i ++ ) put_page ( wdata -> pages [ i ] ) ; kfree ( wdata ) ; rc = - EFAULT ; break ; } for ( ; nr_pages > i + 1 ; nr_pages -- ) put_page ( wdata -> pages [ nr_pages - 1 ] )
<S2SV_ModStart> = dest_mnt ; first_source = source_mnt ;
<S2SV_ModStart> , * p ; bool done <S2SV_ModStart> p ) ) break ; } do { struct mount * parent = last_source -> mnt_parent ; if ( last_source == first_source ) break ; done = parent -> mnt_master == p ; if ( done && peers ( n , parent ) ) break ; last_source = last_source -> mnt_master ; } while ( ! done ) ; <S2SV_ModEnd> type = CL_SLAVE
<S2SV_ModStart> return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> ret < 0 && ! p -> skip_release_on_error
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item *
<S2SV_ModStart> btrfs_dir_item * di = NULL <S2SV_ModStart> - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , <S2SV_ModEnd> di ) ; <S2SV_ModStart> out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } if ( di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_CREATE ) ) { ret = - EEXIST ; <S2SV_ModStart> goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> ; goto out <S2SV_ModStart> out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> ret = btrfs_delete_one_dir_name <S2SV_ModStart> goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out :
<S2SV_ModStart> chip ) { atomic_dec ( & chip -> active ) ; <S2SV_ModStart> card ) ; <S2SV_ModEnd> } mutex_unlock (
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc
<S2SV_ModStart> long secure ; struct phys_req preq ; preq . sector_number = req -> u . discard . sector_number ; preq . nr_sects = req -> u . discard . nr_sectors ; err = xen_vbd_translate ( & preq , blkif , WRITE ) ; if ( err ) { pr_warn ( DRV_PFX "access<S2SV_blank>denied:<S2SV_blank>DISCARD<S2SV_blank>[%llu->%llu]<S2SV_blank>on<S2SV_blank>dev=%04x\\n" , preq . sector_number , preq . sector_number + preq . nr_sects , blkif -> vbd . pdevice ) ; goto fail_response ; } <S2SV_ModStart> secure ) ; fail_response :
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap ) ; <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( ts2020_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap )
<S2SV_ModStart> adap ) ; struct dw2102_state * state <S2SV_ModEnd> ; if ( <S2SV_ModStart> - ENODEV ; state = d -> priv ; <S2SV_ModStart> - EAGAIN ; if ( mutex_lock_interruptible ( & d -> data_mutex ) < 0 ) { mutex_unlock ( & d -> i2c_mutex ) ; return - EAGAIN ; } <S2SV_ModStart> case SU3000_STREAM_CTRL : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> + 0x36 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 3 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 0 , <S2SV_ModStart> case DW2102_RC_QUERY : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 1 ] = state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> 0 ] = state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> ; default : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x08 ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> . addr ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> case 2 : state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0x09 ; state -> data [ 1 ] = msg [ 0 ] . len ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> . len ; state -> data <S2SV_ModEnd> [ 3 ] <S2SV_ModStart> memcpy ( & state -> data <S2SV_ModEnd> [ 4 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> + 4 , state -> data <S2SV_ModEnd> , msg [ <S2SV_ModStart> buf , & state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> & d -> data_mutex ) ; mutex_unlock ( & d ->
<S2SV_ModStart> -> priv ; int ret = 0 <S2SV_ModEnd> ; info ( <S2SV_ModStart> initialized ) { mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xde ; state -> data [ 1 ] = 0 ; <S2SV_ModStart> = 1 ; ret = <S2SV_ModEnd> dvb_usb_generic_rw ( d <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 2 , <S2SV_ModStart> 0 ) ; mutex_unlock ( & d -> data_mutex ) ; } return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x87 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x86 ; state -> data [ 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; msleep ( 50 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x80 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> 2 ] = 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data [ 0 ] = 0x51 <S2SV_ModEnd> ; if ( <S2SV_ModStart> dvb_usb_generic_rw ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> ) err ( <S2SV_ModEnd> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_ModStart> "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex ) ; adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> & d -> <S2SV_ModEnd> i2c_adap , NULL <S2SV_ModStart> ; if ( adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> ( tda18271_attach , adap <S2SV_ModEnd> -> fe_adap [ <S2SV_ModStart> , & d <S2SV_ModEnd> -> i2c_adap ,
<S2SV_ModStart> d -> priv <S2SV_ModEnd> ; struct i2c_adapter <S2SV_ModStart> { } ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x02 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> 300 ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = 0xe ; state -> data <S2SV_ModEnd> [ 1 ] <S2SV_ModStart> = 0x83 ; state -> data <S2SV_ModEnd> [ 2 ] <S2SV_ModStart> ( d , state -> data <S2SV_ModEnd> , 3 , <S2SV_ModStart> , 3 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> "command<S2SV_blank>0x0e<S2SV_blank>transfer<S2SV_blank>failed." ) ; state -> data <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ( d , state -> data , 1 , state -> data <S2SV_ModEnd> , 1 , <S2SV_ModStart> err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; mutex_unlock ( & d -> data_mutex
<S2SV_ModStart> ; if ( ! out ) goto done ; <S2SV_ModEnd> out += HDRLEN_VMALLOC <S2SV_ModStart> = 1 ; <S2SV_ModEnd> } else { <S2SV_ModStart> ; if ( ! out ) goto done ; <S2SV_ModEnd> out += HDRLEN_KMALLOC <S2SV_ModStart> = 0 ; } atomic_set ( & <S2SV_ModStart> ) -> refcount , 1 ) ; done : <S2SV_ModEnd> return out ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> ipc_rcu_getref ( void <S2SV_ModStart> ptr ) { return atomic_inc_not_zero ( & <S2SV_ModStart> ) -> refcount ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> { if ( ! atomic_dec_and_test ( & <S2SV_ModEnd> container_of ( ptr <S2SV_ModStart> ) -> refcount ) <S2SV_ModEnd> ) return ;
<S2SV_ModStart> 0 ) ; scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ) + RDS_CONG_MAP_BYTES ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret
<S2SV_ModStart> off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; <S2SV_ModStart> 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; goto out <S2SV_ModEnd> ; } BUG_ON <S2SV_ModStart> m_inc ) ; out : return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> cred * cred ; int err = - ENOMEM <S2SV_ModStart> ; if ( cred ) { err = create_user_ns ( cred ) ; if ( err ) put_cred ( cred ) ; else <S2SV_ModEnd> * new_cred = <S2SV_ModStart> = cred ; } return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ioc ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
<S2SV_ModStart> dev ) ; ssize_t len ; device_lock ( dev ) ; len = <S2SV_ModEnd> sprintf ( buf <S2SV_ModStart> driver_override ) ; device_unlock ( dev ) ; return len ;
<S2SV_ModStart> , * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> ) { struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
<S2SV_ModStart> size_t total_len ; struct iov_iter iter ; <S2SV_ModStart> ) return 0 ; iov_iter_init ( & iter , iov , nr_segs , total_len , 0 ) <S2SV_ModStart> -> ops ; <S2SV_ModEnd> size_t chars = <S2SV_ModStart> buf -> len ; size_t written <S2SV_ModStart> ; int error <S2SV_ModEnd> ; if ( <S2SV_ModStart> break ; } written = copy_page_to_iter ( buf -> page , buf -> offset , chars , & iter ) ; if ( unlikely ( written < chars ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ;
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> f2fs_sb_info * sbi , bool umount <S2SV_ModStart> ( sbi , ! umount <S2SV_ModEnd> ) ; }
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> nexthdr ) { unsigned int <S2SV_ModEnd> offset = sizeof <S2SV_ModStart> * exthdr ; unsigned int len ; <S2SV_ModStart> offset ) ; len = ipv6_optlen ( exthdr ) ; if ( len + offset >= IPV6_MAXPLEN ) return - EINVAL ; offset += len <S2SV_ModEnd> ; * nexthdr
<S2SV_ModStart> error ; } <S2SV_ModEnd> priv -> spi <S2SV_ModStart> ; ret = ca8210_get_platform_data ( priv -> spi , pdata ) ; if ( ret ) { dev_crit ( & spi_device -> dev , "ca8210_get_platform_data<S2SV_blank>failed\\n" ) ; goto error ; } ret =
<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
<S2SV_ModStart> ) ; struct super_block * sb = sdp -> sd_vfs ; struct <S2SV_ModStart> height - 1 ; int ret <S2SV_ModStart> ++ ) ; if ( buffer_zeronew ( bh_map ) ) { ret = sb_issue_zeroout ( sb , dblock , dblks , GFP_NOFS ) ; if ( ret ) { fs_err ( sdp , "Failed<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>data<S2SV_blank>buffers\\n" ) ; clear_buffer_zeronew ( bh_map ) ; } }
<S2SV_ModStart> int error ; unsigned int nr_blks ; sector_t lblock <S2SV_ModEnd> = offset >> <S2SV_ModStart> = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) return error ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } while ( len ) { struct buffer_head bh_map = { . b_state = 0 , . b_blocknr = 0 } ; bh_map . b_size = len ; set_buffer_zeronew ( & bh_map ) ; error = gfs2_block_map ( inode , lblock , & bh_map , 1 ) ; if ( unlikely ( error ) ) goto out ; len -= bh_map . b_size ; nr_blks = bh_map . b_size >> inode -> i_blkbits ; lblock += nr_blks ; if ( ! buffer_new ( & bh_map ) ) continue ; if ( unlikely ( ! buffer_zeronew ( & bh_map ) ) ) { error = - EIO ; goto out ; } } if <S2SV_ModEnd> ( offset + <S2SV_ModStart> offset + len <S2SV_ModEnd> > inode -> <S2SV_ModStart> FALLOC_FL_KEEP_SIZE ) ) <S2SV_ModEnd> i_size_write ( inode <S2SV_ModStart> , offset + len ) ; <S2SV_ModEnd> mark_inode_dirty ( inode <S2SV_ModStart> mark_inode_dirty ( inode <S2SV_ModEnd> ) ; out <S2SV_ModStart> ; out : brelse ( dibh ) ;
<S2SV_ModStart> . sb_bsize_shift ; loff_t max_chunk_size = UINT_MAX & bsize_mask ; <S2SV_ModStart> ( ip , ( len > max_chunk_size ) ? max_chunk_size : len , <S2SV_ModEnd> & max_bytes ,
<S2SV_ModStart> . fragments ; const struct iphdr * iph ; int err ; <S2SV_ModStart> head -> dev ) goto out_rcu_unlock ; skb_dst_drop ( head ) ; iph = ip_hdr ( head ) ; err = ip_route_input_noref ( head , iph -> daddr , iph -> saddr , iph -> tos , head -> dev ) ; if ( err <S2SV_ModStart> == IP_DEFRAG_CONNTRACK_IN && <S2SV_ModEnd> skb_rtable ( head <S2SV_ModStart> goto out_rcu_unlock ; <S2SV_ModEnd> icmp_send ( head
<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
<S2SV_ModStart> u16 ether_type ; if ( len <= RFC2374_UNFRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> ) ; } if ( len <= RFC2374_FRAG_HDR_SIZE ) return 0 ; <S2SV_ModStart> hdr ) ; if ( fg_off + len > dg_size ) return 0 ;
<S2SV_ModStart> u32 length ; <S2SV_ModEnd> unsigned long offset <S2SV_ModStart> flags ) ; if ( length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id ( buf_ptr ) <S2SV_ModEnd> == IANA_SPECIFIER_ID && <S2SV_ModStart> IANA_SPECIFIER_ID && ( gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC2734_SW_VERSION # <S2SV_ModStart> CONFIG_IPV6 ) || gasp_version ( buf_ptr ) <S2SV_ModEnd> == RFC3146_SW_VERSION # <S2SV_ModStart> endif ) ) fwnet_incoming_packet ( dev , buf_ptr + 2 , length - IEEE1394_GASP_HDR_SIZE , gasp_source_id ( buf_ptr ) <S2SV_ModEnd> , context -> <S2SV_ModStart> true ) ; <S2SV_ModEnd> packet . payload_length
<S2SV_ModStart> ) { struct ext4_map_blocks split_map ; struct ext4_extent zero_ex <S2SV_ModEnd> ; struct ext4_extent <S2SV_ModStart> struct ext4_extent * ex <S2SV_ModEnd> ; ext4_lblk_t ee_block <S2SV_ModStart> , depth ; <S2SV_ModEnd> int err = <S2SV_ModStart> 0 ; int split_flag = 0 <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> inode ) ; ex <S2SV_ModEnd> = path [ <S2SV_ModStart> depth ] . <S2SV_ModEnd> p_ext ; ee_block <S2SV_ModStart> ee_block ) ; WARN_ON ( map -> m_lblk < ee_block ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> * EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) <S2SV_ModEnd> ) { err <S2SV_ModStart> ( inode , ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( inode , path , ex ) ; err = <S2SV_ModEnd> ext4_ext_dirty ( handle <S2SV_ModStart> depth ) ; goto out ; } split_map . m_lblk = map -> m_lblk ; split_map . m_len = map -> m_len ; if ( allocated > map -> m_len ) { <S2SV_ModEnd> if ( allocated <S2SV_ModStart> <= EXT4_EXT_ZERO_LEN && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { zero_ex . ee_block = cpu_to_le32 ( map -> m_lblk + map -> m_len ) ; zero_ex . <S2SV_ModEnd> ee_len = cpu_to_le16 <S2SV_ModStart> = cpu_to_le16 ( allocated - map -> m_len <S2SV_ModEnd> ) ; ext4_ext_store_pblock <S2SV_ModStart> ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) + map -> m_lblk - ee_block ) ; <S2SV_ModEnd> err = ext4_ext_zeroout <S2SV_ModStart> inode , & zero_ex <S2SV_ModEnd> ) ; if <S2SV_ModStart> err ) goto out ; split_map . m_lblk = map -> m_lblk ; split_map . m_len = <S2SV_ModEnd> allocated ; } <S2SV_ModStart> else if ( ( map -> m_lblk - ee_block + map -> m_len < EXT4_EXT_ZERO_LEN ) && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { if ( map -> m_lblk != ee_block ) { zero_ex . ee_block = ex -> ee_block ; zero_ex . ee_len = cpu_to_le16 ( map -> m_lblk - ee_block ) ; ext4_ext_store_pblock ( & zero_ex , ext4_ext_pblock ( ex ) ) <S2SV_ModEnd> ; err = <S2SV_ModStart> ( inode , & zero_ex ) ; if ( err ) <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } allocated = map -> m_lblk - ee_block + map -> m_len ; split_map . m_lblk = ee_block ; split_map . m_len = allocated ; } } allocated = ext4_split_extent ( handle , inode , path , & split_map , split_flag <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ; if ( allocated < 0 ) err = allocated <S2SV_ModEnd> ; out : <S2SV_ModStart> ; out : <S2SV_ModEnd> return err ? <S2SV_ModStart> err : allocated <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; <S2SV_ModStart> ext4_extent * ex <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> ; unsigned int ee_len ; int split_flag = 0 , depth <S2SV_ModEnd> ; ext_debug ( <S2SV_ModStart> ex ) ; split_flag |= <S2SV_ModEnd> ee_block + ee_len <S2SV_ModStart> ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent <S2SV_ModEnd> ( handle , <S2SV_ModStart> inode , path , map , split_flag <S2SV_ModEnd> , flags ) <S2SV_ModStart> , flags ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ! new_idmap_permitted ( file ,
<S2SV_ModStart> bool new_idmap_permitted ( const struct file * file , <S2SV_ModStart> , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid )
<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
<S2SV_ModStart> hx ; u8 * buf <S2SV_ModEnd> ; int ret <S2SV_ModStart> = 0 ; u16 cpu_cs_register = <S2SV_ModEnd> cypress [ type <S2SV_ModStart> ] . cpu_cs_register ; buf = kmalloc ( sizeof ( * hx ) , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; hx = ( struct hexline * ) buf ; buf [ 0 ] = 1 ; if ( usb_cypress_writemem ( udev , cpu_cs_register , buf , 1 <S2SV_ModEnd> ) != 1 <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return <S2SV_ModStart> 0 ) { buf [ 0 ] = 0 ; if ( <S2SV_ModEnd> usb_cypress_writemem ( udev <S2SV_ModStart> ( udev , cpu_cs_register , buf <S2SV_ModEnd> , 1 ) <S2SV_ModStart> ; kfree ( buf <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> rats_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 20 ) <S2SV_ModStart> -> attrib_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , 50 )
<S2SV_ModStart> -> nfcid1_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_NFCID1_MAXSIZE )
<S2SV_ModStart> -> sensb_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSB_RES_MAXSIZE )
<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> - EOPNOTSUPP ; msg -> msg_namelen = 0 ; <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( msg
<S2SV_ModStart> } if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , "%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1
<S2SV_ModStart> struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> . devnum = <S2SV_ModStart> dev -> devnum ; ci <S2SV_ModEnd> . slow = <S2SV_ModStart> speed == USB_SPEED_LOW <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr
<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
<S2SV_ModStart> 0 ; } err = handle -> h_err ; <S2SV_ModStart> h_transaction ) { rc <S2SV_ModEnd> = jbd2_journal_stop ( <S2SV_ModStart> ) ; return err ? err : rc <S2SV_ModEnd> ; } sb <S2SV_ModStart> t_journal -> j_private <S2SV_ModEnd> ; rc =
<S2SV_ModStart> new_parent ) { <S2SV_ModEnd> __ptrace_link ( child <S2SV_ModStart> , new_parent , current_cred ( ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> ; } else { baud = min ( baud , 461550 ) ; <S2SV_ModStart> baud ) ; }
<S2SV_ModStart> port ) { if ( hlist_unhashed ( & mp -> mglist ) )
<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
<S2SV_ModStart> ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
<S2SV_ModStart> -> vm_ops ) <S2SV_ModEnd> return do_fault ( <S2SV_ModStart> , pte , pmd , flags , entry ) ; <S2SV_ModEnd> return do_anonymous_page ( <S2SV_ModStart> , address , pte , pmd , <S2SV_ModEnd> flags ) ;
<S2SV_ModStart> "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
<S2SV_ModStart> ( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;
<S2SV_ModStart> brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> current_profile ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } current_profile <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%d\\n" , current_profile ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> macro_mode ; char * data ; data = kmalloc ( 2 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = snprintf ( buf , PAGE_SIZE , "%s\\n" , macro_mode ) ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> filp ) { __sock_release <S2SV_ModEnd> ( SOCKET_I ( <S2SV_ModStart> ( inode ) , inode
<S2SV_ModStart> sock ) { __sock_release ( sock , NULL <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ) ; if ( sock -> sk ) <S2SV_ModStart> -> ia_uid ; else err = - ENOENT ;
<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
<S2SV_ModStart> <S2SV_null> static inline __u64 <S2SV_ModEnd> dccp_v6_init_sequence ( struct
<S2SV_ModStart> - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> -> vm_file ; * prev = vma ; <S2SV_ModStart> file ) { <S2SV_ModEnd> force_swapin_readahead ( vma <S2SV_ModStart> ) ) { <S2SV_ModEnd> force_shm_swapin_readahead ( vma <S2SV_ModStart> 0 ; } <S2SV_ModEnd> start = (
<S2SV_ModStart> ; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped
<S2SV_ModStart> & IFF_UP ) || <S2SV_ModEnd> ( skb -> <S2SV_ModStart> hard_header_len ) ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> return NET_RX_DROP ; }
<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> case 1 : if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; } <S2SV_ModStart> out ; } if ( fd . entrylength > sizeof ( entry ) || fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> ; error_cmd : kfree_skb ( ack_skb ) ; error_msg_to_dev : error_alloc : d_fnend ( 4 , dev , "(wimax_dev<S2SV_blank>%p<S2SV_blank>state<S2SV_blank>%d)<S2SV_blank>=<S2SV_blank>%d\\n" , wimax_dev , state , result ) ; <S2SV_ModStart> kfree ( cmd <S2SV_ModEnd> ) ; return
<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
<S2SV_ModStart> icmp6_hop_limit ) { if ( <S2SV_ModStart> cnf . hop_limit < <S2SV_ModEnd> ra_msg -> icmph <S2SV_ModStart> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n" ) ; } <S2SV_ModEnd> if ( rt
<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL
<S2SV_ModStart> ) & desc , sizeof ( * desc )
<S2SV_ModStart> * * ptr , size_t minsize <S2SV_ModStart> bLength < 2 || header -> bLength > size <S2SV_ModStart> bDescriptorType == type && header -> bLength >= minsize
<S2SV_ModStart> ) & secd , sizeof ( * secd )
<S2SV_ModStart> if ( prev && <S2SV_ModEnd> ( FRAG6_CB ( <S2SV_ModStart> ) - offset <S2SV_ModEnd> > 0 ) <S2SV_ModStart> > 0 ) goto discard_fq ; if <S2SV_ModEnd> ( next && <S2SV_ModStart> < end ) goto discard_fq ; <S2SV_ModEnd> FRAG6_CB ( skb <S2SV_ModStart> - 1 ; discard_fq : fq_kill ( fq ) ;
<S2SV_ModStart> ( ! rc <S2SV_ModEnd> && tcon )
<S2SV_ModStart> ; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
<S2SV_ModStart> c_dest ) ; snd_use_lock_use ( & new_port -> use_lock ) ; <S2SV_ModStart> = num ; sprintf ( new_port -> name , "port-%d" , num ) ; <S2SV_ModStart> client -> ports_mutex <S2SV_ModEnd> ) ; return
<S2SV_ModStart> = 0 ; if ( too_many_unix_fds ( current ) ) return - ETOOMANYREFS ; <S2SV_ModStart> - ENOMEM ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ] ) ; <S2SV_ModEnd> return max_level ;
<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; BUG_ON <S2SV_ModStart> unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , "%.*s<S2SV_blank>bc<S2SV_blank>" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }
<S2SV_ModStart> != mm ) { smp_mb ( ) ; <S2SV_ModStart> goto out ; } <S2SV_ModStart> ) ) ; smp_mb ( ) ;
<S2SV_ModStart> -> mm ) { <S2SV_ModStart> start ) ; } else { <S2SV_ModEnd> leave_mm ( smp_processor_id <S2SV_ModStart> ) ) ; smp_mb ( ) ; }
<S2SV_ModStart> "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
<S2SV_ModStart> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart> -> rto_min ; <S2SV_ModEnd> if ( put_user
<S2SV_ModStart> op_mutex ) ; kfree_skb ( skb ) ;
<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0
<S2SV_ModStart> vma ) ; struct uio_mem * mem ; <S2SV_ModStart> mi < 0 ) return - EINVAL ; mem = idev -> info -> mem + mi ; if ( vma -> vm_end - vma -> vm_start > mem -> size <S2SV_ModStart> -> vm_start , mem -> <S2SV_ModEnd> addr >> PAGE_SHIFT
<S2SV_ModStart> * fbdev ; <S2SV_ModEnd> fbdev = to_au1100fb_device <S2SV_ModStart> ( fbi ) <S2SV_ModEnd> ; vma -> <S2SV_ModStart> 9 ) ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> vma ) { <S2SV_ModEnd> struct au1200fb_device * <S2SV_ModStart> info -> par <S2SV_ModEnd> ; vma -> <S2SV_ModStart> _CACHE_MASK ; return vm_iomap_memory <S2SV_ModEnd> ( vma , <S2SV_ModStart> ( vma , fbdev -> fb_phys , fbdev -> fb_len <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { if ( <S2SV_ModStart> ) ; } if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result ) ;
<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
<S2SV_ModStart> * io1 ; unsigned long flags ; <S2SV_ModStart> inode -> i_ino ) ; spin_lock_irqsave ( & EXT4_I ( inode ) -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & EXT4_I ( inode ) -> i_completed_io_lock , flags ) ;
<S2SV_ModStart> * wq ; unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> = size ; io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> work ) ; ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> -> list , & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> ) ; iocb
<S2SV_ModStart> return ret ; <S2SV_ModEnd> ret = ext4_convert_unwritten_extents
<S2SV_ModStart> -> inode ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <S2SV_ModEnd> ; mutex_lock ( <S2SV_ModStart> if ( ret < <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { mutex_unlock ( & inode -> i_mutex ) ; return ; } spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> i_mutex ) ; ext4_free_io_end ( io ) ;
<S2SV_ModStart> ext4_init_io_end ( inode , GFP_NOFS
<S2SV_ModStart> ( ! io ) ; if ( io -> page ) put_page ( io -> page
<S2SV_ModStart> * handle = ext4_journal_current_handle ( ) <S2SV_ModEnd> ; int ret <S2SV_ModStart> int dio_credits ; int started = 0 ; <S2SV_ModStart> = EXT4_GET_BLOCKS_IO_CREATE_EXT ; if ( ! handle ) { <S2SV_ModStart> out ; } started = 1 ; } <S2SV_ModStart> 0 ; } if ( started )
<S2SV_ModStart> inode * inode , gfp_t flags <S2SV_ModStart> io ) , flags <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; io -> page = NULL <S2SV_ModEnd> ; INIT_WORK (
<S2SV_ModStart> mapping -> host ) ; if ( ext4_should_dioread_nolock ( page -> mapping -> host ) ) ext4_invalidatepage_free_endio ( page , offset
<S2SV_ModStart> = page ; if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> , fsdata , ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata ,
<S2SV_ModStart> buffer_head * page_bufs = NULL <S2SV_ModStart> ) ; else if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else
<S2SV_ModStart> ext4_io_end_t * io ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags <S2SV_ModStart> list_empty ( & ei <S2SV_ModEnd> -> i_completed_io_list ) <S2SV_ModStart> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> list_empty ( & ei <S2SV_ModEnd> -> i_completed_io_list ) <S2SV_ModStart> = list_entry ( ei <S2SV_ModEnd> -> i_completed_io_list . <S2SV_ModStart> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> ext4_end_io_nolock ( io ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ;
<S2SV_ModStart> get_blocks_flags = EXT4_GET_BLOCKS_CREATE ; if ( ext4_should_dioread_nolock ( mpd -> inode ) ) get_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT
<S2SV_ModStart> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;
<S2SV_ModStart> i_completed_io_list ) ; spin_lock_init ( & ei -> i_completed_io_lock ) ;
<S2SV_ModStart> ",norecovery" ) ; if ( test_opt ( sb , DIOREAD_NOLOCK ) ) seq_puts ( seq , ",dioread_nolock" ) ;
<S2SV_ModStart> ; break ; case Opt_dioread_nolock : set_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ; case Opt_dioread_lock : clear_opt ( sbi -> s_mount_opt , DIOREAD_NOLOCK ) ; break ;
<S2SV_ModStart> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }
<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
<S2SV_ModStart> pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_buffer ) * pipe_bufs <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> GFP_KERNEL ) ; } <S2SV_ModStart> -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( <S2SV_ModStart> pipe ; } free_uid ( user ) ;
<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> maxfraglen , fragheaderlen , mtu <S2SV_ModStart> ; int hh_len <S2SV_ModEnd> ; int copy <S2SV_ModStart> skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE
<S2SV_ModStart> void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )
<S2SV_ModStart> ) ; u32 count , <S2SV_ModStart> challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; <S2SV_ModStart> = now ; WRITE_ONCE ( challenge_count , half + prandom_u32_max ( sysctl_tcp_challenge_ack_limit ) ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; <S2SV_ModEnd> NET_INC_STATS ( sock_net
<S2SV_ModStart> path path ; uid_t check_ruid ; <S2SV_ModStart> sbi , raw_data , & check_ruid <S2SV_ModStart> out_free ; } if ( check_ruid && path . dentry -> d_inode -> i_uid != current_uid ( ) ) { rc = - EPERM ; printk ( KERN_ERR "Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>" "requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n" , path . dentry -> d_inode -> i_uid , current_uid ( ) ) ; goto out_free ; }
<S2SV_ModStart> char * options , uid_t * check_ruid <S2SV_ModStart> * fn_cipher_key_bytes_src ; * check_ruid = 0 ; <S2SV_ModStart> break ; case ecryptfs_opt_check_dev_ruid : * check_ruid = 1 ; break ; case
<S2SV_ModStart> = v ; if ( ! IS_ERR ( vma ) )
<S2SV_ModStart> arg ) { <S2SV_ModEnd> switch ( cmd <S2SV_ModStart> case F_SETLKW64 : return do_locks ( fd , cmd , arg ) ; default : return <S2SV_ModEnd> sys_fcntl64 ( fd <S2SV_ModStart> , cmd , arg <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> skb -> len && skb -> len
<S2SV_ModStart> serio ) ; if ( ! enable ) { wake_up_interruptible ( & sunkbd -> wait ) ; cancel_work_sync ( & sunkbd -> tq ) ; }
<S2SV_ModStart> case SUNKBD_RET_RESET : if ( sunkbd -> enabled )
<S2SV_ModStart> reset >= 0 || ! sunkbd -> enabled <S2SV_ModStart> HZ ) ; if <S2SV_ModEnd> ( sunkbd -> <S2SV_ModStart> ( sunkbd -> reset >= 0 && sunkbd -> enabled ) sunkbd_set_leds_beeps ( sunkbd <S2SV_ModEnd> ) ; }
<S2SV_ModStart> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
<S2SV_ModStart> intf ) { struct usb_host_interface * <S2SV_ModEnd> alt ; alt <S2SV_ModStart> ; if ( ! alt ) return - ENODEV <S2SV_ModEnd> ; return usb_set_interface <S2SV_ModStart> ( udev , alt -> <S2SV_ModEnd> desc . bInterfaceNumber <S2SV_ModStart> bInterfaceNumber , alt -> desc . bAlternateSetting
<S2SV_ModStart> extack ) ) { err = - EOPNOTSUPP ; <S2SV_ModStart> goto err_delete ; } <S2SV_ModStart> "conflict<S2SV_blank>with<S2SV_blank>already<S2SV_blank>offloaded<S2SV_blank>filter" ) ; err = - EOPNOTSUPP ; <S2SV_ModStart> ! match ) { err = <S2SV_ModEnd> - ENOMEM ; <S2SV_ModStart> - ENOMEM ; goto err_delete ; } <S2SV_ModStart> ) ; return err <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;
<S2SV_ModStart> ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> kc -> timer_forward
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; ++ timr <S2SV_ModStart> info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) <S2SV_ModEnd> ; } unlock_timer
<S2SV_ModStart> ( VM_HUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( VM_NOHUGEPAGE | VM_NO_THP <S2SV_ModEnd> ) ) return
<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
<S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; if ( ret > 0 && ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> u16 size , const <S2SV_ModStart> data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = <S2SV_ModEnd> usb_control_msg ( dev <S2SV_ModStart> , 0 , buf <S2SV_ModEnd> , size , <S2SV_ModStart> 500 ) ; kfree ( buf ) ; return ret ;
<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
<S2SV_ModStart> ifindex ; else { dst = skb_dst ( skb ) ; <S2SV_ModStart> = l3mdev_master_ifindex ( dst ? dst -> dev : skb -> dev ) ; } <S2SV_ModEnd> if ( (
<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> fail ; } mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; cp2112_gpio_set <S2SV_ModStart> ; fail : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> ; exit : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; buf <S2SV_ModStart> ret ) ; mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) goto out <S2SV_ModEnd> ; ret = <S2SV_ModStart> task ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> current ) ) <S2SV_ModEnd> goto retry ; <S2SV_ModStart> goto retry ; <S2SV_ModEnd> ret = - <S2SV_ModStart> abs_time ) goto out <S2SV_ModEnd> ; restart = <S2SV_ModStart> - ERESTART_RESTARTBLOCK ; <S2SV_ModEnd> out : if
<S2SV_ModStart> futex_hash_bucket * hb <S2SV_ModEnd> ; hb =
<S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;
<S2SV_ModStart> ! ( flags & <S2SV_ModEnd> RT6_LOOKUP_F_DST_NOREF ) )
<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
<S2SV_ModStart> dir ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> ( in ) <S2SV_ModEnd> dev -> in_pipe <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; if ( out ) <S2SV_ModStart> USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_ModEnd> if ( iso_in
<S2SV_ModStart> ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
<S2SV_ModStart> rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> len ) ; }
<S2SV_ModStart> = vendor_ie ; if ( <S2SV_ModEnd> * ( wmm_ie <S2SV_ModStart> + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 )
<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;
<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
<S2SV_ModStart> sk ) ; if ( writable ) { unix_state_lock ( sk ) ; other = unix_peer ( sk ) ; if ( other && unix_peer ( <S2SV_ModEnd> other ) != <S2SV_ModStart> ) != sk && <S2SV_ModEnd> unix_recvq_full ( other <S2SV_ModStart> ( other ) && unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModStart> = 0 ; unix_state_unlock ( sk <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = 0 ; int sk_locked ; <S2SV_ModStart> out_free ; } sk_locked = 0 ; <S2SV_ModStart> other ) ; restart_locked : <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> SOCK_DEAD ) ) ) <S2SV_ModStart> other ) ; if ( ! sk_locked ) unix_state_lock ( sk ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( unix_peer <S2SV_ModStart> ) = NULL ; unix_dgram_peer_wake_disconnect_wakeup ( sk , other ) <S2SV_ModStart> } if ( unlikely ( <S2SV_ModStart> other ) ) ) { if ( timeo ) { timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! sk_locked ) { unix_state_unlock ( other ) ; unix_state_double_lock ( sk , other ) ; } if ( unix_peer ( sk ) != other || unix_dgram_peer_wake_me ( sk , other ) <S2SV_ModEnd> ) { err <S2SV_ModStart> - EAGAIN ; sk_locked = 1 ; <S2SV_ModStart> out_unlock ; } if ( ! sk_locked ) { sk_locked = 1 ; goto restart_locked ; } } if ( unlikely ( sk_locked ) ) unix_state_unlock ( sk ) ; <S2SV_ModEnd> if ( sock_flag <S2SV_ModStart> ; out_unlock : if ( sk_locked ) unix_state_unlock ( sk ) ;
<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
<S2SV_ModStart> ( buf ) { if ( res . acl_len > buflen ) { ret = - ERANGE ; goto out_free ; } <S2SV_ModStart> acl_len ) ; }
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> , u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index
<S2SV_ModStart> ) ; struct <S2SV_ModEnd> skb_shared_info * shinfo <S2SV_ModStart> err ) ) xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> start = ( <S2SV_ModStart> , newerr ; <S2SV_ModEnd> pending_idx = frag_get_pending_idx <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> continue ; } xen_netbk_idx_release ( netbk , pending_idx <S2SV_ModEnd> , XEN_NETIF_RSP_ERROR ) <S2SV_ModStart> XEN_NETIF_RSP_ERROR ) ; <S2SV_ModEnd> if ( err <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY <S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> err ) ; if ( req -> buf != NULL )
<S2SV_ModStart> issrc , isneg , isimm <S2SV_ModStart> == BPF_ALU_SANITIZE_SRC ; isimm = aux -> alu_state & BPF_ALU_IMMEDIATE ; <S2SV_ModStart> ; if ( isimm ) { <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit ) ; } else { if ( isneg ) <S2SV_ModEnd> * patch ++ <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_REG ( BPF_SUB <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> patch ++ = BPF_ALU64_REG ( BPF_OR <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , off_reg <S2SV_ModEnd> ) ; * <S2SV_ModStart> = BPF_ALU64_IMM ( BPF_NEG <S2SV_ModEnd> , BPF_REG_AX , <S2SV_ModStart> , BPF_REG_AX , 0 <S2SV_ModEnd> ) ; * <S2SV_ModStart> patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; * patch ++ = <S2SV_ModStart> off_reg ) ; } <S2SV_ModStart> issrc && isneg && ! isimm
<S2SV_ModStart> cur_state ; bool off_is_imm = tnum_is_const ( off_reg -> var_off ) ; bool <S2SV_ModStart> off_is_neg ? BPF_ALU_NEG_VALUE : 0 ; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE
<S2SV_ModStart> group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; exit_keys ( tsk ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; if ( tsk -> binfmt ) module_put ( tsk -> binfmt -> module ) ; proc_exit_connector ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif <S2SV_ModStart> ( unlikely ( <S2SV_ModEnd> ! list_empty (
<S2SV_ModStart> -> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
<S2SV_ModStart> ( ! mm || ! mm -> env_end
<S2SV_ModStart> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> ( ) ) { <S2SV_ModStart> buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user <S2SV_ModStart> state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }
<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event
<S2SV_ModStart> -> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . <S2SV_ModStart> COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo .
<S2SV_ModStart> . map , KVM_MAX_VCPU_ID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> pin_lock ) ; hlist_del_init <S2SV_ModEnd> ( & pin <S2SV_ModStart> m_list ) ; hlist_del_init <S2SV_ModEnd> ( & pin
<S2SV_ModStart> ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; if ( replace ) { err = snd_ctl_remove_user_ctl ( file , & info -> id ) ; if ( err ) return err ; } if ( <S2SV_ModEnd> card -> user_ctl_count <S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,
<S2SV_ModStart> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
<S2SV_ModStart> ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> args -> rmtblkcnt = 0 ; args -> rmtvaluelen <S2SV_ModStart> args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2
<S2SV_ModStart> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> 0 ) ; args -> rmtvaluelen <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> -> i_mount , args -> rmtvaluelen <S2SV_ModEnd> ) ; if <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return 0 <S2SV_ModStart> -> valuelen < args -> rmtvaluelen ) { args -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; return XFS_ERROR <S2SV_ModStart> -> valuelen = args -> rmtvaluelen <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno <S2SV_ModEnd> = be32_to_cpu ( <S2SV_ModStart> ( name_rmt -> <S2SV_ModEnd> valueblk ) ; <S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; return
<S2SV_ModStart> ; args . rmtvaluelen = valuelen ; args .
<S2SV_ModStart> ; int valuelen <S2SV_ModEnd> ; int nmap <S2SV_ModStart> ATTR_KERNOVAL ) ) ; ASSERT ( args -> rmtvaluelen == args -> valuelen ) ; valuelen = args -> rmtvaluelen
<S2SV_ModStart> , args -> rmtvaluelen <S2SV_ModEnd> ) ; error <S2SV_ModStart> = args -> rmtvaluelen <S2SV_ModEnd> ; while (
<S2SV_ModStart> = ext4_xattr_create_cache ( <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; }
<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
<S2SV_ModStart> s ; struct mb2_cache_entry <S2SV_ModEnd> * ce = <S2SV_ModStart> 0 ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> base ) { <S2SV_ModEnd> BUFFER_TRACE ( bs <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> bh ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; <S2SV_ModStart> ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ;
<S2SV_ModStart> header , struct mb2_cache_entry <S2SV_ModEnd> * * pce <S2SV_ModStart> ) ; struct mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> hash ) ; ce = mb2_cache_entry_find_first <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ( ext4_mb_cache , <S2SV_ModEnd> hash ) ; <S2SV_ModStart> * bh ; <S2SV_ModEnd> bh = sb_bread <S2SV_ModStart> ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ext4_xattr_cache_insert ( struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ext4_mb_cache , GFP_NOFS , hash , <S2SV_ModEnd> bh -> b_blocknr <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> - EBUSY ) <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> "already<S2SV_blank>in<S2SV_blank>cache" ) ; } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> hash ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> struct mb2_cache <S2SV_ModEnd> * ext4_xattr_create_cache ( <S2SV_ModStart> * ext4_xattr_create_cache ( void <S2SV_ModEnd> ) { return <S2SV_ModStart> ) { return mb2_cache_create ( <S2SV_ModEnd> HASH_BUCKET_BITS ) ;
<S2SV_ModStart> ext4_xattr_destroy_cache ( struct mb2_cache <S2SV_ModEnd> * cache ) <S2SV_ModStart> ( cache ) mb2_cache_destroy <S2SV_ModEnd> ( cache )
<S2SV_ModStart> bh ) { <S2SV_ModEnd> int error = <S2SV_ModStart> error = 0 <S2SV_ModEnd> ; BUFFER_TRACE ( <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; <S2SV_ModStart> "refcount<S2SV_blank>now=0;<S2SV_blank>freeing" ) ; mb2_cache_entry_delete_block ( EXT4_GET_MB_CACHE ( inode ) , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; get_bh <S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_handle_valid ( handle
<S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> . val = ! ! <S2SV_ModStart> -> flags ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) <S2SV_ModEnd> ; set_sndbuf : <S2SV_ModStart> |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_SNDBUF ) <S2SV_ModEnd> ; sk -> <S2SV_ModStart> case SO_RCVBUF : val = min_t ( u32 , val , sysctl_rmem_max ) <S2SV_ModEnd> ; set_rcvbuf : <S2SV_ModStart> |= SOCK_RCVBUF_LOCK ; sk -> sk_rcvbuf = max_t ( u32 , <S2SV_ModEnd> val * 2 <S2SV_ModStart> val * 2 , SOCK_MIN_RCVBUF ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
<S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp -> <S2SV_ModStart> ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL ; newnp ->
<S2SV_ModStart> endif newnp -> ipv6_mc_list = NULL ; newnp -> <S2SV_ModStart> newinet -> inet_opt = NULL ; newnp -> ipv6_mc_list
<S2SV_ModStart> ; if ( size > 64 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n" , size ) ; return 0 ; } if (
<S2SV_ModStart> req_u -> req ; lock_sock ( sk ) <S2SV_ModStart> out ; } <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ; } if ( pg_vec ) free_pg_vec ( pg_vec , order , req -> tp_block_nr ) ; out : <S2SV_ModStart> sk ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <S2SV_ModStart> . pg_vec ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; } else { <S2SV_ModEnd> po -> tp_version <S2SV_ModStart> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <S2SV_ModEnd> } case PACKET_RESERVE
<S2SV_ModStart> "HTC<S2SV_blank>credit<S2SV_blank>config<S2SV_blank>timeout\\n" ) ; kfree_skb ( skb ) ;
<S2SV_ModStart> service_id ) ; kfree_skb ( skb ) ;
<S2SV_ModStart> "HTC<S2SV_blank>start<S2SV_blank>timeout\\n" ) ; kfree_skb ( skb ) ;
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; int ret <S2SV_ModStart> ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { ret = - EINVAL ; goto out ; } <S2SV_ModStart> -> nd_num ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; goto out ; } <S2SV_ModStart> ( ret ) goto out <S2SV_ModEnd> ; } if <S2SV_ModStart> nd_num ; } ret = count ; out : o2nm_unlock_subsystem ( ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> o2nm_cluster * cluster <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } <S2SV_ModStart> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ;
<S2SV_ModStart> node ) { if ( node -> nd_item . ci_parent ) <S2SV_ModStart> ci_parent ) ; else return NULL ;
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,
<S2SV_ModStart> msr ) { switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; }
<S2SV_ModStart> - ENOMEM ; nfp_repr_free ( repr ) ; <S2SV_ModStart> port ) ; kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ;
<S2SV_ModStart> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
<S2SV_ModStart> sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&
<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
<S2SV_ModStart> rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
<S2SV_ModStart> mtu , flags , rt
<S2SV_ModStart> ipv6_select_ident ( fh , rt <S2SV_ModStart> ipv6_select_ident ( fh , rt
<S2SV_ModStart> unsigned int flags , struct rt6_info * rt <S2SV_ModStart> ( & fhdr , rt
<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int udp_push_pending_frames (
<S2SV_ModStart> struct flowi6 * fl6 ; int err = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( up -> pending == AF_INET ) return udp_push_pending_frames ( sk ) ; <S2SV_ModStart> . ip6 ; <S2SV_ModEnd> if ( (
<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV
<S2SV_ModStart> -> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
<S2SV_ModStart> * dev ; int no_module ; <S2SV_ModStart> ( ) ; no_module = ! dev ; if ( no_module <S2SV_ModEnd> && capable ( <S2SV_ModStart> CAP_NET_ADMIN ) ) no_module = request_module ( "netdev-%s" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> , name ) ) pr_err ( "Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>" "with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>" "instead\\n" , name ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> : if ( skb == NULL ||
<S2SV_ModStart> bprm ) { <S2SV_ModEnd> int retval ; <S2SV_ModStart> int retval ; bprm_fill_uid ( bprm ) ; <S2SV_ModEnd> retval = security_bprm_set_creds
<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
<S2SV_ModStart> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
<S2SV_ModStart> -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ; if (
<S2SV_ModStart> IOPRIO_NORM ) ; task_lock ( p ) ; <S2SV_ModStart> -> ioprio ; task_unlock ( p ) ;
<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
<S2SV_ModStart> ) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;
<S2SV_ModStart> - ENOMEM ; nfp_repr_free ( repr ) ; <S2SV_ModStart> port ) ; kfree ( repr_priv ) ; <S2SV_ModStart> err ) { kfree ( repr_priv ) ;
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
<S2SV_ModStart> } if ( assoc_array_ptr_is_leaf ( ptr ) &&
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> fname ) ; priv -> ctrl . fname = NULL ; <S2SV_ModStart> == NULL ) return <S2SV_ModEnd> - ENOMEM ;
<S2SV_ModStart> 0 ) ; if ( intf -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & intf -> dev , "interface<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>endpoints,<S2SV_blank>but<S2SV_blank>must<S2SV_blank>have<S2SV_blank>minimum<S2SV_blank>1\\n" , intf -> altsetting [ 0 ] . desc . bNumEndpoints ) ; err = - EINVAL ; goto fail3 ; } <S2SV_ModStart> "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; err = - EINVAL ;
<S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops <S2SV_ModEnd> ) ; sctp_v6_protosw_exit <S2SV_ModStart> ; sctp_v4_protosw_exit ( ) ; unregister_pernet_subsys ( & sctp_defaults_ops
<S2SV_ModStart> ; status = register_pernet_subsys ( & sctp_defaults_ops ) ; if ( status ) goto err_register_defaults ; status = <S2SV_ModStart> register_pernet_subsys ( & sctp_ctrlsock_ops ) ; if ( status ) goto err_register_ctrlsock <S2SV_ModEnd> ; status = <S2SV_ModStart> unregister_pernet_subsys ( & sctp_ctrlsock_ops ) ; err_register_ctrlsock <S2SV_ModEnd> : sctp_v6_protosw_exit ( <S2SV_ModStart> ) ; err_protosw_init : unregister_pernet_subsys ( & sctp_defaults_ops ) ; err_register_defaults
<S2SV_ModStart> case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;
<S2SV_ModStart> ; return ret < <S2SV_ModEnd> 0 ? ret
<S2SV_ModStart> , } ; if ( info . tcpv_rttcnt > 0 ) { <S2SV_ModStart> ( t , info . tcpv_rttcnt <S2SV_ModEnd> ) ; info <S2SV_ModStart> = t ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
<S2SV_ModStart> raw_frag_vec rfv ; int hdrincl ; <S2SV_ModStart> ) goto out ; hdrincl = inet -> hdrincl <S2SV_ModStart> ; if ( <S2SV_ModEnd> hdrincl ) goto <S2SV_ModStart> , RT_SCOPE_UNIVERSE , <S2SV_ModEnd> hdrincl ? IPPROTO_RAW <S2SV_ModStart> ) | ( <S2SV_ModEnd> hdrincl ? FLOWI_FLAG_KNOWN_NH <S2SV_ModStart> if ( ! <S2SV_ModEnd> hdrincl ) { <S2SV_ModStart> : if ( <S2SV_ModEnd> hdrincl ) err
<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
<S2SV_ModStart> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;
<S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu , <S2SV_ModStart> ! validate_event ( event -> pmu ,
<S2SV_ModStart> ; sbinfo -> max_inodes = config . nr_inodes ; sbinfo -> free_inodes = config . nr_inodes ; sbinfo -> spool = NULL ; if ( <S2SV_ModEnd> config . nr_blocks <S2SV_ModStart> config . nr_blocks != - 1 ) { sbinfo -> spool = hugepage_new_subpool ( <S2SV_ModEnd> config . nr_blocks <S2SV_ModStart> config . nr_blocks <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! sbinfo -> spool <S2SV_ModEnd> ) goto out_free <S2SV_ModStart> goto out_free ; } sb -> s_maxbytes = MAX_LFS_FILESIZE ; sb -> s_blocksize = huge_page_size ( config . hstate ) ; sb -> s_blocksize_bits = huge_page_shift ( config . hstate ) ; sb -> s_magic = HUGETLBFS_MAGIC ; sb -> s_op = & hugetlbfs_ops ; sb -> s_time_gran = 1 ; inode = hugetlbfs_get_root ( sb , & config ) ; if ( ! inode ) goto out_free ; <S2SV_ModStart> ; out_free : if ( sbinfo -> spool ) kfree ( sbinfo -> spool ) ;
<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
<S2SV_ModStart> ( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->
<S2SV_ModStart> ) { struct hugepage_subpool * spool = subpool_vma ( vma ) ; struct <S2SV_ModStart> page * page <S2SV_ModEnd> ; long chg <S2SV_ModStart> ) if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> page ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> unsigned long ) spool <S2SV_ModEnd> ) ; vma_commit_reservation
<S2SV_ModStart> ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool <S2SV_ModEnd> * ) page_private <S2SV_ModStart> hugetlb_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , 1 )
<S2SV_ModStart> inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )
<S2SV_ModStart> offset ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> i_lock ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , ( chg
<S2SV_ModStart> reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma <S2SV_ModStart> reserve ) ; hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , reserve )
<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
<S2SV_ModStart> ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
<S2SV_ModStart> case BPF_TYPE_PROG : raw = bpf_prog_inc ( raw <S2SV_ModEnd> ) ; break <S2SV_ModStart> case BPF_TYPE_MAP : raw =
<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> return map ; map =
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> struct bpf_map * <S2SV_ModEnd> bpf_map_inc ( struct <S2SV_ModStart> uref ) { if ( atomic_inc_return ( & map -> refcnt ) > BPF_MAX_REFCNT ) { atomic_dec <S2SV_ModEnd> ( & map <S2SV_ModStart> refcnt ) ; return ERR_PTR ( - EBUSY ) ; } <S2SV_ModStart> usercnt ) ; return map ;
<S2SV_ModStart> return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput
<S2SV_ModStart> E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart> = map ; <S2SV_ModEnd> fdput ( f
<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
<S2SV_ModStart> * nlh ; struct module * module ; <S2SV_ModStart> = false ; module = cb -> module ; skb = cb -> skb ; <S2SV_ModStart> ; module_put ( <S2SV_ModEnd> module ) ; <S2SV_ModStart> ; consume_skb ( <S2SV_ModEnd> skb ) ;
<S2SV_ModStart> current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> CAP_SYS_ADMIN ) )
<S2SV_ModStart> ctx ) ) goto out <S2SV_ModEnd> ; pos = <S2SV_ModStart> ; } } out :
<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
<S2SV_ModStart> goto inval ; } <S2SV_ModEnd> if ( ( <S2SV_ModStart> goto inval ; <S2SV_ModEnd> switch ( cmd
<S2SV_ModStart> ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0
<S2SV_ModStart> ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16
<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> } err = crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> seed (
<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
<S2SV_ModStart> if ( indev && indev -> ifa_list <S2SV_ModEnd> ) { ifa
<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , "%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &
<S2SV_ModStart> { struct sockaddr_rc sa <S2SV_ModEnd> ; struct sock <S2SV_ModStart> sk ; int len , <S2SV_ModEnd> err = 0 <S2SV_ModStart> err = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> - EINVAL ; memset ( & sa , 0 , sizeof ( sa ) ) ; len = min_t ( unsigned int , sizeof ( sa ) , addr_len ) ; memcpy ( & sa , addr , len ) ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>%pMR" , sk , & sa . rc_bdaddr ) ; <S2SV_ModStart> ; if ( sa . rc_channel <S2SV_ModEnd> && __rfcomm_get_listen_sock_by_addr ( <S2SV_ModStart> && __rfcomm_get_listen_sock_by_addr ( sa . rc_channel , & sa . <S2SV_ModEnd> rc_bdaddr ) ) <S2SV_ModStart> , & sa . <S2SV_ModEnd> rc_bdaddr ) ; <S2SV_ModStart> -> channel = sa . rc_channel <S2SV_ModEnd> ; sk ->
<S2SV_ModStart> -> back_pointer ; if ( ! cursor ) goto gc_complete ; <S2SV_ModStart> BUG_ON ( ! cursor <S2SV_ModEnd> ) ; node
<S2SV_ModStart> ; if ( <S2SV_ModEnd> flag & CL_UNPRIVILEGED <S2SV_ModStart> & CL_UNPRIVILEGED ) { mnt -> mnt . mnt_flags |= MNT_LOCK_ATIME ; if <S2SV_ModEnd> ( mnt -> <S2SV_ModStart> mnt_flags & MNT_READONLY <S2SV_ModEnd> ) mnt -> <S2SV_ModStart> ; if ( mnt -> mnt . mnt_flags & MNT_NODEV ) mnt -> mnt . mnt_flags |= MNT_LOCK_NODEV ; if ( mnt -> mnt . mnt_flags & MNT_NOSUID ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOSUID ; if ( mnt -> mnt . mnt_flags & MNT_NOEXEC ) mnt -> mnt . mnt_flags |= MNT_LOCK_NOEXEC ; } if (
<S2SV_ModStart> mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV
<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct ion_handle * <S2SV_ModStart> ; handle = ion_handle_get_by_id_nolock ( client , id <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> ; return handle <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int ion_handle_put ( <S2SV_ModStart> ; ret = ion_handle_put_nolock ( handle <S2SV_ModEnd> ) ; mutex_unlock
<S2SV_ModStart> * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break
<S2SV_ModStart> len < 0 <S2SV_ModEnd> ) { syslog <S2SV_ModStart> 1 ; } if ( addr . nl_pid ) { syslog ( LOG_WARNING , "Received<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>untrusted<S2SV_blank>pid:%u" , addr . nl_pid ) ; continue ; }
<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
<S2SV_ModStart> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;
<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
<S2SV_ModStart> bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct <S2SV_ModStart> sctp_addr dst_saddr ; struct in6_addr * final_p , final ; <S2SV_ModStart> ) ; } final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false ) <S2SV_ModStart> . sin6_port ; final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_ModStart> , fl6 , final_p <S2SV_ModEnd> , false )
<S2SV_ModStart> ; struct flowi6 * fl6 = & transport -> fl . u . ip6 ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>skb:%p,<S2SV_blank>len:%d,<S2SV_blank>src:%pI6<S2SV_blank>dst:%pI6\\n" <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> saddr , & <S2SV_ModStart> , & fl6 -> <S2SV_ModEnd> daddr ) ; <S2SV_ModStart> daddr ) ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 1 ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; <S2SV_ModStart> , skb , <S2SV_ModEnd> fl6 , np
<S2SV_ModStart> ( tty ) && ! L_EXTPROC ( tty )
<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;
<S2SV_ModStart> > nr_parens ) { ret = - EINVAL ; goto out_free ; } <S2SV_ModEnd> * ( ++
<S2SV_ModStart> inet_daddr ; struct dst_entry * dst ; struct <S2SV_ModStart> * rt ; rcu_read_lock ( ) ; dst = __sk_dst_get ( sk ) ; <S2SV_ModStart> if ( ! dst || ! dst -> obsolete || dst -> ops -> check ( dst <S2SV_ModEnd> , 0 ) <S2SV_ModStart> 0 ) ) { rcu_read_unlock ( ) ; return ; } <S2SV_ModEnd> inet_opt = rcu_dereference <S2SV_ModStart> sk_bound_dev_if ) ; dst = <S2SV_ModEnd> ! IS_ERR ( <S2SV_ModStart> ( rt ) ? <S2SV_ModEnd> & rt -> <S2SV_ModStart> & rt -> dst : NULL ; sk_dst_set ( sk ,
<S2SV_ModStart> -> code ) ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; return ret ; }
<S2SV_ModStart> , * insn_idx , false
<S2SV_ModStart> NULL ; } dst_state -> speculative = src -> speculative ;
<S2SV_ModStart> ; state -> speculative = false ; state -> <S2SV_ModStart> ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? "<S2SV_blank>(speculative<S2SV_blank>execution)" : "" <S2SV_ModStart> ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? "<S2SV_blank>(speculative<S2SV_blank>execution)" : ""
<S2SV_ModStart> insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> ; aux = <S2SV_ModStart> if ( ! aux -> alu_state <S2SV_ModEnd> ) continue ; <S2SV_ModStart> ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> ; new_prog = <S2SV_ModStart> } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> aux = & <S2SV_ModStart> ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> aux ) ) { verbose ( env , "tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n" ) ; return - EINVAL ; } <S2SV_ModEnd> map_ptr = BPF_MAP_PTR <S2SV_ModStart> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> ( map_ptr , <S2SV_ModStart> ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> new_prog = bpf_patch_insn_data <S2SV_ModStart> continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }
<S2SV_ModStart> , int prev_insn_idx , bool speculative <S2SV_ModStart> ) goto err ; elem -> st . speculative |= speculative
<S2SV_ModStart> cur -> curframe ) return false ; if ( old -> speculative && ! cur -> speculative
<S2SV_ModStart> ; if ( new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> VM_PFNMAP ) ) goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> ; } if
<S2SV_ModStart> return true ; <S2SV_ModEnd> } return false
<S2SV_ModStart> ; if ( <S2SV_ModEnd> child -> ptrace <S2SV_ModStart> child -> ptrace <S2SV_ModEnd> && child -> <S2SV_ModStart> current ) { WARN_ON ( child -> state == __TASK_TRACED <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ignore_state || ptrace_freeze_traced ( child <S2SV_ModEnd> ) ) ret <S2SV_ModStart> ret = 0 <S2SV_ModEnd> ; } read_unlock <S2SV_ModStart> ! ignore_state ) { if ( ! <S2SV_ModEnd> wait_task_inactive ( child <S2SV_ModStart> ( child , __TASK_TRACED ) ) { WARN_ON ( child -> state == __TASK_TRACED ) ; ret = <S2SV_ModEnd> - ESRCH ; <S2SV_ModStart> - ESRCH ; } }
<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
<S2SV_ModStart> esr ) { siginfo_t info ; void __user * pc = ( void __user * ) instruction_pointer ( regs ) ; <S2SV_ModStart> esr ) ; __show_regs ( regs ) ; info . si_signo = SIGILL ; info . si_errno = 0 ; info . si_code = ILL_ILLOPC ; info . si_addr = pc ; arm64_notify_die <S2SV_ModEnd> ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , <S2SV_ModStart> , regs , & info , 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> = - EIO ; return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV
<S2SV_ModStart> return ; } if ( alt -> desc . bNumEndpoints < 1 ) { sd -> gspca_dev . usb_err = - ENODEV ; return ; }
<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; if ( error ) goto out_drop_lock ; fh_unlock ( fh ) <S2SV_ModEnd> ; fh_drop_write ( <S2SV_ModStart> return nfserr ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh
<S2SV_ModStart> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) <S2SV_ModEnd> goto out_errno ; <S2SV_ModStart> goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT <S2SV_ModEnd> , argp -> <S2SV_ModStart> argp -> acl_default ) ; out_drop_lock : fh_unlock ( fh ) ; <S2SV_ModEnd> fh_drop_write ( fh
<S2SV_ModStart> ; if ( <S2SV_ModEnd> S_ISDIR ( inode <S2SV_ModStart> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( <S2SV_ModStart> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl
<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ;
<S2SV_ModStart> len ; int <S2SV_ModEnd> err ; if <S2SV_ModStart> EINVAL ; } if ( headroom >= chunk_size - XDP_PACKET_HEADROOM <S2SV_ModEnd> ) return -
<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . <S2SV_ModStart> . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> skb ) { strncpy ( <S2SV_ModEnd> ualg -> cru_name <S2SV_ModStart> -> cru_name , <S2SV_ModEnd> alg -> cra_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_driver_name <S2SV_ModStart> -> cru_driver_name , <S2SV_ModEnd> alg -> cra_driver_name <S2SV_ModStart> ) ) ; strncpy ( <S2SV_ModEnd> ualg -> cru_module_name <S2SV_ModStart> cra_module ) , sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 <S2SV_ModEnd> ; ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl . <S2SV_ModStart> . type , "larval" , sizeof ( rl . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
<S2SV_ModStart> int error ; struct file * f ; <S2SV_ModStart> - EINVAL ; f = vma -> vm_file ; <S2SV_ModStart> if ( ! f || ! f <S2SV_ModEnd> -> f_mapping || <S2SV_ModStart> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> <S2SV_ModStart> PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | <S2SV_ModStart> end - start ) ; fput ( f
<S2SV_ModStart> -> sec_level ; sec . key_size = 0 ;
<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0
<S2SV_ModStart> blkg ) ) <S2SV_ModEnd> return PTR_ERR ( <S2SV_ModStart> blkg ) ; <S2SV_ModEnd> q -> root_blkg
<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> sctp_verify_asconf ( const <S2SV_ModStart> asoc , struct sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> , struct sctp_paramhdr <S2SV_ModStart> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> ; union sctp_params <S2SV_ModStart> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> param . v <S2SV_ModStart> param . v != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * hdr ; __u32 serial <S2SV_ModEnd> ; if ( <S2SV_ModStart> serial ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( asoc , chunk , true , <S2SV_ModEnd> & err_param )
<S2SV_ModStart> ( asoc , asconf_ack , false , <S2SV_ModEnd> & err_param )
<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
<S2SV_ModStart> ; if ( fp &&
<S2SV_ModStart> } else { return false ; } } else if ( r -> CRn == 0 && r -> CRm == 9 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; <S2SV_ModEnd> } else if <S2SV_ModStart> } else { return false <S2SV_ModEnd> ; } if
<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;
<S2SV_ModStart> ] . jf && f_offset <S2SV_ModStart> ? 2 : 5 <S2SV_ModEnd> ; EMIT_COND_JMP (
<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
<S2SV_ModStart> ; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :
<S2SV_ModStart> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; <S2SV_ModStart> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ;
<S2SV_ModStart> 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart> destroy ( dev <S2SV_ModEnd> ) ; return
<S2SV_ModStart> == 0x89 ) { <S2SV_ModStart> return - EFAULT ; } else memset ( & ifr , 0 , sizeof ( ifr ) )
<S2SV_ModStart> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;
<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
<S2SV_ModStart> i > pos + delta <S2SV_ModStart> off + 1 <= pos + delta <S2SV_ModEnd> ) insn ->
<S2SV_ModStart> ; int err <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> uint32_t pos ; if ( inode -> i_size > inode -> i_sb -> s_blocksize ) { err = - ENAMETOOLONG ; goto out_unmap ; } <S2SV_ModStart> ! bh ) { err = - EIO ; goto out_unlock_inode ; } <S2SV_ModEnd> symlink = bh <S2SV_ModStart> return 0 ; out_unlock_inode <S2SV_ModEnd> : up_read ( <S2SV_ModStart> page ) ; out_unmap :
<S2SV_ModStart> from ) ) { kfree ( kbuf ) ; <S2SV_ModStart> - EFAULT ; } <S2SV_ModStart> len ) ; kfree ( kbuf ) ;
<S2SV_ModStart> ACPI_STATUS Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * Prev <S2SV_ModStart> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
<S2SV_ModStart> EIO ; } if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV ;
<S2SV_ModStart> gspca_dev ) { struct usb_interface_cache * intfc ; <S2SV_ModStart> break ; } intfc = <S2SV_ModEnd> gspca_dev -> dev <S2SV_ModStart> [ 0 ] ; if ( intfc -> num_altsetting < 2 ) return - ENODEV ; alt = & intfc <S2SV_ModStart> [ 1 ] ; if ( alt -> desc . bNumEndpoints < 1 ) return - ENODEV
<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
<S2SV_ModStart> u64 redir_content ; if <S2SV_ModEnd> ( redir_index < <S2SV_ModStart> < IOAPIC_NUM_PINS ) <S2SV_ModEnd> redir_content = ioapic <S2SV_ModStart> ] . bits ; else redir_content = ~ 0ULL
<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
<S2SV_ModStart> * ns ; list_for_each_entry ( chain <S2SV_ModEnd> , & ctx <S2SV_ModStart> goto out ; } list_for_each_entry_safe ( set , ns , & ctx -> table -> sets , list ) { if ( set -> flags & NFT_SET_ANONYMOUS && ! list_empty ( & set -> bindings ) ) continue ; err = nft_delset ( ctx , set <S2SV_ModEnd> ) ; if <S2SV_ModStart> } list_for_each_entry_safe ( chain , nc <S2SV_ModEnd> , & ctx <S2SV_ModStart> -> table -> chains <S2SV_ModEnd> , list ) <S2SV_ModStart> list ) { ctx -> chain = chain ; err = nft_delchain ( ctx <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
<S2SV_ModStart> shm_perm ) ; if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; }
<S2SV_ModStart> nikeys ) ; if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart> key -> user <S2SV_ModEnd> ) ; kfree
<S2SV_ModStart> OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
<S2SV_ModStart> thread -> tp_value [ 0 ] <S2SV_ModStart> childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( )
<S2SV_ModStart> ) -> tp_value [ 0 ]
<S2SV_ModStart> long remaining ; int allowed ; <S2SV_ModStart> count ) ; allowed = page_is_allowed <S2SV_ModEnd> ( p >> <S2SV_ModStart> p >> PAGE_SHIFT ) ; if ( ! allowed <S2SV_ModEnd> ) return - <S2SV_ModStart> - EPERM ; if ( allowed == 2 ) { remaining = clear_user ( buf , sz ) ; } else { <S2SV_ModStart> ptr ) ; }
<S2SV_ModStart> 0 ) { int allowed ; <S2SV_ModStart> count ) ; allowed = page_is_allowed <S2SV_ModEnd> ( p >> <S2SV_ModStart> p >> PAGE_SHIFT ) ; if ( ! allowed <S2SV_ModEnd> ) return - <S2SV_ModStart> - EPERM ; if ( allowed == 1 ) { <S2SV_ModStart> EFAULT ; } }
<S2SV_ModStart> report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , "Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n" , i + size , length ) ; break ; } <S2SV_ModEnd> switch ( size <S2SV_ModStart> break ; case 4 : <S2SV_ModEnd> data32 = get_unaligned_le32
<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen
<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
<S2SV_ModStart> = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
<S2SV_ModStart> & TTM_PAGE_FLAG_DMA32 ) && ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModStart> ; while ( ( npages - i ) >= HPAGE_PMD_NR <S2SV_ModEnd> ) { struct
<S2SV_ModStart> == - ENODATA && inode -> i_op -> removexattr ) { <S2SV_ModEnd> rc = inode <S2SV_ModStart> XATTR_NAME_EVM ) ; }
<S2SV_ModStart> ip_proto = 0 ; bool ret = false <S2SV_ModStart> < 5 ) goto out_bad <S2SV_ModEnd> ; nhoff += <S2SV_ModStart> ! iph ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> ! vlan ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } } <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> FLOW_DISSECTOR_KEY_TIPC_ADDRS ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } goto out_good ; } goto out_good <S2SV_ModEnd> ; } case <S2SV_ModStart> ; default : goto out_bad <S2SV_ModEnd> ; } ip_proto_again <S2SV_ModStart> ! hdr ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! keyid ) goto out_bad <S2SV_ModEnd> ; if ( <S2SV_ModStart> ! eth ) goto out_bad <S2SV_ModEnd> ; proto = <S2SV_ModStart> ! opthdr ) goto out_bad <S2SV_ModEnd> ; ip_proto = <S2SV_ModStart> break ; } if ( skb_flow_dissector_uses_key ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS ) ) { key_ports = skb_flow_dissector_target ( flow_dissector , FLOW_DISSECTOR_KEY_PORTS , target_container ) ; key_ports -> ports = __skb_flow_get_ports ( skb , nhoff , ip_proto , data , hlen ) ; } out_good : ret = true ; out_bad : <S2SV_ModStart> ) nhoff ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; ret = aio_setup_single_vector ( READ , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = aio_setup_single_vector ( WRITE , file , <S2SV_ModEnd> kiocb ) ; <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( READ <S2SV_ModStart> ; ret = <S2SV_ModEnd> aio_setup_vectored_rw ( WRITE
<S2SV_ModStart> ssize_t aio_setup_single_vector ( int type , struct file * file , <S2SV_ModStart> kiocb ) { int bytes ; bytes = rw_verify_area ( type , file , & kiocb -> ki_pos , kiocb -> ki_left ) ; if ( bytes < 0 ) return bytes ; <S2SV_ModStart> -> iov_len = bytes <S2SV_ModEnd> ; kiocb ->
<S2SV_ModStart> goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> GFP_KERNEL ) ) { kfree ( state ) ; <S2SV_ModStart> - ENOMEM ; }
<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs
<S2SV_ModStart> ( event , <S2SV_ModEnd> data , regs
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS , 1 <S2SV_ModEnd> , regs , <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , int throttle <S2SV_ModStart> = POLL_HUP ; <S2SV_ModEnd> event -> pending_disable <S2SV_ModStart> ) ; } if ( event -> overflow_handler ) event -> overflow_handler ( event , data , regs ) ; else <S2SV_ModEnd> perf_event_output ( event <S2SV_ModStart> perf_event_output ( event <S2SV_ModEnd> , data , <S2SV_ModStart> pending_kill ) { <S2SV_ModEnd> event -> pending_wakeup <S2SV_ModStart> event -> pending <S2SV_ModEnd> ) ; }
<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct pt_regs * <S2SV_ModStart> , nr , <S2SV_ModEnd> & data ,
<S2SV_ModStart> , u64 nr <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> , nr , <S2SV_ModEnd> data , regs
<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
<S2SV_ModStart> header . size <S2SV_ModEnd> , 0 )
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> . size , <S2SV_ModEnd> 1 ) )
<S2SV_ModStart> perf_event * event <S2SV_ModEnd> , struct perf_sample_data <S2SV_ModStart> ( event , <S2SV_ModEnd> 1 , data
<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> size , 0 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> . size , <S2SV_ModEnd> 0 ) ;
<S2SV_ModStart> u64 nr , <S2SV_ModEnd> struct perf_sample_data * <S2SV_ModStart> , 1 , <S2SV_ModEnd> data , regs <S2SV_ModStart> , 0 , <S2SV_ModEnd> data , regs
<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> u64 overflow , <S2SV_ModEnd> struct perf_sample_data * <S2SV_ModStart> ( event , <S2SV_ModEnd> throttle , data
<S2SV_ModStart> size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample
<S2SV_ModStart> POLL_IN ) ; <S2SV_ModEnd> handle -> event <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> struct serial_icounter_struct icount = { }
<S2SV_ModStart> rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst
<S2SV_ModStart> if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +
<S2SV_ModStart> ) ; goto err_free_controls <S2SV_ModEnd> ; } dev_info <S2SV_ModStart> hdl ) ; <S2SV_ModEnd> v4l2_device_unregister ( &
<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> found = 0 <S2SV_ModEnd> ; const char <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( found
<S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j < <S2SV_ModStart> ( j = 1 <S2SV_ModEnd> ; j <
<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb )
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk ,
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb )
<S2SV_ModStart> snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
<S2SV_ModStart> goto out ; err = ovl_copy_up ( dentry ) ; if ( ! err ) { <S2SV_ModStart> dentry ) ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ) ; } <S2SV_ModEnd> ovl_drop_write ( dentry
<S2SV_ModStart> size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return false ; }
<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
<S2SV_ModStart> * bh ; unsigned int table_len ; <S2SV_ModStart> -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , "error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>" "Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } <S2SV_ModStart> && offset < table_len <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
<S2SV_ModStart> mode ) { mutex_lock ( & loop_index_mutex ) ; __lo_release ( <S2SV_ModEnd> disk -> private_data <S2SV_ModStart> disk -> private_data ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> mutex_unlock ( & loop_index_mutex <S2SV_ModEnd> ) ; }
<S2SV_ModStart> snd_timer_user * tu <S2SV_ModEnd> = file -> <S2SV_ModStart> -> private_data ; long ret <S2SV_ModEnd> ; mutex_lock ( <S2SV_ModStart> & tu -> ioctl_lock ) ; ret = __snd_timer_user_ioctl ( file , cmd , arg ) <S2SV_ModEnd> ; mutex_unlock ( <S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; tu
<S2SV_ModStart> = NULL ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> tu -> timeri ) ; mutex_unlock ( & tu -> ioctl_lock
<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> } __err : <S2SV_ModEnd> return err ;
<S2SV_ModStart> salg ) ; alg = & salg -> base ; <S2SV_ModStart> - EINVAL ; if ( crypto_shash_alg_has_setkey ( salg ) ) goto out_put_alg ; <S2SV_ModStart> salg -> statesize <S2SV_ModEnd> ; if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
<S2SV_ModStart> ) { int ret = pci_read_config_word <S2SV_ModEnd> ( dev , <S2SV_ModStart> offset , value ) ; const struct pci_cmd_info * cmd = data ; * value &= PCI_COMMAND_GUEST ; <S2SV_ModEnd> * value |= <S2SV_ModStart> * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; <S2SV_ModEnd> return ret ;
<S2SV_ModStart> int err ; u16 val ; struct pci_cmd_info * cmd = data ; <S2SV_ModStart> ; } } cmd -> val = value ; if ( ! permissive && ( ! dev_data || ! dev_data -> permissive ) ) return 0 ; err = pci_read_config_word ( dev , offset , & val ) ; if ( err || val == value ) return err ; value &= PCI_COMMAND_GUEST ; value |= val & ~ PCI_COMMAND_GUEST ;
<S2SV_ModStart> -> rx_head ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) { <S2SV_ModStart> ( skb , shinfo <S2SV_ModEnd> -> nr_frags , <S2SV_ModStart> buf_size ) ; }
<S2SV_ModStart> u8 req_id , u8 <S2SV_ModEnd> status , const <S2SV_ModStart> * desc , u8 length , u16 offset , u16 <S2SV_ModEnd> total_size ) { <S2SV_ModStart> 0 ) { unsigned <S2SV_ModStart> int copy_len ; unsigned
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> , ret ; <S2SV_ModEnd> listen_id = cm_id <S2SV_ModStart> goto err3 ; <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> ( & lock <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return 0 ; if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> if ( ud <S2SV_ModStart> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <S2SV_ModStart> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , "recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }
<S2SV_ModStart> void * buffer ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL
<S2SV_ModStart> } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
<S2SV_ModStart> : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> == 0 ) ret = <S2SV_ModEnd> key -> type <S2SV_ModStart> type -> read ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> ( & key <S2SV_ModStart> sem ) ; <S2SV_ModEnd> } error2 :
<S2SV_ModStart> ) ; } kfree ( table ) ;
<S2SV_ModStart> { p -> <S2SV_ModEnd> group_leader = current <S2SV_ModStart> } else { <S2SV_ModEnd> p -> group_leader <S2SV_ModStart> -> parent_exec_id ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else p -> exit_signal = current -> group_leader -> exit_signal ; <S2SV_ModStart> -> self_exec_id ; p -> exit_signal = args -> exit_signal ;
<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
<S2SV_ModStart> lock ) ; packet_len = min ( count , socket_packet -> icmp_len ) ; <S2SV_ModStart> -> icmp_packet , packet_len ) <S2SV_ModEnd> ; kfree (
<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
<S2SV_ModStart> slave_active_lock ) ; spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & master -> timer -> lock ) ;
<S2SV_ModStart> timer ) ; spin_lock_irq ( & slave_active_lock ) ; spin_lock ( & timer -> lock ) ; <S2SV_ModStart> open_list ) { <S2SV_ModEnd> list_move_tail ( & <S2SV_ModStart> = NULL ; list_del_init ( & slave -> ack_list ) ; list_del_init ( & slave -> active_list ) ; } spin_unlock ( & timer -> lock ) ; <S2SV_ModStart> slave_active_lock ) ; <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
<S2SV_ModStart> out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file =
<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( interp , <S2SV_ModEnd> bprm ) ; <S2SV_ModStart> return retval ; file = open_exec ( interp ) ; if ( IS_ERR ( file ) ) return PTR_ERR ( file ) ; bprm -> file = file ; retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) return retval ;
<S2SV_ModStart> ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;
<S2SV_ModStart> ; file = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> { if ( sctp_chunk_pending ( ack ) ) continue ; if (
<S2SV_ModStart> void exit_io_context ( struct task_struct * task <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; task_lock ( task <S2SV_ModEnd> ) ; ioc <S2SV_ModStart> ; ioc = task <S2SV_ModEnd> -> io_context ; <S2SV_ModStart> -> io_context ; task <S2SV_ModEnd> -> io_context = <S2SV_ModStart> ; task_unlock ( task <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) exit_io_context ( tsk
<S2SV_ModStart> ; bad_fork_cleanup_io : if <S2SV_ModEnd> ( p -> <S2SV_ModStart> p -> io_context ) exit_io_context ( p
<S2SV_ModStart> 2 ) ; if ( le16_to_cpu ( vs_param_set -> header . len ) > MWIFIEX_MAX_VSIE_LEN ) { mwifiex_dbg ( priv -> adapter , ERROR , "Invalid<S2SV_blank>param<S2SV_blank>length!\\n" ) ; break ; }
<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> != SYSEX_PATCH ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> if ( count <S2SV_ModStart> < hdr_size ) <S2SV_ModEnd> return - EINVAL <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> count -= hdr_size <S2SV_ModStart> copy_from_user ( & sysex , addr , hdr_size <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( ( unsigned ) count < ( unsigned ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> . len ) <S2SV_ModEnd> sysex . len <S2SV_ModStart> = count ; <S2SV_ModEnd> left = sysex
<S2SV_ModStart> * addr , <S2SV_ModEnd> int count , <S2SV_ModStart> copy_from_user ( & ins , addr <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( ins ) <S2SV_ModEnd> ) ) return
<S2SV_ModStart> fmt , buf + p <S2SV_ModEnd> , c ,
<S2SV_ModStart> : 32 ; if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } <S2SV_ModStart> 4 ) ; <S2SV_ModEnd> } __reg_deduce_bounds (
<S2SV_ModStart> = 0 ; lsa -> l2tp_conn_id = 0 ;
<S2SV_ModStart> struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> -> b_size = ( u64 )
<S2SV_ModStart> urb ) ; usb_free_urb ( urb ) ;
<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (
<S2SV_ModStart> SAS_TASK_STATE_DONE ) ) { <S2SV_ModStart> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }
<S2SV_ModStart> -> rbuff ; memset ( & cf , 0 , sizeof ( cf ) ) <S2SV_ModEnd> ; switch ( <S2SV_ModStart> else return ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> ; int copylen = 0 <S2SV_ModStart> goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
<S2SV_ModStart> >> PAGE_SHIFT ; if ( i + size > MAX_SKB_FRAGS ) return - EMSGSIZE ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> num_pages != size <S2SV_ModStart> num_pages != size <S2SV_ModEnd> ) { for
<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
<S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val * <S2SV_ModStart> = max_t ( int <S2SV_ModEnd> , val *
<S2SV_ModStart> kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> md ) ) { md = NULL ; goto out ; } <S2SV_ModEnd> dm_get ( md <S2SV_ModStart> dm_get ( md ) ; out : spin_unlock ( & _minor_lock
<S2SV_ModStart> retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &
<S2SV_ModStart> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart> no_id ; } <S2SV_ModEnd> list_add ( &
<S2SV_ModStart> lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart> in_use ++ ; <S2SV_ModEnd> if ( next_id
<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> -> pipe ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> -> count ; <S2SV_ModEnd> if ( size <S2SV_ModStart> size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> ( off ) left <S2SV_ModEnd> += off - <S2SV_ModStart> ; if ( left <S2SV_ModEnd> <= buf -> <S2SV_ModStart> ) break ; left <S2SV_ModEnd> -= buf -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> i -> idx <S2SV_ModStart> = idx ; <S2SV_ModEnd> i -> iov_offset <S2SV_ModStart> -> offset + left ; <S2SV_ModEnd> } i -> <S2SV_ModStart> -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> struct siginfo info = { }
<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
<S2SV_ModStart> ) break ; <S2SV_ModEnd> tp -> copied_seq <S2SV_ModStart> = seq ; } tp -> copied_seq = seq ;
<S2SV_ModStart> error ) { if ( bp && ( <S2SV_ModEnd> xfs_da_shrink_inode ( args <S2SV_ModStart> , bp ) != 0 ) <S2SV_ModEnd> ) goto out
<S2SV_ModStart> ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;
<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> from ) ) { ret = <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; goto free_kbuf ; }
<S2SV_ModStart> rc ) { struct task_struct * <S2SV_ModEnd> task = kthread_run <S2SV_ModStart> ; if ( IS_ERR ( task ) ) { <S2SV_ModStart> uwbd . task = NULL ; <S2SV_ModEnd> printk ( KERN_ERR <S2SV_ModStart> "UWB<S2SV_blank>won\'t<S2SV_blank>work\\n" ) ; } else { rc -> uwbd . task = task ; <S2SV_ModEnd> rc -> uwbd <S2SV_ModStart> pid ; } }
<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> & RTM_F_FIB_MATCH ) { if ( ! res . fi ) { err = fib_props [ res . type ] . error ; if ( ! err ) err = - EHOSTUNREACH ; <S2SV_ModEnd> goto errout_free ; <S2SV_ModStart> goto errout_free ; } err = fib_dump_info ( skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq , RTM_NEWROUTE , table_id , rt -> rt_type , res . prefix , res . prefixlen , fl4 . flowi4_tos , res . fi , 0 ) ; } else { err = rt_fill_info ( net , dst , src , table_id , & fl4 , skb , NETLINK_CB ( in_skb ) . portid , nlh -> nlmsg_seq ) ; } if ( err < 0 ) goto errout_free ;
<S2SV_ModStart> ( used_address && msg_sys -> msg_name && <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name , <S2SV_ModStart> -> msg_namelen ; if ( msg_sys -> msg_name ) <S2SV_ModStart> -> name , msg_sys <S2SV_ModEnd> -> msg_name ,
<S2SV_ModStart> 1 ) { struct sockaddr * addr_p = ( struct sockaddr * ) & addr ; socklen_t addr_l = sizeof ( addr ) ; <S2SV_ModStart> ; len = recvfrom <S2SV_ModEnd> ( fd , <S2SV_ModStart> ) , 0 , addr_p , & addr_l <S2SV_ModStart> len < 0 || addr . nl_pid <S2SV_ModStart> ( LOG_ERR , "recvfrom<S2SV_blank>failed;<S2SV_blank>pid:%u<S2SV_blank>error:%d<S2SV_blank>%s" , addr . nl_pid , errno , strerror ( errno ) <S2SV_ModEnd> ) ; close
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> sk -> sk_family <S2SV_ModEnd> ; struct sk_buff <S2SV_ModStart> goto out ; <S2SV_ModEnd> if ( flags <S2SV_ModStart> AF_INET ) { struct sockaddr_in * <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_ModStart> skb ) ; <S2SV_ModEnd> struct sockaddr_in6 * <S2SV_ModStart> struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) -> iif ) ; * addr_len = sizeof ( * sin6
<S2SV_ModStart> ; bool slow <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ; } * addr_len = sizeof ( * sin6 ) ;
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; skb = <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
<S2SV_ModStart> ) goto out_nofree <S2SV_ModEnd> ; skb = <S2SV_ModStart> != NULL ) { <S2SV_ModStart> , sizeof ( sa ) ) ; * addr_len = sizeof ( sa ) ; } <S2SV_ModEnd> out : skb_free_datagram
<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> copy_from_user ( buf + sizeof ( hdr ) <S2SV_ModStart> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> USB_DT_INTERFACE_ASSOCIATION ) { struct usb_interface_assoc_descriptor * d ; d = ( struct usb_interface_assoc_descriptor * ) header ; if ( d -> bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE ) { dev_warn ( ddev , "config<S2SV_blank>%d<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>interface<S2SV_blank>association<S2SV_blank>descriptor<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>skipping\\n" , cfgno , d -> bLength ) ; continue ; } <S2SV_ModStart> iad_num ] = d <S2SV_ModEnd> ; iad_num ++
<S2SV_ModStart> u64 ) len - s
<S2SV_ModStart> { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> failed_mount3 ; } # ifdef CONFIG_EXT2_FS_XATTR sbi -> s_mb_cache = ext2_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext2_msg ( sb , KERN_ERR , "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache" ) ; goto failed_mount3 ; } # endif <S2SV_ModStart> ; failed_mount3 : if ( sbi -> s_mb_cache ) ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ;
<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ) ; struct mb2_cache_entry * ce ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModEnd> ; if ( <S2SV_ModStart> : ce = mb2_cache_entry_find_first ( ext2_mb_cache , hash ) ; while ( ce ) { struct buffer_head * bh ; bh = sb_bread ( <S2SV_ModEnd> inode -> i_sb <S2SV_ModStart> inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , "ext2_xattr_cache_find" , "inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%ld<S2SV_blank>read<S2SV_blank>error" , inode -> i_ino , ( unsigned long ) ce -> e_block ) ; } else { lock_buffer ( bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { mb2_cache_entry_put ( ext2_mb_cache , ce ) ; unlock_buffer ( bh ) ; brelse ( bh ) ; <S2SV_ModEnd> goto again ; <S2SV_ModStart> goto again ; } else if ( le32_to_cpu ( HDR ( bh ) -> h_refcount ) > EXT2_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , "block<S2SV_blank>%ld<S2SV_blank>refcount<S2SV_blank>%d>%d" , <S2SV_ModEnd> ( unsigned long <S2SV_ModStart> ce -> e_block <S2SV_ModEnd> , le32_to_cpu ( <S2SV_ModStart> ) ) ; mb2_cache_entry_touch ( ext2_mb_cache , ce ) ; mb2_cache_entry_put ( ext2_mb_cache , <S2SV_ModEnd> ce ) ; <S2SV_ModStart> } ce = mb2_cache_entry_find_next ( ext2_mb_cache , ce <S2SV_ModEnd> ) ; }
<S2SV_ModStart> int ext2_xattr_cache_insert ( struct mb2_cache * cache , <S2SV_ModStart> h_hash ) ; <S2SV_ModEnd> int error ; <S2SV_ModStart> int error ; error = mb2_cache_entry_create ( cache , GFP_NOFS , hash <S2SV_ModEnd> , bh -> <S2SV_ModStart> bh -> b_blocknr <S2SV_ModEnd> ) ; if <S2SV_ModStart> error ) { <S2SV_ModEnd> if ( error <S2SV_ModStart> } } else <S2SV_ModEnd> ea_bdebug ( bh <S2SV_ModStart> ( bh , "inserting<S2SV_blank>[%x]" <S2SV_ModEnd> , ( int <S2SV_ModStart> int ) hash ) ; <S2SV_ModEnd> return error ;
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> down_write ( & <S2SV_ModStart> cleanup ; } <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( EXT2_SB ( inode -> i_sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; ext2_free_blocks <S2SV_ModStart> , - 1 <S2SV_ModEnd> ) ; ea_bdebug
<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,
<S2SV_ModStart> ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,
<S2SV_ModStart> int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( sb ) -> s_mb_cache ; <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ; ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> new_bh ) { <S2SV_ModEnd> lock_buffer ( old_bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( HDR ( old_bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext2_mb_cache , hash , old_bh -> b_blocknr <S2SV_ModEnd> ) ; ea_bdebug <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> dquot_free_block_nodirty ( inode
<S2SV_ModStart> header ) { <S2SV_ModEnd> lock_buffer ( bh <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_ModStart> "modifying<S2SV_blank>in-place" ) ; mb2_cache_entry_delete_block ( EXT2_SB ( sb ) -> s_mb_cache , hash , bh -> b_blocknr <S2SV_ModEnd> ) ; } <S2SV_ModStart> { int offset <S2SV_ModEnd> ; unlock_buffer (
<S2SV_ModStart> ; if ( l < 10 || l > 20 ) return - 1 ; if (
<S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ; <S2SV_ModStart> 1 ) ; if ( len < 0 ) return 0 ;
<S2SV_ModStart> & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModStart> AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; <S2SV_ModEnd> memcpy ( & <S2SV_ModStart> AX25_ADDR_LEN ) ; }
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> [ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( "%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( "NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
<S2SV_ModStart> , rqstp , res <S2SV_ModEnd> ) ; out
<S2SV_ModStart> + op_decode_hdr_maxsz + <S2SV_ModEnd> 1 ; encode_getattr_two <S2SV_ModStart> acl_len ) ; xdr_set_scratch_buffer ( xdr , page_address ( args -> acl_scratch ) , PAGE_SIZE ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void _copy_from_pages (
<S2SV_ModStart> commands ) ; <S2SV_ModEnd> ch_end = ( <S2SV_ModStart> commands ) ; if ( SCTP_CID_SHUTDOWN_ACK == ch -> type ) ootb_shut_ack = 1 ; if ( SCTP_CID_ABORT == ch -> type ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; if ( SCTP_CID_COOKIE_ACK == ch -> type ) ootb_cookie_ack = 1 ; if ( SCTP_CID_ERROR == ch -> type ) { sctp_walk_errors ( err , ch ) { if ( SCTP_ERROR_STALE_COOKIE == err -> cause ) { ootb_cookie_ack = 1 ; break ; } } }
<S2SV_ModStart> i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>control<S2SV_blank>header\\n" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , "too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , "skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , "invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"
<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , "too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy" "<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (
<S2SV_ModStart> = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! index_key .
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; if (
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )
<S2SV_ModStart> br_mdb_entry e ; memset ( & e , 0 , sizeof ( e ) ) ;
<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
<S2SV_ModStart> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;
<S2SV_ModStart> args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> "ipc_flood_duration_ms" ) ) { ret = <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; goto out ; }
<S2SV_ModStart> -> status ; int length = urb -> actual_length ; <S2SV_ModStart> = status ; if ( length + desc -> length > desc -> wMaxCommand ) { set_bit ( WDM_OVERFLOW , & desc -> flags ) ; } else { if ( ! test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { <S2SV_ModEnd> memmove ( desc <S2SV_ModStart> -> inbuf , length ) ; desc -> length += length ; <S2SV_ModStart> desc -> reslength = length ; } } <S2SV_ModEnd> skip_error : wake_up
<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
<S2SV_ModStart> env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> env ) ; env -> insn_aux_data [ insn_idx ] . seen = true ; <S2SV_ModStart> insn_idx ++ ; env -> insn_aux_data [ insn_idx ] . seen = true ;
<S2SV_ModStart> goto err ; err = - EINVAL ; if ( size != sizeof ( outarg ) + <S2SV_ModEnd> outarg . namelen <S2SV_ModStart> + 1 ) goto err ; name . name = buf ; name . len = outarg . namelen ; err = fuse_copy_one ( cs , buf , outarg . namelen + 1 )
<S2SV_ModStart> ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
<S2SV_ModStart> ( ret || ! cm_id -> device ||
<S2SV_ModStart> end , void * <S2SV_ModStart> len ) ; if ( * obuf == NULL ) { * obuf = kmalloc ( len , GFP_NOFS ) ; if ( ! * obuf ) return - ENOMEM ; olen = len ; } <S2SV_ModStart> & head_len , *
<S2SV_ModStart> = buf ; <S2SV_ModEnd> u8 reply_struct_v ; <S2SV_ModStart> ; int ret <S2SV_ModEnd> ; ceph_decode_8_safe ( <S2SV_ModStart> p , end <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( ret ) return ret ; } return 0 <S2SV_ModEnd> ; bad : <S2SV_ModStart> ; bad : return <S2SV_ModEnd> - EINVAL ; <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; void * preply = & reply ; void * <S2SV_ModStart> end , & preply <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> void * end <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; void * dbuf = NULL ; void * <S2SV_ModStart> struct ceph_crypto_key old_key ; void * ticket_buf = NULL <S2SV_ModStart> , end , & dbuf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> bad ) ; if ( is_enc ) { dout ( "<S2SV_blank>encrypted<S2SV_blank>ticket\\n" ) ; dlen = ceph_x_decrypt ( & old_key , p , end , & ticket_buf , 0 <S2SV_ModEnd> ) ; if <S2SV_ModStart> out ; } tp = ticket_buf ; <S2SV_ModStart> bad ) ; ticket_buf = kmalloc ( dlen , GFP_NOFS ) ; if ( ! ticket_buf ) { ret = - ENOMEM ; goto out ; } tp = ticket_buf ; <S2SV_ModStart> ; out : kfree ( ticket_buf ) ; kfree ( dbuf ) ;
<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;
<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
<S2SV_ModStart> -> ctx -> task <S2SV_ModEnd> != ctx -> <S2SV_ModStart> != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context
<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
<S2SV_ModStart> [ 1 ] ; void * data ; int ret <S2SV_ModStart> - EPIPE ; data = kmemdup ( buf , count , GFP_ATOMIC ) ; if ( ! data ) return - ENOMEM ; <S2SV_ModStart> ( sg , data <S2SV_ModEnd> , count ) <S2SV_ModStart> count ) ; ret = <S2SV_ModEnd> __send_to_port ( port <S2SV_ModStart> , count , data <S2SV_ModEnd> , false ) <S2SV_ModStart> false ) ; kfree ( data ) ; return ret ;
<S2SV_ModStart> ; __be32 * pdata ; if ( datalen != 4 ) return - EINVAL ;
<S2SV_ModStart> { if ( datalen != 1 ) return - EINVAL ; if (
<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> < 0 ) { ret = chg ; goto out_err ; } <S2SV_ModEnd> if ( hugepage_subpool_get_pages <S2SV_ModStart> chg ) ) { ret = <S2SV_ModEnd> - ENOSPC ; <S2SV_ModStart> - ENOSPC ; goto out_err ; } <S2SV_ModStart> chg ) ; goto out_err <S2SV_ModEnd> ; } if <S2SV_ModStart> return 0 ; out_err : resv_map_put ( vma ) ; return ret ;
<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags (
<S2SV_ModStart> / 9 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n" , size ) ; return 0 ; }
<S2SV_ModStart> * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
<S2SV_ModStart> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> ; } if
<S2SV_ModStart> ; long timeo ; msg -> msg_namelen = 0
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> ( err ) goto free_data <S2SV_ModEnd> ; if (
<S2SV_ModStart> , sizeof ( *
<S2SV_ModStart> unlikely ( len + ring -> frameoffset
<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
<S2SV_ModStart> ( err ) { kvfree ( in ) ; <S2SV_ModStart> goto err_cqwq ; }
<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,
<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; struct gs_host_config * hconf <S2SV_ModEnd> ; struct gs_device_config <S2SV_ModStart> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> ; rc = <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> hconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; kfree ( hconf ) ; <S2SV_ModStart> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> dconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> icount + 1 <S2SV_ModStart> GS_MAX_INTF ) ; kfree ( dconf ) ; <S2SV_ModStart> ! dev ) { kfree ( dconf ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> , intf , <S2SV_ModEnd> dconf ) ; <S2SV_ModStart> ; kfree ( dconf ) ; kfree ( <S2SV_ModStart> dev ; } kfree ( dconf ) ;
<S2SV_ModStart> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( <S2SV_ModEnd> ! handle )
<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =
<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; <S2SV_ModStart> ( csum , skb_checksum ( skb , tend_off , <S2SV_ModEnd> offset , 0 <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> ; suppress_route : if ( ! ( arg -> flags & FIB_LOOKUP_NOREF ) )
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> tmp = *
<S2SV_ModStart> NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL <S2SV_ModStart> -> sign ) <S2SV_ModEnd> flags |= NTLMSSP_NEGOTIATE_SIGN <S2SV_ModStart> |= NTLMSSP_NEGOTIATE_KEY_XCH ; <S2SV_ModEnd> sec_blob -> NegotiateFlags
<S2SV_ModStart> -> server -> <S2SV_ModEnd> ops -> generate_signingkey <S2SV_ModStart> ( ses ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> srv_mutex ) ; return rc <S2SV_ModEnd> ; } } <S2SV_ModStart> GlobalMid_Lock ) ; <S2SV_ModEnd> return rc ;
<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> : if ( rec >= f -> num ) { ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , f -> num ) ; return false ; } if (
<S2SV_ModStart> ; } } if ( * old_keycode <= KEY_MAX ) { <S2SV_ModStart> keybit ) ; for ( i = 0 ; i < dev -> keycodemax ; i ++ ) { if ( input_fetch_keycode ( dev , i ) == * old_keycode ) { __set_bit ( * old_keycode <S2SV_ModEnd> , dev -> <S2SV_ModStart> keybit ) ; break ; } } } __set_bit ( ke -> keycode , dev -> keybit ) ; return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> keybit ) ; if ( old_keycode > KEY_MAX ) { dev_warn ( dev -> dev . parent ? : & dev -> dev , "%s:<S2SV_blank>got<S2SV_blank>too<S2SV_blank>big<S2SV_blank>old<S2SV_blank>keycode<S2SV_blank>%#x\\n" , __func__ , old_keycode ) ; } else
<S2SV_ModStart> & multicast_idr , NULL <S2SV_ModEnd> , 0 ,
<S2SV_ModStart> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;
<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
<S2SV_ModStart> net != c_net <S2SV_ModEnd> ) continue ;
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR
<S2SV_ModStart> int err ; int npages = ( data_len + ( PAGE_SIZE - 1 ) ) >> PAGE_SHIFT ; err = - EMSGSIZE ; if ( npages > MAX_SKB_FRAGS ) goto failure ; <S2SV_ModStart> ) { int <S2SV_ModEnd> i ; if <S2SV_ModStart> data_len ) break <S2SV_ModEnd> ; skb ->
<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }
<S2SV_ModStart> mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
<S2SV_ModStart> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }
<S2SV_ModStart> ) ) { bool disconnect ; <S2SV_ModStart> |= MNT_SYNC_UMOUNT ; disconnect = ! IS_MNT_LOCKED_AND_LAZY ( p ) ; <S2SV_ModStart> -> mnt , disconnect ? & unmounted : NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 ) ; if ( ! disconnect ) { list_add_tail ( & p -> mnt_child , & p -> mnt_parent -> mnt_mounts ) ; } else { <S2SV_ModStart> ) ; } }
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL
<S2SV_ModStart> er_list ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , key , sizeof ( extra_response -> key ) ) ; strlcpy <S2SV_ModEnd> ( extra_response -> <S2SV_ModStart> , NOTUNDERSTOOD , sizeof ( extra_response -> value ) <S2SV_ModEnd> ) ; list_add_tail
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> kfree ( tmpbuf
<S2SV_ModStart> id ; goto errout_free <S2SV_ModEnd> ; } err <S2SV_ModStart> id ) ; errout_free :
<S2SV_ModStart> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;
<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> -> group_leader ; switch <S2SV_ModEnd> ( event -> <S2SV_ModStart> event -> sigev_notify ) { case SIGEV_SIGNAL | SIGEV_THREAD_ID : <S2SV_ModEnd> rtn = find_task_by_vpid <S2SV_ModStart> -> sigev_notify_thread_id ) ; if ( ! rtn <S2SV_ModEnd> || ! same_thread_group <S2SV_ModStart> , current ) <S2SV_ModEnd> ) return NULL <S2SV_ModStart> return NULL ; case SIGEV_SIGNAL : case SIGEV_THREAD : if <S2SV_ModEnd> ( event -> <S2SV_ModStart> sigev_signo <= 0 || <S2SV_ModEnd> event -> sigev_signo <S2SV_ModStart> > SIGRTMAX ) <S2SV_ModEnd> return NULL ; <S2SV_ModStart> return NULL ; case SIGEV_NONE : <S2SV_ModStart> rtn ) ; default : return NULL ; }
<S2SV_ModStart> long tmp = <S2SV_ModEnd> atomic_long_cmpxchg ( & <S2SV_ModStart> new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> msg_name ; if ( sin ) { <S2SV_ModStart> sin ) ; } <S2SV_ModStart> -> msg_name ; if ( sin6 ) { <S2SV_ModStart> sin6 ) ; }
<S2SV_ModStart> dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> cd -> fd
<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
<S2SV_ModStart> , spi ) > 0 ? : 0
<S2SV_ModStart> ( mp ) ) ) return __this_address ; if ( be32_to_cpu ( agf -> agf_length ) > mp -> m_sb . sb_dblocks ) return __this_address ; if ( be32_to_cpu ( agf -> agf_freeblks ) < be32_to_cpu ( agf -> agf_longest ) || be32_to_cpu ( agf -> agf_freeblks ) > be32_to_cpu ( agf -> agf_length <S2SV_ModStart> ; if ( xfs_sb_version_hasrmapbt ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_rmap_blocks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( <S2SV_ModStart> agf_btreeblks ) > be32_to_cpu ( agf -> agf_length ) ) return __this_address ; if ( xfs_sb_version_hasreflink ( & mp -> m_sb ) && be32_to_cpu ( agf -> agf_refcount_blocks ) >
<S2SV_ModStart> path . dentry ; kuid_t dir_uid = dir -> d_inode -> i_uid ; umode_t dir_mode = dir -> d_inode -> i_mode <S2SV_ModStart> = may_create_in_sticky ( dir_mode , dir_uid <S2SV_ModEnd> , d_backing_inode (
<S2SV_ModStart> int may_create_in_sticky ( umode_t dir_mode , kuid_t dir_uid <S2SV_ModEnd> , struct inode <S2SV_ModStart> ( ! ( dir_mode <S2SV_ModEnd> & S_ISVTX ) <S2SV_ModStart> -> i_uid , dir_uid <S2SV_ModEnd> ) || uid_eq <S2SV_ModStart> ( likely ( dir_mode <S2SV_ModEnd> & 0002 ) <S2SV_ModStart> ) || ( dir_mode <S2SV_ModEnd> & 0020 &&
<S2SV_ModStart> idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
<S2SV_ModStart> fsnotify_group * group <S2SV_ModEnd> ; int ret <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> group = inotify_new_group <S2SV_ModStart> = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; <S2SV_ModStart> group ) ) return <S2SV_ModEnd> PTR_ERR ( group <S2SV_ModStart> PTR_ERR ( group <S2SV_ModEnd> ) ; ret <S2SV_ModStart> if ( ret < 0 ) <S2SV_ModEnd> fsnotify_put_group ( group <S2SV_ModStart> fsnotify_put_group ( group <S2SV_ModEnd> ) ; return
<S2SV_ModStart> * inotify_new_group ( <S2SV_ModEnd> unsigned int max_events <S2SV_ModStart> -> inotify_data . fa = NULL <S2SV_ModEnd> ; group -> <S2SV_ModStart> -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } <S2SV_ModEnd> return group ;
<S2SV_ModStart> -> private_data ; <S2SV_ModEnd> pr_debug ( "%s:<S2SV_blank>group=%p\\n" <S2SV_ModStart> group ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ; kfree ( card -> evtbd_ring_vbase ) ; <S2SV_ModStart> - 1 ; }
<S2SV_ModStart> ) usb_hdr ; u16 offs , total_size ; u8 data_len ; if ( elt -> length < sizeof ( struct oz_get_desc_rsp ) - 1 ) break ; <S2SV_ModEnd> data_len = elt <S2SV_ModStart> -> length - ( <S2SV_ModStart> ( struct oz_get_desc_rsp ) - 1 ) ; offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , "USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp <S2SV_ModStart> ) + 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> snd_timer_read ) ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ; schedule ( ) ; mutex_lock ( & tu -> ioctl_lock <S2SV_ModEnd> ) ; spin_lock_irq <S2SV_ModStart> qlock ) ; <S2SV_ModEnd> if ( tu <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> spin_lock_irq ( & <S2SV_ModStart> qlock ) ; mutex_unlock ( & tu -> ioctl_lock ) ;
<S2SV_ModStart> , bool in_task_switch , struct desc_struct * desc <S2SV_ModStart> seg ) ; if ( desc ) * desc = seg_desc ;
<S2SV_ModStart> int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; int cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL <S2SV_ModEnd> , VCPU_SREG_CS ) <S2SV_ModStart> , VCPU_SREG_CS ) <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> 2 ) ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE <S2SV_ModEnd> ) return X86EMUL_CONTINUE <S2SV_ModStart> return X86EMUL_CONTINUE ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; return rc ; fail : ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> unsigned short sel , old_sel ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_sel , & old_desc , NULL , VCPU_SREG_CS ) <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> sel , VCPU_SREG_CS , cpl , false , & new_desc <S2SV_ModStart> return rc ; rc = assign_eip_far ( ctxt <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_sel , & old_desc , 0 , VCPU_SREG_CS <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return rc ; } return rc <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ; unsigned long eip , cs ; u16 old_cs <S2SV_ModEnd> ; int cpl <S2SV_ModStart> ctxt ) ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; <S2SV_ModStart> ctxt , & eip <S2SV_ModEnd> , ctxt -> <S2SV_ModStart> ) return rc <S2SV_ModEnd> ; rc = <S2SV_ModStart> ; rc = __load_segment_descriptor <S2SV_ModEnd> ( ctxt , <S2SV_ModStart> cs , VCPU_SREG_CS , 0 , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , eip , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) { WARN_ON ( ! ctxt -> mode != X86EMUL_MODE_PROT64 ) ; ops -> set_segment ( ctxt , old_cs , & old_desc , 0 , VCPU_SREG_CS ) ; } <S2SV_ModEnd> return rc ;
<S2SV_ModStart> cpl , false , NULL
<S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
<S2SV_ModStart> ) { struct packet_rollover * rollover = NULL ; struct <S2SV_ModStart> EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; <S2SV_ModStart> -> running ) goto out ; err = - EALREADY <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> fanout ) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) { err = - ENOMEM ; <S2SV_ModEnd> rollover = kzalloc <S2SV_ModStart> sizeof ( * <S2SV_ModEnd> rollover ) , <S2SV_ModStart> if ( ! rollover ) goto out <S2SV_ModEnd> ; atomic_long_set ( <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_huge <S2SV_ModStart> atomic_long_set ( & <S2SV_ModEnd> rollover -> num_failed <S2SV_ModStart> 0 ) ; po -> rollover = rollover ; } <S2SV_ModEnd> match = NULL <S2SV_ModStart> } out : if ( err && rollover ) { kfree ( rollover ) ; po -> rollover = NULL ; } <S2SV_ModStart> fanout_mutex ) ; <S2SV_ModEnd> return err ;
<S2SV_ModStart> * f ; mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> ; if ( f ) { <S2SV_ModEnd> po -> fanout <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( po <S2SV_ModStart> ) ; } mutex_unlock ( & fanout_mutex ) ; }
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> , len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;
<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
<S2SV_ModStart> ) ; struct mnt_namespace * ns = dest_mnt -> mnt_ns ; struct <S2SV_ModStart> ; if ( ! parent_path ) { err = count_mounts ( ns , source_mnt <S2SV_ModEnd> ) ; if <S2SV_ModStart> goto out ; } if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_ModStart> mnt_hash ) ; child -> mnt_parent -> mnt_ns -> pending_mounts = 0 ; <S2SV_ModStart> ; out : ns -> pending_mounts = 0 ;
<S2SV_ModStart> prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
<S2SV_ModStart> = new_ns ; new_ns -> mounts ++ ;
<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
<S2SV_ModStart> ) ) { struct mnt_namespace * ns ; <S2SV_ModStart> mnt_list ) ; ns = p -> mnt_ns ; if ( ns ) { ns -> mounts -- ; __touch_mnt_namespace ( ns ) ; } <S2SV_ModEnd> p -> mnt_ns
<S2SV_ModStart> ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> if ( ! list_empty ( & asoc -> asocs ) <S2SV_ModEnd> ) { list_del
<S2SV_ModStart> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )
<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n" , dst ) ; return ret ; }
<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :
<S2SV_ModStart> - EOPNOTSUPP ; mutex_lock ( & speakup_tty_mutex ) ; if ( speakup_tty ) { mutex_unlock ( & speakup_tty_mutex ) ; return - EBUSY ; } <S2SV_ModStart> ! ldisc_data ) { speakup_tty = NULL ; mutex_unlock ( & speakup_tty_mutex ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> = ldisc_data ; mutex_unlock ( & speakup_tty_mutex ) ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> ext4_group_t flex_group ; unsigned <S2SV_ModStart> -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 1 || sbi -> s_log_groups_per_flex > 31 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } <S2SV_ModStart> -> s_log_groups_per_flex ; <S2SV_ModEnd> flex_group_count = (
<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
<S2SV_ModStart> ; err : <S2SV_ModEnd> free_percpu ( ctx
<S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>prepare<S2SV_blank>beacon\\n" ) ; dev_kfree_skb ( skb ) ;
<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> || ns_capable ( task_active_pid_ns ( current ) <S2SV_ModEnd> -> user_ns ,
<S2SV_ModStart> = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> pcrypt_free ( struct aead_instance <S2SV_ModEnd> * inst ) <S2SV_ModStart> * ctx = aead_instance_ctx <S2SV_ModEnd> ( inst )
<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
<S2SV_ModStart> ; if ( unlikely ( headcount > UIO_MAXIOV ) ) { <S2SV_ModEnd> msg . msg_iovlen <S2SV_ModStart> . msg_iovlen = 1 <S2SV_ModEnd> ; err = <S2SV_ModStart> & msg , 1 <S2SV_ModEnd> , MSG_DONTWAIT | <S2SV_ModStart> MSG_TRUNC ) ; pr_debug ( "Discarded<S2SV_blank>rx<S2SV_blank>packet:<S2SV_blank>len<S2SV_blank>%zd\\n" , sock_len ) ; continue ; } if ( ! headcount ) { if ( unlikely ( vhost_enable_notify ( & net -> dev , vq ) ) ) { vhost_disable_notify ( & net -> dev , vq ) ; continue ; } break ; } if ( unlikely ( ( vhost_hlen ) ) ) move_iovec_hdr ( vq -> iov , nvq -> hdr , vhost_hlen , in ) ; else copy_iovec_hdr ( vq -> iov , nvq -> hdr , sock_hlen , in ) ; msg . msg_iovlen = in ; err = sock -> ops -> recvmsg ( NULL , sock , & msg , sock_len , MSG_DONTWAIT | MSG_TRUNC ) ;
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> ctxt -> rip_relative && likely ( ctxt -> memopp )
<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; cmd = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> info . si_code != SI_QUEUE ) { WARN_ON_ONCE ( info . si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> info -> si_code != SI_QUEUE ) { WARN_ON_ONCE ( info -> si_code < 0 ) ; <S2SV_ModEnd> return - EPERM <S2SV_ModStart> - EPERM ; }
<S2SV_ModStart> ; if ( ( int ) <S2SV_ModStart> <= 0 || ( int ) <S2SV_ModStart> g -> head <= 0 || ( int ) ( g -> sect * g -> head )
<S2SV_ModStart> ( ( data ^ PSW_USER_BITS ) <S2SV_ModStart> ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return -
<S2SV_ModStart> i_ext ) { bool ret = __f2fs_init_extent_tree ( inode , i_ext <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! F2FS_I ( inode ) -> extent_tree ) set_inode_flag ( inode , FI_NO_EXTENT <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> PCI_DMA_FROMDEVICE ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> - 1 ; }
<S2SV_ModStart> * cred , fmode_t <S2SV_ModEnd> mode ) {
<S2SV_ModStart> * deleg_stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , open_stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock
<S2SV_ModStart> * path , fmode_t fmode , <S2SV_ModStart> -> d_inode , fmode <S2SV_ModEnd> ) ; status <S2SV_ModStart> path , sp , fmode
<S2SV_ModStart> * opendata ; fmode_t <S2SV_ModEnd> delegation_type = 0
<S2SV_ModStart> * state , fmode_t mode , int open_mode <S2SV_ModEnd> ) { int <S2SV_ModStart> = 0 ; if ( open_mode & O_EXCL ) goto out ; <S2SV_ModStart> FMODE_READ | FMODE_WRITE <S2SV_ModEnd> ) ) { <S2SV_ModStart> 0 ; } out :
<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) return 0
<S2SV_ModStart> dentry * res ; fmode_t fmode = nd -> intent . open . flags & ( FMODE_READ | FMODE_WRITE | FMODE_EXEC ) <S2SV_ModStart> & path , fmode , <S2SV_ModStart> path , state , fmode
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> == 0 )
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = FMODE_READ ; <S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = FMODE_WRITE ;
<S2SV_ModStart> -> arg . fmode <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> path * path , fmode_t fmode <S2SV_ModStart> dir , path , fmode
<S2SV_ModStart> nfs4_state * state , fmode_t fmode <S2SV_ModStart> ; if ( fmode <S2SV_ModEnd> & FMODE_EXEC ) <S2SV_ModStart> , state , fmode & ( FMODE_READ | FMODE_WRITE ) <S2SV_ModEnd> ) ; return
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
<S2SV_ModStart> -> o_arg . fmode , data -> o_arg . open_flags <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> * opendata , fmode_t fmode <S2SV_ModEnd> , struct nfs4_state <S2SV_ModStart> . open_flags = 0 ; opendata -> o_arg . fmode = fmode <S2SV_ModEnd> ; memset ( <S2SV_ModStart> , newstate , fmode <S2SV_ModEnd> ) ; *
<S2SV_ModStart> state -> owner , 0
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; out_free
<S2SV_ModStart> * state ; fmode_t fmode = openflags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , & path , fmode <S2SV_ModStart> path , state , fmode <S2SV_ModStart> , state , fmode <S2SV_ModEnd> ) ; out_drop
<S2SV_ModStart> nfs4_state_owner * sp , fmode_t fmode <S2SV_ModStart> open_flags = flags ; p -> o_arg . fmode = fmode & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModEnd> p -> o_arg
<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; iput
<S2SV_ModStart> * cred ; fmode_t fmode = flags & ( FMODE_READ | FMODE_WRITE ) ; <S2SV_ModStart> , & path , fmode <S2SV_ModStart> path , state , fmode <S2SV_ModStart> , state , fmode <S2SV_ModEnd> ) ; out_putcred
<S2SV_ModStart> * inode , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> -> type & fmode ) == fmode <S2SV_ModEnd> ) { rcu_read_unlock
<S2SV_ModStart> . open_flags & O_EXCL ; fmode_t fmode = opendata -> o_arg . fmode <S2SV_ModEnd> ; nfs4_stateid stateid <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> ( delegation , fmode <S2SV_ModEnd> ) ) { <S2SV_ModStart> & stateid , fmode <S2SV_ModEnd> ) ) goto
<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { write_seqlock <S2SV_ModStart> , stateid , fmode <S2SV_ModEnd> ) ; write_sequnlock
<S2SV_ModStart> * stateid , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> ) { case
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( fmode <S2SV_ModEnd> ) { case <S2SV_ModStart> -> state | fmode <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> = 0 ; fmode <S2SV_ModEnd> &= ( FMODE_READ <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) goto no_delegation_unlock <S2SV_ModStart> -> stateid , fmode <S2SV_ModEnd> ) ; ret <S2SV_ModStart> , NULL , fmode <S2SV_ModEnd> ) ; ret
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> , int wait <S2SV_ModStart> = 0 ; fmode_t <S2SV_ModEnd> newstate ; atomic_inc <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 0 )
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 1 )
<S2SV_ModStart> * state , fmode_t fmode <S2SV_ModEnd> ) { if <S2SV_ModStart> -> state == fmode <S2SV_ModEnd> ) return ; <S2SV_ModStart> if ( ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> { if ( fmode <S2SV_ModEnd> & FMODE_WRITE ) <S2SV_ModStart> -> state = fmode <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; return
<S2SV_ModStart> , arg -> fmode <S2SV_ModEnd> ) ; RESERVE_SPACE
<S2SV_ModStart> * xdr , fmode_t fmode <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> ; switch ( fmode <S2SV_ModEnd> & ( FMODE_READ <S2SV_ModStart> ; default : WRITE32 ( 0 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;
<S2SV_ModStart> sk ) ; struct skcipher_tfm * tfm = private ; struct crypto_skcipher * skcipher = tfm -> skcipher ; <S2SV_ModStart> + crypto_skcipher_reqsize ( skcipher ) ; if ( ! tfm -> has_key ) return - ENOKEY <S2SV_ModEnd> ; ctx = <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher <S2SV_ModEnd> ) , GFP_KERNEL <S2SV_ModStart> , crypto_skcipher_ivsize ( skcipher ) ) ; INIT_LIST_HEAD ( & ctx -> tsgl ) ; ctx -> len = len ; ctx -> used = 0 ; ctx -> more = 0 ; ctx -> merge = 0 ; ctx -> enc = 0 ; atomic_set ( & ctx -> inflight , 0 ) ; af_alg_init_completion ( & ctx -> completion ) ; ask -> private <S2SV_ModEnd> = ctx ; <S2SV_ModStart> -> req , skcipher <S2SV_ModEnd> ) ; skcipher_request_set_callback
<S2SV_ModStart> mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = <S2SV_ModEnd> crypto_alloc_skcipher ( name <S2SV_ModStart> mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ;
<S2SV_ModStart> private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; }
<S2SV_ModStart> keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> , key , <S2SV_ModStart> keylen ) ; tfm -> has_key = ! err ; return err ;
<S2SV_ModStart> oldubufs ) { vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( oldubufs ) <S2SV_ModStart> ( ubufs ) vhost_net_ubuf_put_wait_and_free <S2SV_ModEnd> ( ubufs )
<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool get_desc ( <S2SV_ModStart> struct desc_struct * out , <S2SV_ModEnd> unsigned short sel <S2SV_ModStart> SEGMENT_LDT ) { bool success = false <S2SV_ModEnd> ; struct ldt_struct <S2SV_ModStart> -> nr_entries ) { * out = <S2SV_ModEnd> ldt -> entries <S2SV_ModStart> sel ] ; success = true ; } <S2SV_ModStart> ) ; return success <S2SV_ModEnd> ; } # <S2SV_ModStart> size ) return false ; * out = * <S2SV_ModEnd> ( struct desc_struct <S2SV_ModStart> desc_base ) ; return true ;
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> return sel ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> ! ( desc . <S2SV_ModEnd> type & BIT <S2SV_ModStart> ( ( desc . <S2SV_ModEnd> l << 1 <S2SV_ModStart> ) | desc . <S2SV_ModEnd> d ) {
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> - 1L ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> return get_desc_base ( &
<S2SV_ModStart> inode , struct ext4_map_blocks * map , struct <S2SV_ModStart> ext4_extent * ex ; ext4_lblk_t ee_block ; unsigned int ee_len <S2SV_ModStart> . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; <S2SV_ModStart> long long ) ee_block , ee_len ) ; if ( ee_block != map -> m_lblk || ee_len > map -> m_len ) { err = ext4_split_unwritten_extents ( handle , inode , map , path , EXT4_GET_BLOCKS_CONVERT ) ; if ( err < 0 ) goto out ; ext4_ext_drop_refs ( path ) ; path = ext4_ext_find_extent ( inode , map -> m_lblk , path ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; goto out ; } depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; } <S2SV_ModEnd> err = ext4_ext_get_access
<S2SV_ModStart> , inode , map ,
<S2SV_ModStart> split_flag & EXT4_EXT_MAY_ZEROOUT <S2SV_ModEnd> ; flags1 = <S2SV_ModStart> | EXT4_EXT_MARK_UNINIT2 ; if ( split_flag & EXT4_EXT_DATA_VALID2 ) split_flag1 |= EXT4_EXT_DATA_VALID1 ; <S2SV_ModStart> = split_flag & ( EXT4_EXT_MAY_ZEROOUT | EXT4_EXT_DATA_VALID2 ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> err = 0 ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> ) ) { if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else
<S2SV_ModStart> |= EXT4_EXT_MARK_UNINIT2 ; if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;
<S2SV_ModStart> segs ) { <S2SV_ModEnd> u32 hash , <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; hash = siphash_3u32 <S2SV_ModEnd> ( ( __force <S2SV_ModStart> iph -> protocol , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
<S2SV_ModStart> net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
<S2SV_ModStart> skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs [
<S2SV_ModStart> saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,
<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> && ! opt
<S2SV_ModStart> out_dev ) && skb -> protocol == htons ( ETH_P_IP ) && <S2SV_ModStart> ) ) ) IPCB ( skb ) -> flags |= IPSKB_DOREDIRECT ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
<S2SV_ModStart> struct hns_roce_ib_alloc_ucontext_resp resp = { }
<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> - ENOMEM ; * bounce_buf_ret = bounce_buf ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> hgcm_call_add_pagelist_size ( bounce_buf
<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> & facilities )
<S2SV_ModStart> NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o
<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> case 0x40 : if ( len < 3 ) return - 1 ; <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ;
<S2SV_ModStart> char * p , unsigned packet_len <S2SV_ModStart> facilities_len == 0 || ( unsigned ) facilities_len > packet_len <S2SV_ModStart> while ( facilities_len >= 3 && <S2SV_ModEnd> * p == <S2SV_ModStart> 1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> 1 ) ; break ; default : printk ( KERN_DEBUG "ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n" , * p ) ; len = 1 ; break ; } <S2SV_ModStart> len < 0 ) return 0 ; if ( WARN_ON ( len >= facilities_len ) <S2SV_ModStart> + 1 ; } return facilities_len == 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> : if ( len < 3 ) return - 1 ; if ( <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_CALL ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_ADD ) { if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_DIGIS ) { if ( l % AX25_ADDR_LEN ) return - 1 ;
<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }
<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
<S2SV_ModStart> siocb -> scm , true
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> ( d ) ; msg -> msg_namelen = 0
<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
<S2SV_ModStart> elen ) ; elen += sizeof ( struct pathComponent ) ; <S2SV_ModStart> > 0 ) { elen += pc -> lengthComponentIdent ; break ; } <S2SV_ModEnd> case 2 : <S2SV_ModStart> case 5 : elen += pc -> lengthComponentIdent ; if ( elen > fromlen ) return - EIO ; <S2SV_ModStart> break ; } <S2SV_ModEnd> } if (
<S2SV_ModStart> int ret ; hci_req_sync_lock ( hdev ) ; if ( <S2SV_ModEnd> test_bit ( HCI_UP <S2SV_ModStart> flags ) ) <S2SV_ModEnd> ret = __hci_req_sync <S2SV_ModStart> hci_status ) ; else ret = - ENETDOWN ;
<S2SV_ModStart> ( uid , file -> f_cred -> fsuid <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( gid , file -> f_cred -> fsgid <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ) ) ; if ( af == NULL ) break ;
<S2SV_ModStart> srcu ) ; kvm_iommu_unmap_pages ( kvm , & old ) ; <S2SV_ModStart> ) goto out_free <S2SV_ModEnd> ; r = <S2SV_ModStart> ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_slots ; } if ( <S2SV_ModStart> return 0 ; out_slots : kfree ( slots ) ;
<S2SV_ModStart> resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> { if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> type == HUB_INIT2 || type == HUB_INIT3 ) { device_lock ( hub -> intfdev ) ; if ( hub -> disconnected ) { device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ; return ; } if ( type == HUB_INIT2 <S2SV_ModStart> goto init2 ; goto init3 ; } kref_get ( & hub -> kref ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; device_unlock ( hub -> intfdev ) ; <S2SV_ModStart> ) ) ; if ( type == HUB_INIT2 || type == HUB_INIT3 ) device_unlock ( hub -> intfdev ) ; kref_put ( & hub -> kref , hub_release ) ;
<S2SV_ModStart> ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
<S2SV_ModStart> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;
<S2SV_ModStart> ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ) ) { struct snd_timer_instance * t = <S2SV_ModEnd> list_entry ( timer <S2SV_ModStart> ; if ( t <S2SV_ModEnd> -> flags & <S2SV_ModStart> = - EBUSY <S2SV_ModEnd> ; goto unlock
<S2SV_ModStart> - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;
<S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> = SKB_GSO_UDP ; append : <S2SV_ModEnd> return skb_append_datato_frags (
<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> + bit_idx ; handle_irq_for_port ( port , ctrl <S2SV_ModEnd> ) ; bit_idx
<S2SV_ModStart> ( ) ; struct evtchn_loop_ctrl ctrl = { 0 } ; <S2SV_ModStart> xen_evtchn_handle_events ( cpu , & ctrl <S2SV_ModStart> evtchn_rwlock ) ; __this_cpu_inc ( irq_epoch ) ;
<S2SV_ModStart> ret = 0 ; xen_cpu_init_eoi ( cpu )
<S2SV_ModStart> info ) ; INIT_LIST_HEAD ( & info -> eoi_list ) ;
<S2SV_ModStart> evtchn_port_t evtchn ; unsigned int cpu ; <S2SV_ModStart> ( evtchn ) || ! list_empty ( & info -> eoi_list ) ) return ; cpu = info -> eoi_cpu ; if ( info -> eoi_time && info -> irq_epoch == per_cpu ( irq_epoch , cpu ) ) { lateeoi_list_add ( info ) ; return ; } info -> eoi_time = 0 <S2SV_ModEnd> ; unmask_evtchn (
<S2SV_ModStart> unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( cpu , ctrl , <S2SV_ModStart> , & ready <S2SV_ModEnd> ) ; ready
<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> long * ready <S2SV_ModEnd> ) { struct <S2SV_ModStart> ( unlikely ( ! ctrl <S2SV_ModEnd> ) ) pr_warn <S2SV_ModStart> handle_irq_for_port ( port , ctrl
<S2SV_ModStart> ( unsigned cpu , struct evtchn_loop_ctrl * ctrl <S2SV_ModStart> ( cpu , ctrl <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ( cpu , NULL <S2SV_ModEnd> ) ; return
<S2SV_ModStart> { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> ( store ) <S2SV_ModEnd> ; sector_t size <S2SV_ModStart> -> next_free ; <S2SV_ModEnd> ps -> next_free <S2SV_ModStart> -> next_free ++ ; skip_metadata ( ps )
<S2SV_ModStart> current_area -- ; skip_metadata ( ps ) ;
<S2SV_ModStart> while ( buflen >= sizeof ( * union_desc ) ) { union_desc = ( struct usb_cdc_union_desc * ) buf ; if ( union_desc -> bLength > buflen ) { dev_err ( & intf -> dev , "Too<S2SV_blank>large<S2SV_blank>descriptor\\n" ) ; return NULL ; } <S2SV_ModEnd> if ( union_desc <S2SV_ModStart> "Found<S2SV_blank>union<S2SV_blank>header\\n" ) ; if ( union_desc -> bLength >= sizeof ( * union_desc ) ) return union_desc ; dev_err ( & intf -> dev , "Union<S2SV_blank>descriptor<S2SV_blank>to<S2SV_blank>short<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%zd\\n)" , union_desc -> bLength , sizeof ( * union_desc ) ) ; return NULL <S2SV_ModEnd> ; } buflen
<S2SV_ModStart> tn_buf ) ; return - EACCES ;
<S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } down_write <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } inode <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
<S2SV_ModStart> ext4_lblk_t lblk ; <S2SV_ModEnd> unsigned int blkbits <S2SV_ModStart> ret ; } <S2SV_ModEnd> start = round_up <S2SV_ModStart> EXT4_EX_NOCACHE ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> inode ) ; <S2SV_ModEnd> ret = ext4_alloc_file_blocks <S2SV_ModStart> flags , mode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
<S2SV_ModStart> vma -> vm_file ) ; down_read ( & EXT4_I ( inode ) -> i_mmap_sem <S2SV_ModStart> ; out : up_read ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
<S2SV_ModStart> out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> last_block_offset ) ; <S2SV_ModEnd> if ( ext4_test_inode_flag <S2SV_ModStart> handle ) ; <S2SV_ModEnd> inode -> i_mtime <S2SV_ModStart> ; out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
<S2SV_ModStart> ) ; } down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ext4_truncate ( inode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem
<S2SV_ModStart> i_data_sem ) ; init_rwsem ( & ei -> i_mmap_sem ) ;
<S2SV_ModStart> goto all_leaves_cluster_together ; pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) <S2SV_ModEnd> ; } split_node <S2SV_ModStart> return true ; <S2SV_ModEnd> all_leaves_cluster_together : pr_devel
<S2SV_ModStart> sent = 0 <S2SV_ModEnd> ; smb_msg .
<S2SV_ModStart> val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
<S2SV_ModStart> ] . bm_bn ; xfs_daddr_t eofs <S2SV_ModStart> ) ) ; eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , "%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>" , __func__ , blkno , eofs ) ; return NULL ; }
<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( lc -> <S2SV_ModStart> ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> XFRMA_REPLAY_ESN_VAL ] ; struct xfrm_replay_state_esn * rs ; if <S2SV_ModEnd> ( p -> <S2SV_ModStart> & XFRM_STATE_ESN ) { if ( <S2SV_ModEnd> ! rt ) <S2SV_ModStart> - EINVAL ; rs = nla_data ( rt ) ; if ( rs -> bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof ( rs -> bmp [ 0 ] ) / 8 ) return - EINVAL ; if ( nla_len ( rt ) < xfrm_replay_state_esn_len ( rs ) && nla_len ( rt ) != sizeof ( * rs ) ) return - EINVAL ; }
<S2SV_ModStart> * up ; int klen , ulen ; <S2SV_ModStart> rta ) ; klen = <S2SV_ModEnd> xfrm_replay_state_esn_len ( up <S2SV_ModStart> ( up ) ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> ; pp = kzalloc ( klen <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ;
<S2SV_ModStart> * up ; int ulen ; <S2SV_ModStart> rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || <S2SV_ModEnd> xfrm_replay_state_esn_len ( replay_esn <S2SV_ModStart> replay_esn ) != ulen <S2SV_ModEnd> ) return -
<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
<S2SV_ModStart> struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) )
<S2SV_ModStart> ; bool is_drop_n_account = false ; bool do_vnet <S2SV_ModStart> -> has_vnet_hdr ) { <S2SV_ModStart> virtio_net_hdr ) ; do_vnet = true ; } <S2SV_ModStart> < 0 ) { <S2SV_ModStart> = 0 ; do_vnet = false ; } <S2SV_ModStart> -> max_frame_len ; do_vnet = false ; <S2SV_ModStart> ; if ( do_vnet <S2SV_ModEnd> ) { if
<S2SV_ModStart> goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
<S2SV_ModStart> ; rc = 0 ; if ( copy_to_user ( arg , & ifr , sizeof ( ifr ) ) ) rc = <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ipxitf_put ( ipxif <S2SV_ModStart> ( ipxif ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
<S2SV_ModStart> -> running ) list_del_init <S2SV_ModEnd> ( & ti
<S2SV_ModStart> = current ; <S2SV_ModEnd> BUG_ON ( !
<S2SV_ModStart> task = current <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) ; } <S2SV_ModEnd> atomic_long_set ( &
<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
<S2SV_ModStart> -> i_mapping ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> f_op ) ; <S2SV_ModEnd> if ( f
<S2SV_ModStart> goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; <S2SV_ModEnd> if ( list_lru_init <S2SV_ModStart> & s -> s_inode_lru <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto fail ; <S2SV_ModEnd> INIT_LIST_HEAD ( &
<S2SV_ModStart> s_inode_lru ) ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> force ) { sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1
<S2SV_ModStart> : if ( is_nmi <S2SV_ModEnd> ( intr_info )
<S2SV_ModStart> ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ) ) ; ptr -> next = NULL ; ptr -> buffer_length = 0 ; ptr -> kernel_data = NULL ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; param += <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ptr
<S2SV_ModStart> ret , n ; int num_descriptors ; size_t offset = offsetof ( struct hid_descriptor , desc ) <S2SV_ModStart> ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( "hid<S2SV_blank>descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short\\n" ) ; return - EINVAL ; } <S2SV_ModStart> hdesc -> bCountryCode ; num_descriptors = min_t ( int , hdesc -> bNumDescriptors , ( hdesc -> bLength - offset ) / sizeof ( struct hid_class_descriptor ) ) <S2SV_ModStart> ; n < num_descriptors <S2SV_ModEnd> ; n ++
<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> goto err ; cpu = cpumask_first ( mask ) ;
<S2SV_ModStart> ++ ) { if ( ! cd -> disk ) continue ;
<S2SV_ModStart> ) ) { put_disk ( disk ) ;
<S2SV_ModStart> * iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } error <S2SV_ModStart> nd ) ; out2 :
<S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 45 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else <S2SV_ModStart> = intel_pebs_aliases_snb ; if ( boot_cpu_data . x86_model == 62 ) x86_pmu . extra_regs = intel_snbep_extra_regs ; else
<S2SV_ModStart> dev ; int len <S2SV_ModEnd> = 0 ; <S2SV_ModStart> interface ) { mutex_unlock ( & dev -> io_mutex ) ; return - ENODEV <S2SV_ModEnd> ; } spin_lock_irqsave <S2SV_ModStart> flags ) ; len <S2SV_ModEnd> = snprintf ( <S2SV_ModStart> flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> ) ; return simple_read_from_buffer ( buffer , count , ppos , in_buffer , len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> cycles ) ; this_cpu_add ( net_rand_state . s1 , fast_pool -> pool [ cycles & 3 ] ) ;
<S2SV_ModStart> ( ) ; this_cpu_add ( net_rand_state . s1 , rol32 ( jiffies , 24 ) + user_tick ) ;
<S2SV_ModStart> } if ( rq -> curr -> se . on_rq &&
<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
<S2SV_ModStart> * rq ) <S2SV_ModEnd> { int cpu <S2SV_ModStart> ; u64 irq_time ; if ( rq -> skip_clock_update ) return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (
<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
<S2SV_ModStart> . mode = L2CAP_MODE_ERTM <S2SV_ModEnd> } ; void <S2SV_ModStart> sk ) ; if ( pi -> num_conf_req || pi -> num_conf_rsp ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( pi -> dcid ) ; req . scid = cpu_to_le16 ( pi -> scid ) ; l2cap_send_cmd ( pi -> conn , l2cap_get_ident ( pi -> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; } break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : <S2SV_ModStart> . txwin_size = L2CAP_DEFAULT_TX_WINDOW <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . retrans_timeout = 0 <S2SV_ModEnd> ; rfc . <S2SV_ModStart> . monitor_timeout = 0 ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; case L2CAP_MODE_STREAMING : rfc . mode = L2CAP_MODE_STREAMING ; rfc . txwin_size = 0 ; rfc . max_transmit = 0 ; rfc . retrans_timeout = 0 ; rfc . monitor_timeout = 0 <S2SV_ModEnd> ; rfc .
<S2SV_ModStart> < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) ; l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & req ) ; <S2SV_ModStart> goto unlock ; } <S2SV_ModStart> , rsp ) ; l2cap_pi ( sk ) -> num_conf_rsp ++ <S2SV_ModStart> buf ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
<S2SV_ModStart> : if ( l2cap_pi ( sk ) -> num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP ) { int len = cmd -> len - sizeof ( * rsp ) ; char req [ 64 ] ; result = L2CAP_CONF_SUCCESS ; len = l2cap_parse_conf_rsp ( sk , rsp -> data , len , req , & result ) ; if ( len < 0 ) { struct l2cap_disconn_req req ; req . dcid = cpu_to_le16 ( l2cap_pi ( sk ) -> dcid ) ; req . scid = cpu_to_le16 ( l2cap_pi ( sk ) -> scid ) <S2SV_ModEnd> ; l2cap_send_cmd ( <S2SV_ModStart> conn ) , L2CAP_DISCONN_REQ , sizeof ( req ) , & <S2SV_ModEnd> req ) ; <S2SV_ModStart> ; goto done ; } l2cap_send_cmd ( conn , l2cap_get_ident ( conn ) , L2CAP_CONF_REQ , len , req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ; if ( result != L2CAP_CONF_SUCCESS ) goto done ; break
<S2SV_ModStart> req ) ; l2cap_pi ( sk ) -> num_conf_req ++ ;
<S2SV_ModStart> } if ( pi -> num_conf_rsp || pi -> num_conf_req ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) return - ECONNREFUSED ; break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : if ( pi -> mode != rfc . mode ) { result = L2CAP_CONF_UNACCEPT ; rfc . mode = pi -> mode ; if ( pi -> num_conf_rsp == 1 ) return - ECONNREFUSED ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; } if ( <S2SV_ModStart> { if ( mtu < L2CAP_DEFAULT_MIN_MTU ) result = L2CAP_CONF_UNACCEPT ; else { <S2SV_ModEnd> pi -> omtu <S2SV_ModStart> pi -> omtu = mtu ; pi -> conf_state |= L2CAP_CONF_MTU_DONE ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ; switch ( rfc . mode ) { case L2CAP_MODE_BASIC : pi -> fcs = L2CAP_FCS_NONE ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_ERTM : pi -> remote_tx_win = rfc . txwin_size ; pi -> remote_max_tx = rfc . max_transmit ; pi -> max_pdu_size = rfc . max_pdu_size ; rfc . retrans_timeout = L2CAP_DEFAULT_RETRANS_TO ; rfc . monitor_timeout = L2CAP_DEFAULT_MONITOR_TO ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_STREAMING : pi -> remote_tx_win = rfc . txwin_size ; pi -> max_pdu_size = rfc . max_pdu_size ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; default : <S2SV_ModEnd> result = L2CAP_CONF_UNACCEPT <S2SV_ModStart> = L2CAP_CONF_UNACCEPT ; memset ( & rfc , 0 , sizeof ( rfc ) ) ; rfc . mode = pi -> mode ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; if ( result == L2CAP_CONF_SUCCESS ) <S2SV_ModEnd> pi -> conf_state <S2SV_ModStart> |= L2CAP_CONF_OUTPUT_DONE ; <S2SV_ModEnd> } rsp ->
<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
<S2SV_ModStart> case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) ==
<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
<S2SV_ModStart> ctxt -> mode != X86EMUL_MODE_PROT64 <S2SV_ModEnd> ) && ( <S2SV_ModStart> msr_data ) ; <S2SV_ModEnd> if ( ( <S2SV_ModStart> 0 ) ; <S2SV_ModEnd> ctxt -> eflags <S2SV_ModStart> u16 ) msr_data & <S2SV_ModEnd> ~ SELECTOR_RPL_MASK ; <S2SV_ModStart> + 8 ; if <S2SV_ModEnd> ( efer & <S2SV_ModStart> efer & EFER_LMA <S2SV_ModEnd> ) { cs <S2SV_ModStart> -> _eip = ( efer & EFER_LMA ) ? msr_data : ( u32 ) <S2SV_ModStart> VCPU_REGS_RSP ) = ( efer & EFER_LMA ) ? msr_data : ( u32 )
<S2SV_ModStart> -> bio ) { if ( srp -> rq -> cmd != srp -> rq -> __cmd ) kfree ( srp -> rq -> cmd ) ; <S2SV_ModStart> EIO ) ; srp -> rq = NULL ; }
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; int copied <S2SV_ModStart> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name <S2SV_ModStart> 0xFF ; } <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; struct ddpehdr <S2SV_ModStart> ( ! err && msg -> msg_name ) { struct sockaddr_at * sat = msg -> msg_name ; <S2SV_ModEnd> sat -> sat_family <S2SV_ModStart> -> deh_snet ; <S2SV_ModEnd> msg -> msg_namelen
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> & RCV_SHUTDOWN ) return 0 ; <S2SV_ModEnd> return err ; <S2SV_ModStart> msg_namelen ) ; <S2SV_ModEnd> } skb_free_datagram (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> AX25_ADDR_LEN ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sax ) ; }
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> copied , err <S2SV_ModEnd> ; int vnet_hdr_len <S2SV_ModStart> out_free ; } copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { <S2SV_ModEnd> if ( sock <S2SV_ModStart> == SOCK_PACKET ) { <S2SV_ModStart> sockaddr_pkt ) ; } else { struct sockaddr_ll * sll = & PACKET_SKB_CB ( skb ) -> sa . ll ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> sll_addr ) ; } memcpy <S2SV_ModEnd> ( msg -> <S2SV_ModStart> msg -> msg_name <S2SV_ModEnd> , & PACKET_SKB_CB <S2SV_ModStart> msg_namelen ) ; }
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
<S2SV_ModStart> msg -> msg_name ) { size_t len = sizeof ( call -> conn -> trans -> peer -> srx ) ; memcpy ( msg -> msg_name , & call -> conn -> trans -> peer -> srx , len ) ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = len ; } <S2SV_ModEnd> sock_recv_ts_and_drops ( msg
<S2SV_ModStart> . msg_name = addr ? <S2SV_ModStart> ) & address : NULL <S2SV_ModStart> . msg_namelen = 0 <S2SV_ModEnd> ; if (
<S2SV_ModStart> & flags ) <S2SV_ModEnd> err = verify_compat_iovec <S2SV_ModStart> VERIFY_WRITE ) ; <S2SV_ModEnd> else err = <S2SV_ModStart> | MSG_CMSG_COMPAT ) ; msg_sys -> msg_namelen = 0
<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) goto out <S2SV_ModEnd> ; err =
<S2SV_ModStart> MSG_DONTWAIT ) ; <S2SV_ModEnd> if ( !
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> - EOPNOTSUPP ; <S2SV_ModEnd> err = 0
<S2SV_ModStart> -> dest_addr ; <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> = sizeof ( * sx25 ) ; } <S2SV_ModEnd> x25_check_rbuf ( sk
<S2SV_ModStart> -> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev
<S2SV_ModStart> crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp .
<S2SV_ModStart> crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher .
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp .
<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
<S2SV_ModStart> skb ) { strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl .
<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
<S2SV_ModStart> esize ) { <S2SV_ModEnd> res -> nlimbs <S2SV_ModStart> : 1 ; if ( res -> nlimbs ) { if ( mpi_resize ( res , 1 ) < 0 ) goto enomem ; rp = res -> d ; rp [ 0 ] = 1 ; }
<S2SV_ModStart> { if ( max_length < sizeof ( struct ieee80211_radiotap_header ) ) return - EINVAL ; if ( <S2SV_ModStart> iterator -> _rtheader + sizeof ( uint32_t )
<S2SV_ModStart> perf_event_context * ctx , * uninitialized_var ( gctx ) <S2SV_ModStart> move_group ) { <S2SV_ModEnd> gctx = group_leader <S2SV_ModStart> -> ctx ; mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; perf_remove_from_context ( group_leader , false ) ; perf_event__state_init ( group_leader ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , false ) ; perf_event__state_init ( sibling ) ; put_ctx ( gctx ) ; } } else { <S2SV_ModStart> mutex_lock ( & ctx -> mutex ) ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { synchronize_rcu ( ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } } perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) { mutex_unlock ( & <S2SV_ModStart> mutex ) ; <S2SV_ModEnd> put_ctx ( gctx <S2SV_ModStart> ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_disable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }
<S2SV_ModStart> * sibling ; lockdep_assert_held <S2SV_ModEnd> ( & ctx <S2SV_ModStart> func ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * sub ; struct perf_event_context * ctx = leader -> ctx ; <S2SV_ModStart> 0 , ret ; u64 count , enabled , running ; u64 values [ 5 ] ; lockdep_assert_held ( & ctx -> mutex ) ; count = perf_event_read_value ( leader , & enabled , & running ) ; values [ n ++ ] = 1 + leader -> nr_siblings ; if ( read_format & PERF_FORMAT_TOTAL_TIME_ENABLED ) values [ n ++ ] = enabled ; if ( read_format & PERF_FORMAT_TOTAL_TIME_RUNNING ) values [ n ++ ] = running ; values [ n ++ ] = count ; if ( read_format & PERF_FORMAT_ID ) values [ n ++ ] = primary_event_id ( leader ) ; size = n * sizeof ( u64 ) ; if ( copy_to_user ( buf , values , size ) ) return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> ret = size <S2SV_ModStart> ) ) { return <S2SV_ModEnd> - EFAULT ; <S2SV_ModStart> - EFAULT ; <S2SV_ModEnd> } ret += <S2SV_ModStart> size ; } <S2SV_ModEnd> return ret ;
<S2SV_ModStart> refresh ) { struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; ret = _perf_event_refresh ( event , refresh ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_disable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> void ) { struct perf_event_context * ctx ; <S2SV_ModStart> , owner_entry ) { ctx = perf_event_ctx_lock ( event ) ; <S2SV_ModStart> ( event , _perf_event_enable ) ; perf_event_ctx_unlock ( event , ctx ) ; } <S2SV_ModEnd> mutex_unlock ( &
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; long ret ; ctx = perf_event_ctx_lock ( event ) ; ret = _perf_ioctl ( event , cmd <S2SV_ModEnd> , arg ) <S2SV_ModStart> arg ) ; perf_event_ctx_unlock <S2SV_ModEnd> ( event , <S2SV_ModStart> ( event , ctx ) ; <S2SV_ModEnd> return ret ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> ctx ; mutex_lock_double ( & src_ctx -> mutex , & dst_ctx <S2SV_ModEnd> -> mutex ) <S2SV_ModStart> ) ; } synchronize_rcu ( <S2SV_ModEnd> ) ; list_for_each_entry_safe <S2SV_ModStart> mutex ) ; mutex_unlock ( & src_ctx -> mutex ) ;
<S2SV_ModStart> -> private_data ; struct perf_event_context * ctx ; int ret ; ctx = perf_event_ctx_lock ( event ) ; ret = <S2SV_ModEnd> perf_read_hw ( event <S2SV_ModStart> count ) ; perf_event_ctx_unlock ( event , ctx ) ; return ret ;
<S2SV_ModStart> owner ) { mutex_lock_nested <S2SV_ModEnd> ( & owner <S2SV_ModStart> owner -> perf_event_mutex , SINGLE_DEPTH_NESTING
<S2SV_ModStart> ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( <S2SV_ModStart> next -> ds <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> != NULL && <S2SV_ModStart> != NULL && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> } if ( inet_opt <S2SV_ModEnd> == NULL || <S2SV_ModStart> NULL || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; dccp_set_state
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = ireq ->
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
<S2SV_ModStart> __be32 daddr ; struct ip_options_rcu * inet_opt ; <S2SV_ModStart> return 0 ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> ; rt =
<S2SV_ModStart> __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
<S2SV_ModStart> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> ) ; dst_release
<S2SV_ModStart> cipso_v4_delopt ( struct ip_options_rcu <S2SV_ModEnd> * * opt_ptr <S2SV_ModStart> 0 ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> = opt -> opt . <S2SV_ModStart> & opt -> opt . <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> srr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> rr -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> ts -= cipso_len <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> > opt -> opt . cipso ) opt -> opt . <S2SV_ModEnd> router_alert -= cipso_len <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> , opt -> opt . <S2SV_ModStart> < opt -> opt . optlen ) if ( opt -> opt . <S2SV_ModEnd> __data [ iter <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; opt -> opt . <S2SV_ModEnd> optlen = ( <S2SV_ModStart> -= opt -> opt . <S2SV_ModStart> = opt -> opt . optlen ; call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> || opt -> opt .
<S2SV_ModStart> opt_len ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> opt ) ; if ( opt ) call_rcu ( & opt -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
<S2SV_ModStart> hdr_delta ; struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> ; opt = rcu_dereference_protected ( sk_inet -> inet_opt , 1 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> & sk_inet -> inet_opt <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> * opt ; int res = - ENOMSG ; rcu_read_lock ( ) ; opt = rcu_dereference ( <S2SV_ModEnd> inet_sk ( sk <S2SV_ModStart> sk ) -> inet_opt ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( opt && opt -> opt . cipso ) res = <S2SV_ModEnd> cipso_v4_getattr ( opt <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> + opt -> opt . <S2SV_ModStart> secattr ) ; rcu_read_unlock ( ) ; return res ;
<S2SV_ModStart> opt_len ; struct ip_options_rcu * old , <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> sk ) ; old = rcu_dereference_protected ( sk_inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( old <S2SV_ModEnd> ) sk_conn -> <S2SV_ModStart> -> icsk_ext_hdr_len -= old -> opt . <S2SV_ModEnd> optlen ; sk_conn <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ) ; } rcu_assign_pointer ( sk_inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; return
<S2SV_ModStart> icmp_param -> replyopts . opt . opt <S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> icmp_param -> replyopts . opt ; if ( ipc . opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> icmp_param -> replyopts . opt . opt
<S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> param -> replyopts . opt . opt
<S2SV_ModStart> icmp_param . replyopts . opt . opt <S2SV_ModStart> icmp_param . replyopts . opt <S2SV_ModStart> . replyopts . opt . opt .
<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt .
<S2SV_ModStart> skb ) { const <S2SV_ModStart> == 0 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> sptr = skb_network_header
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * ip_options_get_alloc ( <S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + (
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> optp , struct ip_options_rcu <S2SV_ModEnd> * opt , <S2SV_ModStart> ) opt -> opt . <S2SV_ModStart> ; opt -> opt . <S2SV_ModStart> ( net , & opt ->
<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
<S2SV_ModStart> daddr , struct ip_options_rcu <S2SV_ModEnd> * opt ) <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ( skb , & opt ->
<S2SV_ModStart> ) ; struct ip_options_rcu * inet_opt <S2SV_ModEnd> ; struct rtable <S2SV_ModStart> ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt <S2SV_ModStart> : if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> is_strictroute && rt <S2SV_ModStart> ) + ( inet_opt ? inet_opt -> opt . <S2SV_ModEnd> optlen : 0 <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> optlen ) { <S2SV_ModStart> -> ihl += inet_opt -> opt . <S2SV_ModEnd> optlen >> 2 <S2SV_ModStart> ( skb , & inet_opt ->
<S2SV_ModStart> ) ; struct ip_options_data <S2SV_ModEnd> replyopts ; struct <S2SV_ModStart> replyopts . opt . opt <S2SV_ModStart> . opt . opt . <S2SV_ModStart> ; if ( replyopts . opt . opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> daddr = replyopts . opt
<S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> -> opt , & opt -> <S2SV_ModStart> + opt -> opt .
<S2SV_ModStart> ) optbuf ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; <S2SV_ModStart> ; if ( inet_opt ) memcpy ( optbuf , & inet_opt -> opt , sizeof ( struct ip_options ) + inet_opt -> opt . <S2SV_ModEnd> optlen ) ;
<S2SV_ModStart> : { struct ip_options_rcu * old , <S2SV_ModEnd> * opt = <S2SV_ModStart> err ) break ; old = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) <S2SV_ModStart> endif if ( old <S2SV_ModEnd> ) icsk -> <S2SV_ModStart> -> icsk_ext_hdr_len -= old -> opt . <S2SV_ModEnd> optlen ; if <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> # endif } rcu_assign_pointer ( inet -> inet_opt , opt ) ; if ( old ) call_rcu ( & old -> rcu , opt_kfree_rcu <S2SV_ModEnd> ) ; break
<S2SV_ModStart> int err ; struct ip_options_data opt_copy ; <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> if ( ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
<S2SV_ModStart> sizeof ( struct ip_options_rcu <S2SV_ModEnd> ) + opt <S2SV_ModStart> && ip_options_echo ( & ireq -> opt <S2SV_ModEnd> -> opt ,
<S2SV_ModStart> ; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> if ( ! inet_opt || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; tp
<S2SV_ModStart> <S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * tcp_v4_save_options ( <S2SV_ModStart> skb ) { const <S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * dopt = <S2SV_ModStart> int opt_size = sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> ; dopt = <S2SV_ModStart> ( ip_options_echo ( & dopt -> opt <S2SV_ModEnd> , skb )
<S2SV_ModStart> ; # endif struct ip_options_rcu * inet_opt ; <S2SV_ModStart> -> loc_addr ; inet_opt = ireq -> opt ; rcu_assign_pointer ( newinet -> inet_opt , inet_opt ) ; <S2SV_ModEnd> ireq -> opt <S2SV_ModStart> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( inet_opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; newinet
<S2SV_ModStart> sk_buff * skb ; struct ip_options_data opt_copy <S2SV_ModStart> . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } <S2SV_ModEnd> saddr = ipc <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt . <S2SV_ModStart> . opt -> opt .
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; struct rtable <S2SV_ModStart> NULL ) { struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> p ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> ) != ulen || replay_esn -> bmp_len != up -> bmp_len
<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> * TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> u64 nsec ; u32 <S2SV_ModEnd> rem ; nsec <S2SV_ModStart> -> tv_sec - div_u64_rem <S2SV_ModEnd> ( nsec ,
<S2SV_ModStart> return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( & <S2SV_ModStart> = timespec_to_ns ( &
<S2SV_ModStart> == CPUCLOCK_SCHED ) * tp = ns_to_timespec <S2SV_ModEnd> ( cpu . <S2SV_ModStart> cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> struct timespec ts ; s32 rem <S2SV_ModStart> . tv_sec = div_s64_rem <S2SV_ModEnd> ( nsec , <S2SV_ModStart> NSEC_PER_SEC , & rem <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( rem <S2SV_ModEnd> < 0 ) <S2SV_ModStart> 0 ) ) { <S2SV_ModEnd> ts . tv_sec <S2SV_ModStart> ts . tv_sec -- ; rem += NSEC_PER_SEC ; } <S2SV_ModEnd> ts . tv_nsec <S2SV_ModStart> ts . tv_nsec = rem <S2SV_ModEnd> ; return ts
<S2SV_ModStart> mtemp , save_adjust <S2SV_ModEnd> ; s64 freq_adj <S2SV_ModStart> ; time_offset = div_s64 <S2SV_ModEnd> ( time_offset , <S2SV_ModStart> time_offset , NTP_INTERVAL_FREQ <S2SV_ModEnd> ) ; time_offset
<S2SV_ModStart> drop ; } memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; <S2SV_ModStart> == 5 ) <S2SV_ModEnd> return 0 ; <S2SV_ModStart> return 0 ; <S2SV_ModEnd> opt -> optlen
<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
<S2SV_ModStart> ( user_alloc && ( <S2SV_ModStart> PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size
<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> || ( skb <S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 1 ;
<S2SV_ModStart> ) ; usb_unanchor_urb ( urb ) ; usb_free_urb
<S2SV_ModStart> ; if ( in_dev -> dead ) goto no_promotions ; if ( <S2SV_ModStart> ) ; } no_promotions :
<S2SV_ModStart> 1 ; } if ( in_dev -> dead ) goto no_promotions ; <S2SV_ModStart> } } } no_promotions :
<S2SV_ModStart> ) { struct in_device * idev <S2SV_ModEnd> = ( ( <S2SV_ModStart> ) -> ifa_dev <S2SV_ModEnd> ; struct netdev_notifier_info <S2SV_ModStart> netdev_notifier_info info ; if ( idev -> dead ) return NOTIFY_DONE ; <S2SV_ModStart> & info , idev ->
<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> arg ) { return video_usercopy <S2SV_ModEnd> ( file , <S2SV_ModStart> , cmd , arg , __video_do_ioctl ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * parg = ( void * ) arg ; long err = - EINVAL ; bool has_array_args ; size_t array_size = 0 ; void __user * user_ptr = NULL ; void * * kernel_ptr = NULL ; if ( _IOC_DIR ( cmd ) != _IOC_NONE ) { if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) { unsigned long n = cmd_input_size ( cmd ) ; if ( copy_from_user ( parg , ( void __user * ) arg , n ) ) goto out ; if ( n < _IOC_SIZE ( cmd ) ) memset ( ( u8 * ) parg + n , 0 , _IOC_SIZE ( cmd ) - n ) ; } else { memset ( parg , 0 , _IOC_SIZE ( cmd ) ) ; } } err = check_array_args ( cmd , parg , & array_size , & user_ptr , & kernel_ptr ) ; if ( err < 0 ) goto out ; has_array_args = err ; if ( has_array_args ) { mbuf = kmalloc ( array_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_array_args ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , array_size ) ) goto out_array_args ; * kernel_ptr = mbuf ; } err = func ( file , cmd , parg ) ; if ( err == - ENOIOCTLCMD ) <S2SV_ModEnd> err = - <S2SV_ModStart> - EINVAL ; if ( has_array_args ) { * kernel_ptr = user_ptr ; if ( copy_to_user ( user_ptr , mbuf , array_size ) ) err = - EFAULT ; goto out_array_args ; } if ( err < 0 ) goto out ; out_array_args : <S2SV_ModEnd> switch ( _IOC_DIR <S2SV_ModStart> ) ) { <S2SV_ModEnd> case _IOC_READ : <S2SV_ModStart> _IOC_READ : case <S2SV_ModEnd> ( _IOC_WRITE | <S2SV_ModStart> : if ( <S2SV_ModEnd> copy_to_user ( (
<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> vcpu ) { int r = EMULATE_DONE ; <S2SV_ModStart> vcpu ) ; if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> = 0 ; r = EMULATE_FAIL ; } <S2SV_ModStart> ) ; return r <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED )
<S2SV_ModStart> "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>scatterlist<S2SV_blank>from<S2SV_blank>DMA<S2SV_blank>API\\n" ) ; kfree ( a ) ;
<S2SV_ModStart> ; unsigned long mmio_pgoff <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - ENODEV ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <S2SV_ModEnd> vma -> vm_pgoff <S2SV_ModStart> vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <S2SV_ModEnd> ( & info <S2SV_ModStart> mm_lock ) ; <S2SV_ModEnd> vma -> vm_page_prot <S2SV_ModStart> , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> int idx ; unsigned int count ; <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = control -> id ; <S2SV_ModStart> , SNDRV_CTL_EVENT_MASK_VALUE , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> struct snd_ctl_elem_id id ; unsigned int count <S2SV_ModStart> -> count ; count = kcontrol -> count ; <S2SV_ModStart> ; idx < <S2SV_ModEnd> count ; idx
<S2SV_ModStart> 0 ) { struct snd_ctl_elem_id id = kctl -> id ; <S2SV_ModStart> SNDRV_CTL_EVENT_MASK_TLV , & <S2SV_ModEnd> id ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( struct <S2SV_ModStart> vapic_addr ) { if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & <S2SV_ModStart> . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> __set_bit ( KVM_APIC_CHECK_VAPIC <S2SV_ModStart> apic_attention ) ; } else { <S2SV_ModEnd> __clear_bit ( KVM_APIC_CHECK_VAPIC <S2SV_ModStart> ) ; } vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; }
<S2SV_ModStart> { u32 data <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; kvm_read_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; apic_set_tpr
<S2SV_ModStart> arch . apic <S2SV_ModEnd> ; apic_sync_pv_eoi_to_guest ( <S2SV_ModStart> 24 ) ; kvm_write_guest_cached ( vcpu -> kvm , & <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> . apic -> vapic_cache , & data , sizeof ( u32 ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> srcu ) ; <S2SV_ModEnd> r = 1 <S2SV_ModStart> srcu_idx ) ; <S2SV_ModEnd> return r ;
<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
<S2SV_ModStart> -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
<S2SV_ModStart> ( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (
<S2SV_ModStart> compareKeyIndex ) ; node -> sorted = tr_new ( tr_variant , 1 ) ; tr_variantInitDict ( <S2SV_ModEnd> node -> sorted <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> tmp ) ; v = <S2SV_ModEnd> node -> sorted <S2SV_ModStart> { node -> sorted = NULL ; } node -> v = v ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> node ) { TR_ASSERT ( node != NULL ) ; <S2SV_ModStart> ( node -> sorted != NULL <S2SV_ModEnd> ) { tr_free <S2SV_ModStart> node -> sorted -> <S2SV_ModEnd> val . l <S2SV_ModStart> vals ) ; tr_free ( node -> sorted ) ;
<S2SV_ModStart> buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( buf ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( sa
<S2SV_ModStart> f ) ; snprintf ( addr , sizeof ( addr ) <S2SV_ModEnd> , "%d.%d.%d.%d" ,
<S2SV_ModStart> && strncmp ( rpath <S2SV_ModEnd> , home ,
<S2SV_ModStart> ( ret ) ret = - EINVAL ; if ( ! ret && CONFIG_IS_ENABLED ( FIT_SIGNATURE ) ) { ret = fdt_check_no_at ( fit , 0 ) ; if ( ret ) <S2SV_ModStart> ) ; return ret ; } } if ( ret ) { log_debug ( "FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n" , ret ) ; return ret <S2SV_ModEnd> ; } }
<S2SV_ModStart> BOOTSTAGE_SUB_FORMAT ) ; ret = <S2SV_ModEnd> fit_check_format ( fit <S2SV_ModStart> , IMAGE_SIZE_INVAL ) ; if ( ret <S2SV_ModStart> { printf ( "Bad<S2SV_blank>FIT<S2SV_blank>%s<S2SV_blank>image<S2SV_blank>format!<S2SV_blank>(err=%d)\\n" , prop_name , ret ) ; if ( CONFIG_IS_ENABLED ( FIT_SIGNATURE ) && ret == - EADDRNOTAVAIL ) printf ( "Signature<S2SV_blank>checking<S2SV_blank>prevents<S2SV_blank>use<S2SV_blank>of<S2SV_blank>unit<S2SV_blank>addresses<S2SV_blank>(@)<S2SV_blank>in<S2SV_blank>nodes\\n" <S2SV_ModEnd> ) ; bootstage_error <S2SV_ModStart> ) ; return ret <S2SV_ModEnd> ; } bootstage_mark
<S2SV_ModStart> } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; if ( ret ) { log_debug ( "FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n" , ret ) ; return - EINVAL ; } } if (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> sig_blob ) { const char * name = fit_get_name ( fit , conf_noffset , NULL ) ; <S2SV_ModStart> * reqd_mode ; if ( strchr ( name , '@' ) ) { printf ( "Configuration<S2SV_blank>node<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>\'@\'\\n" , name ) ; return - EPERM ; }
<S2SV_ModStart> NULL ) ; if ( strchr ( name , '@' ) ) { err_msg = "Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@" ; goto error ; }
<S2SV_ModStart> ) { const char * name = fit_get_name ( fit , image_noffset , NULL ) ; const <S2SV_ModStart> size_t size ; <S2SV_ModEnd> char * err_msg <S2SV_ModStart> = "" ; if ( strchr ( name , '@' ) ) { err_msg = "Node<S2SV_blank>name<S2SV_blank>contains<S2SV_blank>@" ; goto err ; } <S2SV_ModStart> = "Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size" ; goto err ; } return fit_image_verify_with_data <S2SV_ModEnd> ( fit , <S2SV_ModStart> ( fit , image_noffset , data , size ) ; err : printf ( "error!\\n%s<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n" , err_msg <S2SV_ModEnd> , fit_get_name ( <S2SV_ModStart> 0 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> fdt ) ; bool expect_end = false ; <S2SV_ModStart> = nextoffset ; if ( expect_end && tag != FDT_END ) return - FDT_ERR_BADLAYOUT ; <S2SV_ModStart> & len ) ; if ( ! depth && * name ) return - FDT_ERR_BADLAYOUT <S2SV_ModStart> = '\\0' ; if ( depth == - 1 ) expect_end = true ;
<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> * ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> max ) ; d2 = b <S2SV_ModEnd> = ( int <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> i < ( loopmaxh <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> 2U ) { size_t j ; <S2SV_ModStart> + maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> ( i < loopmaxh ) { size_t j ; <S2SV_ModEnd> for ( j <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxh , max , offx , loopmaxw <S2SV_ModStart> , upb ; size_t i <S2SV_ModEnd> ; upb = <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> i ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> j < ( loopmaxw <S2SV_ModEnd> & ~ ( <S2SV_ModStart> & ~ ( size_t <S2SV_ModEnd> ) 1U ) <S2SV_ModStart> ( j < loopmaxw <S2SV_ModEnd> ) { sycc_to_rgb <S2SV_ModStart> = d2 ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> comps <S2SV_ModStart> . h = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> comps <S2SV_ModStart> 2 ] . <S2SV_ModEnd> dy = img <S2SV_ModStart> ; img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return ; <S2SV_ModStart> ; fails : <S2SV_ModEnd> free ( r <S2SV_ModStart> r ) ; <S2SV_ModEnd> free ( g <S2SV_ModStart> g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> * cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b
<S2SV_ModStart> { for ( pad = ( <S2SV_ModEnd> w % 4
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , "%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> max = w
<S2SV_ModStart> ; cmap_len = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> 0 x_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; y_origin = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> endif image_w = get_tga_ushort <S2SV_ModEnd> ( & tga <S2SV_ModStart> ; image_h = get_tga_ushort <S2SV_ModEnd> ( & tga
<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
<S2SV_ModStart> |= 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> = 256 ; }
<S2SV_ModStart> * p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x0 <S2SV_ModStart> * p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x1 <S2SV_ModStart> * p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y0 <S2SV_ModStart> * p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y1
<S2SV_ModStart> x , y , written <S2SV_ModStart> = y = written = <S2SV_ModStart> pix = c1 ; written ++ <S2SV_ModStart> = c1 ; written ++ ; <S2SV_ModStart> } } } if ( written != width * height ) { fprintf ( stderr , "warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ] ) ; <S2SV_ModEnd> l_mco_size = 5 <S2SV_ModStart> l_mco_size ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
<S2SV_ModStart> ( header -> biBitCount == 0 ) { fprintf ( stderr , "Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n" , 0 ) ; return OPJ_FALSE ; } if ( header ->
<S2SV_ModStart> -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> p_stream ) ; <S2SV_ModEnd> if ( p_total_data_size
<S2SV_ModStart> J2K_CP_CSTY_SOP ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> J2K_CP_CSTY_EPH ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 2 ) ; } return OPJ_FALSE ; }
<S2SV_ModStart> file ) ; { int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> 2 ] , snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , "maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n" ) ; free ( frame_codestream ) ; return 1 ; } } <S2SV_ModEnd> outfile = fopen <S2SV_ModStart> "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n" , outfilename ) ; free ( frame_codestream
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> , p_data , p_total_data_size , <S2SV_ModStart> , p_data , p_total_data_size ,
<S2SV_ModStart> , p_data , p_total_data_size ,
<S2SV_ModStart> p_data , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <S2SV_ModStart> p_manager ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> char lbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strbase [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char ltest [ 512 <S2SV_ModEnd> ] ; char <S2SV_ModStart> char strtest [ 512 <S2SV_ModEnd> ] ; if <S2SV_ModStart> ( lbase , "%511[^\\r\\n]" <S2SV_ModEnd> , strbase ) <S2SV_ModStart> ( ltest , "%511[^\\r\\n]" <S2SV_ModEnd> , strtest ) <S2SV_ModStart> ( nbase != 511 <S2SV_ModEnd> && ntest != <S2SV_ModStart> && ntest != 511 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( f , "PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d" <S2SV_ModEnd> , temp ,
<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l
<S2SV_ModStart> = AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . sun_path <S2SV_ModStart> sun . sun_path <S2SV_ModEnd> , path , <S2SV_ModStart> ; sun_len = sizeof <S2SV_ModEnd> ( struct sockaddr_un <S2SV_ModStart> ( struct sockaddr_un ) ; <S2SV_ModEnd> if ( bind
<S2SV_ModStart> = AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . sun_path <S2SV_ModStart> sun . sun_path <S2SV_ModEnd> , address , <S2SV_ModStart> ; sun_len = sizeof <S2SV_ModEnd> ( struct sockaddr_un <S2SV_ModStart> ( struct sockaddr_un ) ; <S2SV_ModEnd> client -> control
<S2SV_ModStart> ptr ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( "invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> dir , dir_len <S2SV_ModStart> dir , dir_len , "" , 0 ) <S2SV_ModEnd> ; char * <S2SV_ModStart> dst ) ; free ( src ) ; <S2SV_ModStart> NULL ; } free ( src ) ;
<S2SV_ModStart> != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3 <S2SV_ModEnd> ) { univention_debug
<S2SV_ModStart> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> ) ) { return <S2SV_ModStart> occ0 ) ; <S2SV_ModEnd> } else return
<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( occ0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorDecodeTile" , "%s" , "occ0%rowsize<S2SV_blank>!=<S2SV_blank>0" ) ; return 0 ; } <S2SV_ModEnd> assert ( sp <S2SV_ModStart> 0 ) { if ( ! <S2SV_ModStart> , rowsize ) ) return 0
<S2SV_ModStart> NULL ) ; if ( ! <S2SV_ModStart> , cc ) ) return 0
<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } <S2SV_ModEnd> while ( cc
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpAcc ( TIFF <S2SV_ModStart> cc ) ; if <S2SV_ModEnd> ( cc % <S2SV_ModStart> * stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> tmp ) return 0 <S2SV_ModStart> tmp ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> fpDiff ( TIFF <S2SV_ModStart> cc ) ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> tmp ) return 0 <S2SV_ModStart> cp -- ) return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( TIFF <S2SV_ModStart> / 2 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc16" , "%s" , "cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc32" , "%s" , "cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( TIFF <S2SV_ModStart> ) cp0 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc <S2SV_ModStart> ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff16 ( TIFF <S2SV_ModStart> / 2 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff32" , "%s" , "(cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff8 ( TIFF <S2SV_ModStart> ) cp0 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( cc <S2SV_ModStart> ; } } return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( TIFF <S2SV_ModStart> wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( TIFF <S2SV_ModStart> wc ) ; return
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( TIFF <S2SV_ModStart> / 2 ; if ( ! <S2SV_ModStart> , cc ) ) return 0 <S2SV_ModStart> wc ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff32 ( TIFF <S2SV_ModStart> / 4 ; if ( ! <S2SV_ModStart> , cc ) ) return 0 <S2SV_ModStart> wc ) ; return 1 ;
<S2SV_ModStart> ; stripsperplane = TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> ( td -> <S2SV_ModStart> td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ;
<S2SV_ModStart> bitspersample , samplesperpixel = 1 <S2SV_ModStart> input_compression , input_photometric = PHOTOMETRIC_MINISBLACK
<S2SV_ModStart> = 0 ; uint32 <S2SV_ModEnd> strip , nstrips
<S2SV_ModStart> int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 bytes_read <S2SV_ModStart> uint16 bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ; uint32
<S2SV_ModStart> s < ns && row < imagelength
<S2SV_ModStart> col < imagewidth && colb < imagew
<S2SV_ModStart> col < imagewidth && colb < imagew
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpContig2SeparateByRow" ) ; return 0 ; }
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpSeparate2ContigByRow" ) ; return 0 ; }
<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
<S2SV_ModStart> { uint16 bitspersample = 1
<S2SV_ModStart> "(cc0%rowsize)!=0" ) ; _TIFFfree ( working_copy ) ;
<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> uint8 * tmp <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> int outskew , int64 <S2SV_ModEnd> inskew ) {
<S2SV_ModStart> in ) ; int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> tilew ; uint8 <S2SV_ModStart> if ( colb > iskew <S2SV_ModEnd> ) { uint32
<S2SV_ModStart> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> 0 ) ; }
<S2SV_ModStart> char * buffer , tsize_t buffersize <S2SV_ModStart> case 0xd8 : if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> 0 ) { if ( * bufferoffset + datalen + 2 + 6 > buffersize ) return ( 0 ) ; <S2SV_ModStart> datalen + 2 ) ; if ( * bufferoffset + 9 >= buffersize ) return ( 0 <S2SV_ModStart> = 1 ; if ( * bufferoffset + 11 + 3 * ( ncomp - 1 ) >= buffersize ) return ( 0 ) ; <S2SV_ModStart> case 0xdb : if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> 0 ) { if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> } else { if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> + 1 ; if ( * bufferoffset + * striplength - i > buffersize ) return ( 0 ) ;
<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
<S2SV_ModStart> = 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = 0 <S2SV_ModStart> ! read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; } <S2SV_ModStart> 3 ) ; } <S2SV_ModStart> buffsize ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; }
<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( "reverseSamplesBytes" , "bytes_per_pixel<S2SV_blank>too<S2SV_blank>large" ) ; return ( 1 ) ; }
<S2SV_ModStart> } bufp += stripsize <S2SV_ModEnd> ; } return
<S2SV_ModStart> uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField (
<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
<S2SV_ModStart> ; } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "readContigTilesIntoBuffer" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size." ) ; exit ( - 1 ) ; } <S2SV_ModStart> _TIFFmalloc ( tile_buffsize + 3 <S2SV_ModStart> 0 ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] =
<S2SV_ModStart> if ( count > <S2SV_ModEnd> 4 ) {
<S2SV_ModStart> 1 ) { if ( code >= clear ) { fprintf ( stderr , "bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n" , code , clear ) ; return 0 ; }
<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> LARGE_INTEGER offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ) ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & offset <S2SV_ModStart> ( ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> Information = 0 ; } TCfree ( readBuffer )
<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
<S2SV_ModStart> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
<S2SV_ModStart> j ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ) ; } }
<S2SV_ModStart> ( a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> else if ( a -> type == szMAPI_BINARY &&
<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> "checked_xcalloc" , ( res <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( "checked_xmalloc" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,
<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; <S2SV_ModEnd> ptr = malloc <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if <S2SV_ModStart> '\\0' , ( res <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> = malloc ( res <S2SV_ModEnd> ) ; if
<S2SV_ModStart> start ; char * b64 = malloc ( <S2SV_ModEnd> len + 1 <S2SV_ModStart> len + 1 ) ; if ( ! b64 ) return VLC_EGENERIC <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> & p_orig , b64 ) ; free (
<S2SV_ModStart> MP4_READBOX_ENTER ( MP4_Box_data_string_t ) ; if ( p_box -> i_size < 8 || p_box -> i_size > SIZE_MAX ) MP4_READBOX_EXIT ( 0
<S2SV_ModStart> 5 ) ; if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ;
<S2SV_ModStart> return ; } if ( check_secure ( ) ) return ;
<S2SV_ModStart> != NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }
<S2SV_ModStart> ( _ ( "E145:<S2SV_blank>Shell<S2SV_blank>commands<S2SV_blank>and<S2SV_blank>some<S2SV_blank>functionality<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim" <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> endif if ( restricted != 0 && ( ea . argt & RESTRICT ) ) { errormsg = _ ( "E981:<S2SV_blank>Command<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>rvim" ) ; goto doend ; } if (
<S2SV_ModStart> ( vt ) ; if ( state == NULL ) return NULL
<S2SV_ModStart> VTermState ) ) ; if ( state == NULL ) return NULL
<S2SV_ModStart> } } } <S2SV_ModEnd> vterm_allocator_free ( screen
<S2SV_ModStart> = new_cols ; <S2SV_ModEnd> vterm_allocator_free ( screen
<S2SV_ModStart> ; if ( state == NULL <S2SV_ModEnd> ) return NULL <S2SV_ModStart> VTermScreen ) ) ; if ( screen == NULL ) return NULL <S2SV_ModStart> cols ) ; if ( screen -> buffer == NULL || screen -> sb_buffer == NULL ) { vterm_screen_free ( screen ) ; return NULL ; }
<S2SV_ModStart> ] ) ; <S2SV_ModEnd> vterm_allocator_free ( screen
<S2SV_ModStart> ptr ) { if ( ptr )
<S2SV_ModStart> allocdata ) ; if ( vt == NULL ) return NULL ; <S2SV_ModStart> strbuffer_len ) ; if ( vt -> parser . strbuffer == NULL ) { vterm_allocator_free ( vt , vt ) ; return NULL ; } <S2SV_ModStart> outbuffer_len ) ; if ( vt -> outbuffer == NULL ) { vterm_allocator_free ( vt , vt -> parser . strbuffer ) ; vterm_allocator_free ( vt , vt ) ; return NULL ; }
<S2SV_ModStart> b_p_keymap ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; else <S2SV_ModStart> gui_mch_set_rendering_options ( p_rop ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_AUTOCMD else if ( gvarp == & p_ft ) { if ( ! valid_filetype ( * varp ) ) errmsg = e_invarg ; } # endif # ifdef FEAT_SYN_HL else if ( gvarp == & p_syn ) { if ( ! valid_filetype ( * varp
<S2SV_ModStart> ( bt_terminal ( curwin <S2SV_ModEnd> -> w_buffer )
<S2SV_ModStart> = family ; <S2SV_ModEnd> memcpy ( &
<S2SV_ModStart> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> NULL ) { if <S2SV_ModEnd> ( errno == <S2SV_ModStart> == ENOMEM ) <S2SV_ModEnd> log_warn ( "lldp" <S2SV_ModStart> , "unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>" "for<S2SV_blank>management<S2SV_blank>address" ) ; else log_warn ( "lldp" , "too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>" "received<S2SV_blank>on<S2SV_blank>%s" , hardware -> h_ifname
<S2SV_ModStart> = family ; <S2SV_ModEnd> memcpy ( &
<S2SV_ModStart> m_family ) ; if ( proto == LLDP_MGMT_ADDR_NONE ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> NULL ) { if <S2SV_ModEnd> ( errno == <S2SV_ModStart> == ENOMEM ) <S2SV_ModEnd> log_warn ( "lldp" <S2SV_ModStart> , "unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>" "for<S2SV_blank>management<S2SV_blank>address" ) ; else log_warn ( "lldp" , "too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>" "received<S2SV_blank>on<S2SV_blank>%s" , hardware -> h_ifname
<S2SV_ModStart> = PEEK_UINT8 ; if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( "lldp" , "too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s" , hardware -> h_ifname ) ; goto malformed ; } <S2SV_ModStart> : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) <S2SV_ModEnd> , "Organisational" )
<S2SV_ModStart> return 0 ; struct html_renderopt * options = opaque ; <S2SV_ModStart> "<q>" ) ; if ( options -> flags & HTML_ESCAPE ) escape_html ( ob , text -> data , text -> size ) ; else
<S2SV_ModStart> 0 ) { if ( strlen ( p ) > 8 ) { <S2SV_ModStart> } else { cli_dbgmsg ( "Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n" ) ; } } else {
<S2SV_ModStart> if ( ( strlen ( ptr ) > 2 ) && (
<S2SV_ModStart> case LZX_BLOCKTYPE_UNCOMPRESSED : if ( window_posn + this_run > lzx -> window_size ) { D ( ( "match<S2SV_blank>ran<S2SV_blank>over<S2SV_blank>window<S2SV_blank>boundary" ) ) return lzx -> error = MSPACK_ERR_DECRUNCH ; }
<S2SV_ModStart> -> sys ; if ( lzx -> inbuf ) <S2SV_ModStart> inbuf ) ; if ( lzx -> window )
<S2SV_ModStart> mem ) { if ( mem ) { <S2SV_ModStart> mem ) ; mem = NULL ; } return ;
<S2SV_ModStart> 8 ) ; if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva , 4 ) || ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , wwsect + 0x295 + sects [ scount ] . rva + 0x299 , 4 ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>unpack<S2SV_blank>memory<S2SV_blank>address<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds.\\n" ) ; return CL_EFORMAT ; }
<S2SV_ModStart> int i , j , <S2SV_ModStart> overlays = 0 , rescan = 1 <S2SV_ModStart> falign , hdr_size <S2SV_ModEnd> ; struct cli_exe_section <S2SV_ModStart> ; # endif while ( rescan == 1 ) { rescan = 0 ; <S2SV_ModStart> ++ ) { exe_sections [ i ] . rva = PEALIGN ( EC32 ( section_hdr [ i ] . VirtualAddress ) , valign ) ; exe_sections [ i ] . vsz = PESALIGN ( EC32 ( section_hdr [ i ] . VirtualSize ) , valign ) ; exe_sections [ i ] . raw = PEALIGN ( EC32 ( section_hdr [ i ] . PointerToRawData ) , falign ) ; exe_sections [ i ] . rsz = PESALIGN ( EC32 ( section_hdr [ i ] . SizeOfRawData ) , falign ) ; exe_sections [ i ] . chr = EC32 ( section_hdr [ i ] . Characteristics ) ; exe_sections [ i ] . urva = EC32 ( section_hdr [ i ] . VirtualAddress ) ; exe_sections [ i ] . uvsz = EC32 ( section_hdr [ i ] . VirtualSize ) ; exe_sections [ i ] . uraw = EC32 ( section_hdr [ i ] . PointerToRawData ) ; exe_sections [ i ] . ursz = EC32 ( section_hdr [ i ] . SizeOfRawData ) ; if ( exe_sections [ i ] . rsz ) { if ( ! CLI_ISCONTAINED ( 0 , fsize , exe_sections [ i ] . uraw , exe_sections [ i ] . ursz ) || exe_sections [ i ] . raw >= fsize ) { cli_dbgmsg ( "Broken<S2SV_blank>PE<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>%d<S2SV_blank>starts<S2SV_blank>or<S2SV_blank>exists<S2SV_blank>beyond<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>(Offset@<S2SV_blank>%lu,<S2SV_blank>Total<S2SV_blank>filesize<S2SV_blank>%lu)\\n" , i , ( unsigned long ) exe_sections [ i ] . raw , ( unsigned long ) fsize ) ; if ( nsections == 1 ) { free ( section_hdr ) ; free ( exe_sections ) ; if ( DETECT_BROKEN_PE ) { cli_append_virus ( ctx , "Heuristics.Broken.Executable" ) ; return CL_VIRUS ; } return CL_CLEAN ; } for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & exe_sections [ j ] , & exe_sections [ j + 1 ] , sizeof ( struct cli_exe_section ) ) ; for ( j = i ; j < nsections - 1 ; j ++ ) memcpy ( & section_hdr [ j ] , & section_hdr [ j + 1 ] , sizeof ( struct pe_image_section_hdr ) ) ; nsections -- ; rescan = 1 ; break ; } } } } for ( i = 0 ; i < nsections ; i ++ ) { <S2SV_ModStart> ] = 0 <S2SV_ModEnd> ; # if <S2SV_ModStart> rsz ) { <S2SV_ModEnd> if ( SCAN_ALGO
<S2SV_ModStart> ( length > 1 <S2SV_ModEnd> ) { if
<S2SV_ModStart> int i , old_length_chars , <S2SV_ModStart> prefix ) return ; old_length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 <S2SV_ModStart> } } } length_chars = ( server -> prefix_chars ) ? strlen ( server -> prefix_chars ) : 0 ; if ( server -> prefix_chars && ( length_chars != old_length_chars ) ) irc_nick_realloc_prefixes ( server , old_length_chars , length_chars ) ;
<S2SV_ModStart> chanmode ) { if ( ! chanmode_found ) { <S2SV_ModStart> } } } }
<S2SV_ModStart> mask2 , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const char <S2SV_ModStart> = NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> return NULL ; length = strlen ( mask <S2SV_ModEnd> ) + 256 <S2SV_ModStart> + 1 ; mask2 <S2SV_ModEnd> = malloc ( <S2SV_ModStart> if ( ! mask2 <S2SV_ModEnd> ) goto end <S2SV_ModStart> seconds ) ; mask2 <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> = '\\0' ; if ( strftime ( mask2 <S2SV_ModEnd> , length - <S2SV_ModStart> - 1 , mask <S2SV_ModEnd> , date_tmp ) <S2SV_ModStart> , date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , "\\01" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , "\\\\" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , "\\01" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> ) weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; if <S2SV_ModStart> , mask , mask7 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; if ( mask3 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free ( <S2SV_ModStart> ) free ( mask6 <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return mask7 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> ) { int pkt_len ; int <S2SV_ModStart> 2 ] ; <S2SV_ModEnd> char cap_src [ <S2SV_ModStart> = 0 ; int <S2SV_ModEnd> offset = 0 <S2SV_ModStart> ( line , "%9d.%9d:<S2SV_blank>%15[a-z0-9/:.-](%1[io])<S2SV_blank>len=%9d:%12s->%12s/" <S2SV_ModEnd> , & sec <S2SV_ModStart> return - 1 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "netscreen:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length" ) ; return FALSE
<S2SV_ModStart> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
<S2SV_ModStart> = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
<S2SV_ModStart> int num_items_scanned ; int pkt_len , <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , "LEN=%9d" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> g_strdup ( "toshiba:<S2SV_blank>OFFSET<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>valid<S2SV_blank>LEN<S2SV_blank>item" ) ; return FALSE ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "toshiba:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length"
<S2SV_ModStart> int num_items_scanned ; guint pkt_len ; int <S2SV_ModEnd> pktnum , hr <S2SV_ModStart> + 64 , "LEN=%9u" <S2SV_ModEnd> , & pkt_len <S2SV_ModStart> FALSE ; } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "toshiba:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } <S2SV_ModStart> ( buf , pkt_len <S2SV_ModEnd> ) ; pd
<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; if <S2SV_ModStart> FALSE ; } return parse_netscreen_packet ( wth -> random_fh , phdr , buf <S2SV_ModEnd> , line , <S2SV_ModStart> , line , <S2SV_ModEnd> err , err_info <S2SV_ModStart> err_info ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ; c_t = ( <S2SV_ModStart> , 4 ) + 1 ) % 0xf <S2SV_ModStart> ] = c_t <S2SV_ModEnd> ; macinf -> <S2SV_ModStart> lchId_type_table [ c_t <S2SV_ModEnd> ] ; rlcinf <S2SV_ModStart> lchId_rlc_map [ c_t <S2SV_ModEnd> ] ; }
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
<S2SV_ModStart> sec , csec , <S2SV_ModEnd> pkt_len ; int <S2SV_ModStart> ( line , "%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" <S2SV_ModEnd> , & yy <S2SV_ModStart> ( line , "%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9d,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" <S2SV_ModEnd> , direction , <S2SV_ModStart> csec = 0 ; } if ( pkt_len < 0 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>packet<S2SV_blank>header<S2SV_blank>has<S2SV_blank>a<S2SV_blank>negative<S2SV_blank>packet<S2SV_blank>length" ) ; return FALSE
<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> } if ( ( <S2SV_ModStart> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len <S2SV_ModStart> sizeof ( EAPOL_RSN_KEY )
<S2SV_ModStart> { gint64 offset <S2SV_ModEnd> ; char line <S2SV_ModStart> = offset ; return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> -> phdr , <S2SV_ModEnd> wth -> frame_buffer <S2SV_ModStart> wth -> frame_buffer , line
<S2SV_ModStart> err_info ) { <S2SV_ModEnd> char line [ <S2SV_ModStart> FALSE ; } return parse_cosine_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> , phdr , buf , line <S2SV_ModEnd> , err ,
<S2SV_ModStart> rng ) { return wc_SignatureGenerateHash_ex ( hash_type , sig_type , hash_data , hash_len , sig , sig_len <S2SV_ModEnd> , key , <S2SV_ModStart> key , key_len , rng , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> rng ) { return wc_SignatureGenerate_ex ( hash_type , sig_type <S2SV_ModEnd> , data , <S2SV_ModStart> , data_len , sig , <S2SV_ModEnd> sig_len , key <S2SV_ModStart> key_len , rng , 1 <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; } ( * psig ) = s + <S2SV_ModEnd> padlen + 3 <S2SV_ModStart> + 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return "4" "invalid<S2SV_blank>Padding<S2SV_blank>String" ; } <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> job ) , "%s" ,
<S2SV_ModStart> ctx , expr -> unary . child
<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
<S2SV_ModStart> ; if ( ! str ) return false ; if (
<S2SV_ModStart> ( s ) && ! eof ( s )
<S2SV_ModStart> LAST_KEYMAP_FILE_TYPE ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , "Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n" ) ; } else { <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> , pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> return false ; <S2SV_ModEnd> i = 0 <S2SV_ModStart> ; } } }
<S2SV_ModStart> NULL ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_ARRAY_REF <S2SV_ModStart> . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
<S2SV_ModStart> } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> ) ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> ; return ; } <S2SV_ModStart> ( page && page_name_is_good ( page ) && <S2SV_ModStart> if ( page && page_name_is_good ( page )
<S2SV_ModStart> len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> DEBUG ( "accept,<S2SV_blank>" <S2SV_ModStart> continue ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( ( <S2SV_ModStart> = accept ( serve -> socket <S2SV_ModEnd> , ( struct <S2SV_ModStart> continue ; } handle_connection ( servers , net , serve , NULL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , "%u" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"<S2SV_blank>enctype=\\"application/x-www-form-urlencoded\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if
<S2SV_ModStart> 3 ) ; # if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , "check_flag" ) ; lua_newtable ( L ) ; auxiliar_enumerate ( L , - 1 , check_flags_const ) ; lua_settable ( L , - 3 ) ; # endif
<S2SV_ModStart> "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
<S2SV_ModStart> = NULL ; char * error_str = NULL ; char * error_description = NULL ; <S2SV_ModStart> } else { if ( oidc_validate_post_logout_url ( r , url , & error_str , & error_description ) == FALSE ) { <S2SV_ModEnd> return oidc_util_html_send_error ( <S2SV_ModStart> -> error_template , error_str , error_description , HTTP_BAD_REQUEST <S2SV_ModEnd> ) ; }
<S2SV_ModStart> else if ( ( uri . hostname == NULL ) && ( <S2SV_ModStart> != url ) )
