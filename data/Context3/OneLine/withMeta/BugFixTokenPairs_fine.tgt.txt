<S2SV_ModStart> client_path ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
<S2SV_ModStart> ; } } cleanup : <S2SV_ModEnd> return res ;
<S2SV_ModStart> = tpm_kdfa ( <S2SV_ModEnd> session -> authHash
<S2SV_ModStart> += 2 ; if ( i + 1 < data_size )
<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
<S2SV_ModStart> ( parserTestSuite , "Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
<S2SV_ModStart> ipc == NULL && client -> session == NULL
<S2SV_ModStart> ( fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n" <S2SV_ModEnd> , & n
<S2SV_ModStart> ++ len ) { <S2SV_ModStart> == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = (
<S2SV_ModStart> str ) ; <S2SV_ModEnd> g_string_free ( result
<S2SV_ModStart> ( ret = ff_set_dimensions ( avctx , <S2SV_ModEnd> s -> width <S2SV_ModStart> s -> height <S2SV_ModEnd> ) ) <
<S2SV_ModStart> ; if ( <S2SV_ModEnd> av_strstart ( proto_name <S2SV_ModStart> ( proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> , NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA ;
<S2SV_ModStart> == 8 ) && c -> format != CHUNKY
<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> } if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> -> filesize = UINT64_MAX <S2SV_ModEnd> ; s ->
<S2SV_ModStart> -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for (
<S2SV_ModStart> -> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (
<S2SV_ModStart> size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> ; if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; } if (
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> ; sc -> drefs_count = 0 ; sc ->
<S2SV_ModStart> , * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> pb ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> g ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> 0 ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ; if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> c -> tile_width <S2SV_ModEnd> , 16 ) <S2SV_ModStart> , 16 ) * 3
<S2SV_ModStart> } if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , "No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n" ) ; return AVERROR ( EINVAL ) ; } if (
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> frame -> color_primaries <S2SV_ModStart> frame -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if
<S2SV_ModStart> <= w - ( int )
<S2SV_ModStart> 8 ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , "Block<S2SV_blank>parameters<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
<S2SV_ModStart> avctx -> width || <S2SV_ModEnd> s -> height
<S2SV_ModStart> ; if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> cblk_style & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
<S2SV_ModStart> AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> item_num > 65536 || item_num < 0
<S2SV_ModStart> ; if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ; if (
<S2SV_ModStart> , size2 , NULL <S2SV_ModEnd> ) ; if
<S2SV_ModStart> 0 ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
<S2SV_ModStart> s ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> av_log ( mxf -> fc
<S2SV_ModStart> cur_pic . field_picture <S2SV_ModEnd> ) return 0
<S2SV_ModStart> ; frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> studio_profile ) { <S2SV_ModEnd> if ( !
<S2SV_ModStart> ; if ( * value == 0 ||
<S2SV_ModStart> * ptrptr && <S2SV_ModEnd> nmemb && size <S2SV_ModStart> nmemb && size <S2SV_ModEnd> ) return AVERROR
<S2SV_ModStart> 100 ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> pixels ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> pts == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
<S2SV_ModStart> s ) { int64_t <S2SV_ModEnd> hours , minutes
<S2SV_ModStart> bpp <= 8 && c -> format != CHUNKY
<S2SV_ModStart> in -> data [ plane ] && in -> linesize
<S2SV_ModStart> src -> data [ plane ] && src -> linesize
<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> [ p ] && in -> linesize [ p ]
<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]
<S2SV_ModStart> [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> [ i ] && out -> linesize [ i ]
<S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> in -> data [ plane ] && in -> linesize
<S2SV_ModStart> , y ; av_assert0 ( s -> bit_depth > 1 ) ;
<S2SV_ModStart> ] ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;
<S2SV_ModStart> < width + 4 <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
<S2SV_ModStart> timescale > UINT16_MAX || ! track -> par -> channels
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea ( bgp
<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
<S2SV_ModStart> ; rc = foreach_shareopt <S2SV_ModEnd> ( shareopts ,
<S2SV_ModStart> ( SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
<S2SV_ModStart> credssp ) ; rdp -> nego -> transport -> credssp = NULL ;
<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> credssp ) ; transport -> credssp = NULL ;
<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> ( ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> wmac ) ; if ( ! <S2SV_ModStart> , rdp ) ) return FALSE
<S2SV_ModStart> rdp ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
<S2SV_ModStart> UINT32 nsc_rle_encode ( const
<S2SV_ModStart> = conn ; <S2SV_ModEnd> g_debug ( "GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s"
<S2SV_ModStart> ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> channel ) ; <S2SV_ModEnd> set_description ( client
<S2SV_ModStart> < 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity
<S2SV_ModStart> input -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1
<S2SV_ModStart> ) ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,
<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ; if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count ,
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> p == q ) || ( <S2SV_ModEnd> size < 16 <S2SV_ModStart> size < 16 ) || ( <S2SV_ModEnd> size > 256 <S2SV_ModStart> size > 256 )
<S2SV_ModStart> ] . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> MagickCoreSignature ) ; pixel = 0 ;
<S2SV_ModStart> pixel_info ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> AcquireQuantumMemory ( pixels_length + image -> rows
<S2SV_ModStart> "`%s\'" , option ) ; page_geometry = DestroyString ( page_geometry
<S2SV_ModStart> ( packets + 257UL <S2SV_ModEnd> , image ->
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { for
<S2SV_ModStart> maptype ) { case RMT_NONE : break ;
<S2SV_ModStart> Rec . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> 0 ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
<S2SV_ModStart> != EOF ) if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
<S2SV_ModStart> } if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> ) length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> "UnableToReadImageData" ) ; }
<S2SV_ModStart> options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> length = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" )
<S2SV_ModStart> 6 ) ) { MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> "ImproperImageHeader" ) ; }
<S2SV_ModStart> image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> ( void ) strncpy <S2SV_ModEnd> ( clone_info ->
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
<S2SV_ModStart> 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> ; x += 4 <S2SV_ModEnd> ) { index
<S2SV_ModStart> size_t ) ldblk + 1
<S2SV_ModStart> ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel * sizeof
<S2SV_ModStart> size_t ) count + 1
<S2SV_ModStart> ReadBlobMSBShort ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> name , MaxTextExtent - 1
<S2SV_ModStart> image ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )

<S2SV_ModStart> = 1.0f / MagickMax ( w . x , MagickMax <S2SV_ModEnd> ( w .
<S2SV_ModStart> MagickFalse ; } return ( <S2SV_ModStart> dds_info , 4 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> MagickFalse ; } return ( <S2SV_ModStart> dds_info , 3 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> if ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
<S2SV_ModStart> ) / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> ( ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> image , q ) , exception
<S2SV_ModStart> ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> { MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
<S2SV_ModStart> ReadBlobLSBLong ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> read_info ) ; <S2SV_ModEnd> if ( EOFBlob
<S2SV_ModStart> , sizeof ( double <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } if (
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> height ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ; if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> "`%s\'" , option ) ; geometry = DestroyString ( geometry
<S2SV_ModStart> ; if ( <S2SV_ModEnd> g_path_is_absolute ( filename
<S2SV_ModStart> [ i ] ) ; log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf
<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
<S2SV_ModStart> ) >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> attr >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> * ue ; if <S2SV_ModEnd> ( tree_root == <S2SV_ModStart> == NULL ) return 0
<S2SV_ModStart> return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
<S2SV_ModStart> , xmi_data , xmi_size ,

<S2SV_ModStart> M_fs_error_t res ; <S2SV_ModEnd> res = M_fs_file_open
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
<S2SV_ModStart> -> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN
<S2SV_ModStart> ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
<S2SV_ModStart> sec_attr == NULL || sec_attr_len
<S2SV_ModStart> ; bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> } bufsize = MIN ( <S2SV_ModStart> file -> size , sizeof buf )
<S2SV_ModStart> len = file && file -> size > 0
<S2SV_ModStart> SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ( ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> t1_buf_array , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; }
<S2SV_ModStart> "<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x" ) ; assert_regexp_syntax_error ( "\\\\x0" ) ; assert_regexp_syntax_error ( "\\\\x" ) ; assert_regexp_syntax_error ( "\\\\xxy" ) ;
<S2SV_ModStart> 2 ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> -> length , 0 ,
<S2SV_ModStart> target ) , 0 ,
<S2SV_ModStart> re_ast ) -> levels = 0 ; ( * re_ast ) ->
<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
<S2SV_ModStart> otp_id ) ; fclose ( opwfile ) ;
<S2SV_ModStart> path ) ; unlink ( path ) ; <S2SV_ModStart> | O_CREAT | O_EXCL <S2SV_ModEnd> , 0600 )
<S2SV_ModStart> , fsuid , <S2SV_ModEnd> NULL ) ;
<S2SV_ModStart> ( path , g_settings_privatereports ? 0 :
<S2SV_ModStart> 400 ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( "abrt" ) ; if ( ! gr ) { error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; return 403 ; } } else
<S2SV_ModStart> = 0 ; value = get_map_string_item_or_NULL ( settings , "PrivateReports" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , "PrivateReports" ) ; }
<S2SV_ModStart> struct dump_dir * dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else
<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> ( dest_filename , "wx" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> g_tv_comment , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0
<S2SV_ModStart> dd ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> == GTK_RESPONSE_OK ) { <S2SV_ModStart> item_name ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }
<S2SV_ModStart> O_APPEND | O_CREAT | O_NOFOLLOW
<S2SV_ModStart> int pidfd = open ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC <S2SV_ModEnd> , S_IRUSR |
<S2SV_ModStart> ( filepath , "r" <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; file = fopen_safe <S2SV_ModEnd> ( "/tmp/keepalived.json" ,
<S2SV_ModStart> ( tf = fopen_safe <S2SV_ModEnd> ( tfile ->
<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( dump_file ,
<S2SV_ModStart> ; log_file = fopen_safe <S2SV_ModEnd> ( file_name ,
<S2SV_ModStart> O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW
<S2SV_ModStart> ) ; return 0
<S2SV_ModStart> vrrp_rx_bufs_multiples ) ; conf_write ( fp , "<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o" , global_data -> umask ) ;
<S2SV_ModStart> ; # endif install_keyword ( "umask" , & umask_handler ) ;
<S2SV_ModStart> "<S2SV_blank><S2SV_blank>-G,<S2SV_blank>--no-syslog<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Don\'t<S2SV_blank>log<S2SV_blank>via<S2SV_blank>syslog\\n" ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n" ) ;
<S2SV_ModStart> ( ) ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; }
<S2SV_ModStart> <= * len && plen > 0
<S2SV_ModStart> - 2 ; if ( plen < 0 ) return 0 ;
<S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , MAXALIGN
<S2SV_ModStart> 0 , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."
<S2SV_ModStart> lua_newtable ( L ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"
<S2SV_ModStart> len ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array" ) ;
<S2SV_ModStart> len = 0 ; luaL_checkstack ( L , 3 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map" )
<S2SV_ModStart> ++ ) { luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_check" ) ;
<S2SV_ModStart> . left ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_unpack_full" ) ;
<S2SV_ModStart> 0 ) { int class = <S2SV_ModEnd> getClientTypeByName ( v <S2SV_ModStart> j ] ) ; if ( class <S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER
<S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER ) { err = "Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>" "an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits." <S2SV_ModEnd> ; goto loaderr
<S2SV_ModStart> -> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break ;
<S2SV_ModStart> o == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> tf = ( <S2SV_ModEnd> luaY_parser ) (
<S2SV_ModStart> "verify-client" ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ;
<S2SV_ModStart> "localhost." ) || <S2SV_ModEnd> ! strcmp (
<S2SV_ModStart> ; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer ,
<S2SV_ModStart> cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table ) ;
<S2SV_ModStart> cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
<S2SV_ModStart> in ) && ( alloc > 2 ) &&
<S2SV_ModStart> = alloc ; size_t <S2SV_ModEnd> strindex = 0
<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> ui -> ft_in_start && bu
<S2SV_ModStart> , strlen ( cp <S2SV_ModEnd> ) - 1
<S2SV_ModStart> SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> uint8_t * outbuf <S2SV_ModStart> uint8_t * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch (
<S2SV_ModStart> scsi_disk_emulate_command ( r <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; if ( pMap -> ranges == NULL ) { LOGE ( "malloc<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
<S2SV_ModStart> fn ) ; fclose ( mapf ) ;
<S2SV_ModStart> ; stbbr_send ( "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>" <S2SV_ModEnd> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>" "<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"
<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
<S2SV_ModStart> OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
<S2SV_ModStart> client_p , "Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , "Malformed<S2SV_blank>AUTHENTICATE"
<S2SV_ModStart> -> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
<S2SV_ModStart> ++ ; } if ( pattern [ end ] == 0 ) break ;
<S2SV_ModStart> = Mymr_C_VIRAMA ; if ( len > 0 )
<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> -> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> endif if ( ctxt -> instate == XML_PARSER_EOF ) return ; if (
<S2SV_ModStart> -> window , window_width , window_height <S2SV_ModEnd> ) ; evas_object_show
<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
<S2SV_ModStart> * aVTrans ; sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> ) * ( ( sqlite3_int64 )
<S2SV_ModStart> ( sz * ( sqlite3_int64 )
<S2SV_ModStart> ( 2 * ( sqlite3_int64 )
<S2SV_ModStart> * pNew ; sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc <S2SV_ModEnd> + nExtra ;
<S2SV_ModStart> ] ) { sqlite3_int64 <S2SV_ModEnd> nAlloc = ( <S2SV_ModStart> ( pIn ? 2 * ( sqlite3_int64 ) pIn [ 0 ] <S2SV_ModEnd> : 10 )
<S2SV_ModStart> . aMemory ; sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> pSorter -> nMemory <S2SV_ModStart> pSorter -> nMemory <S2SV_ModEnd> ; while (
<S2SV_ModStart> pWith ) { sqlite3_int64 <S2SV_ModEnd> nByte = sizeof
<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while
<S2SV_ModStart> -> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
<S2SV_ModStart> { while ( ( len > 0 ) && ( <S2SV_ModStart> == 0x20 ) )
<S2SV_ModStart> = info_ptr ; if ( info_ptr == NULL ) return ;
<S2SV_ModStart> ; if ( ctxt -> error ) return ; if (
<S2SV_ModStart> ( buffer , i +
<S2SV_ModStart> if ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> 3 , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
<S2SV_ModStart> -> stratum_port ; snprintf ( address , 254 <S2SV_ModEnd> , "%s:%s" ,
<S2SV_ModStart> == * ptr && ptr [ 1 ]
<S2SV_ModStart> ( ) ; errors += test_float_formatting ( ) ;
<S2SV_ModStart> len -= cut + 1
<S2SV_ModStart> > SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
<S2SV_ModStart> if ( prefixlen <= <S2SV_ModEnd> len ) {
<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> ) ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
<S2SV_ModStart> case NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :
<S2SV_ModStart> NPNVSupportsWindowless ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> NPPVformValue ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> int i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> NULL ; static size_t <S2SV_ModEnd> len = 0
<S2SV_ModStart> && str [ j <S2SV_ModEnd> ] ; i
<S2SV_ModStart> } if ( strlen ( token ) > 4 &&
<S2SV_ModStart> fs -> clusters + <S2SV_ModEnd> 1 ) get_fat
<S2SV_ModStart> . security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
<S2SV_ModStart> ; dname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
<S2SV_ModStart> -> entries = safe_calloc ( <S2SV_ModEnd> xref -> n_entries
<S2SV_ModStart> ; daddy = safe_calloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; buf = safe_calloc <S2SV_ModEnd> ( sz +
<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> , port , server -> connrec -> address ,
<S2SV_ModStart> ; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
<S2SV_ModStart> size_t chanmap_size = SF_MIN ( <S2SV_ModStart> sf . channels , layout_tag & 0xffff )
<S2SV_ModStart> 10 ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ; }
<S2SV_ModStart> } else { strcpy <S2SV_ModEnd> ( result , <S2SV_ModStart> result , "undefined" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_ModStart> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; }
<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;
<S2SV_ModStart> -> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec ->
<S2SV_ModStart> ; if ( <S2SV_ModEnd> i_status != OK
<S2SV_ModStart> } } } <S2SV_ModEnd> } else {
<S2SV_ModStart> -> pu4_wts_ofsts_mat ; ps_dec -> u4_first_slice_in_pic = 0 ;
<S2SV_ModStart> u4_first_slice_in_pic = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1
<S2SV_ModStart> ; WORD32 ret <S2SV_ModEnd> ; ps_dec ->
<S2SV_ModStart> buflen , buf_size - 8
<S2SV_ModStart> IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
<S2SV_ModStart> -> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps = 0
<S2SV_ModStart> * ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t *
<S2SV_ModStart> return ret ; if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } }
<S2SV_ModStart> = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;
<S2SV_ModStart> ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> ps_cur_mb_info ) ; if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> END_OF_MMCO ) { if ( j >= MAX_REF_BUFS ) { ALOGE ( "b/25818142" ) ; android_errorWriteLog ( 0x534e4554 , "25818142" ) ; ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; }
<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm ->
<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_dec ->
<S2SV_ModStart> -> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> -> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm ->
<S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } if
<S2SV_ModStart> ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk
<S2SV_ModStart> u1_first_byte ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }
<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
<S2SV_ModStart> 16 ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
<S2SV_ModStart> ) ) ; memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ;
<S2SV_ModStart> -> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type = P_SLICE
<S2SV_ModStart> 0 ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
<S2SV_ModStart> ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; }
<S2SV_ModStart> pv_parse_tu_coeff_data ; } <S2SV_ModEnd> if ( u1_slice_type
<S2SV_ModStart> = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
<S2SV_ModStart> 128 , size + EXTRA_BS_OFFSET
<S2SV_ModStart> , * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> { ps_dec ->
<S2SV_ModStart> cu_qp_delta_abs ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
<S2SV_ModStart> 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> { ps_codec -> <S2SV_ModEnd> pu1_inp_bitsbuf += (
<S2SV_ModStart> max_dpb_size ++ ; ps_codec -> i4_max_dpb_size = max_dpb_size ;
<S2SV_ModStart> } else { ret = <S2SV_ModStart> ps_slice_hdr ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; }
<S2SV_ModStart> { ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; ps_codec ->
<S2SV_ModStart> u4_ofst ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; }
<S2SV_ModStart> 0 ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
<S2SV_ModStart> ; ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec ->
<S2SV_ModStart> return IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }
<S2SV_ModStart> u2_decode_header ) && ( <S2SV_ModStart> bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done )
<S2SV_ModStart> = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; } ps_dec
<S2SV_ModStart> = e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
<S2SV_ModStart> ; if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , "26070014" ) ; } if (
<S2SV_ModStart> = 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
<S2SV_ModStart> 4 ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
<S2SV_ModStart> ) == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> IVD_ERROR_NONE == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> ; while ( ( <S2SV_ModStart> ) != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> s_bit_stream . u4_offset < <S2SV_ModEnd> ps_dec -> s_bit_stream
<S2SV_ModStart> ) == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> i ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> ) ; NLSF_Q15
<S2SV_ModStart> = 0 ; ctx -> si . w = 0 ; ctx -> si . h = 0 ;
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> map = { 0 , 0 ,
<S2SV_ModStart> ; vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi .
<S2SV_ModStart> map = { 0 , 0 ,
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> void usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ) return ; if ( ! cfg -> rc_target_bitrate ) return ;
<S2SV_ModStart> , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> = RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci ->
<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( input ,
<S2SV_ModStart> pc ) { memcpy <S2SV_ModEnd> ( pc ->
<S2SV_ModStart> ] ) { memcpy <S2SV_ModEnd> ( p ,
<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q ,
<S2SV_ModStart> + 256 * gaussian <S2SV_ModEnd> ( sigma ,
<S2SV_ModStart> ( i = 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> ] = s
<S2SV_ModStart> ( i = 0 ; i < 17 ; i ++ ) s [ ( i + rows ) <S2SV_ModEnd> * pitch ]
<S2SV_ModStart> i , j ; ( void ) bothclamp
<S2SV_ModStart> ++ ) { memcpy ( dst , src , 16 ) ; <S2SV_ModEnd> src += src_stride
<S2SV_ModStart> ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride
<S2SV_ModStart> ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride
<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
<S2SV_ModStart> int source_sz , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , void
<S2SV_ModStart> mbmi ) { ( void ) mbmi ;
<S2SV_ModStart> , mb_col ; memset <S2SV_ModEnd> ( overlaps ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ; # else ( void ) flags ;
<S2SV_ModStart> yv12_mc_running_avg ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;
<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( sortlist ,
<S2SV_ModStart> . mvc ; memset <S2SV_ModEnd> ( cm ->
<S2SV_ModStart> ; } # else ( void ) cpi ; #
<S2SV_ModStart> int sse ; ( void ) cpi ; act = vpx_variance16x16 <S2SV_ModEnd> ( x ->
<S2SV_ModStart> } intra_pred_var = vpx_get_mb_ss <S2SV_ModEnd> ( x ->
<S2SV_ModStart> ib ] ; <S2SV_ModEnd> dequant_ptr = d
<S2SV_ModStart> double motion_pct ; ( void ) cpi ;
<S2SV_ModStart> . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd ->
<S2SV_ModStart> next_frame -> pcnt_motion ; ( void ) cpi
<S2SV_ModStart> vpx_codec_cx_pkt pkt ; ( void ) cpi ;
<S2SV_ModStart> double next_iiratio ; memcpy <S2SV_ModEnd> ( & local_next_frame
<S2SV_ModStart> cpi ) { ( void ) cpi ;
<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( cm ->
<S2SV_ModStart> int sse ; vpx_mse16x16 <S2SV_ModEnd> ( orig +
<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> segmentation_map ) { memcpy <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> frames_till_gf_update_due ; } memset <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> oxcf -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { LAYER_CONTEXT
<S2SV_ModStart> ; Total += vpx_mse16x16 <S2SV_ModEnd> ( src +
<S2SV_ModStart> ; # else ( void ) flags ;
<S2SV_ModStart> map ) { memcpy <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> predictor ; return vpx_get4x4sse_cs <S2SV_ModEnd> ( sptr ,
<S2SV_ModStart> ; distortion = vpx_variance16x16 <S2SV_ModEnd> ( * (
<S2SV_ModStart> ( void ) mb ; ( void )
<S2SV_ModStart> ; Total += vpx_mse16x16 <S2SV_ModEnd> ( src +
<S2SV_ModStart> 1 ) ) { Adjustment = <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> ) * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <S2SV_ModEnd> else cpi ->
<S2SV_ModStart> -> active_worst_quality ; if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; }
<S2SV_ModStart> ; var = vpx_variance16x16 <S2SV_ModEnd> ( * (
<S2SV_ModStart> fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> fullpixel ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> 2 ] ; <S2SV_ModEnd> * sr =
<S2SV_ModStart> BEST_SEG_INFO bsi ; memset <S2SV_ModEnd> ( & bsi
<S2SV_ModStart> ) ) { memset <S2SV_ModEnd> ( cpi ->
<S2SV_ModStart> cpi ) ; vpx_free <S2SV_ModEnd> ( ctx )
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> ; } # else ( void ) cfg ; ( void ) mem_loc ; #
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> ) si ; ( void ) flags ;
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> ; img -> bit_depth = 8 ; img ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_above_block_mode ( const
<S2SV_ModStart> < MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane (
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode ( const
<S2SV_ModStart> 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ tx_size
<S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> nmvc = default_nmv_context
<S2SV_ModStart> - 1 ; memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;
<S2SV_ModStart> ) cb_priv ; if ( int_fb )
<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
<S2SV_ModStart> lvl ++ ) memset <S2SV_ModEnd> ( lfi ->
<S2SV_ModStart> ( ) { <S2SV_ModEnd> once ( setup_rtcd_internal
<S2SV_ModStart> col ) { vp9_tile_set_row ( tile , cm , row ) ; vp9_tile_set_col ( tile , cm , col <S2SV_ModEnd> ) ; }

<S2SV_ModStart> ) b ; return ( int ) ( buf2 -> size - <S2SV_ModEnd> buf1 -> size <S2SV_ModStart> buf1 -> size ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * fc , vpx_reader <S2SV_ModEnd> * r )
<S2SV_ModStart> int allow_hp , vpx_reader <S2SV_ModEnd> * r )
<S2SV_ModStart> * fc , vpx_reader <S2SV_ModEnd> * r )
<S2SV_ModStart> * tx_probs , vpx_reader <S2SV_ModEnd> * r )
<S2SV_ModStart> v ; return ( v & 1 ) <S2SV_ModEnd> ? m - <S2SV_ModStart> ? m - ( <S2SV_ModStart> + 1 ) >> 1 ) <S2SV_ModEnd> : m + <S2SV_ModStart> : m + ( v >> 1 ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> vpx_free ( cr -> last_coded_q_map ) ; vpx_free ( cr
<S2SV_ModStart> double energy ; double energy_midpoint ; vpx_clear_system_state ( ) ; energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ; energy = vp9_log_block_var <S2SV_ModEnd> ( cpi , <S2SV_ModStart> , bs ) - energy_midpoint <S2SV_ModEnd> ; return clamp
<S2SV_ModStart> void write_segment_id ( vpx_writer <S2SV_ModEnd> * w ,
<S2SV_ModStart> costs , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_tree <S2SV_ModEnd> tree ) {
<S2SV_ModStart> costs , const vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_tree <S2SV_ModEnd> tree ) {
<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( & cpi
<S2SV_ModStart> { variance_node node ; memset ( & node , 0 , sizeof ( node ) )
<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( x ->
<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( ctx ->
<S2SV_ModStart> , plane , vp9_encode_block_intra <S2SV_ModEnd> , & arg
<S2SV_ModStart> plane_bsize ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ; return ; } # endif vpx_subtract_block <S2SV_ModEnd> ( bh ,
<S2SV_ModStart> void vp9_entropy_mv_init ( void
<S2SV_ModStart> int input_stats ( TWO_PASS <S2SV_ModEnd> * p ,
<S2SV_ModStart> void reset_fpf_position ( TWO_PASS <S2SV_ModEnd> * p ,
<S2SV_ModStart> { if ( is_two_pass_svc ( cpi ) <S2SV_ModEnd> ) { int
<S2SV_ModStart> i ++ ) vpx_free_frame_buffer <S2SV_ModEnd> ( & ctx
<S2SV_ModStart> -> rc ; const <S2SV_ModStart> = rc -> avg_frame_bandwidth <S2SV_ModEnd> * kf_ratio ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> rc -> source_alt_ref_pending
<S2SV_ModStart> void vp9_rc_init_minq_luts ( void ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 ) ; # endif <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> = target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
<S2SV_ModStart> int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> best_intra_mode ) {
<S2SV_ModStart> vp9_block_error_c ( const tran_low_t <S2SV_ModEnd> * coeff , <S2SV_ModStart> coeff , const tran_low_t <S2SV_ModEnd> * dqcoeff ,
<S2SV_ModStart> output ) { <S2SV_ModEnd> const int16_t *
<S2SV_ModStart> output ) { <S2SV_ModEnd> const int16_t *
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> , sizeof ( output [ 0 ] <S2SV_ModEnd> ) * length
<S2SV_ModStart> ) ) ; assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ;
<S2SV_ModStart> * segcounts , vpx_prob <S2SV_ModEnd> * segment_tree_probs )
<S2SV_ModStart> * segcounts , vpx_prob <S2SV_ModEnd> * probs )
<S2SV_ModStart> = 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ;
<S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( seg ->
<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
<S2SV_ModStart> int prob_diff_update_cost ( vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) {
<S2SV_ModStart> void vp9_write_prob_diff_update ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> * w , vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) {
<S2SV_ModStart> i ) { TWO_PASS <S2SV_ModEnd> * const twopass
<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree ,
<S2SV_ModStart> ) ; return segfeature_active <S2SV_ModEnd> ( seg ,
<S2SV_ModStart> = argv ; ( void ) plane ; ( void ) plane_bsize ; ( void ) tx_size ; <S2SV_ModStart> ! args -> <S2SV_ModEnd> eobs [ block
<S2SV_ModStart> = { x -> plane [ plane ] . eobs
<S2SV_ModStart> int i , vpx_tree <S2SV_ModEnd> tree , unsigned
<S2SV_ModStart> tokens , const vpx_tree_index <S2SV_ModEnd> * tree )
<S2SV_ModStart> void vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree , unsigned
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> void write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output ,
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> cpi ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx )
<S2SV_ModStart> ; vp9_ppflags_t flags ; vp9_zero ( flags ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args )
<S2SV_ModStart> ( ctx -> frame_workers <S2SV_ModEnd> == NULL )
<S2SV_ModStart> -> error_code ) set_error_detail ( ctx , <S2SV_ModEnd> error -> has_detail <S2SV_ModStart> detail : NULL )
<S2SV_ModStart> svc_ctx ) { SvcInternal_t <S2SV_ModEnd> * const si <S2SV_ModStart> si = ( SvcInternal_t <S2SV_ModEnd> * ) svc_ctx
<S2SV_ModStart> ) { const SvcInternal_t <S2SV_ModEnd> * const si
<S2SV_ModStart> options ) { SvcInternal_t <S2SV_ModEnd> * const si
<S2SV_ModStart> -> fn ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> ctx -> priv <S2SV_ModEnd> , ap )
<S2SV_ModStart> . get_frame ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter )
<S2SV_ModStart> . get_si ( get_alg_priv ( ctx ) <S2SV_ModEnd> , si )
<S2SV_ModStart> . set_fb_fn ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cb_get ,
<S2SV_ModStart> . cfg_set ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cfg )
<S2SV_ModStart> . get_cx_data ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter )
<S2SV_ModStart> . get_glob_hdrs ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> . get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> img_data_owner ) vpx_free <S2SV_ModEnd> ( img ->
<S2SV_ModStart> ( x ) memset <S2SV_ModEnd> ( x ,
<S2SV_ModStart> ) src_pitch ; memcpy <S2SV_ModEnd> ( dest ,
<S2SV_ModStart> ) ; } memset <S2SV_ModEnd> ( ybf ,
<S2SV_ModStart> ; ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
<S2SV_ModStart> ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\'%s\'" <S2SV_ModEnd> , name )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> stream -> ebml ) <S2SV_ModEnd> ; } #
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ; if ( stats -> file == NULL ) fatal ( "First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!" ) ; if (
<S2SV_ModStart> { int c_sz ; ( void ) _aux
<S2SV_ModStart> _aux ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
<S2SV_ModStart> # if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads ( pbi
<S2SV_ModStart> ; fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;
<S2SV_ModStart> } else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
<S2SV_ModStart> = port & USHRT_MAX <S2SV_ModEnd> ; * str
<S2SV_ModStart> ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ALOGE ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256" ) ;
<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> -> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> numSamples ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( "b/26366256" ) ; pWTIntFrame -> numSamples = 0 ; }
<S2SV_ModStart> } if ( dataSize < 0 ||
<S2SV_ModStart> * samples_per_partition ; int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> info -> stagemasks <S2SV_ModStart> -> stagemasks [ idx <S2SV_ModEnd> ] & (
<S2SV_ModStart> book -> dim && i < n
<S2SV_ModStart> goto errout ; int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; }
<S2SV_ModStart> if ( q < p ) { DPRINTF ( ( "Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n" , q , p ) ) ; goto out ; } if ( q
<S2SV_ModStart> c . len = 20 + level <S2SV_ModEnd> ) * sizeof
<S2SV_ModStart> scn , root_storage <S2SV_ModEnd> ) ) <
<S2SV_ModStart> ) { size_t tail = <S2SV_ModEnd> ( i << <S2SV_ModStart> ) + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail
<S2SV_ModStart> = FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;
<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;
<S2SV_ModStart> return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
<S2SV_ModStart> client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
<S2SV_ModStart> ; client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client ->
<S2SV_ModStart> ) ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( "Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; side_closed ( side ) ; break ; }
<S2SV_ModStart> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
<S2SV_ModStart> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> header_len > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
<S2SV_ModStart> * result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
<S2SV_ModStart> ( u8 ) , <S2SV_ModEnd> strmLen ) ;
<S2SV_ModStart> ( decContainer_t ) , 1
<S2SV_ModStart> H264SwDecMalloc ( size , 1
<S2SV_ModStart> dpbSize ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( "b/28533562" ) ; android_errorWriteLog ( 0x534e4554 , "28533562" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
<S2SV_ModStart> downmix_object_t * pDownmixer __unused <S2SV_ModStart> , bool init __unused
<S2SV_ModStart> ) pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , "63662938" ) ; return - EINVAL ; }
<S2SV_ModStart> ; if ( multiuser_get_app_id ( uid ) <S2SV_ModEnd> >= AID_APP )
<S2SV_ModStart> = "add" ; if ( uid >= AID_APP ) { return 0 ; }
<S2SV_ModStart> value ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> 1 ) ; memcpy <S2SV_ModEnd> ( m , <S2SV_ModStart> m , name , nlen + 1
<S2SV_ModStart> name ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *
<S2SV_ModStart> |= SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> obj , base -> buf , cb_data <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , NULL , <S2SV_ModEnd> data ) ;
<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *
<S2SV_ModStart> >> 2 ; if ( q + o >= e ) goto out ;
<S2SV_ModStart> size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h )
<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1
<S2SV_ModStart> ) ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf (
<S2SV_ModStart> sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> ; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
<S2SV_ModStart> conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return
<S2SV_ModStart> MT_CPTYPE_PASSSALT ) { if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( "Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } <S2SV_ModStart> . data , 16 <S2SV_ModEnd> ) ; send_auth
<S2SV_ModStart> ; if ( <S2SV_ModEnd> act_size > MT_PACKET_LEN <S2SV_ModStart> act_size > MT_PACKET_LEN - packet -> size
<S2SV_ModStart> { if ( length > MT_PACKET_LEN - <S2SV_ModStart> packet -> size <S2SV_ModEnd> ) { fprintf
<S2SV_ModStart> ; if ( data_len > MT_PACKET_LEN - 4 - <S2SV_ModStart> packet -> size <S2SV_ModEnd> ) { fprintf
<S2SV_ModStart> ( uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
<S2SV_ModStart> ( int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize -
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> { if ( 3 == <S2SV_ModStart> , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * o_column_idx
<S2SV_ModStart> , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit (
<S2SV_ModStart> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ch , seq , size << 3
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ".txt" ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> Com_Printf ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ( & t ) ; if ( tm == NULL ) return g_strdup ( "???"
<S2SV_ModStart> ; signal_remove ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
<S2SV_ModStart> read_settings ) ; signal_add ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;
<S2SV_ModStart> alternate_nick ) ; g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ;
<S2SV_ModStart> -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; } else
<S2SV_ModStart> NULL ) { flush_cmd ( ) ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( scanned
<S2SV_ModStart> return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else
<S2SV_ModStart> ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."
<S2SV_ModStart> = json_tokener_success ; if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; }
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
<S2SV_ModStart> ] ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>image<S2SV_blank>dimensions" ) ; goto done ; }
<S2SV_ModStart> ')' ) ) { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> PINC ; name_end
<S2SV_ModStart> svbranch . len + 1
<S2SV_ModStart> j ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n" ) ; return - 1 ; }
<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
<S2SV_ModStart> ctl -> pw , ".chfn"
<S2SV_ModStart> setpwnam ( pw , ".chsh"
<S2SV_ModStart> file ) ; int num = snprintf <S2SV_ModEnd> ( outfilename , <S2SV_ModStart> ( outfilename , sizeof ( outfilename ) , <S2SV_ModStart> snum ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , "maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n" ) ; return 1 ; }
<S2SV_ModStart> goto not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> e == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else
<S2SV_ModStart> code == gcode && wordlist [ key ] . index >= 0
<S2SV_ModStart> ; } } if ( * state != CCS_START )
<S2SV_ModStart> -> dmin ; if ( q >= end ) return 0 ;
<S2SV_ModStart> CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> num < 0 || num >= 256
<S2SV_ModStart> & 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
<S2SV_ModStart> 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
<S2SV_ModStart> = 0 ; last_name = 0 ;
<S2SV_ModStart> ( isspace ( ( unsigned char )
<S2SV_ModStart> ( isspace ( ( unsigned char )
<S2SV_ModStart> ) { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG )
<S2SV_ModStart> arg_val ) ; arg = ( arg != NULL ) ? arg : "" ;
<S2SV_ModStart> if ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
<S2SV_ModStart> if ( retval == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ; if ( retval
<S2SV_ModStart> 0 ] == NULL || * realms [ 0 ] ==
<S2SV_ModStart> if ( REMAIN == 0 || REMAIN
<S2SV_ModStart> ) ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
<S2SV_ModStart> ; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
<S2SV_ModStart> princ ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> params <S2SV_ModStart> params . realm ) && data_eq_string ( * c1 , "kadmin" ) && ! data_eq_string ( * c2 , "history" ) ; <S2SV_ModEnd> fail_princ : if
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> ; if ( ctx -> terminated ||
<S2SV_ModStart> = GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> ; kgctx . established = 1 ; kgctx .
<S2SV_ModStart> ( kdc_active_realm , client . princ <S2SV_ModEnd> , request ->
<S2SV_ModStart> objp ) ; * objp = NULL ;
<S2SV_ModStart> tl2 ; } * tl_data_head = NULL ;
<S2SV_ModStart> out_buf ) ; <S2SV_ModEnd> XDR_DESTROY ( &
<S2SV_ModStart> if ( REMAIN == 0 || REMAIN
<S2SV_ModStart> kret = 0 ; if ( sprinc == NULL ) return NULL
<S2SV_ModStart> ; if ( password == NULL ||
<S2SV_ModStart> + 1 ; if ( i < n_key_data - 1 ) <S2SV_ModStart> key_data [ i + 1
<S2SV_ModStart> ; } } if ( ! <S2SV_ModEnd> xdr_opaque ( xdrs <S2SV_ModStart> size ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE
<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
<S2SV_ModStart> = KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
<S2SV_ModStart> ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !
<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (
<S2SV_ModStart> errcode != 0 && state -> status == NULL ) state -> status = "UNKNOWN_REASON" <S2SV_ModEnd> ; au_state ->
<S2SV_ModStart> ; cleanup : if ( status == NULL ) status = "UNKNOWN_REASON" <S2SV_ModEnd> ; if (
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_FOR_USER" ; return code ; } <S2SV_ModEnd> code = verify_for_user_checksum
<S2SV_ModStart> ( code ) { * status = "DECODE_PA_S4U_X509_USER" ; return code ; } <S2SV_ModEnd> code = verify_s4u_x509_user_checksum
<S2SV_ModStart> = 1 ; if ( bits_left == 0 ) <S2SV_ModStart> ( 16 ) <S2SV_ModEnd> ; bits_left =
<S2SV_ModStart> if ( chunk_num >= <S2SV_ModEnd> chm -> num_chunks
<S2SV_ModStart> = create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
<S2SV_ModStart> ; if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } if (
<S2SV_ModStart> filename [ filename_size <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> == '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Path<S2SV_blank>is<S2SV_blank>absolute" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;
<S2SV_ModStart> ae ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; assert ( 0 == unlink ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( "Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here." ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ;
<S2SV_ModStart> ; if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
<S2SV_ModStart> outbuff ) - 128 <S2SV_ModEnd> ) ) {
<S2SV_ModStart> 1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
<S2SV_ModStart> ( * b + len , * avail - len <S2SV_ModEnd> , nl )
<S2SV_ModStart> AE_IFLNK ) { if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , "Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte" ) ; return ( ARCHIVE_FATAL ) ; }
<S2SV_ModStart> { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , "Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n" ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> bits == TGA_BPP_32 && <S2SV_ModEnd> tga -> alphabits
<S2SV_ModStart> tmp_im ) { gdImageDestroy <S2SV_ModEnd> ( tmp_im )
<S2SV_ModStart> char buf [ 1024 <S2SV_ModEnd> ] ; int
<S2SV_ModStart> if ( remain <= <S2SV_ModEnd> 0 ) {
<S2SV_ModStart> { if ( buffer_caret + pixel_block_size > rle_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } if (
<S2SV_ModStart> ( ) { check_file ( "heap_overflow_1.tga" ) ; check_file ( "heap_overflow_2.tga" <S2SV_ModEnd> ) ; return
<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
<S2SV_ModStart> ) off |= ( ( unsigned ) <S2SV_ModStart> ++ << 24UL )
<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; } if
<S2SV_ModStart> = line_end ; <S2SV_ModEnd> error = add_push_report_pkt
<S2SV_ModStart> error = 0 <S2SV_ModEnd> ; switch (
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
<S2SV_ModStart> filestats ) ; if ( filestats . st_size < 8 ) { printf ( "ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n" ) ; return - 1 ; }
<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; addr
<S2SV_ModStart> = htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
<S2SV_ModStart> + 2 ; ( ( <S2SV_ModStart> + 1 ] ) && ( kk < input -> length ) )
<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> } if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> ( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> , - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error
<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> , CONST_STR_LEN ( "%2f?" ) , CONST_STR_LEN ( "/?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f?" ) , CONST_STR_LEN ( "//?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
<S2SV_ModStart> return false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }
<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
<S2SV_ModStart> SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
<S2SV_ModStart> ( szFileName , pszFileName , <S2SV_ModStart> ) - 5 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; r = safe_mount <S2SV_ModEnd> ( "cgroup_root" , <S2SV_ModStart> MS_RELATIME , "size=10240k,mode=755" , root
<S2SV_ModStart> ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> NULL ) !=
<S2SV_ModStart> } ret = safe_mount ( path , destpath , "none" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ; if
<S2SV_ModStart> } if ( safe_mount <S2SV_ModEnd> ( "none" , <S2SV_ModStart> 0 , "size=100000,mode=755" , rootfs -> path ? rootfs -> mount : NULL
<S2SV_ModStart> mntent , path , rootfs -> mount
<S2SV_ModStart> mntent , path , rootfs
<S2SV_ModStart> mntent -> mnt_dir , NULL
<S2SV_ModStart> } if ( safe_mount ( console -> name , path , "none" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) ) {
<S2SV_ModStart> } if ( safe_mount ( console -> name , lxcpath , "none" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , <S2SV_ModEnd> console -> name <S2SV_ModStart> name , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , "%s/console" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( "lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console" ) ; return - 1 ; } INFO ( "console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s" , lxcpath ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> pathname = RUNTIME_PATH "/lxc/lock/var/lib/lxc/" <S2SV_ModEnd> ; ret =
<S2SV_ModStart> -> pid , fc -> uid ,
<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> if ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> if ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access ( <S2SV_ModStart> O_RDONLY ) ) <S2SV_ModEnd> return - EACCES
<S2SV_ModStart> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> 3 * len + 8
<S2SV_ModStart> return MS_FALSE ; if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , "Invalid<S2SV_blank>time<S2SV_blank>filter." , "msPostGISLayerSetTimeFilter()" ) ; return MS_FALSE ; }
<S2SV_ModStart> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ; jpc_pchg_t
<S2SV_ModStart> int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } <S2SV_ModEnd> v = 0
<S2SV_ModStart> int m ; if ( n < 0 || n >= 32 ) { return EOF ; } <S2SV_ModEnd> assert ( !
<S2SV_ModStart> numlvls > 0 && jas_seq2d_size ( a )
<S2SV_ModStart> -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> actualnumcolors = hdr

<S2SV_ModStart> ( buf = jas_alloc3 ( bufsize , numcols <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ; if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
<S2SV_ModStart> inmem ) ? jas_stream_memopen2 <S2SV_ModEnd> ( 0 ,
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble" ) ; }
<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read" ) ; }
<S2SV_ModStart> * bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write" ) ; }
<S2SV_ModStart> cnt ) { ssize_t <S2SV_ModEnd> n ; assert
<S2SV_ModStart> ) obj ; size_t <S2SV_ModEnd> newpos ; JAS_DBGLOG
<S2SV_ModStart> v |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24 )
<S2SV_ModStart> 101 , ( "jas_malloc(%zu)\\n" <S2SV_ModEnd> , size )
<S2SV_ModStart> 101 , ( "jas_realloc(%x,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , ptr ,


<S2SV_ModStart> } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n" ) ; return - 1 ; } if (

<S2SV_ModStart> size_t j ; jas_uchar <S2SV_ModEnd> * dp ;
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
<S2SV_ModStart> * jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf ,
<S2SV_ModStart> int n , jas_ulonglong <S2SV_ModEnd> val ) {
<S2SV_ModStart> 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }
<S2SV_ModStart> { jas_eprintf ( "got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n" <S2SV_ModEnd> , box ->
<S2SV_ModStart> ) ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ;
<S2SV_ModStart> unsigned int i ; bpcc -> bpcs = 0
<S2SV_ModStart> unsigned int channo ; cdef -> ents = 0
<S2SV_ModStart> unsigned int i ; cmap -> ents = 0
<S2SV_ModStart> = 0 ; pclr -> bpc = 0 ;
<S2SV_ModStart> ! el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , "get<S2SV_blank>" ) && strcmp ( ptr , "gets<S2SV_blank>" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont = el
<S2SV_ModStart> } it = limited_get <S2SV_ModEnd> ( key , <S2SV_ModStart> nkey , c <S2SV_ModEnd> ) ; if
<S2SV_ModStart> } if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr , "get<S2SV_blank>" , 4 ) && strncmp <S2SV_ModEnd> ( ptr , <S2SV_ModStart> ptr , "gets<S2SV_blank>" , 5 )
<S2SV_ModStart> } if ( <S2SV_ModEnd> udp_specified && settings
<S2SV_ModStart> . udpport = 0 <S2SV_ModEnd> ; settings .
<S2SV_ModStart> error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
<S2SV_ModStart> } while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> ] == '\\n' )
<S2SV_ModStart> * ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser .
<S2SV_ModStart> "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; * pp = p -> next ;
<S2SV_ModStart> 3 ; } if ( desc == NULL ) desc = "" ;
<S2SV_ModStart> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> base_addr , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> + 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> ) ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
<S2SV_ModStart> len - o - 4
<S2SV_ModStart> "corrupt<S2SV_blank>BSON" ) ; VALIDATE_TEST ( "test59.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ;
<S2SV_ModStart> ( sr -> uri_processed <S2SV_ModEnd> ) < 0
<S2SV_ModStart> ; sr -> fd_is_fdt = MK_FALSE ; sr ->
<S2SV_ModStart> 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
<S2SV_ModStart> = hash ; sr -> fd_is_fdt = MK_TRUE ;
<S2SV_ModStart> , s + 2 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n" )
<S2SV_ModStart> ) ) { if ( dlen < 2 ) break ; <S2SV_ModStart> dlen -= 2 <S2SV_ModEnd> ; * pt
<S2SV_ModStart> buf + 2 , sizeof ( obuf )
<S2SV_ModStart> buffer , encoded , sizeof ( buffer )
<S2SV_ModStart> 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ;
<S2SV_ModStart> ( bcache , cache_id ( id ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) == 0
<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> ] -> data )
<S2SV_ModStart> char ) ) ; if ( fc . messages == NULL ) return - 1
<S2SV_ModStart> ; dlen -= 3 <S2SV_ModEnd> ; for (
<S2SV_ModStart> list . name , true
<S2SV_ModStart> dlen , buf , false
<S2SV_ModStart> char * src , bool quote_backtick ) { const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char *
<S2SV_ModStart> 0 ) { struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( "uname" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , "%d.%d" , & major , & minor ) ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , "Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>" "A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>" "Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n" , major , minor ) ; exit ( 1 ) ; }
<S2SV_ModStart> fp ) ; unlink ( RUN_LIB_FILE ) ;
<S2SV_ModStart> # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
<S2SV_ModStart> ) ) { char t <S2SV_ModEnd> = from_hex ( <S2SV_ModStart> [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
<S2SV_ModStart> . dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> int n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int part_read
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
<S2SV_ModStart> xfr_cmd , fname <S2SV_ModEnd> ) ; free
<S2SV_ModStart> sshd_hostkey_sign ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> stderr , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" ) ;
<S2SV_ModStart> options . disable_forwarding || ! use_privsep
<S2SV_ModStart> options . disable_forwarding && use_privsep
<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , "." ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
<S2SV_ModStart> return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;
<S2SV_ModStart> ; # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
<S2SV_ModStart> encrypt ) { if ( len < POLY1305_BLOCK_SIZE ) return 0 ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> return ( 1
<S2SV_ModStart> ) ) { if ( <S2SV_ModStart> -> seq_num ) < 0 ) { SSLerr ( SSL_F_DTLS1_READ_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } <S2SV_ModEnd> rr -> length
<S2SV_ModStart> ; if ( <S2SV_ModEnd> peer != NULL <S2SV_ModStart> peer != NULL <S2SV_ModEnd> ) { al
<S2SV_ModStart> == SSL3_RT_HANDSHAKE && s -> packet_length > DTLS1_RT_HEADER_LENGTH && s -> packet [ DTLS1_RT_HEADER_LENGTH ] <S2SV_ModEnd> == SSL3_MT_CLIENT_HELLO )
<S2SV_ModStart> NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free
<S2SV_ModStart> NULL && ! SSL_WRITE_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> if ( ! SSL_READ_ETM <S2SV_ModEnd> ( s )
<S2SV_ModStart> & comp , s -> tlsext_use_etm <S2SV_ModEnd> ) ) {
<S2SV_ModStart> 1 ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; return - 1 ; }
<S2SV_ModStart> err ; } if ( signature -> type == V_ASN1_BIT_STRING && signature -> flags & 0x7 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_INVALID_BIT_STRING_BITS_LEFT ) ; goto err ; }
<S2SV_ModStart> r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ;
<S2SV_ModStart> -> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }
<S2SV_ModStart> { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY <S2SV_ModEnd> , ASN1_R_INVALID_BIT_STRING_BITS_LEFT )
<S2SV_ModStart> while ( f && f
<S2SV_ModStart> { if ( ! SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_SERVER_CERTIFICATE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } if (
<S2SV_ModStart> skey ) ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_DHE , ERR_R_INTERNAL_ERROR ) ; return 0 ; }
<S2SV_ModStart> ; if ( ckey == NULL ) { SSLerr ( SSL_F_TLS_CONSTRUCT_CKE_ECDHE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if (
<S2SV_ModStart> if ( n <S2SV_ModEnd> != i )
<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
<S2SV_ModStart> : if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> ; client -> <S2SV_ModEnd> pool = get_pool
<S2SV_ModStart> if ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> ; if ( <S2SV_ModEnd> size_left < 4
<S2SV_ModStart> uint32_t id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> entry . uncompressed_filesize || read <= 8
<S2SV_ModStart> TSRMLS_CC ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
<S2SV_ModStart> ( ! eof && vars -> str . c != vars -> ptr
<S2SV_ModStart> return ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive" ) ; RETURN_FALSE ; }
<S2SV_ModStart> = 1 ; apr_brigade_cleanup ( brigade ) ;
<S2SV_ModStart> len2 ; } if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , "the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated." , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; }
<S2SV_ModStart> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException
<S2SV_ModStart> -> socket_mode = 0660 <S2SV_ModEnd> ; if (
<S2SV_ModStart> { buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 )
<S2SV_ModStart> } buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 )
<S2SV_ModStart> get_debug_info = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
<S2SV_ModStart> = pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
<S2SV_ModStart> 1 ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ) ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
<S2SV_ModStart> RETURN_FALSE ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
<S2SV_ModStart> RETURN_FALSE ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> if ( q < p || q
<S2SV_ModStart> border < 0 || color < 0
<S2SV_ModStart> = U_ZERO_ERROR ; buflen ++ ;
<S2SV_ModStart> RETURN_FALSE ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> ( exception_ce , "%s" ,
<S2SV_ModStart> ; if ( zend_hash_find <S2SV_ModEnd> ( ht ,
<S2SV_ModStart> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
<S2SV_ModStart> var_hash TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept ;
<S2SV_ModStart> ( ! offset || ! ht
<S2SV_ModStart> ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers (
<S2SV_ModStart> ) ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> -> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;
<S2SV_ModStart> / 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
<S2SV_ModStart> ncolumns ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;
<S2SV_ModStart> ) ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> NULL ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ) ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
<S2SV_ModStart> pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> } num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )
<S2SV_ModStart> charlen ; } if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;
<S2SV_ModStart> pos ) { check_stack_depth ( ) ;
<S2SV_ModStart> = 0 ; check_stack_depth ( ) ;
<S2SV_ModStart> ) ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> , & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) )
<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
<S2SV_ModStart> char fstr [ 7 ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0' ;
<S2SV_ModStart> ; if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if (
<S2SV_ModStart> ; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> ; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL
<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> sh_size < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> parameters_size ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> . name ) { continue ; } <S2SV_ModEnd> if ( values

<S2SV_ModStart> , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux <S2SV_ModEnd> ; if (
<S2SV_ModStart> = 16 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> buf ) ) { return 0 ; } <S2SV_ModEnd> ext_block = (
<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;

<S2SV_ModStart> ; } } return - 1 ;
<S2SV_ModStart> - pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> list . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> object -> list
<S2SV_ModStart> ; RAnalOp next_op = { 0 }
<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
<S2SV_ModStart> if ( argReg > <S2SV_ModEnd> regsz ) { <S2SV_ModStart> regsz ) { return ;
<S2SV_ModStart> * opcode_desc ; if ( len < 2 ) { return NULL ; }
<S2SV_ModStart> 0 ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } vstart += vnaux <S2SV_ModEnd> ; for (
<S2SV_ModStart> sts ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> < 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free
<S2SV_ModStart> ) { i ++ <S2SV_ModEnd> ; } if
<S2SV_ModStart> = NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false
<S2SV_ModStart> header . types_size <S2SV_ModEnd> ) { continue
<S2SV_ModStart> '=' : case \'"\' : case '\\\\' : case
<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
<S2SV_ModStart> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , ".." ) || strchr ( name , '/'
<S2SV_ModStart> == 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , "/dev/null/" , 2 ) ; # else <S2SV_ModStart> 2 ) ; # endif
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> , psm , 0 ,
<S2SV_ModStart> . st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if (
<S2SV_ModStart> fpath , fi , & sb
<S2SV_ModStart> "auth_tag_len" ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> ) ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> iv ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> ) ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> cb1 = (
<S2SV_ModStart> ; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
<S2SV_ModStart> , scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
<S2SV_ModStart> p -> tokenpos >= ( <S2SV_ModEnd> p -> tokenlen <S2SV_ModStart> p -> tokenlen - 1 )
<S2SV_ModStart> bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
<S2SV_ModStart> config ) ; if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ;
<S2SV_ModStart> ) ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( "%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , "Restricted" , 1 ) ; }
<S2SV_ModStart> -> enable ( false
<S2SV_ModStart> -> enable ( false
<S2SV_ModStart> -> enable ( false
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , MSG_NOSIGNAL )
<S2SV_ModStart> "success" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 250000 )
<S2SV_ModStart> us_delay ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( us_delay )
<S2SV_ModStart> us_delay ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( us_delay )
<S2SV_ModStart> ( read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_NOSIGNAL )
<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 50 )
<S2SV_ModStart> } ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( ev )
<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( * ev )
<S2SV_ModStart> ; r = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> ( ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 100000 )
<S2SV_ModStart> keylockstates ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 200000 )
<S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 200000 )
<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )
<S2SV_ModStart> "btif_hl_select_wake_reset" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )
<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> sizeof ( tETH_HDR )
<S2SV_ModStart> ~ IFF_UP ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) & ifr )
<S2SV_ModStart> 0 ) { TEMP_FAILURE_RETRY ( <S2SV_ModStart> uinput_fd , UI_DEV_DESTROY )
<S2SV_ModStart> value ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> event ) ) )
<S2SV_ModStart> int sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_DONTWAIT )
<S2SV_ModStart> int received = TEMP_FAILURE_RETRY ( <S2SV_ModStart> size , 0 )
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> FIONREAD , size )
<S2SV_ModStart> ssize_t sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> len , MSG_DONTWAIT )
<S2SV_ModStart> int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & clen )
<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
<S2SV_ModStart> } } return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> } ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> } ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , MSG_WAITALL )
<S2SV_ModStart> int ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )
<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> r , MSG_WAITALL )
<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> s , 0 )
<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> msg , MSG_NOSIGNAL )
<S2SV_ModStart> { err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & delay )
<S2SV_ModStart> != INVALID_FD ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> data , length )
<S2SV_ModStart> { if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> length , 0 )
<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> transmitted_length , length )
<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> transmitted_length , length )
<S2SV_ModStart> __func__ ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 10000 )
<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> & timeout ) )
<S2SV_ModStart> int bytes_read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> reader -> buffer_size )
<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , - 1 )
<S2SV_ModStart> int fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL , NULL )
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & size )
<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT ) )
<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT ) )
<S2SV_ModStart> ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> msg , MSG_DONTWAIT )
<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> p_buf , msglen )
<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )
<S2SV_ModStart> ; result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) )
<S2SV_ModStart> "UIPC<S2SV_blank>SEND<S2SV_blank>WAKE<S2SV_blank>UP" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
<S2SV_ModStart> data ) { UINT16 buflen = <S2SV_ModEnd> ( UINT16 ) <S2SV_ModStart> BT_HDR ) ) ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , "28672558" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen
<S2SV_ModStart> pin_code == NULL || pin_len > PIN_CODE_LEN
<S2SV_ModStart> alarm_timer ) ; btif_config_write ( <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb <S2SV_ModEnd> , NULL )
<S2SV_ModStart> ) ; } btif_config_devcache_cleanup ( ) ;
<S2SV_ModStart> - namelen - 1 <S2SV_ModEnd> ) ; if
<S2SV_ModStart> src == NULL ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count
<S2SV_ModStart> ERROR ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( "%s:<S2SV_blank>Data<S2SV_blank>count<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>capacity<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , "30591838" ) ; return ERROR ; }
<S2SV_ModStart> | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode <S2SV_ModEnd> ) ; if
<S2SV_ModStart> } r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
<S2SV_ModStart> } if ( vt_verify_kbmode <S2SV_ModEnd> ( fd_d )
<S2SV_ModStart> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" ,
<S2SV_ModStart> ; r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
<S2SV_ModStart> ; if ( ! p -> question ) return 0 ; if (
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) == 0
<S2SV_ModStart> ; # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , "Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n" , tmp_dir ) ; exit ( 1 ) ; } # endif
<S2SV_ModStart> = "/tmp" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , "/w3m-XXXXXX" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
<S2SV_ModStart> ; if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
<S2SV_ModStart> 0 , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> { if ( l == NULL ) break ; if (
<S2SV_ModStart> NULL ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device" ) ; goto error ; } if (
<S2SV_ModStart> , PCAP_ERRBUF_SIZE , "truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" <S2SV_ModEnd> PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize
<S2SV_ModStart> , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ( len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" <S2SV_ModEnd> , len )
<S2SV_ModStart> ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>?)" ) ) ; break ; }
<S2SV_ModStart> ( len < 10 <S2SV_ModEnd> ) ND_PRINT (
<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>c<S2SV_blank>%04x" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
<S2SV_ModStart> uint32_t ) ; ND_TCHECK <S2SV_ModEnd> ( dp [ <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ) ; astat
<S2SV_ModStart> 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length - 1 <S2SV_ModEnd> ) ; return
<S2SV_ModStart> length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; return
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> p , length <S2SV_ModEnd> ) ; break
<S2SV_ModStart> depth ++ ; if ( depth == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else
<S2SV_ModStart> return ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> ) ) ; ND_TCHECK ( bp -> bp_flags ) ;
<S2SV_ModStart> ; ND_TCHECK ( * dp <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( cp ) ;
<S2SV_ModStart> tmp ) { ND_TCHECK2 ( * tptr , alen ) ;
<S2SV_ModStart> ) bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> dp -> ip6r_len <S2SV_ModEnd> ; ND_PRINT (
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ND_TTEST2 ( cp
<S2SV_ModStart> ) ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; }
<S2SV_ModStart> == 12 && ( <S2SV_ModStart> flags & TH_SYN )
<S2SV_ModStart> ] ) ) ) ; ND_TCHECK ( tptr [ 1 ]
<S2SV_ModStart> trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> = id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> ; i <= sysid_len <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
<S2SV_ModStart> + 1 ; ND_TCHECK2 ( * s , 1 ) ;
<S2SV_ModStart> len ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p + <S2SV_ModStart> p + 2 <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
<S2SV_ModStart> ) ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; }
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> ) ) ; if ( plenbytes < 0 ) return plenbytes ;
<S2SV_ModStart> ndo -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
<S2SV_ModStart> EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;
<S2SV_ModStart> op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
<S2SV_ModStart> ++ ; } ND_TCHECK ( * p ) ;
<S2SV_ModStart> int len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
<S2SV_ModStart> * tptr , 2 <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ( tlen < 1U +
<S2SV_ModStart> ndo , p <S2SV_ModEnd> ) ) )
<S2SV_ModStart> ( ) ; ND_TCHECK_32BITS ( bp ) ;
<S2SV_ModStart> case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>length)" ) ) ; break ; }
<S2SV_ModStart> ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> p , alen , 0
<S2SV_ModStart> ) ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> rm_call . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0
<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
<S2SV_ModStart> -> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
<S2SV_ModStart> ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> , cp , ep2 <S2SV_ModEnd> , map , <S2SV_ModStart> nmap ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; }
<S2SV_ModStart> , cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> < ep2 ) <S2SV_ModEnd> ND_PRINT ( (
<S2SV_ModStart> case BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;
<S2SV_ModStart> case LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
<S2SV_ModStart> case IPOPT_LSRR : if ( <S2SV_ModStart> , option_len ) == - 1 ) goto trunc
<S2SV_ModStart> command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family (
<S2SV_ModStart> mq_ops ) { struct blk_mq_hw_ctx * hctx ; <S2SV_ModStart> mq_flush_lock , flags ) ; hctx = q -> mq_ops -> map_queue ( q , flush_rq -> mq_ctx -> cpu ) ; blk_mq_tag_set_rq ( hctx , flush_rq -> tag , fq -> orig_rq
<S2SV_ModStart> { rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
<S2SV_ModStart> { rq = tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; fn (
<S2SV_ModStart> -> udf . parent_partref = 0 ; fid -> udf .
<S2SV_ModStart> type == USER_CLIENT && client -> data . user . fifo
<S2SV_ModStart> ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX ) return - EINVAL ; if ( len < 0 || len > MAX_ARG_LEN ) return - EINVAL ; if (
<S2SV_ModStart> ; int n ; if ( ! body -> unit_size ) break ; n
<S2SV_ModStart> = 0 ; lsa -> l2tp_unused = 0 ;
<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
<S2SV_ModStart> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> NULL ; } sas_probe_devices ( port ) ;
<S2SV_ModStart> return res ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; <S2SV_ModEnd> } } <S2SV_null>
<S2SV_ModStart> == 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy
<S2SV_ModStart> gone ) ; sas_destruct_devices ( port ) ;
<S2SV_ModStart> destroy_list ) ; INIT_LIST_HEAD ( & port -> sas_port_del_list ) ;
<S2SV_ModStart> port , dev ) ; sas_destruct_devices ( port
<S2SV_ModStart> -> ctx = kcalloc ( nvec , <S2SV_ModEnd> sizeof ( struct
<S2SV_ModStart> skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr
<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
<S2SV_ModStart> return ret ; if ( map -> m_flags & EXT4_MAP_NEW && ! ( map -> m_flags & EXT4_MAP_UNWRITTEN ) && ! ( flags & EXT4_GET_BLOCKS_ZERO ) && ! IS_NOQUOTA ( inode ) && ext4_should_order_data ( inode ) ) { ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) return ret ; } } return <S2SV_ModEnd> retval ; }
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2
<S2SV_ModStart> { ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret
<S2SV_ModStart> { ret = posix_acl_update_mode ( inode , & new_mode , & acl ) ; if ( ret ) goto out <S2SV_ModEnd> ; } break
<S2SV_ModStart> { err = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err
<S2SV_ModStart> { error = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( error ) return error ; <S2SV_ModEnd> } break ;
<S2SV_ModStart> ; dentry -> d_flags |= DCACHE_RCUACCESS ; dentry ->
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> return err ;
<S2SV_ModStart> ; ue -> card = card ; ue ->
<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
<S2SV_ModStart> ; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
<S2SV_ModStart> * ace ; unsigned
<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
<S2SV_ModStart> , slots ) kvm_iommu_unmap_pages <S2SV_ModEnd> ( kvm , <S2SV_ModStart> kvm , memslot <S2SV_ModEnd> ) ; srcu_read_unlock
<S2SV_ModStart> out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ;
<S2SV_ModStart> = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ;
<S2SV_ModStart> ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if (
<S2SV_ModStart> compat_timex tx32 ; memset ( txc , 0 , sizeof ( struct timex ) ) ;
<S2SV_ModStart> ; ret = hermes_disable_port ( hw , 0 ) ; } else { priv -> tkip_cm_active = 0 ; ret = hermes_enable_port <S2SV_ModEnd> ( hw ,
<S2SV_ModStart> -> name , sizeof ( req -> name ) - 1 <S2SV_ModEnd> ) ; snprintf
<S2SV_ModStart> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int dev_get_valid_name (
<S2SV_ModStart> -> map = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ( 2 , "vm_close<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> ( 2 , "vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n" <S2SV_ModEnd> , map ,
<S2SV_ModStart> tk_status ) ; switch ( task -> tk_status ) { case - EACCES : case - EIO : goto die ; default : <S2SV_ModStart> goto retry_rebind ; }
<S2SV_ModStart> break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;
<S2SV_ModStart> ; task -> tk_rebind_retry = 2 ; task ->
<S2SV_ModStart> = 0x0 ; vcpu -> arch . pv_time_enabled = false ;
<S2SV_ModStart> -> arch . pv_time_enabled <S2SV_ModEnd> ) return -
<S2SV_ModStart> vcpu ) { <S2SV_ModEnd> vcpu -> arch <S2SV_ModStart> -> arch . pv_time_enabled = false ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;
<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
<S2SV_ModStart> SCALAR_VALUE ) { coerce_reg_to_size ( & <S2SV_ModStart> [ value_regno ] , size <S2SV_ModEnd> ) ; }
<S2SV_ModStart> unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
<S2SV_ModStart> ret = 0 ; if ( ! access_ok ( VERIFY_READ , uregs , sizeof ( elf_xtregs_t ) ) ) return - EFAULT
<S2SV_ModStart> ; print_bpf_insn ( env ,
<S2SV_ModStart> FLAG_MATCHED ) || ( op & ASN1_OP_MATCH__SKIP && <S2SV_ModStart> dp == datalen )
<S2SV_ModStart> user -> uid_keyring && user -> session_keyring
<S2SV_ModStart> ; if ( skb -> mac_header <S2SV_ModEnd> < ( tnl_hlen
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> ( attrs , PAGE_KERNEL <S2SV_ModEnd> ) ; void
<S2SV_ModStart> nsops < 1 || nsops > SEMOPM
<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
<S2SV_ModStart> alts ) ; if ( altsd -> bNumEndpoints < 1 ) { kfree ( fp ) ; kfree ( rate_table ) ; return - EINVAL ; }
<S2SV_ModStart> |= S_ISGID ; else if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) && ! in_group_p ( inode -> i_gid ) && ! capable_wrt_inode_uidgid ( dir , CAP_FSETID ) ) mode &= ~ S_ISGID ;
<S2SV_ModStart> out ; } same -> dest_count = count ;
<S2SV_ModStart> xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
<S2SV_ModStart> = { . start = link -> start , .
<S2SV_ModStart> -> length ) ; if ( err ) return - EFAULT
<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;
<S2SV_ModStart> while ( bytes || ! iov -> iov_len
<S2SV_ModStart> , count ) ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL
<S2SV_ModStart> ; if ( unlikely ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) ) return - EINVAL ; if (
<S2SV_ModStart> tp_event ) && perf_paranoid_tracepoint_raw <S2SV_ModEnd> ( ) &&
<S2SV_ModStart> ( ! npages || base_gfn != old . base_gfn
<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
<S2SV_ModStart> -> data_buffer = kzalloc ( TPM_BUFSIZE <S2SV_ModEnd> , GFP_KERNEL )
<S2SV_ModStart> ~ MNT_WRITE_HOLD ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ;
<S2SV_ModStart> copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED
<S2SV_ModStart> 0 ] ; if ( ( void * ) old > vec -> iov_base + vec -> iov_len ) return 0 ;
<S2SV_ModStart> p ++ ) ; if ( ( void * ) p > head -> iov_base + head -> iov_len ) return 0
<S2SV_ModStart> head -> iov_base ; if ( hdr > head -> iov_len ) return 0
<S2SV_ModStart> 0 ; } aux . tp_padding = 0 ;
<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
<S2SV_ModStart> bh ) ; clear_buffer_delay ( bh ) ; clear_buffer_unwritten ( bh ) ;
<S2SV_ModStart> int ret = proc_dointvec_minmax <S2SV_ModEnd> ( table ,
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
<S2SV_ModStart> err_free_buf ; } if ( usbinterface -> altsetting [ 0 ] . desc . bNumEndpoints < 1 ) { dev_err ( & usbinterface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; error = - EINVAL ; goto err_free_urb ; }
<S2SV_ModStart> policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ;
<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
<S2SV_ModStart> else { return false <S2SV_ModEnd> ; } case
<S2SV_ModStart> -> cid_mask = ( 1 << KVM_X2APIC_CID_BITS ) - 1 ;
<S2SV_ModStart> tree ) ; if ( tcon )
<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {
<S2SV_ModStart> ) * flags |= FOLL_COW <S2SV_ModEnd> ; return 0
<S2SV_ModStart> ) && ! can_follow_write_pte ( pte , flags <S2SV_ModEnd> ) ) {
<S2SV_ModStart> } ret = fscrypt_get_encryption_info <S2SV_ModEnd> ( dir )
<S2SV_ModStart> ) return ; <S2SV_ModEnd> crypto_free_skcipher ( ci
<S2SV_ModStart> -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer .
<S2SV_ModStart> ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < <S2SV_ModEnd> cap -> bLength <S2SV_ModStart> cap -> bLength ) { dev -> bos -> desc -> bNumDeviceCaps = i ; break ; } length = cap -> bLength <S2SV_ModEnd> ; total_len -=
<S2SV_ModStart> sta -> lock ) ; spin_lock_init ( & sta -> ps_lock
<S2SV_ModStart> wqh ) ; spin_lock_init ( & ctx -> cancel_lock ) ;
<S2SV_ModStart> & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4
<S2SV_ModStart> unsigned long flags ; if ( ! tty ) return
<S2SV_ModStart> -> chan_net = get_net ( net ) <S2SV_ModEnd> ; chan ->
<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
<S2SV_ModStart> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
<S2SV_ModStart> ip ++ ; if ( unlikely ( length > ( size_t ) ( length + len ) ) ) goto _output_error ;
<S2SV_ModStart> . acl_data_offset , <S2SV_ModEnd> acl_len ) ;
<S2SV_ModStart> ; if ( ( dst_group || dst_pid ) <S2SV_ModEnd> && ! netlink_capable
<S2SV_ModStart> ptr ) { struct floppy_raw_cmd cmd = * ptr ; cmd . next = NULL ; cmd . kernel_data = NULL ; <S2SV_ModStart> ( param , & cmd <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( cmd <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> rc = 0 ; if ( ! scontext_len ) return - EINVAL
<S2SV_ModStart> ( peer ) peer = maybe_get_net <S2SV_ModEnd> ( peer )
<S2SV_ModStart> ; if ( len <S2SV_ModEnd> > 32 )
<S2SV_ModStart> ; if ( ( unsigned long ) len > ( unsigned long ) <S2SV_ModEnd> count ) len
<S2SV_ModStart> if ( nbytes > <S2SV_ModEnd> sizeof ( *
<S2SV_ModStart> session_keyring ) { key_put ( keyring ) ;
<S2SV_ModStart> << KEY_FLAG_BUILTIN ; if ( flags & KEY_ALLOC_UID_KEYRING ) key -> flags |= 1 << KEY_FLAG_UID_KEYRING ;
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ; return ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
<S2SV_ModStart> ) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (
<S2SV_ModStart> ( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo ->
<S2SV_ModStart> case S_IFDIR : fa = xfs_dinode_verify_fork ( dip , mp , XFS_DATA_FORK ) ; if ( fa ) return fa ; break ; case 0 : break ; default : return __this_address ; } if ( XFS_DFORK_Q ( dip ) ) { fa = xfs_dinode_verify_fork ( dip , mp , XFS_ATTR_FORK ) ; if ( fa ) return fa ; <S2SV_ModEnd> } else {
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
<S2SV_ModStart> prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely (
<S2SV_ModStart> 0 ) ; if ( ! r ) return - EINVAL ;
<S2SV_ModStart> = 0 ; info -> port = NULL ;
<S2SV_ModStart> - EOPNOTSUPP ; memset ( perm_addr , 0 , sizeof ( perm_addr ) ) ;
<S2SV_ModStart> ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ;
<S2SV_ModStart> ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ;
<S2SV_ModStart> p ) ; RCU_INIT_POINTER ( mm -> exe_file , NULL ) ;
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel <S2SV_ModEnd> ( & stime
<S2SV_ModStart> 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ;
<S2SV_ModStart> ) ; } fuse_conn_put ( & cc -> fc ) ;
<S2SV_ModStart> goto read_error ; m -> msg_namelen = 0 ;
<S2SV_ModStart> ip_vs_timeout_user t ; memset ( & t , 0 , sizeof ( t ) ) ;
<S2SV_ModStart> "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> current_timeo ) ; if <S2SV_ModEnd> ( sk != <S2SV_ModStart> . sk ) goto do_error
<S2SV_ModStart> ; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , "invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n" ) ; break
<S2SV_ModStart> ; if ( ! retval ) <S2SV_ModEnd> retval = context
<S2SV_ModStart> port ) { <S2SV_ModEnd> return usb_serial_generic_open (
<S2SV_ModStart> ; int ret ; if ( current_chrooted ( ) ) return - EPERM
<S2SV_ModStart> -> lun ) sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
<S2SV_ModStart> * v ; if ( id >= KVM_MAX_VCPUS ) return - EINVAL ;
<S2SV_ModStart> ( likely ( serio <S2SV_ModEnd> && ! filtered
<S2SV_ModStart> 0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
<S2SV_ModStart> 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> == 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write
<S2SV_ModStart> ; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
<S2SV_ModStart> key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error2 ; <S2SV_ModEnd> ret = key_permission
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( keyring )
<S2SV_ModStart> KEY_LOOKUP_PARTIAL ) && key_read_state ( key ) == KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) goto invalid_key
<S2SV_ModStart> - ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( key )
<S2SV_ModStart> ; if ( key_is_positive ( key <S2SV_ModEnd> ) ) zap
<S2SV_ModStart> key_ref ) ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { ret = - ENOKEY ; goto error2 ; }
<S2SV_ModStart> if ( keyring && link_ret == 0
<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
<S2SV_ModStart> != 0 ) { kfree ( bo ) ; return ret ; } <S2SV_ModEnd> bo -> dumb
<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
<S2SV_ModStart> ; } else return
<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , "first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>" "(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
<S2SV_ModStart> ] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen
<S2SV_ModStart> ) sockaddr ; memset ( addr , 0 , sizeof ( * addr ) ) ;
<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
<S2SV_ModStart> else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if
<S2SV_ModStart> NULL ) { memset ( sax , 0 , sizeof ( sax ) ) ;
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> SOL_PPPOL2TP ) return - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
<S2SV_ModStart> ) break ; <S2SV_ModEnd> rinfo [ val
<S2SV_ModStart> ; rinfo = kzalloc <S2SV_ModEnd> ( SZ_SG_REQ_INFO *
<S2SV_ModStart> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM
<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
<S2SV_ModStart> pass < 10 || image
<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }
<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS
<S2SV_ModStart> ] ) ; free_uid ( fpl -> user ) ;
<S2SV_ModStart> -> count ; new_fpl -> user = get_uid ( fpl -> user ) ;
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> -> fp -> user , scm -> fp ->
<S2SV_ModStart> return - EFAULT ; if ( ! tls_desc_okay ( & info ) ) return - EINVAL
<S2SV_ModStart> EBADFD ; } ca . device [ sizeof ( ca . device ) - 1 ] = 0 ;
<S2SV_ModStart> DRM_DEBUG ( "clip<S2SV_blank>rectangles<S2SV_blank>are<S2SV_blank>only<S2SV_blank>valid<S2SV_blank>with<S2SV_blank>the<S2SV_blank>render<S2SV_blank>ring\\n" ) ; return - EINVAL ; } if ( args -> num_cliprects > UINT_MAX / sizeof ( * cliprects ) ) { DRM_DEBUG ( "execbuf<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>cliprects\\n" , args -> num_cliprects
<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) , & final ) ; rcu_read_unlock ( <S2SV_ModEnd> ) ; dst
<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> tot_len ) ; atomic_set ( & opt2 -> refcnt , 1 ) ;
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * )
<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
<S2SV_ModStart> int err ; if ( ! <S2SV_ModStart> & mask ) ) return - EINVAL
<S2SV_ModStart> name ) , "crypto-%s" <S2SV_ModEnd> , name )
<S2SV_ModStart> sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
<S2SV_ModStart> NULL ) { memset ( srose , 0 , msg -> msg_namelen ) ;
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
<S2SV_ModStart> : kfree ( req ) ; kfree (
<S2SV_ModStart> * rsize >= 18 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 31 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 62 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> * rsize >= 112 <S2SV_ModEnd> && rdesc [
<S2SV_ModStart> flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ;
<S2SV_ModStart> nla ) ; strncpy <S2SV_ModEnd> ( algo -> <S2SV_ModStart> auth -> alg_name , sizeof ( algo -> alg_name )
<S2SV_ModStart> value ) { if ( voice < 0 || voice >= devc -> nr_voice ) return ;
<S2SV_ModStart> channel_info * info ; if ( voice < 0 || voice >= devc -> nr_voice ) return ; if ( chn < 0 || chn > 15 ) return ; info
<S2SV_ModStart> len = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_READ , buff , len ) ) ) return - EFAULT
<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
<S2SV_ModStart> 'R' ) : if ( rr -> u . ER . len_id + offsetof ( struct rock_ridge , u . ER . data ) > rr -> len ) goto out ;
<S2SV_ModStart> { if ( ! dev_name ||
<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
<S2SV_ModStart> idProduct ) ; if ( iface_desc -> desc . bNumEndpoints < 1 ) { dev_err ( & interface -> dev , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>endpoints\\n" ) ; retval = - EINVAL ; goto error ; }
<S2SV_ModStart> sk , SCM_TSTAMP_SND , false
<S2SV_ModStart> -> len && SKB_EXT_ERR ( skb ) -> opt_stats <S2SV_ModEnd> ) put_cmsg (
<S2SV_ModStart> , attr , attr -> size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> server , volume_info <S2SV_ModEnd> ) ; if
<S2SV_ModStart> if ( count > <S2SV_ModEnd> DJREPORT_SHORT_LENGTH - 2
<S2SV_ModStart> tpr_threshold ) ; } else { # ifdef CONFIG_X86_64 exec_control |= CPU_BASED_CR8_LOAD_EXITING | CPU_BASED_CR8_STORE_EXITING ; # endif
<S2SV_ModStart> sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
<S2SV_ModStart> fq ) ; q -> fq = NULL ;
<S2SV_ModStart> svm , MC_VECTOR ) ; set_exception_intercept ( svm , AC_VECTOR
<S2SV_ModStart> ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case
<S2SV_ModStart> 1u << DB_VECTOR ) | ( 1u << AC_VECTOR
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ) ) { pr_debug <S2SV_ModEnd> ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"
<S2SV_ModStart> ! unconditional ( e <S2SV_ModEnd> ) ) return
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; random_ether_addr (
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> = port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> ; if ( plen <S2SV_ModEnd> ) { ret
<S2SV_ModStart> totalpages ) { long <S2SV_ModEnd> points ; if
<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> ) ) { if ( unlikely ( stackidx >= private -> stacksize ) ) { verdict = NF_DROP ; break ; }
<S2SV_ModStart> return size ; nr_pages = DIV_ROUND_UP ( size , BUF_PAGE_SIZE ) ; if ( nr_pages < 2 ) nr_pages = 2 ; size = nr_pages * BUF_PAGE_SIZE <S2SV_ModEnd> ; if (
<S2SV_ModStart> tpg -> tport_tpgt <S2SV_ModEnd> ; if (
<S2SV_ModStart> __func__ ) ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : <S2SV_ModEnd> put_page ( page
<S2SV_ModStart> , size - skb_out <S2SV_ModEnd> -> len ,
<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
<S2SV_ModStart> if ( err < 0
<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
<S2SV_ModStart> = dest_mnt ; first_source = source_mnt ;
<S2SV_ModStart> return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
<S2SV_ModStart> ret < 0 && ! p -> skip_release_on_error
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item *
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> exit ; } m -> msg_namelen = 0 ;
<S2SV_ModStart> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) )
<S2SV_ModStart> = NULL ; <S2SV_ModEnd> sctp_auth_asoc_init_active_key ( asoc
<S2SV_ModStart> 0 ) ; scat = & rm -> data . op_sg [ sg ] ; ret = <S2SV_ModEnd> sizeof ( struct <S2SV_ModStart> ) + RDS_CONG_MAP_BYTES ; ret = min_t ( int , ret , scat -> length - conn -> c_xmit_data_off ) ; return ret
<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
<S2SV_ModStart> . fragments > INT_MAX <S2SV_ModEnd> / params ->
<S2SV_ModStart> src ) ; __switch_to_tm ( src ) ; tm_recheckpoint_new_task ( src ) ;
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , false
<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
<S2SV_ModStart> ; if ( urb -> actual_length > 0 &&
<S2SV_ModStart> SOCK_RCU_FREE ) ; inet_sk ( newsk ) -> mc_list = NULL ;
<S2SV_ModStart> ! new_idmap_permitted ( file ,
<S2SV_ModStart> - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ;
<S2SV_ModStart> -> nfcid1_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_NFCID1_MAXSIZE )
<S2SV_ModStart> -> sensb_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSB_RES_MAXSIZE )
<S2SV_ModStart> -> sensf_res_len = min_t ( __u8 , <S2SV_ModStart> * data ++ , NFC_SENSF_RES_MAXSIZE )
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> ; return error < 0 ? error : 0
<S2SV_ModStart> ) val ; <S2SV_ModEnd> memset ( ptr
<S2SV_ModStart> page ) ; <S2SV_ModEnd> memset ( addr
<S2SV_ModStart> fail2 ; } BUILD_BUG_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT ) ; if ( WARN_ON ( EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT ( efx ) ) ) { rc = - EINVAL ; goto fail3 ; }
<S2SV_ModStart> efx_ethtool_ops ) ; net_dev -> gso_max_segs = EFX_TSO_MAX_SEGS ;
<S2SV_ModStart> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_free ; }
<S2SV_ModStart> . f_namelen ; sb -> s_stack_depth = max ( upperpath . mnt -> mnt_sb -> s_stack_depth , lowerpath . mnt -> mnt_sb -> s_stack_depth ) + 1 ; err = - EINVAL ; if ( sb -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( "overlayfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n" ) ; goto out_put_workpath ; }
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> port ) { if ( hlist_unhashed ( & mp -> mglist ) )
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
<S2SV_ModStart> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if (
<S2SV_ModStart> ( page_table ) ; if ( ! vma -> vm_ops -> fault ) return VM_FAULT_SIGBUS
<S2SV_ModStart> "overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n" ) ; ret = - EINVAL ;
<S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( ru
<S2SV_ModStart> filp ) { __sock_release <S2SV_ModEnd> ( SOCKET_I ( <S2SV_ModStart> ( inode ) , inode
<S2SV_ModStart> - EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
<S2SV_ModStart> arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset >
<S2SV_ModStart> ; rx_drop : <S2SV_ModEnd> rcv_stats -> rx_dropped
<S2SV_ModStart> ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
<S2SV_ModStart> goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
<S2SV_ModStart> res , ret ; if ( uaddr == uaddr2 ) return - EINVAL
<S2SV_ModStart> icmp6_hop_limit ) { if ( <S2SV_ModStart> cnf . hop_limit < <S2SV_ModEnd> ra_msg -> icmph <S2SV_ModStart> icmph . icmp6_hop_limit ) { in6_dev -> cnf . hop_limit = ra_msg -> icmph . icmp6_hop_limit ; } else { ND_PRINTK ( 2 , warn , "RA:<S2SV_blank>Got<S2SV_blank>route<S2SV_blank>advertisement<S2SV_blank>with<S2SV_blank>lower<S2SV_blank>hop_limit<S2SV_blank>than<S2SV_blank>current\\n" ) ; } <S2SV_ModEnd> if ( rt
<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL
<S2SV_ModStart> ) & desc , sizeof ( * desc )
<S2SV_ModStart> ) & secd , sizeof ( * secd )
<S2SV_ModStart> ( ! rc <S2SV_ModEnd> && tcon )
<S2SV_ModStart> "" ) ; if ( ! l2cap_is_socket ( sock ) ) return - EBADFD ;
<S2SV_ModStart> vcpu , X86_CR4_VMXE ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } if ( vmx_get_cpl ( vcpu
<S2SV_ModStart> vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
<S2SV_ModStart> |= MSG_TRUNC ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> ( sk ) ; msg -> msg_namelen = 0
<S2SV_ModStart> ) ; } <S2SV_ModEnd> err = 0
<S2SV_ModStart> ; } } if ( trans == NULL ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( - ENODEV ) ; goto out ; }
<S2SV_ModStart> + in_iovs ; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ) ; if ( err ) goto out ; err = fuse_verify_ioctl_iov ( out_iov , out_iovs ) ; if ( err ) goto out ;
<S2SV_ModStart> { int i ; account_pipe_buffers ( pipe , pipe -> buffers , 0 ) ; free_uid ( pipe -> user )
<S2SV_ModStart> out ; } else if ( ( too_many_pipe_buffers_hard ( pipe -> user ) || too_many_pipe_buffers_soft ( pipe -> user ) ) && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto out ; }
<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
<S2SV_ModStart> = v ; if ( ! IS_ERR ( vma ) )
<S2SV_ModStart> skb -> len && skb -> len
<S2SV_ModStart> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
<S2SV_ModStart> -> it_overrun += 1LL <S2SV_ModEnd> << i ;
<S2SV_ModStart> ; overrun = timer_overrun_to_int ( timr , 0 ) <S2SV_ModEnd> ; unlock_timer (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> kc -> timer_forward
<S2SV_ModStart> it_overrun = - 1LL <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> it_overrun += <S2SV_ModEnd> hrtimer_forward ( timer
<S2SV_ModStart> sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )
<S2SV_ModStart> -> log_file ; d -> log_file = eventfp ;
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
<S2SV_ModStart> ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL ; if (
<S2SV_ModStart> int ret ; p -> replacement_session_keyring = NULL ;
<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte
<S2SV_ModStart> futex_hash_bucket * hb <S2SV_ModEnd> ; hb =
<S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> - EINVAL ; memset ( & tfrc , 0 , sizeof ( tfrc ) ) ;
<S2SV_ModStart> args ) ; if ( retval ) return retval ; args -> flags &= ~ ATTR_REPLACE <S2SV_ModEnd> ; } if
<S2SV_ModStart> dir ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
<S2SV_ModStart> page ) ; rm -> atomic . op_active = 0 ;
<S2SV_ModStart> peer_wait ) ; init_waitqueue_func_entry ( & u -> peer_wake , unix_dgram_peer_wake_relay ) ;
<S2SV_ModStart> = other ; unix_dgram_peer_wake_disconnect_wakeup ( sk , old_peer ) ;
<S2SV_ModStart> ) ; } unix_dgram_peer_wake_disconnect ( sk , skpair ) ;
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> netbk , pending_idx , XEN_NETIF_RSP_OKAY
<S2SV_ModStart> -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
<S2SV_ModStart> ; if ( ! ctx -> gf128 ) return - ENOKEY ; if (
<S2SV_ModStart> err ) ; if ( req -> buf != NULL )
<S2SV_ModStart> ; kiocb_batch_free ( ctx ,
<S2SV_ModStart> -> vfork_done ; # ifdef CONFIG_FUTEX if ( unlikely ( tsk -> robust_list ) ) exit_robust_list ( tsk ) ; # ifdef CONFIG_COMPAT if ( unlikely ( tsk -> compat_robust_list ) ) compat_exit_robust_list ( tsk ) ; # endif # endif
<S2SV_ModStart> ( ! mm || ! mm -> env_end
<S2SV_ModStart> 1 ) ; if ( ! ret && xsave -> header . xcomp_bv ) ret = - EINVAL ;
<S2SV_ModStart> event ) { u64 <S2SV_ModEnd> event_id = event
<S2SV_ModStart> . map , KVM_MAX_VCPU_ID <S2SV_ModEnd> ) ; }
<S2SV_ModStart> out_free ; } if ( ! N ) { ret = - EINVAL ; parse_error ( pe , FILT_ERR_NO_FILTER , ptr - str ) ; goto out_free ; }
<S2SV_ModStart> uint dblocks = xfs_attr3_rmt_blocks <S2SV_ModEnd> ( mp ,
<S2SV_ModStart> valuelen ) ; args -> rmtvaluelen = args -> valuelen ;
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> ( args -> rmtvaluelen <S2SV_ModEnd> ) ; xfs_trans_log_buf
<S2SV_ModStart> ; args . rmtvaluelen = valuelen ; args .
<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
<S2SV_ModStart> imm ) ; <S2SV_ModEnd> return PTR_ERR (
<S2SV_ModStart> ; if ( size > 64 ) { hid_warn ( hdev , "invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n" , size ) ; return 0 ; } if (
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( & svm
<S2SV_ModStart> ; if ( kvm_set_msr <S2SV_ModEnd> ( vcpu ,
<S2SV_ModStart> msr ) { switch ( msr -> index ) { case MSR_FS_BASE : case MSR_GS_BASE : case MSR_KERNEL_GS_BASE : case MSR_CSTAR : case MSR_LSTAR : if ( is_noncanonical_address ( msr -> data ) ) return 1 ; break ; case MSR_IA32_SYSENTER_EIP : case MSR_IA32_SYSENTER_ESP : msr -> data = get_canonical ( msr -> data ) ; }
<S2SV_ModStart> ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr ->
<S2SV_ModStart> sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&
<S2SV_ModStart> rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
<S2SV_ModStart> mnt ) ; nd -> last_type = LAST_BIND ;
<S2SV_ModStart> path ) ; <S2SV_ModEnd> out : return
<S2SV_ModStart> mtu , flags , rt
<S2SV_ModStart> ipv6_select_ident ( fptr , ( struct rt6_info * ) skb_dst ( skb )
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int udp_push_pending_frames (
<S2SV_ModStart> , 0 ) ; if ( ! data_interface || ! control_interface ) return - ENODEV
<S2SV_ModStart> -> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
<S2SV_ModStart> xid ) ; switch ( rc ) { case 0 : if ( newInode && ! S_ISREG ( newInode -> i_mode ) ) { CIFSSMBClose ( xid , pTcon , fileHandle ) ; break ; } case - ENOENT : posix_open = true ; case - EOPNOTSUPP : break ; default : pTcon -> broken_posix_open = true ; } } if ( ! posix_open ) rc = cifs_get_inode_info_unix ( & newInode , full_path , parent_dir_inode -> i_sb , xid ) ; } else rc = cifs_get_inode_info ( & newInode , full_path , NULL , parent_dir_inode -> i_sb , xid , NULL ) ; <S2SV_ModStart> == 0 ) && ( newInode != NULL ) ) { d_add ( direntry , newInode ) ; if ( posix_open ) { filp = lookup_instantiate_filp ( nd , direntry , generic_file_open ) ; if ( IS_ERR ( filp ) ) { rc = PTR_ERR ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; goto lookup_out ; } cfile = cifs_new_fileinfo ( fileHandle , filp , tlink , oplock ) ; if ( cfile == NULL ) { fput ( filp ) ; CIFSSMBClose ( xid , pTcon , fileHandle ) ; rc = - ENOMEM ; goto lookup_out ; } } renew_parental_timestamps ( direntry ) ; } else if <S2SV_ModEnd> ( rc == <S2SV_ModStart> - ENOENT ) <S2SV_ModEnd> { rc =
<S2SV_ModStart> : if ( skb == NULL ||
<S2SV_ModStart> = 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
<S2SV_ModStart> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
<S2SV_ModStart> -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor <S2SV_ModEnd> ; if (
<S2SV_ModStart> rds_loop_transport ; } <S2SV_ModEnd> } conn ->
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> ( sb , KERN_ERR ,
<S2SV_ModStart> "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;
<S2SV_ModStart> } if ( assoc_array_ptr_is_leaf ( ptr ) &&
<S2SV_ModStart> gc ) ; <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> case SIOCYAMGCFG : memset ( & yi , 0 , sizeof ( yi ) ) ;
<S2SV_ModStart> ; return ret < <S2SV_ModEnd> 0 ? ret
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi <S2SV_ModStart> cdi -> capacity <S2SV_ModEnd> ) return -
<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
<S2SV_ModStart> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
<S2SV_ModStart> ; mapping = vma -> vm_file -> f_dentry -> d_inode -> i_mapping <S2SV_ModEnd> ; mutex_lock (
<S2SV_ModStart> ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
<S2SV_ModStart> type ) ; if ( ! IS_ERR ( raw ) )
<S2SV_ModStart> return map ; map =
<S2SV_ModStart> return prog ; prog = bpf_prog_inc ( prog <S2SV_ModEnd> ) ; fdput
<S2SV_ModStart> = hcd ; if ( ci -> platdata -> flags & CI13XXX_DISABLE_STREAMING ) hw_write ( ci , OP_USBMODE , USBMODE_CI_SDIS , USBMODE_CI_SDIS ) ;
<S2SV_ModStart> current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> CAP_SYS_ADMIN ) )
<S2SV_ModStart> sock , sk ) ; memset ( sa , 0 , sizeof ( * sa )
<S2SV_ModStart> ; if ( vfs_select_inode ( old_dentry , 0 ) == vfs_select_inode ( new_dentry , 0 ) <S2SV_ModEnd> ) return 0
<S2SV_ModStart> src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0
<S2SV_ModStart> ; int bytes_returned ; unsigned int <S2SV_ModEnd> name_len ; __u16
<S2SV_ModStart> tfm ) { <S2SV_ModEnd> return 0 ;
<S2SV_ModStart> } err = crypto_rng_alg ( tfm ) <S2SV_ModEnd> -> seed (
<S2SV_ModStart> ) ; return <S2SV_ModEnd> ralg -> seedsize
<S2SV_ModStart> if ( indev && indev -> ifa_list <S2SV_ModEnd> ) { ifa
<S2SV_ModStart> mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV
<S2SV_ModStart> EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ! ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOSUID ) && ! ( mnt_flags & MNT_NOSUID ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NOEXEC ) && ! ( mnt_flags & MNT_NOEXEC ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_ATIME ) && ( ( mnt -> mnt . mnt_flags & MNT_ATIME_MASK ) != ( mnt_flags & MNT_ATIME_MASK ) ) ) { return - EPERM ; }
<S2SV_ModStart> = SCALAR_VALUE ; if ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) { <S2SV_ModStart> -> dst_reg , insn -> imm ) ; } else { __mark_reg_known ( regs + insn -> dst_reg , ( u32 ) insn -> imm ) ; } <S2SV_ModEnd> } } else
<S2SV_ModStart> ( tty ) && ! L_EXTPROC ( tty )
<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
<S2SV_ModStart> -> index ; memset ( & sync , 0 , sizeof ( sync ) ) ;
<S2SV_ModStart> , * insn_idx , false
<S2SV_ModStart> NULL ; } dst_state -> speculative = src -> speculative ;
<S2SV_ModStart> cur -> curframe ) return false ; if ( old -> speculative && ! cur -> speculative
<S2SV_ModStart> ; if ( new_len > old_len ) { unsigned long pgoff ; if ( <S2SV_ModStart> VM_PFNMAP ) ) goto Efault ; pgoff = ( addr - vma -> vm_start ) >> PAGE_SHIFT ; pgoff += vma -> vm_pgoff ; if ( pgoff + ( new_len >> PAGE_SHIFT ) < pgoff ) goto Einval <S2SV_ModEnd> ; } if
<S2SV_ModStart> return true ; <S2SV_ModEnd> } return false
<S2SV_ModStart> 0 ) ; if ( ! res ) return - EINVAL ;
<S2SV_ModStart> -> setkey = skcipher_setkey <S2SV_ModEnd> ; skcipher ->
<S2SV_ModStart> ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , "cipher" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp . <S2SV_ModStart> . type , "compression" , sizeof ( rcomp . type ) <S2SV_ModEnd> ) ; if
<S2SV_ModStart> -> sec_level ; sec . key_size = 0 ;
<S2SV_ModStart> = - EINVAL ; msg -> msg_namelen = 0
<S2SV_ModStart> NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> free_ret ; } if ( memcmp ( & dd , dd_config , sizeof ( dd ) ) ) { ret = - EINVAL ; goto free_ret ; }
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> - ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;
<S2SV_ModStart> goto out_dput ; error = btrfs_check_dir_item_collision ( BTRFS_I ( dir ) -> root , dir -> i_ino , name , namelen ) ; if ( error ) goto out_dput ;
<S2SV_ModStart> == - EEXIST || ret == - EOVERFLOW
<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
<S2SV_ModStart> r = - EINVAL ; if ( atomic_read ( & kvm -> online_vcpus ) ) goto create_irqchip_unlock ; r = -
<S2SV_ModStart> ; if ( ! kvm_vcpu_compatible ( vcpu ) ) { r = - EINVAL ; goto unlock_vcpu_destroy ; } if (
<S2SV_ModStart> ; if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> ( asoc , asconf_ack , false , <S2SV_ModEnd> & err_param )
<S2SV_ModStart> ; if ( <S2SV_ModEnd> atomic_read ( &
<S2SV_ModStart> ; if ( fp &&
<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;
<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
<S2SV_ModStart> 0 ) { mutex_lock ( & kvm -> lock ) ; list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; <S2SV_ModStart> destroy ( dev <S2SV_ModEnd> ) ; return
<S2SV_ModStart> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ;
<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
<S2SV_ModStart> i > pos + delta <S2SV_ModStart> off + 1 <= pos + delta <S2SV_ModEnd> ) insn ->
<S2SV_ModStart> return ret ; fsnotify_put_group ( group ) ;
<S2SV_ModStart> ( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
<S2SV_ModStart> ; if ( shm_file == NULL ) { err = - EIDRM ; goto out_unlock0 ; } if (
<S2SV_ModStart> shm_perm ) ; if ( shp -> shm_file == NULL ) { ipc_unlock_object ( & shp -> shm_perm ) ; err = - EIDRM ; goto out_unlock ; }
<S2SV_ModStart> nikeys ) ; if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart> key -> user <S2SV_ModEnd> ) ; kfree
<S2SV_ModStart> thread -> tp_value [ 0 ] <S2SV_ModStart> childregs -> ARM_r3 ; thread -> tp_value [ 1 ] = get_tpuser ( )
<S2SV_ModStart> ) -> tp_value [ 0 ]
<S2SV_ModStart> ; int err = 0 ; msg -> msg_namelen
<S2SV_ModStart> ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) , GFP_KERNEL , & sa , NULL <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> ) ) ; hdr -> sadb_msg_reserved = 0 ;
<S2SV_ModStart> clips_ptr ) { if ( num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS ) { ret = - EINVAL ; goto out_err1 ; }
<S2SV_ModStart> = "stack<S2SV_blank>" ; strict = true ;
<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
<S2SV_ModStart> case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID :
<S2SV_ModStart> goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;
<S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , regs
<S2SV_ModStart> ( event , <S2SV_ModEnd> data , regs
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , 0
<S2SV_ModStart> PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , xcp ,
<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
<S2SV_ModStart> val , regs <S2SV_ModEnd> ) ; }
<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
<S2SV_ModStart> struct serial_icounter_struct icount = { }
<S2SV_ModStart> if ( ( skb_mac_header <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) < skb -> head +
<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> CPU_FTR_TM_COMP ) && hv_enabled <S2SV_ModEnd> ; break ;
<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk ,
<S2SV_ModStart> snd_kcontrol * kctl ; if ( card -> last_numid >= UINT_MAX - count ) card -> last_numid = 0
<S2SV_ModStart> size ) ; if ( ( dj_report -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & hdev -> dev , "%s:<S2SV_blank>invalid<S2SV_blank>device<S2SV_blank>index:%d\\n" , __func__ , dj_report -> device_index ) ; return false ; }
<S2SV_ModStart> } if ( <S2SV_ModEnd> djrcv_dev -> paired_dj_devices
<S2SV_ModStart> ; if ( sk != rcvr -> sk ) { sctp_bh_unlock_sock ( sk ) ; sk = rcvr -> sk ; sctp_bh_lock_sock ( sk ) ; } if (
<S2SV_ModStart> & tu -> ioctl_lock <S2SV_ModEnd> ) ; tu
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> ) , & _dh <S2SV_ModEnd> ) ; BUG_ON
<S2SV_ModStart> void * buffer ; if ( params -> buffer . fragment_size == 0 || params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) return - EINVAL
<S2SV_ModStart> } if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
<S2SV_ModStart> ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ;
<S2SV_ModStart> out_free_buffer ; } } else if ( request_size < 0 ) { rc = - EINVAL ; goto out_free_buffer ;
<S2SV_ModStart> argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file =
<S2SV_ModStart> ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ;
<S2SV_ModStart> ; file = kzalloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> { if ( sctp_chunk_pending ( ack ) ) continue ; if (
<S2SV_ModStart> ) exit_io_context ( tsk
<S2SV_ModStart> ; bad_fork_cleanup_io : if <S2SV_ModEnd> ( p -> <S2SV_ModStart> p -> io_context ) exit_io_context ( p
<S2SV_ModStart> fmt , buf + p <S2SV_ModEnd> , c ,
<S2SV_ModStart> = 0 ; lsa -> l2tp_conn_id = 0 ;
<S2SV_ModStart> struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) )
<S2SV_ModStart> -> b_size = ( u64 )
<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (
<S2SV_ModStart> , APIC_TMICT ) == 0 || apic -> lapic_timer . period
<S2SV_ModStart> direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
<S2SV_ModStart> } if ( le32_to_cpu ( raw_super -> segment_count ) > F2FS_MAX_SEGMENT ) { f2fs_msg ( sb , KERN_INFO , "Invalid<S2SV_blank>segment<S2SV_blank>count<S2SV_blank>(%u)" , le32_to_cpu ( raw_super -> segment_count ) ) ; return 1 ; } if (
<S2SV_ModStart> struct siginfo info = { }
<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
<S2SV_ModStart> error ) { if ( bp && ( <S2SV_ModEnd> xfs_da_shrink_inode ( args <S2SV_ModStart> , bp ) != 0 ) <S2SV_ModEnd> ) goto out
<S2SV_ModStart> var_off ) ; if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; }
<S2SV_ModStart> rc ) { if ( rc -> uwbd . task )
<S2SV_ModStart> -> sa ; * addr_len = sizeof ( * saddr ) ; } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> - ENOMEM ; * ( ( struct vbg_ioctl_hdr * ) buf ) = hdr ; <S2SV_ModStart> copy_from_user ( buf + sizeof ( hdr ) <S2SV_ModStart> * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) <S2SV_ModEnd> ) ) {
<S2SV_ModStart> u64 ) len - s
<S2SV_ModStart> { if ( serial -> port [ 0 ] &&
<S2SV_ModStart> DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
<S2SV_ModStart> ; if ( l < 10 || l > 20 ) return - 1 ; if (
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> slow ) ; cond_resched ( ) <S2SV_ModEnd> ; msg ->
<S2SV_ModStart> , rqstp , res <S2SV_ModEnd> ) ; out
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void _copy_from_pages (
<S2SV_ModStart> case EXIT_REASON_VMON : case EXIT_REASON_INVEPT :
<S2SV_ModStart> = KEYRING_SEARCH_LOOKUP_ITERATE ; match_data -> cmp = asymmetric_key_cmp ;
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! index_key .
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> . cmp = key_default_cmp <S2SV_ModEnd> , . match_data
<S2SV_ModStart> nlmsg_data ( nlh ) ; memset ( bpm , 0 , sizeof ( * bpm )
<S2SV_ModStart> br_mdb_entry e ; memset ( & e , 0 , sizeof ( e ) ) ;
<S2SV_ModStart> struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )
<S2SV_ModStart> nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;
<S2SV_ModStart> args -> local_vec_addr ; if ( args -> nr_local == 0 ) return - EINVAL
<S2SV_ModStart> ; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )
<S2SV_ModStart> err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }
<S2SV_ModStart> == 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
<S2SV_ModStart> ( ret || ! cm_id -> device ||
<S2SV_ModStart> tty_mutex ) ; tty_driver_kref_put ( driver ) ;
<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
<S2SV_ModStart> | 1 ) ; if ( vcpu -> arch . time_offset & ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break
<S2SV_ModStart> -> ctx -> task <S2SV_ModEnd> != ctx -> <S2SV_ModStart> != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu <S2SV_ModEnd> ) goto err_context
<S2SV_ModStart> -> ctx . <S2SV_ModEnd> pmu = pmu
<S2SV_ModStart> ; __be32 * pdata ; if ( datalen != 4 ) return - EINVAL ;
<S2SV_ModStart> { if ( datalen != 1 ) return - EINVAL ; if (
<S2SV_ModStart> break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ;
<S2SV_ModStart> end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
<S2SV_ModStart> * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , "required<S2SV_blank>endpoint<S2SV_blank>is<S2SV_blank>missing\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
<S2SV_ModStart> ; if ( nlh -> nlmsg_len < NLMSG_HDRLEN || skb -> len < nlh -> nlmsg_len || <S2SV_ModStart> struct nfgenmsg ) ) { nfnl_err_reset ( & err_list ) ; status |= NFNL_BATCH_FAILURE ; goto done <S2SV_ModEnd> ; } if
<S2SV_ModStart> net ) ; <S2SV_ModEnd> svc_shutdown_net ( serv
<S2SV_ModStart> ; serv = svc_create_pooled <S2SV_ModEnd> ( & nfs4_callback_program
<S2SV_ModStart> FATTR4_WORD2_SUPPATTR_EXCLCREAT ) { u32 supp [ 3 ] ; memcpy ( supp , nfsd_suppattrs [ minorversion ] , sizeof ( supp ) ) ; supp [ 0 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD0 ; supp [ 1 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD1 ; supp [ 2 ] &= NFSD_SUPPATTR_EXCLCREAT_WORD2 ; <S2SV_ModStart> ( xdr , supp [ 0 ] , supp [ 1 ] , supp [ 2 ] <S2SV_ModEnd> ) ; if
<S2SV_ModStart> goto out ; if ( path . mnt == exp -> ex_path . mnt && path . dentry == dentry && nfsd_mountpoint ( dentry , exp ) == 2 ) { path_put ( & path ) ; goto out ; }
<S2SV_ModStart> ; long timeo ; msg -> msg_namelen = 0
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> -> mglist && mp -> timer_armed &&
<S2SV_ModStart> , sizeof ( *
<S2SV_ModStart> unlikely ( len + ring -> frameoffset
<S2SV_ModStart> = BT_CONFIG ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> cpuinfo_x86 * c ; if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM
<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,
<S2SV_ModStart> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
<S2SV_ModStart> if ( ! EXT4_SB ( sb ) -> s_journal <S2SV_ModEnd> ) return 0
<S2SV_ModStart> < 0 ) goto error ; <S2SV_ModEnd> goto set ;
<S2SV_ModStart> ; return ret <S2SV_ModEnd> ; } return
<S2SV_ModStart> process_keyring ) return 0 <S2SV_ModEnd> ; keyring =
<S2SV_ModStart> return - ENOMEM <S2SV_ModEnd> ; ret =
<S2SV_ModStart> key * keyring ; if ( new -> thread_keyring ) return 0
<S2SV_ModStart> return 0 ; if ( serial -> num_bulk_in < 2 || serial -> num_interrupt_in < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; }
<S2SV_ModStart> : if ( rec >= f -> num ) { ldm_error ( "REC<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>NUM<S2SV_blank>value<S2SV_blank>(%d)" , rec , f -> num ) ; return false ; } if (
<S2SV_ModStart> & multicast_idr , NULL <S2SV_ModEnd> , 0 ,
<S2SV_ModStart> err3 ; } mutex_lock ( & mut ) ; idr_replace ( & multicast_idr , mc , mc -> id ) ; mutex_unlock ( & mut ) ;
<S2SV_ModStart> ( serial -> num_bulk_out <S2SV_ModEnd> < 2 ) <S2SV_ModStart> < 2 ) { dev_err ( & serial -> interface -> dev , "missing<S2SV_blank>bulk<S2SV_blank>out<S2SV_blank>endpoints\\n" ) ; return - ENODEV ; } <S2SV_ModEnd> port = serial
<S2SV_ModStart> net != c_net <S2SV_ModEnd> ) continue ;
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } if (
<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> svm , AC_VECTOR ) ; set_exception_intercept ( svm , DB_VECTOR
<S2SV_ModStart> break ; } if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) break ;
<S2SV_ModStart> ( ) ; if ( ! check_mnt ( real_mount ( path -> mnt ) ) ) tree = ERR_PTR ( - EINVAL ) ; else
<S2SV_ModStart> mnt_parent ) ; if ( dentry != vfsmnt -> mnt_root ) { bptr = * buffer ; blen = * buflen ; error = 3 ; break ; }
<S2SV_ModStart> mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else
<S2SV_ModStart> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } }
<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> "" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ;
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> , e -> elems , e ->
<S2SV_ModStart> 0 ) { <S2SV_ModEnd> kfree ( tmpbuf
<S2SV_ModStart> snd_timer_tread tread ; memset ( & tread , 0 , sizeof ( tread ) ) ;
<S2SV_ModStart> ; sig_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> ; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
<S2SV_ModStart> ; if ( dumpable != SUID_DUMP_USER && <S2SV_ModEnd> ! ptrace_has_cap (
<S2SV_ModStart> , spi ) > 0 ? : 0
<S2SV_ModStart> idr ) ; atomic_dec ( & group -> inotify_data . user -> inotify_devs ) ;
<S2SV_ModStart> cpl , false , NULL
<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> ; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
<S2SV_ModStart> = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ;
<S2SV_ModStart> prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ;
<S2SV_ModStart> = new_ns ; new_ns -> mounts ++ ;
<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
<S2SV_ModStart> ) ; return count_mounts ( m -> mnt_ns , child ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> if ( ! list_empty ( & asoc -> asocs ) <S2SV_ModEnd> ) { list_del
<S2SV_ModStart> ; if ( <S2SV_ModEnd> ! f2fs_readonly (
<S2SV_ModStart> = fcc ; if ( ! test_opt ( sbi , FLUSH_MERGE ) ) return err ;
<S2SV_ModStart> : if ( ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) bprm -> per_clear |= PER_CLEAR_ON_SETID ; if (
<S2SV_ModStart> ; err : <S2SV_ModEnd> free_percpu ( ctx
<S2SV_ModStart> = 0 ; msg -> msg_namelen = 0 ;
<S2SV_ModStart> || ns_capable ( task_active_pid_ns ( current ) <S2SV_ModEnd> -> user_ns ,
<S2SV_ModStart> = pcrypt_aead_decrypt ; inst -> free = pcrypt_free ;
<S2SV_ModStart> = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
<S2SV_ModStart> - ENOMEM ; tmp . name [ sizeof ( tmp . name ) - 1 ] = 0 ;
<S2SV_ModStart> ctxt -> rip_relative && likely ( ctxt -> memopp )
<S2SV_ModStart> ( ( data ^ PSW_USER_BITS ) <S2SV_ModStart> ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return -
<S2SV_ModStart> ) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
<S2SV_ModStart> * cred , fmode_t <S2SV_ModEnd> mode ) {
<S2SV_ModStart> termios_rwsem ) ; tty -> disc_data = NULL ; tty -> receive_room = 0 ;
<S2SV_ModStart> private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> ( upid == INT_MIN ) return - ESRCH ; if ( upid ==
<S2SV_ModStart> , inode , map ,
<S2SV_ModStart> |= EXT4_EXT_MARK_UNINIT2 ; if ( flags & EXT4_GET_BLOCKS_CONVERT ) split_flag |= EXT4_EXT_DATA_VALID2 ;
<S2SV_ModStart> ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT <S2SV_ModEnd> && ! opt
<S2SV_ModStart> rtm_flags |= RTM_F_NOTIFY ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT ) r -> rtm_flags |= RTCF_DOREDIRECT
<S2SV_ModStart> struct hns_roce_ib_alloc_ucontext_resp resp = { }
<S2SV_ModStart> err = 0 ; if ( ! net_eq ( current -> nsproxy -> net_ns , sock_net ( sk ) ) ) return - EINVAL
<S2SV_ModStart> return - EINVAL ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY
<S2SV_ModStart> current_timeo ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
<S2SV_ModStart> ( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }
<S2SV_ModStart> disconnect = ! ( ( ( how & UMOUNT_CONNECTED ) && mnt_has_parent ( p ) && ( p -> mnt_parent -> mnt . mnt_flags & MNT_UMOUNT ) ) || <S2SV_ModStart> IS_MNT_LOCKED_AND_LAZY ( p )
<S2SV_ModStart> siocb -> scm , true
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> siocb -> scm , false
<S2SV_ModStart> ( d ) ; msg -> msg_namelen = 0
<S2SV_ModStart> -> i_unique ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > inode -> i_sb -> s_blocksize - udf_file_entry_alloc_offset ( inode ) ) goto out ; }
<S2SV_ModStart> ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) )
<S2SV_ModStart> { if ( ( <S2SV_ModStart> shmflg & SHM_RND ) && addr >= shmlba
<S2SV_ModStart> ) ) ; if ( af == NULL ) break ;
<S2SV_ModStart> resolution ) { memset ( & r1 , 0 , sizeof ( r1 ) ) ;
<S2SV_ModStart> { if ( <S2SV_ModEnd> arg >= cdi
<S2SV_ModStart> ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
<S2SV_ModStart> mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
<S2SV_ModStart> -> rq_procinfo ; if ( nfs_request_too_big ( rqstp , proc ) ) { dprintk ( "nfsd:<S2SV_blank>NFSv%d<S2SV_blank>argument<S2SV_blank>too<S2SV_blank>large\\n" , rqstp -> rq_vers ) ; * statp = rpc_garbage_args ; return 1 ; }
<S2SV_ModStart> media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;
<S2SV_ModStart> ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
<S2SV_ModStart> - ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;
<S2SV_ModStart> goto out_key2 ; if ( match_futex ( & q . key , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
<S2SV_ModStart> current_area -- ; skip_metadata ( ps ) ;
<S2SV_ModStart> tn_buf ) ; return - EACCES ;
<S2SV_ModStart> i_data_sem ) ; init_rwsem ( & ei -> i_mmap_sem ) ;
<S2SV_ModStart> sent = 0 <S2SV_ModEnd> ; smb_msg .
<S2SV_ModStart> val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
<S2SV_ModStart> sctp_ierror_t ret ; if ( ! net -> sctp . auth_enable || ! new_asoc -> peer . auth_capable ) { kfree_skb ( chunk -> auth_chunk ) ; sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; }
<S2SV_ModStart> -> private ; struct dm_dev * dev = fc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( fc -> <S2SV_ModStart> ( fc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if <S2SV_ModEnd> ( lc -> <S2SV_ModStart> ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( <S2SV_ModStart> -> bdev , <S2SV_ModEnd> dev -> mode
<S2SV_ModStart> flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> iv ) ; <S2SV_ModEnd> while ( walk
<S2SV_ModStart> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list )
<S2SV_ModStart> struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) )
<S2SV_ModStart> goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
<S2SV_ModStart> &= KVM_PIT_CHANNEL_MASK ; if ( addr == 3 ) return 0 ;
<S2SV_ModStart> -> running ) list_del_init <S2SV_ModEnd> ( & ti
<S2SV_ModStart> = current ; <S2SV_ModEnd> BUG_ON ( !
<S2SV_ModStart> task = current <S2SV_ModEnd> ; if (
<S2SV_ModStart> ) ; } <S2SV_ModEnd> atomic_long_set ( &
<S2SV_ModStart> file ) ; <S2SV_ModEnd> file_free ( file
<S2SV_ModStart> s_inode_lru ) ; <S2SV_ModEnd> for ( i
<S2SV_ModStart> force ) { sb -> s_readonly_remount = 1 ; smp_wmb ( <S2SV_ModEnd> ) ; }
<S2SV_ModStart> ; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1
<S2SV_ModStart> : if ( is_nmi <S2SV_ModEnd> ( intr_info )
<S2SV_ModStart> ; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) {
<S2SV_ModStart> ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) &&
<S2SV_ModStart> goto err ; cpu = cpumask_first ( mask ) ;
<S2SV_ModStart> ++ ) { if ( ! cd -> disk ) continue ;
<S2SV_ModStart> ) ) { put_disk ( disk ) ;
<S2SV_ModStart> } if ( rq -> curr -> se . on_rq &&
<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
<S2SV_ModStart> ( commands , SCTP_CMD_SET_ASOC <S2SV_ModEnd> , SCTP_ASOC (
<S2SV_ModStart> 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ;
<S2SV_ModStart> rs_bound_addr == 0 || ! rs -> rs_transport
<S2SV_ModStart> -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) ==
<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
<S2SV_ModStart> |= MSG_TRUNC ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; for (
<S2SV_ModStart> goto end ; <S2SV_ModEnd> if ( skb
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; if (
<S2SV_ModStart> return - EOPNOTSUPP <S2SV_ModEnd> ; BT_DBG (
<S2SV_ModStart> return err ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
<S2SV_ModStart> = BT_CONFIG ; <S2SV_ModEnd> release_sock ( sk
<S2SV_ModStart> ) goto read_error <S2SV_ModEnd> ; skb =
<S2SV_ModStart> goto out ; <S2SV_ModEnd> err = -
<S2SV_ModStart> err ; } if ( kern_msg -> msg_name )
<S2SV_ModStart> err ; } if ( m -> msg_name )
<S2SV_ModStart> -> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc
<S2SV_ModStart> __func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> noblock ) ; <S2SV_ModEnd> do { int
<S2SV_ModStart> ; u32 offset <S2SV_ModEnd> ; if (
<S2SV_ModStart> goto out ; <S2SV_ModEnd> skb = skb_recv_datagram
<S2SV_ModStart> ) goto end <S2SV_ModEnd> ; err =
<S2SV_ModStart> ; long timeo <S2SV_ModEnd> ; lock_sock (
<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
<S2SV_ModStart> return rc ; <S2SV_ModEnd> copied = skb
<S2SV_ModStart> , timeo ) <S2SV_ModEnd> ; if (
<S2SV_ModStart> -> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev
<S2SV_ModStart> crypto_report_acomp racomp ; strncpy <S2SV_ModEnd> ( racomp .
<S2SV_ModStart> crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher .
<S2SV_ModStart> crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher .
<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp .
<S2SV_ModStart> crypto_report_kpp rkpp ; strncpy <S2SV_ModEnd> ( rkpp .
<S2SV_ModStart> sb ) ; sb -> s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH ;
<S2SV_ModStart> # ifdef CONFIG_SCHED_STACK_END_CHECK if <S2SV_ModEnd> ( task_stack_end_corrupted ( <S2SV_ModStart> ( prev ) ) panic ( "corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\n"
<S2SV_ModStart> - EIO ; if ( ++ rs -> cont_loops >= RR_MAX_CE_ENTRIES ) goto out ;
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = ireq ->
<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
<S2SV_ModStart> __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . <S2SV_ModEnd> faddr ; rt
<S2SV_ModStart> ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) <S2SV_ModEnd> ) ; dst_release
<S2SV_ModStart> p ) { memset ( p , 0 , sizeof ( * p ) ) ;
<S2SV_ModStart> ) != ulen || replay_esn -> bmp_len != up -> bmp_len
<S2SV_ModStart> ; dl = kzalloc <S2SV_ModEnd> ( size ,
<S2SV_ModStart> ( user_alloc && ( <S2SV_ModStart> PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size
<S2SV_ModStart> ; r = __copy_from_user <S2SV_ModEnd> ( data ,
<S2SV_ModStart> aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED
<S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 0 ;
<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
<S2SV_ModStart> ( wake_q ) ; if ( nr_wake < 0 || nr_requeue < 0 ) return - EINVAL
<S2SV_ModStart> -> device_data ; cancel_autoload_drivers ( ) ;
<S2SV_ModStart> event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + ( hwc -> idx - X86_PMC_IDX_FIXED )
<S2SV_ModStart> ; r = <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( vcpu
<S2SV_ModStart> ipv6_pinfo ) ) ; newnp -> ipv6_mc_list = NULL ; newnp -> ipv6_ac_list = NULL ; newnp -> ipv6_fl_list = NULL
<S2SV_ModStart> { if ( th -> fin ) goto discard ; if (
<S2SV_ModStart> -> i_iget5_offset ; fh16 [ 3 ] = 0 ;
<S2SV_ModStart> return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> { for ( pad = ( <S2SV_ModEnd> w % 4
<S2SV_ModStart> ; if ( ( <S2SV_ModStart> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , "%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> max = w
<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
<S2SV_ModStart> ( header -> biBitCount == 0 ) { fprintf ( stderr , "Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n" , 0 ) ; return OPJ_FALSE ; } if ( header ->
<S2SV_ModStart> p_stream ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> p_stream ) ; <S2SV_ModEnd> if ( p_total_data_size
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> , p_data , p_total_data_size ,
<S2SV_ModStart> ( f , "PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d" <S2SV_ModEnd> , temp ,
<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l
<S2SV_ModStart> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> s ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> NULL ) ; if ( ! <S2SV_ModStart> , cc ) ) return 0
<S2SV_ModStart> 0 ) ; if <S2SV_ModEnd> ( ( cc0 <S2SV_ModStart> % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } <S2SV_ModEnd> while ( cc
<S2SV_ModStart> ; stripsperplane = TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> ( td -> <S2SV_ModStart> td -> td_imagelength , <S2SV_ModEnd> rowsperstrip ) ;
<S2SV_ModStart> = 0 ; uint32 <S2SV_ModEnd> strip , nstrips
<S2SV_ModStart> s < ns && row < imagelength
<S2SV_ModStart> col < imagewidth && colb < imagew
<S2SV_ModStart> col < imagewidth && colb < imagew
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpContig2SeparateByRow" ) ; return 0 ; }
<S2SV_ModStart> tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpSeparate2ContigByRow" ) ; return 0 ; }
<S2SV_ModStart> ( void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in ,
<S2SV_ModStart> { uint16 bitspersample = 1
<S2SV_ModStart> "(cc0%rowsize)!=0" ) ; _TIFFfree ( working_copy ) ;
<S2SV_ModStart> int outskew , int64 <S2SV_ModEnd> inskew ) {
<S2SV_ModStart> tif_rawcc ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> 0 ) ; }
<S2SV_ModStart> , buffer , t2p -> tiff_datasize ,
<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( "reverseSamplesBytes" , "bytes_per_pixel<S2SV_blank>too<S2SV_blank>large" ) ; return ( 1 ) ; }
<S2SV_ModStart> } bufp += stripsize <S2SV_ModEnd> ; } return
<S2SV_ModStart> ; uint32 nstrips <S2SV_ModEnd> ; nstrips =
<S2SV_ModStart> if ( count > <S2SV_ModEnd> 4 ) {
<S2SV_ModStart> 1 ) { if ( code >= clear ) { fprintf ( stderr , "bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n" , code , clear ) ; return 0 ; }
<S2SV_ModStart> ! vct_iscrlf ( <S2SV_ModEnd> r ) )
<S2SV_ModStart> ) break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> "checked_xcalloc" , ( res <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> connection == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
<S2SV_ModStart> ( length > 1 <S2SV_ModEnd> ) { if
<S2SV_ModStart> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
<S2SV_ModStart> = audio_conv_info ; usb_conv_info -> class_data_type = USB_CONV_AUDIO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_AUDIO ) { return 0 ;
<S2SV_ModStart> = usb_ms_conv_info ; usb_conv_info -> class_data_type = USB_CONV_MASS_STORAGE ; } else if ( usb_conv_info -> class_data_type != USB_CONV_MASS_STORAGE ) { return 0 ;
<S2SV_ModStart> = video_conv_info ; usb_conv_info -> class_data_type = USB_CONV_VIDEO ; } else if ( usb_conv_info -> class_data_type != USB_CONV_VIDEO ) { return descriptor_len ;
<S2SV_ModStart> if ( ( ( <S2SV_ModStart> ) < bodyLength ) || ( bodyLength < sizeof ( EAPOL_RSN_KEY ) )
<S2SV_ModStart> ; remaining = tvb_reported_length_remaining <S2SV_ModEnd> ( tvb ,
<S2SV_ModStart> } if ( ( <S2SV_ModStart> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len <S2SV_ModStart> sizeof ( EAPOL_RSN_KEY )
<S2SV_ModStart> ctx , expr -> unary . child
<S2SV_ModStart> NULL ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case EXPR_FIELD_REF
<S2SV_ModStart> ; if ( ! str ) return false ; if (
<S2SV_ModStart> ( s ) && ! eof ( s )
<S2SV_ModStart> , pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> ParseCommon * ) <S2SV_ModEnd> append ) ;
<S2SV_ModStart> } if ( ! page_name_is_good ( page <S2SV_ModEnd> ) ) {
<S2SV_ModStart> len > BUFSIZE - <S2SV_ModEnd> sizeof ( struct
