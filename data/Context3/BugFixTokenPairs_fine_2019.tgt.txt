<S2SV_ModStart> ++ len ) { <S2SV_ModStart> == '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out = (
<S2SV_ModStart> ; s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> return ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> ( s -> <S2SV_ModEnd> max_ra == INT_MAX
<S2SV_ModStart> gb ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> += run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> * st ; int ret ; <S2SV_ModStart> val ) ; ret = <S2SV_ModStart> ] ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> sum = ( <S2SV_ModStart> ++ ; } \\\n} <S2SV_ModEnd> typedef struct PCDTable <S2SV_ModStart> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
<S2SV_ModStart> "`%s\'" , option ) ; page_geometry = DestroyString ( page_geometry
<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> Quantum index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> RelinquishMagickMemory ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j
<S2SV_ModStart> size_t ) count + 1
<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ) ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> ; if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> ; while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> if ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break ; <S2SV_ModStart> + filepos ) >= <S2SV_ModEnd> GetBlobSize ( image <S2SV_ModStart> - 1 ) ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile"
<S2SV_ModStart> = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> NULL ) { status = MagickFalse ; break <S2SV_ModEnd> ; } image
<S2SV_ModStart> ( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> IndexPacket index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * <S2SV_ModStart> j ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j <S2SV_ModStart> ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels
<S2SV_ModStart> "`%s\'" , option ) ; geometry = DestroyString ( geometry
<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> , 0 , ROUNDUP ( size , granularity ) ) ; } <S2SV_ModEnd> return mobj ;
<S2SV_ModStart> uaddr_t a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> len , & end_addr <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( a = ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> ; a < <S2SV_ModStart> ; a < end_addr <S2SV_ModEnd> ; a +=
<S2SV_ModStart> return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if
<S2SV_ModStart> return res ; res = utee_param_to_param ( utc , <S2SV_ModEnd> param , callee_params <S2SV_ModStart> , callee_params ) ; if ( res != TEE_SUCCESS ) return res
<S2SV_ModStart> <S2SV_null> <S2SV_null> static TEE_Result utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModEnd> struct tee_ta_param * <S2SV_ModStart> 1 ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> ) { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p -> <S2SV_ModStart> = b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> ; } } return TEE_SUCCESS ;
<S2SV_ModStart> mem ) { size_t req_size = 0 ; <S2SV_ModStart> size ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
<S2SV_ModStart> outbuf ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart> & 0x07 ; <S2SV_ModEnd> octets_left = inlen <S2SV_ModStart> - 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> ) - zero_bits
<S2SV_ModStart> SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen
<S2SV_ModStart> ; unsigned char * signature = NULL <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> unsigned int siglen <S2SV_ModEnd> ; const EVP_MD <S2SV_ModStart> ; if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> ; err : free ( signature ) ;
<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; }
<S2SV_ModStart> U2FH_OK ) { int offs = sizeof ( nonce ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> if ( resplen < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> dev -> cid <S2SV_ModStart> -> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionInterface = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMajor = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> versionMinor = resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> ; dev -> <S2SV_ModStart> -> capFlags = resp [ offs ++ ] <S2SV_ModEnd> ; } else
<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
<S2SV_ModStart> cfg ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> } else { fd = open ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModEnd> , & st <S2SV_ModStart> == 0 ) && <S2SV_ModEnd> S_ISREG ( st <S2SV_ModStart> { file = fdopen ( fd <S2SV_ModEnd> , "a" ) <S2SV_ModStart> = file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } } <S2SV_ModStart> ) ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;
<S2SV_ModStart> authfile , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; goto err ; } else { fd = - 1 <S2SV_ModStart> opwfile ) ; <S2SV_ModEnd> if ( fd <S2SV_ModStart> if ( fd != - 1 <S2SV_ModEnd> ) close (
<S2SV_ModStart> ; int openasuser = 0 <S2SV_ModStart> should_free_authpending_file = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> done ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> DEFAULT_AUTHFILE ) ; if ( ! openasuser ) { DBG ( "WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>" "consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration" <S2SV_ModEnd> , buf ) <S2SV_ModStart> buf ) ; } } DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; <S2SV_ModStart> ) ; } if ( ! openasuser ) { openasuser <S2SV_ModEnd> = geteuid ( <S2SV_ModStart> -> openasuser ; } <S2SV_ModStart> openasuser ) { DBG ( "Dropping<S2SV_blank>privileges" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> ) ) { <S2SV_ModStart> ( "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> ( "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) ; <S2SV_ModStart> { if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( "could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges" <S2SV_ModEnd> ) ; retval <S2SV_ModStart> } DBG ( "Restored<S2SV_blank>privileges" <S2SV_ModEnd> ) ; }
<S2SV_ModStart> { LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> ( s ) { tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 4 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
<S2SV_ModStart> text ; int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> ) { int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> ; if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> if ( ! js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog <S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
<S2SV_ModStart> Resub * out , int depth <S2SV_ModStart> scratch ; int result ; int <S2SV_ModStart> Rune c ; if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> I_END : return 0 <S2SV_ModEnd> ; case I_JUMP <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> ) { * <S2SV_ModStart> scratch ; return 0 <S2SV_ModEnd> ; } pc <S2SV_ModStart> case I_PLA : result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> flags , out , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> * out ; result = <S2SV_ModEnd> match ( pc <S2SV_ModStart> , & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> c ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> 0 ) return 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } pc <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } else <S2SV_ModStart> ) ) return 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_EOL <S2SV_ModStart> } } return 1 <S2SV_ModEnd> ; case I_WORD <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> i ) return 1 <S2SV_ModEnd> ; pc = <S2SV_ModStart> default : return 1 <S2SV_ModEnd> ; } }
<S2SV_ModStart> NULL ; return <S2SV_ModEnd> match ( prog <S2SV_ModStart> eflags , sub , 0
<S2SV_ModStart> OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> char buf [ 100 <S2SV_ModEnd> ] ; js_Object <S2SV_ModStart> = "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_ModEnd> double number =
<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
<S2SV_ModStart> void addModuleArgument ( Parse * pParse <S2SV_ModEnd> , Table * <S2SV_ModStart> zArg ) { sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> * azModuleArg ; sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s" , pTable -> zName ) ; }
<S2SV_ModStart> # ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> >= 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> nOpAlloc <S2SV_ModStart> ; # else sqlite3_int64 <S2SV_ModEnd> nNew = ( <S2SV_ModStart> -> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> 1024 / sizeof <S2SV_ModStart> sizeof ( Op <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> * aVTrans ; sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> ) * ( ( sqlite3_int64 )
<S2SV_ModStart> ( sz * ( sqlite3_int64 )
<S2SV_ModStart> * z ; sqlite3_int64 <S2SV_ModEnd> n = * <S2SV_ModStart> 0 ) { sqlite3_int64 <S2SV_ModEnd> sz = (
<S2SV_ModStart> ( 2 * ( sqlite3_int64 )
<S2SV_ModStart> * pNew ; sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc <S2SV_ModEnd> + nExtra ;
<S2SV_ModStart> ] ) { sqlite3_int64 <S2SV_ModEnd> nAlloc = ( <S2SV_ModStart> ( pIn ? 2 * ( sqlite3_int64 ) pIn [ 0 ] <S2SV_ModEnd> : 10 )
<S2SV_ModStart> . aMemory ; sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> pSorter -> nMemory <S2SV_ModStart> pSorter -> nMemory <S2SV_ModEnd> ; while (
<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTable ,
<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab , <S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pTab ,
<S2SV_ModStart> pWith ) { sqlite3_int64 <S2SV_ModEnd> nByte = sizeof
<S2SV_ModStart> * aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = MAX <S2SV_ModStart> ( 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> p -> nAlloc <S2SV_ModEnd> ) ; while
<S2SV_ModStart> * pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = sizeof <S2SV_ModStart> ( 2 * ( sqlite3_int64 ) <S2SV_ModStart> MatchinfoBuffer ) ; sqlite3_int64 nStr = <S2SV_ModEnd> strlen ( zMatchinfo <S2SV_ModStart> ; pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
<S2SV_ModStart> -> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte +
<S2SV_ModStart> ) ) { sqlite3_int64 <S2SV_ModEnd> nNew = sizeof <S2SV_ModStart> * * ) sqlite3_realloc64 <S2SV_ModEnd> ( ( void
<S2SV_ModStart> ; uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> ; uint16_t numChannels = 0 <S2SV_ModStart> numChannels < 1 || numChannels > 256 <S2SV_ModStart> ) ) { if ( ! config -> num_channels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> ; uint32_t sampleRate = 0 <S2SV_ModStart> config -> num_channels || ! config -> sample_rate
<S2SV_ModStart> { uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> , CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> if ( ! desc_chunk || !
<S2SV_ModStart> ; dname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> ; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> { ascii = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> ; ascii = safe_calloc <S2SV_ModEnd> ( str_len )
<S2SV_ModStart> fp ) { <S2SV_ModEnd> char * header <S2SV_ModStart> char * header = safe_calloc ( <S2SV_ModEnd> 1024 ) ; <S2SV_ModStart> 1024 ) ; long
<S2SV_ModStart> ; data = safe_calloc ( <S2SV_ModEnd> blk_sz * n_blks
<S2SV_ModStart> -> entries = safe_calloc ( <S2SV_ModEnd> xref -> n_entries
<S2SV_ModStart> ; daddy = safe_calloc <S2SV_ModEnd> ( sizeof (
<S2SV_ModStart> ; buf = safe_calloc <S2SV_ModEnd> ( sz +
<S2SV_ModStart> -> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
<S2SV_ModStart> ; pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( pdf_t <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen ( <S2SV_ModStart> -> name = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> { dst_name = safe_calloc <S2SV_ModEnd> ( strlen (
<S2SV_ModStart> b ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
<S2SV_ModStart> -> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> file ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> ms ) { uint32_t <S2SV_ModEnd> nestsize = ( <S2SV_ModStart> nestsize = ( uint32_t <S2SV_ModEnd> ) ms ->
<S2SV_ModStart> MOV_GPMF_TRAK_SUBTYPE ) ; if ( mp4 == 0 ) { printf ( "error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> index ) ; double <S2SV_ModEnd> in = 0.0 <S2SV_ModStart> ) ) { double in = 0.0 , out = 0.0 ; <S2SV_ModStart> fourcc , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n" <S2SV_ModEnd> , PRINTF_4CC ( <S2SV_ModStart> ) , rate , in , out
<S2SV_ModStart> [ sizeof ( the_url <S2SV_ModEnd> ) - 1
<S2SV_ModStart> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> ; } else break ; } else <S2SV_ModStart> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j
<S2SV_ModStart> = allow_add_in_command ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> "." ) ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> } else { if ( strlen ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> = 0 ; } <S2SV_ModStart> ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> , '%' ) <S2SV_ModStart> sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n" , sep ) ) ; return GF_NOT_SUPPORTED ; }
<S2SV_ModStart> ) ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> navigate . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf (
<S2SV_ModStart> * ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> url_arg ) ; } <S2SV_ModStart> ! e ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> ( sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> gf_dm_sess_del ( sess <S2SV_ModStart> str ) { strncpy <S2SV_ModEnd> ( the_url , <S2SV_ModStart> , "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; gf_term_connect (
<S2SV_ModStart> - opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> - sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> = 0 ; if ( strlen ( <S2SV_ModEnd> sep2 + 1 <S2SV_ModStart> + 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )
<S2SV_ModStart> , szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )
<S2SV_ModStart> sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> dref ) { GF_Box * dref ; <S2SV_ModStart> ( "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> GF_DataReferenceBox * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ; }
<S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; #
<S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , enc_tables . T <S2SV_ModEnd> ) ; #
<S2SV_ModStart> void ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static inline <S2SV_ModStart> = 0 ; len - i >= 8 * 32 <S2SV_ModEnd> ; i += <S2SV_ModStart> ] ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
<S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = x <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> 0 ] ; <S2SV_ModEnd> j = ( <S2SV_ModStart> + b ; if ( j >= 0 && j < elements * size ) {
<S2SV_ModStart> alternate_nick ) ; g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ;
<S2SV_ModStart> -> sasl_username = g_strdup ( <S2SV_ModStart> src -> sasl_username ) <S2SV_ModStart> -> sasl_password = g_strdup ( <S2SV_ModStart> src -> sasl_password )
<S2SV_ModStart> -> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; } else
<S2SV_ModStart> ')' ) ) { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> PINC ; name_end
<S2SV_ModStart> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; } else
<S2SV_ModStart> len , group <S2SV_ModEnd> ; Node * <S2SV_ModStart> * * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> ) goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;
<S2SV_ModStart> , then_len , else_len , <S2SV_ModStart> then_len + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; r <S2SV_ModStart> ) ) { <S2SV_ModEnd> else_len = compile_length_tree <S2SV_ModStart> , reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> . addr = SIZE_OP_ATOMIC_END + <S2SV_ModStart> ; r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r =
<S2SV_ModStart> tlen ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> tlen = compile_length_tree
<S2SV_ModStart> & 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
<S2SV_ModStart> 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
<S2SV_ModStart> { if ( name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> 0 ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . control <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . spaninfo <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . <S2SV_ModEnd> rtable = fi <S2SV_ModStart> = fi ; <S2SV_ModEnd> } fi ->
<S2SV_ModStart> endif # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA if
<S2SV_ModStart> out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> return NULL ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> out ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image , <S2SV_ModStart> ( image , fg , out <S2SV_ModEnd> ) ; }
<S2SV_ModStart> return NULL ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> ; buf = g_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> ( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
<S2SV_ModStart> , - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error
<S2SV_ModStart> 0 ) { const int qslen = blen - qs ; <S2SV_ModStart> + qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j += <S2SV_ModStart> ; j += qslen <S2SV_ModEnd> ; } buffer_string_set_length
<S2SV_ModStart> , CONST_STR_LEN ( "%2f?" ) , CONST_STR_LEN ( "/?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f?" ) , CONST_STR_LEN ( "//?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
<S2SV_ModStart> ) == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> = 0 ; size_t pathlen = 0 ; <S2SV_ModStart> case AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( struct <S2SV_ModStart> ) -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] = '\\0'
<S2SV_ModStart> && ntokens >= 4 <S2SV_ModEnd> && settings . <S2SV_ModStart> && ntokens >= 4 <S2SV_ModEnd> && settings .
<S2SV_ModStart> "updateDevice()<S2SV_blank>:<S2SV_blank>memory<S2SV_blank>allocation<S2SV_blank>error" ) ; * pp = p -> next ;
<S2SV_ModStart> 3 ; } if ( desc == NULL ) desc = "" ;
<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> fp ) ; unlink ( RUN_LIB_FILE ) ;
<S2SV_ModStart> # ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
<S2SV_ModStart> ( ) ; <S2SV_ModEnd> save_cpu ( ) <S2SV_ModStart> rv ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; # endif set_caps ( ) ; <S2SV_ModEnd> FILE * rj
<S2SV_ModStart> ) ) { char t <S2SV_ModEnd> = from_hex ( <S2SV_ModStart> [ 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> } } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> inverse_db_table [ y & 255 <S2SV_ModStart> inverse_db_table [ y & 255
<S2SV_ModStart> 1 ] ; <S2SV_ModEnd> return NULL ;
<S2SV_ModStart> ++ r ; if <S2SV_ModEnd> ( pow ( <S2SV_ModStart> , dim ) <= entries ) return - 1 ; if <S2SV_ModEnd> ( ( int <S2SV_ModStart> dim ) ) > entries ) return - 1 <S2SV_ModEnd> ; return r
<S2SV_ModStart> ; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> 1 ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> -> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } else <S2SV_ModStart> g -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ) + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )
<S2SV_ModStart> , n ) ; if ( w == NULL ) return 0
<S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
<S2SV_ModStart> ; if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( cp <S2SV_ModStart> ) != NULL || <S2SV_ModEnd> strcmp ( cp <S2SV_ModStart> ( cp , "." ) == 0 || strcmp ( cp , <S2SV_ModStart> ) == 0 <S2SV_ModEnd> ) { run_err
<S2SV_ModStart> ; if ( <S2SV_ModEnd> size_left < 4
<S2SV_ModStart> uint32_t id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> out ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image , <S2SV_ModStart> ( image , fg , out <S2SV_ModEnd> ) ; }
<S2SV_ModStart> NULL ) ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> , out ) ) { <S2SV_ModEnd> rv = gdDPExtractData <S2SV_ModStart> size ) ; } else { rv = NULL ; }
<S2SV_ModStart> mode_t old_umask ; const <S2SV_ModEnd> char * base_path <S2SV_ModStart> ; base_path = "/tmp" ; <S2SV_ModEnd> __debug__ ( (
<S2SV_ModStart> '=' : case \'"\' : case '\\\\' : case
<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
<S2SV_ModStart> { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\"\\n" <S2SV_ModEnd> , module , <S2SV_ModStart> { r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s\\"\\n" <S2SV_ModEnd> , module ,
<S2SV_ModStart> continue ; } char op0 = 0 ; <S2SV_ModStart> q ) { op0 = * q ; <S2SV_ModStart> cmd = p <S2SV_ModEnd> ; } else <S2SV_ModStart> * p = op0 <S2SV_ModEnd> ; cmd =
<S2SV_ModStart> int tagval , uint32 <S2SV_ModEnd> * length )
<S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width &&
<S2SV_ModStart> * data ; struct stream packet = * s ; <S2SV_ModStart> ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } if (
<S2SV_ModStart> int tagval ; struct stream packet ; <S2SV_ModStart> length ) ; packet = * s ; <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> return False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p (
<S2SV_ModStart> * buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> s ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header ( <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> uint8 result ; uint32 <S2SV_ModEnd> length ; STREAM <S2SV_ModStart> ; STREAM s ; struct stream packet <S2SV_ModStart> return False ; packet = * s ; <S2SV_ModStart> length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> * next_order ; struct stream packet = * s ; <S2SV_ModStart> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( "process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream" , & packet ) ; }
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair <S2SV_ModStart> it ) ; <S2SV_ModEnd> for ( it
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> * key ; <S2SV_ModEnd> } * pair
<S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off <S2SV_ModStart> uint8_t retval ; int <S2SV_ModEnd> keylen ; rec_off
<S2SV_ModStart> ] ; int nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb <S2SV_ModStart> offset + 4 ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8
<S2SV_ModStart> { int kb , r <S2SV_ModStart> K_UNICODE : K_XLATE ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_debug_errno ( r , "Keyboard<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>XLATE<S2SV_blank>or<S2SV_blank>UNICODE<S2SV_blank>mode,<S2SV_blank>not<S2SV_blank>resetting:<S2SV_blank>%m" ) ; return 0 ; } else if ( r < 0 ) return r
<S2SV_ModStart> } r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
<S2SV_ModStart> } if ( vt_verify_kbmode <S2SV_ModEnd> ( fd_d )
<S2SV_ModStart> ; assert ( name ) ; r = vt_verify_kbmode ( fd ) ; if ( r == - EBUSY ) { log_warning_errno ( r , "Virtual<S2SV_blank>console<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>K_XLATE<S2SV_blank>or<S2SV_blank>K_UNICODE:<S2SV_blank>%m" , name ) ; return 0 ; } else if ( r < 0 ) return log_warning_errno ( r , "Failed<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>kbdmode<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>%m" ,
<S2SV_ModStart> ; r = vt_verify_kbmode <S2SV_ModEnd> ( fd )
<S2SV_ModStart> ; if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device" ) ; goto error ; } if (
<S2SV_ModStart> ; # endif char * crypt_password ; <S2SV_ModStart> ; # endif crypt_password = crypt ( password , user_password ) ; if ( crypt_password == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; return - 1 ; } <S2SV_ModStart> ( user_password , crypt_password <S2SV_ModEnd> ) != 0
<S2SV_ModStart> # ifdef _WIN32 DWORD error ; <S2SV_ModStart> HANDLE Token ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; <S2SV_ModStart> 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; error = GetLastError ( ) ; if ( error != ERROR_LOGON_FAILURE ) { pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , "LogonUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; } return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; pcap_fmt_errmsg_for_win32_err ( errmsgbuf <S2SV_ModEnd> , PCAP_ERRBUF_SIZE , <S2SV_ModStart> ( ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; CloseHandle <S2SV_ModEnd> ( Token ) <S2SV_ModStart> ( Token ) ; return - 1 ; } <S2SV_ModEnd> CloseHandle ( Token <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; # <S2SV_ModStart> ; # else int error ; <S2SV_ModStart> , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return <S2SV_ModStart> , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ; # endif errno = 0 ; <S2SV_ModStart> NULL ) { error = errno ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; if ( error == 0 ) { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed" ) ; } else { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) ) ; } <S2SV_ModEnd> return - 1 <S2SV_ModStart> , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ) { error = errno ; <S2SV_ModStart> , PCAP_ERRBUF_SIZE , error <S2SV_ModEnd> , "setuid" ) <S2SV_ModStart> "setuid" ) ; rpcapd_log ( LOGPRIO_ERROR , "setuid()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) ) ;
<S2SV_ModStart> * findalldevs_if ; uint32 replylen ; <S2SV_ModStart> 0 ; } replylen = 0 ; <S2SV_ModStart> -> description ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> -> name ) replylen <S2SV_ModEnd> += strlen ( <S2SV_ModStart> name ) ; replylen <S2SV_ModEnd> += sizeof ( <S2SV_ModStart> : # endif replylen <S2SV_ModEnd> += ( sizeof <S2SV_ModStart> , nif , replylen <S2SV_ModEnd> ) ; for
<S2SV_ModStart> struct block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) <S2SV_ModStart> , PCAP_ERRBUF_SIZE , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> struct block_trailer ) , total_length , BT_SHB_INSANE_MAX <S2SV_ModEnd> ) ; *
<S2SV_ModStart> , PCAP_ERRBUF_SIZE , "truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" <S2SV_ModEnd> PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%" PRIsize
<S2SV_ModStart> , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof (
<S2SV_ModStart> ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> FALSE ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> case INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> 2 ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> case WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
<S2SV_ModStart> ( len < 10 <S2SV_ModEnd> ) ND_PRINT (
<S2SV_ModStart> ; if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> else if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
<S2SV_ModStart> 0 ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;
<S2SV_ModStart> ( optlen == 6 <S2SV_ModEnd> ) ND_PRINT ( <S2SV_ModStart> ( ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]" <S2SV_ModEnd> ) ) ; <S2SV_ModStart> case 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_ModStart> , "<S2SV_blank>%u" , EXTRACT_16BITS <S2SV_ModEnd> ( option + <S2SV_ModStart> ( ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]" <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> depth ++ ; if ( depth == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else
<S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( cp ) ;
<S2SV_ModStart> 1 ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ) ; }
<S2SV_ModStart> ) ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; }
<S2SV_ModStart> ) ) ; if ( plenbytes < 0 ) return plenbytes ;
<S2SV_ModStart> case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;
<S2SV_ModStart> unicodestr ) ; # define MAILSLOT_BROWSE_STR "\\\\MAILSLOT\\\\BROWSE" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , MAILSLOT_BROWSE_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR "\\\\PIPE\\\\LANMAN" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> 2 ) , PIPE_LANMAN_STR <S2SV_ModEnd> ) == 0 <S2SV_ModStart> return ; } # undef PIPE_LANMAN_STR
<S2SV_ModStart> char * ret ; size_t len <S2SV_ModStart> return NULL ; len = <S2SV_ModEnd> strlen ( ptr <S2SV_ModStart> ( ptr ) ; if ( len > 0 && ptr [ len <S2SV_ModStart> ) ptr [ len <S2SV_ModEnd> - 1 ]
<S2SV_ModStart> case MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>length)" ) ) ; break ; }
<S2SV_ModStart> ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> : TLV_TCHECK ( 12 <S2SV_ModEnd> ) ; ft_flags <S2SV_ModStart> ( ndo , "%s" , tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> , u_int len , const unsigned attr_set_level <S2SV_ModStart> } if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else if ( <S2SV_ModStart> tptr , alen , attr_set_level + 1
<S2SV_ModStart> p , alen , 0
<S2SV_ModStart> case RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
<S2SV_ModStart> -> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
<S2SV_ModStart> -> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> -= optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ( ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) ) ;
<S2SV_ModStart> ; int hexdump , ret <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
<S2SV_ModStart> ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> hexdump ) ; trunc : return - 1 ;
<S2SV_ModStart> ( lshp -> ls_length <S2SV_ModEnd> ) ; ND_PRINT
<S2SV_ModStart> case BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;
<S2SV_ModStart> if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING ) return <S2SV_ModStart> if ( index >= <S2SV_ModEnd> MAX_SUPPORTED_TV_TIMING_V1_2 ) return
<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> umap_lock ) ; skip_mm :
<S2SV_ModStart> mmap_sem ) ; VM_WARN_ON ( ! mmget_still_valid ( mm ) ) ;
<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm ; <S2SV_ModStart> NULL_VM_UFFD_CTX ; } skip_mm :
<S2SV_ModStart> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ;
<S2SV_ModStart> return NULL ; if ( ! mmget_still_valid ( mm ) ) return NULL ;
<S2SV_ModStart> struct mlx5_ib_create_qp_resp resp = { }
<S2SV_ModStart> = hidg ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_ModStart> ) ; goto release_write_pending <S2SV_ModEnd> ; } else <S2SV_ModStart> count ; } <S2SV_ModEnd> return status ; <S2SV_ModStart> flags ) ; <S2SV_ModEnd> hidg -> write_pending
<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;
<S2SV_ModStart> ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ; }
<S2SV_ModStart> out ; } } if ( free < 0 ) { err = - ENOMEM ; goto out ;
<S2SV_ModStart> ; int error = 0 <S2SV_ModStart> &= PAGE_MASK ; if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> ; prev =
<S2SV_ModStart> - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; if ( err ) goto err_free_dev ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int dev_get_valid_name (
<S2SV_ModStart> unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL
<S2SV_ModStart> if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;
<S2SV_ModStart> if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {
<S2SV_ModStart> ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( <S2SV_ModStart> ) ; } <S2SV_ModEnd> for ( i
<S2SV_ModStart> tp ) ; xfs_iunlock ( ip , XFS_ILOCK_EXCL ) ;
<S2SV_ModStart> if ( iter >= <S2SV_ModEnd> CIPSO_V4_TAG_MAXCNT ) return <S2SV_ModStart> ) ; } while <S2SV_ModEnd> ( iter < <S2SV_ModStart> tags [ iter ++
<S2SV_ModStart> "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; ret = iwl_sta_ucode_activate ( priv , sta_id ) <S2SV_ModEnd> ; break ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , "invalid<S2SV_blank>sta_id<S2SV_blank>%u" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;
<S2SV_ModStart> 1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;
<S2SV_ModStart> attrs [ NFC_ATTR_DEVICE_INDEX ] || ! info -> attrs [ NFC_ATTR_TARGET_INDEX
<S2SV_ModStart> ; out_err : if ( rv && new_smi -> io . io_cleanup ) { new_smi -> io . io_cleanup ( & new_smi -> io ) ; new_smi -> io . io_cleanup = NULL ; }
<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> EIO ; } io -> io_cleanup = mem_cleanup ;
<S2SV_ModStart> - ENODEV ; <S2SV_ModEnd> switch ( io <S2SV_ModStart> ; } } io -> io_cleanup = port_cleanup ;
<S2SV_ModStart> fq ) ; q -> fq = NULL ;
<S2SV_ModStart> ip_idents_hashrnd __read_mostly ; static u32 ip_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip_idents_hashrnd ) ) ; net_get_random_once ( & ip_idents_hashrnd_extra , sizeof ( ip_idents_hashrnd_extra <S2SV_ModStart> iph -> protocol ^ ip_idents_hashrnd_extra
<S2SV_ModStart> ip6_idents_hashrnd __read_mostly ; static u32 ip6_idents_hashrnd_extra __read_mostly ; <S2SV_ModStart> sizeof ( ip6_idents_hashrnd ) ) ; net_get_random_once ( & ip6_idents_hashrnd_extra , sizeof ( ip6_idents_hashrnd_extra <S2SV_ModStart> hash ) ; hash = jhash_1word ( hash , ip6_idents_hashrnd_extra ) ;
<S2SV_ModStart> = p ; <S2SV_ModEnd> err = hci_uart_register_dev <S2SV_ModStart> err ) { return err ; } set_bit <S2SV_ModEnd> ( HCI_UART_PROTO_READY , <S2SV_ModStart> ) ; return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> ) ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto <S2SV_ModStart> pte ) ) * vec = 0 <S2SV_ModEnd> ; else if <S2SV_ModStart> pte ) ; * vec = ! ! <S2SV_ModEnd> non_swap_entry ( entry <S2SV_ModStart> ( entry ) ; <S2SV_ModEnd> } vec ++
<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
<S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
<S2SV_ModStart> * gb_cur , version , version_length ; u8 lto_length , wks_length , miux_length ; u8 * version_tlv = NULL , * lto_tlv = NULL , * wks_tlv = NULL , * miux_tlv = NULL <S2SV_ModEnd> ; __be16 wks <S2SV_ModStart> version_length ) ; if ( ! version_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> lto_length ) ; if ( ! lto_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> wks_length ) ; if ( ! wks_tlv ) { ret = - ENOMEM ; goto out ; } <S2SV_ModStart> miux_length ) ; if ( ! miux_tlv ) { ret = - ENOMEM ; goto out ; }
<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> out ; } ext_size = sizeof ( EXT4_I ( inode ) -> i_data ) ; <S2SV_ModStart> -> i_data , ext_size ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size <S2SV_ModEnd> ) ; neh
<S2SV_ModStart> = 0 ; size_t ext_size = 0 ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;
<S2SV_ModStart> if ( err < 0
<S2SV_ModStart> new_parent ) { <S2SV_ModEnd> __ptrace_link ( child <S2SV_ModStart> , new_parent , current_cred ( ) <S2SV_ModEnd> ) ; }
<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> ) ; } cifs_small_buf_release ( req ) ;
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> 0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
<S2SV_ModStart> ; } else { baud = min ( baud , 461550 ) ; <S2SV_ModStart> baud ) ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
<S2SV_ModStart> } else { if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> * obuf =
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool <S2SV_ModEnd> buffer_pipe_buf_get ( struct <S2SV_ModStart> -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; <S2SV_ModStart> ref ++ ; return true ;
<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
<S2SV_ModStart> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> ( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;
<S2SV_ModStart> ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
<S2SV_ModStart> < 0 ) { long n_pages ; n_pages = min ( - credit , si_mem_available ( ) ) ; <S2SV_ModStart> = decrease_reservation ( n_pages <S2SV_ModEnd> , GFP_BALLOON ) <S2SV_ModStart> GFP_BALLOON ) ; if ( state == BP_DONE && n_pages != - credit && n_pages < totalreserve_pages ) state = BP_EAGAIN ; }
<S2SV_ModStart> id ) ; <S2SV_ModEnd> return - EINVAL
<S2SV_ModStart> refcount ) ; cleanup_srcu_struct ( & user -> release_barrier ) ;
<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
<S2SV_ModStart> ) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
<S2SV_ModStart> rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES ) return ; <S2SV_ModStart> ( rate_ie ) { if ( rate_ie -> len > MWIFIEX_SUPPORTED_RATES - rate_len ) return ; <S2SV_ModStart> len ) ; }
<S2SV_ModStart> = vendor_ie ; if ( <S2SV_ModEnd> * ( wmm_ie <S2SV_ModStart> + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 )
<S2SV_ModStart> err ) ; if ( req -> buf != NULL )
<S2SV_ModStart> & FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
<S2SV_ModStart> unmap ; } if ( unlikely ( ! try_get_page ( * page ) ) ) { ret = - ENOMEM ; goto unmap ; } <S2SV_ModEnd> out : ret
<S2SV_ModStart> ) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
<S2SV_ModStart> -> code ) ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n" , dst ) ; return ret ; }
<S2SV_ModStart> , * insn_idx , false
<S2SV_ModStart> NULL ; } dst_state -> speculative = src -> speculative ;
<S2SV_ModStart> ; state -> speculative = false ; state -> <S2SV_ModStart> ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:<S2SV_blank>safe\\n" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? "<S2SV_blank>(speculative<S2SV_blank>execution)" : "" <S2SV_ModStart> ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d%s:" <S2SV_ModEnd> , env -> <S2SV_ModStart> env -> insn_idx , env -> cur_state -> speculative ? "<S2SV_blank>(speculative<S2SV_blank>execution)" : ""
<S2SV_ModStart> insn -> code == ( BPF_ALU64 | BPF_ADD | BPF_X ) || insn -> code == ( BPF_ALU64 | BPF_SUB | BPF_X ) ) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X ; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X ; struct bpf_insn insn_buf [ 16 ] ; struct bpf_insn * patch = & insn_buf [ 0 ] ; bool issrc , isneg ; u32 off_reg <S2SV_ModEnd> ; aux = <S2SV_ModStart> if ( ! aux -> alu_state <S2SV_ModEnd> ) continue ; <S2SV_ModStart> ) continue ; isneg = aux -> alu_state & BPF_ALU_NEG_VALUE ; issrc = ( aux -> alu_state & BPF_ALU_SANITIZE ) == BPF_ALU_SANITIZE_SRC ; off_reg = issrc ? insn -> src_reg : insn -> dst_reg ; if ( isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; * patch ++ = BPF_MOV32_IMM ( BPF_REG_AX , aux -> alu_limit - 1 ) ; * patch ++ = BPF_ALU64_REG ( BPF_SUB , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_REG ( BPF_OR , BPF_REG_AX , off_reg ) ; * patch ++ = BPF_ALU64_IMM ( BPF_NEG , BPF_REG_AX , 0 ) ; * patch ++ = BPF_ALU64_IMM ( BPF_ARSH , BPF_REG_AX , 63 ) ; if ( issrc ) { * patch ++ = BPF_ALU64_REG ( BPF_AND , BPF_REG_AX , off_reg ) ; insn -> src_reg = BPF_REG_AX ; } else { * patch ++ = BPF_ALU64_REG ( BPF_AND , off_reg , BPF_REG_AX ) ; } if ( isneg ) insn -> code = insn -> code == code_add ? code_sub : code_add ; * patch ++ = * insn ; if ( issrc && isneg ) * patch ++ = BPF_ALU64_IMM ( BPF_MUL , off_reg , - 1 ) ; cnt = patch - insn_buf <S2SV_ModEnd> ; new_prog = <S2SV_ModStart> } if ( insn -> code != ( BPF_JMP | BPF_CALL ) ) continue ; if ( insn -> src_reg == BPF_PSEUDO_CALL ) continue ; if ( insn -> imm == BPF_FUNC_get_route_realm ) prog -> dst_needed = 1 ; if ( insn -> imm == BPF_FUNC_get_prandom_u32 ) bpf_user_rnd_init_once ( ) ; if ( insn -> imm == BPF_FUNC_override_return ) prog -> kprobe_override = 1 ; if ( insn -> imm == BPF_FUNC_tail_call ) { prog -> cb_access = 1 ; env -> prog -> aux -> stack_depth = MAX_BPF_STACK ; env -> prog -> aux -> max_pkt_offset = MAX_PACKET_OFF ; insn -> imm = 0 ; insn -> code = BPF_JMP | BPF_TAIL_CALL ; <S2SV_ModEnd> aux = & <S2SV_ModStart> ; if ( ! bpf_map_ptr_unpriv ( aux ) ) continue ; if ( <S2SV_ModStart> aux ) ) { verbose ( env , "tail_call<S2SV_blank>abusing<S2SV_blank>map_ptr\\n" ) ; return - EINVAL ; } <S2SV_ModEnd> map_ptr = BPF_MAP_PTR <S2SV_ModStart> map_state ) ; insn_buf [ 0 ] = BPF_JMP_IMM ( BPF_JGE , BPF_REG_3 , map_ptr -> max_entries , 2 ) ; insn_buf [ 1 ] = BPF_ALU32_IMM ( BPF_AND , BPF_REG_3 , container_of <S2SV_ModEnd> ( map_ptr , <S2SV_ModStart> ( map_ptr , struct bpf_array , map ) -> index_mask ) ; insn_buf [ 2 ] = * insn ; cnt = 3 ; <S2SV_ModEnd> new_prog = bpf_patch_insn_data <S2SV_ModStart> continue ; } if ( prog -> jit_requested && BITS_PER_LONG == 64 && ( insn -> imm == BPF_FUNC_map_lookup_elem || insn -> imm == BPF_FUNC_map_update_elem || insn -> imm == BPF_FUNC_map_delete_elem || insn -> imm == BPF_FUNC_map_push_elem || insn -> imm == BPF_FUNC_map_pop_elem || insn -> imm == BPF_FUNC_map_peek_elem ) ) { aux = & env -> insn_aux_data [ i + delta ] ; if ( bpf_map_ptr_poisoned ( aux ) ) goto patch_call_imm ; map_ptr = BPF_MAP_PTR ( aux -> map_state ) ; ops = map_ptr -> ops ; if ( insn -> imm == BPF_FUNC_map_lookup_elem && ops -> map_gen_lookup ) { cnt = ops -> map_gen_lookup ( map_ptr , insn_buf ) ; if ( cnt == 0 || cnt >= ARRAY_SIZE ( insn_buf ) ) { verbose ( env , "bpf<S2SV_blank>verifier<S2SV_blank>is<S2SV_blank>misconfigured\\n" ) ; return - EINVAL ; } new_prog = bpf_patch_insn_data ( env , i + delta , insn_buf , cnt ) ; if ( ! new_prog ) return - ENOMEM ; delta += cnt - 1 ; env -> prog = prog = new_prog ; insn = new_prog -> insnsi + i + delta ; continue ; }
<S2SV_ModStart> , int prev_insn_idx , bool speculative <S2SV_ModStart> ) goto err ; elem -> st . speculative |= speculative
<S2SV_ModStart> cur -> curframe ) return false ; if ( old -> speculative && ! cur -> speculative
<S2SV_ModStart> err ; } ca . name [ sizeof ( ca . name ) - 1 ] = 0 ;
<S2SV_ModStart> & smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
<S2SV_ModStart> task ) { <S2SV_ModEnd> del_timer ( & <S2SV_ModStart> -> timer ) <S2SV_ModEnd> ; complete (
<S2SV_ModStart> SAS_TASK_STATE_DONE ) ) { <S2SV_ModStart> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }
<S2SV_ModStart> instance ) ; return - ENOMEM ; } return <S2SV_ModEnd> 0 ; }
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , func <S2SV_ModEnd> , line ,
<S2SV_ModStart> ; __be32 * pdata ; if ( datalen != 4 ) return - EINVAL ;
<S2SV_ModStart> { if ( datalen != 1 ) return - EINVAL ; if (
<S2SV_ModStart> queued_requests -- ; dwc3_gadget_del_and_unmap_request <S2SV_ModEnd> ( dep ,
<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
<S2SV_ModStart> net != c_net <S2SV_ModEnd> ) continue ;
<S2SV_ModStart> id ; goto errout_free <S2SV_ModEnd> ; } err <S2SV_ModStart> id ) ; errout_free :
<S2SV_ModStart> dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> cd -> fd
<S2SV_ModStart> 64 : 32 ; u32 dst = insn -> dst_reg ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_val_alu ( env , insn ) ; if ( ret < 0 ) { verbose ( env , "R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>pointers<S2SV_blank>or<S2SV_blank>scalars\\n" , dst ) ; return ret ; }
<S2SV_ModStart> ; if ( can_skip_alu_sanitation ( env , insn ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> ; if ( update_alu_sanitation_state ( aux , alu_state , <S2SV_ModEnd> alu_limit ) ) <S2SV_ModStart> return - EACCES <S2SV_ModEnd> ; do_sim :
<S2SV_ModStart> ; if ( ( int ) <S2SV_ModStart> <= 0 || ( int ) <S2SV_ModStart> g -> head <= 0 || ( int ) ( g -> sect * g -> head )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static bool get_desc ( <S2SV_ModStart> struct desc_struct * out , <S2SV_ModEnd> unsigned short sel <S2SV_ModStart> SEGMENT_LDT ) { bool success = false <S2SV_ModEnd> ; struct ldt_struct <S2SV_ModStart> -> nr_entries ) { * out = <S2SV_ModEnd> ldt -> entries <S2SV_ModStart> sel ] ; success = true ; } <S2SV_ModStart> ) ; return success <S2SV_ModEnd> ; } # <S2SV_ModStart> size ) return false ; * out = * <S2SV_ModEnd> ( struct desc_struct <S2SV_ModStart> desc_base ) ; return true ;
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; unsigned <S2SV_ModStart> return 0 ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return 0 <S2SV_ModStart> = get_desc_limit ( & <S2SV_ModStart> if ( desc . <S2SV_ModEnd> g ) limit
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> return sel ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> ! ( desc . <S2SV_ModEnd> type & BIT <S2SV_ModStart> ( ( desc . <S2SV_ModEnd> l << 1 <S2SV_ModStart> ) | desc . <S2SV_ModEnd> d ) {
<S2SV_ModStart> { struct desc_struct <S2SV_ModEnd> desc ; short <S2SV_ModStart> - 1L ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! get_desc ( & desc , sel ) <S2SV_ModEnd> ) return - <S2SV_ModStart> return get_desc_base ( &
<S2SV_ModStart> segs ) { <S2SV_ModEnd> u32 hash , <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; hash = siphash_3u32 <S2SV_ModEnd> ( ( __force <S2SV_ModStart> iph -> protocol , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
<S2SV_ModStart> net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id
<S2SV_ModStart> skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs [
<S2SV_ModStart> saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,
<S2SV_ModStart> struct hns_roce_ib_alloc_ucontext_resp resp = { }
<S2SV_ModStart> ++ ) { if ( ! cd -> disk ) continue ;
<S2SV_ModStart> ) ) { put_disk ( disk ) ;
<S2SV_ModStart> -> head <= 0 || ( unsigned char ) ( ( g -> sect << 2 ) >> FD_SIZECODE ( g ) ) ==
<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
<S2SV_ModStart> buf [ MAX_PKT_SIZE + 1 <S2SV_ModStart> ( buf ) - 1 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> if ( sa
<S2SV_ModStart> * p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x0 <S2SV_ModStart> * p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdx , <S2SV_ModEnd> p_image -> x1 <S2SV_ModStart> * p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y0 <S2SV_ModStart> * p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp -> <S2SV_ModStart> p_cp -> tdy , <S2SV_ModEnd> p_image -> y1
<S2SV_ModStart> x , y , written <S2SV_ModStart> = y = written = <S2SV_ModStart> pix = c1 ; written ++ <S2SV_ModStart> = c1 ; written ++ ; <S2SV_ModStart> } } } if ( written != width * height ) { fprintf ( stderr , "warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> LARGE_INTEGER offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ) ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> , readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & offset <S2SV_ModStart> ( ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> Information = 0 ; } TCfree ( readBuffer )
<S2SV_ModStart> printparam pp ; unsigned <S2SV_ModEnd> contentlen = 0 <S2SV_ModStart> sb ++ ; sscanf ( sb , "%u" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } else <S2SV_ModStart> & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"<S2SV_blank>enctype=\\"application/x-www-form-urlencoded\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" <S2SV_ModEnd> ) ; while <S2SV_ModStart> 'U' : { unsigned <S2SV_ModEnd> l = 0 <S2SV_ModStart> ! writable || ! contentlen || <S2SV_ModStart> } while ( l < contentlen && <S2SV_ModStart> ) buf , ( contentlen - l ) > <S2SV_ModStart> LINESIZE - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> l ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( buf <S2SV_ModStart> error ) { buf [ i ] = 0 ; <S2SV_ModStart> l += i <S2SV_ModEnd> ; } if
<S2SV_ModStart> "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" <S2SV_ModStart> s_poll_interval ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const char <S2SV_ModStart> , op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri ,
