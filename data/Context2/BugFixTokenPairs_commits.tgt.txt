<S2SV_ModStart> p_fm_config_conx_hdlt hdl = NULL <S2SV_ModStart> ; goto cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> ) { res = <S2SV_ModEnd> commandList [ <S2SV_ModStart> ) ; goto cleanup ; <S2SV_ModStart> 1 ; cleanup : if ( hdl ) { if ( hdl -> sm_hdl ) { if ( hdl -> sm_hdl -> c_path [ 0 ] ) unlink ( hdl -> sm_hdl -> c_path ) ; } if ( hdl -> pm_hdl ) { if ( hdl -> pm_hdl -> c_path [ 0 ] ) unlink ( hdl -> pm_hdl -> c_path ) ; } if ( hdl -> fe_hdl ) { if ( hdl -> fe_hdl -> c_path [ 0 ] ) unlink ( hdl -> fe_hdl -> c_path ) ; } <S2SV_ModEnd> free ( <S2SV_ModStart> ) ; }
<S2SV_ModStart> unix_addr ; hsm_com_errno_t res = HSM_COM_OK ; <S2SV_ModStart> ) { res = HSM_COM_PATH_ERR ; goto cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> ) { res = <S2SV_ModEnd> HSM_COM_BIND_ERR ; <S2SV_ModStart> HSM_COM_BIND_ERR ; goto cleanup ; <S2SV_ModStart> ) { res = HSM_COM_CHMOD_ERR ; goto cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> ) { res = HSM_COM_CONX_ERR ; goto cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> HSM_COM_C_STATE_IN ; res = HSM_COM_SEND_ERR ; } return res ; cleanup : close ( fd ) ; return res <S2SV_ModEnd> ; }
<S2SV_ModStart> ) ; if ( mkstemp ( hdl -> c_path ) == - 1 ) { res = HSM_COM_PATH_ERR ; goto cleanup ; }
<S2SV_ModStart> } } <S2SV_ModEnd> cleanup : <S2SV_ModStart> cleanup : <S2SV_ModEnd> return res
<S2SV_ModStart> mgr_hdl ; <S2SV_ModEnd> memset ( <S2SV_ModStart> c_path ) <S2SV_ModEnd> ) ; <S2SV_ModStart> c_path , "%s%s%d_C_XXXXXX" <S2SV_ModEnd> , HSM_FM_SCK_PREFIX <S2SV_ModStart> -> instance <S2SV_ModEnd> ) ;
<S2SV_ModStart> tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg <S2SV_ModStart> { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , <S2SV_ModStart> TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( "Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval <S2SV_ModStart> rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( ! rc ) { LOG_ERR ( "HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res <S2SV_ModStart> ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; }
<S2SV_ModStart> tpm_kdfa ( <S2SV_ModEnd> session ->
<S2SV_ModStart> 2 ; if ( i + 1 < data_size )
<S2SV_ModStart> ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
<S2SV_ModStart> ) { test_parser_param ( <S2SV_ModEnd> 0 ) <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> parserTestSuite , "Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
<S2SV_ModStart> ) { if ( client_obj -> ipc ) { <S2SV_ModStart> ) ; } else { crm_trace ( "Sending<S2SV_blank>response<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>%s" , client_obj -> name , from_peer ? "(originator<S2SV_blank>of<S2SV_blank>delegated<S2SV_blank>request)" : "" ) ; }
<S2SV_ModStart> == NULL && client -> session == NULL
<S2SV_ModStart> { static <S2SV_ModEnd> gid_t gid_cluster <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> if ( uid_client <S2SV_ModEnd> != 0 <S2SV_ModStart> != 0 ) { crm_trace ( "Giving<S2SV_blank>access<S2SV_blank>to<S2SV_blank>group<S2SV_blank>%u" , gid_cluster ) ; qb_ipcs_connection_auth_set ( c , <S2SV_ModEnd> - 1 <S2SV_ModStart> - 1 <S2SV_ModEnd> , gid_cluster
<S2SV_ModStart> NULL ; char * path = xml_get_path ( xml ) ; <S2SV_ModStart> == 0 && strstr ( path , "/" XML_CIB_TAG_ACLS "/" ) == NULL <S2SV_ModStart> else { <S2SV_ModEnd> crm_trace ( <S2SV_ModStart> } } free ( path ) ;
<S2SV_ModStart> ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s.html" <S2SV_ModStart> ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s/%s-links.html" <S2SV_ModStart> ) ; snprintf ( charbuf , sizeof ( charbuf ) <S2SV_ModEnd> , "%s_thumb_%03d"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> 1 , "prestring=%490s" <S2SV_ModEnd> , buf <S2SV_ModStart> ) > L_BUFSIZE <S2SV_ModEnd> - 3 <S2SV_ModStart> 1 , "protos=%490s" <S2SV_ModEnd> , buf <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>*<S2SV_blank><S2SV_blank>These<S2SV_blank>prototypes<S2SV_blank>were<S2SV_blank>autogen\'d<S2SV_blank>by<S2SV_blank>xtractprotos,<S2SV_blank>v.<S2SV_blank>%s" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "cpp<S2SV_blank>-ansi<S2SV_blank>-DNO_PROTOS<S2SV_blank>%s<S2SV_blank>%s"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.data.%d" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%f<S2SV_blank>%f\\n"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.cmd" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.png" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.ps" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.eps" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "%s.tex"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>title<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>xlabel<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>ylabel<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>png;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>postscript<S2SV_blank>eps;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>terminal<S2SV_blank>latex;<S2SV_blank>set<S2SV_blank>output<S2SV_blank>\'%s\'" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>x" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "set<S2SV_blank>logscale<S2SV_blank>y" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "plot<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s,<S2SV_blank>\\\\" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "<S2SV_blank>\'%s\'<S2SV_blank>title<S2SV_blank>\'%s\'<S2SV_blank>%s"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "gnuplot<S2SV_blank>%s" <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , "wgnuplot<S2SV_blank>%s"
<S2SV_ModStart> buf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> fp , "Rootname:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , fp <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , fp <S2SV_ModStart> buf , L_BUFSIZE <S2SV_ModEnd> , fp <S2SV_ModStart> fp , "Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf <S2SV_ModStart> fp , "Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n" <S2SV_ModEnd> , buf
<S2SV_ModStart> fp , "<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>pts<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>format<S2SV_blank>=<S2SV_blank>%127s\\n" <S2SV_ModEnd> , &
<S2SV_ModStart> linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> linebuf , L_BUFSIZE <S2SV_ModEnd> , fp <S2SV_ModStart> linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------" <S2SV_ModEnd> , selname
<S2SV_ModStart> combname [ L_BUFSIZE <S2SV_ModEnd> ] ; <S2SV_ModStart> combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dh" <S2SV_ModStart> combname , L_BUFSIZE <S2SV_ModEnd> , "sel_comb_%dv"
<S2SV_ModStart> len ) { <S2SV_ModStart> '\\\\' ) { if ( * end_ptr == '\\0' ) { return 0 ; } end_ptr ++ ; } } <S2SV_ModEnd> out =
<S2SV_ModStart> ) ; <S2SV_ModEnd> g_string_free (
<S2SV_ModStart> JSObjectRef globalobject <S2SV_ModEnd> ; JSStringRef <S2SV_ModStart> ( context <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> JSStringRelease (
<S2SV_ModStart> 0 ) if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; } else <S2SV_ModStart> uschar * hn ; if ( received_protocol ) { fprintf ( stderr , "received_protocol<S2SV_blank>is<S2SV_blank>set<S2SV_blank>already\\n" ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_ModStart> ret = ff_set_dimensions ( avctx , <S2SV_ModEnd> s -> <S2SV_ModStart> -> height <S2SV_ModEnd> ) )
<S2SV_ModStart> 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> continue ; <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> ) { <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if (
<S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> if ( <S2SV_ModEnd> av_strstart ( <S2SV_ModStart> proto_name , "file" , NULL ) ) { if ( strcmp ( c -> allowed_extensions , "ALL" ) && ! av_match_ext ( url , c -> allowed_extensions ) ) { av_log ( s , AV_LOG_ERROR , "Filename<S2SV_blank>extension<S2SV_blank>of<S2SV_blank>\\\'%s\\\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>common<S2SV_blank>multimedia<S2SV_blank>extension,<S2SV_blank>blocked<S2SV_blank>for<S2SV_blank>security<S2SV_blank>reasons.\\n" "If<S2SV_blank>you<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>override<S2SV_blank>this<S2SV_blank>adjust<S2SV_blank>allowed_extensions,<S2SV_blank>you<S2SV_blank>can<S2SV_blank>set<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\\\'ALL\\\'<S2SV_blank>to<S2SV_blank>allow<S2SV_blank>all\\n" , url ) ; return AVERROR_INVALIDDATA ; } } else if ( av_strstart ( proto_name , <S2SV_ModStart> NULL ) ) { ; } else <S2SV_ModEnd> return AVERROR_INVALIDDATA
<S2SV_ModStart> 8 ) && c -> format != CHUNKY
<S2SV_ModStart> s -> interlaced_dct = 0 ; s ->
<S2SV_ModStart> ; } if ( s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO ) { w_align = 8 ; h_align = 8 ; } <S2SV_ModStart> == AV_CODEC_ID_JV || s -> codec_id == AV_CODEC_ID_INTERPLAY_VIDEO
<S2SV_ModStart> if ( x >= 16 || c >= 256 ) { return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> < zsize + ( sub_type != 2 ) <S2SV_ModStart> ) { if ( src >= src_end ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> > 68 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } ctx -> data_offset = 0x280 ; } if ( <S2SV_ModEnd> ( ctx <S2SV_ModStart> ; } <S2SV_ModEnd> if (
<S2SV_ModStart> if ( <S2SV_ModEnd> h0 -> <S2SV_ModStart> if ( <S2SV_ModEnd> last_pic_structure != <S2SV_ModStart> if ( <S2SV_ModEnd> last_pic_structure !=
<S2SV_ModStart> else { uint64_t <S2SV_ModEnd> target_end = <S2SV_ModStart> -> chunksize == UINT64_MAX ) <S2SV_ModEnd> && s <S2SV_ModStart> -> chunksize == UINT64_MAX ) && s -> off < <S2SV_ModEnd> target_end ) <S2SV_ModStart> , "Stream<S2SV_blank>ends<S2SV_blank>prematurely<S2SV_blank>at<S2SV_blank>%" PRIu64 ",<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\\n" ,
<S2SV_ModStart> NULL ; uint64_t <S2SV_ModEnd> off = <S2SV_ModStart> , "Range:<S2SV_blank>bytes=%" PRIu64 <S2SV_ModEnd> "-" , <S2SV_ModStart> filesize = UINT64_MAX <S2SV_ModEnd> ; s
<S2SV_ModStart> filesize = UINT64_MAX <S2SV_ModEnd> ; s
<S2SV_ModStart> chunksize = UINT64_MAX <S2SV_ModEnd> ; for
<S2SV_ModStart> -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { <S2SV_ModStart> chunksize = strtoull <S2SV_ModEnd> ( line <S2SV_ModStart> av_log ( h <S2SV_ModEnd> , AV_LOG_TRACE <S2SV_ModStart> , "Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "\'\\n" , <S2SV_ModStart> 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , "Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%" PRIu64 "\\n" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> ) { uint64_t <S2SV_ModEnd> target = <S2SV_ModStart> , "Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> "<S2SV_blank>error=%s.\\n" , <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%" PRIu64 <S2SV_ModEnd> ".\\n" ,
<S2SV_ModStart> hd ; uint64_t <S2SV_ModEnd> old_off = <S2SV_ModStart> filesize == UINT64_MAX <S2SV_ModEnd> && whence
<S2SV_ModStart> off = strtoull <S2SV_ModEnd> ( p <S2SV_ModStart> filesize = strtoull <S2SV_ModEnd> ( slash
<S2SV_ModStart> filesize == UINT64_MAX <S2SV_ModEnd> ) { <S2SV_ModStart> filesize = strtoull <S2SV_ModEnd> ( p <S2SV_ModStart> filesize = UINT64_MAX ; s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = <S2SV_ModEnd> 1 ; <S2SV_ModStart> 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , <S2SV_ModEnd> & s <S2SV_ModStart> s -> <S2SV_ModEnd> cookie_dict ) <S2SV_ModStart> icy_metaint = strtoull <S2SV_ModEnd> ( p
<S2SV_ModStart> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = <S2SV_ModStart> -> icy_data_read <S2SV_ModEnd> ; if
<S2SV_ModStart> ) { int profile , level ; <S2SV_ModStart> , gb , & profile , & level ) ; if ( <S2SV_ModEnd> profile == <S2SV_ModStart> && ( <S2SV_ModEnd> level > <S2SV_ModStart> 0 && <S2SV_ModEnd> level < <S2SV_ModStart> ; } else if ( s -> studio_profile ) { avpriv_request_sample ( s -> avctx , "Mixes<S2SV_blank>studio<S2SV_blank>and<S2SV_blank>non<S2SV_blank>studio<S2SV_blank>profile\\n" ) ; return AVERROR_PATCHWELCOME ; } s -> avctx -> profile = profile ; s -> avctx -> level = level ; <S2SV_ModStart> ) { av_assert0 ( s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) ;
<S2SV_ModStart> * gb , int * profile , int * level <S2SV_ModStart> ) { * <S2SV_ModEnd> profile = <S2SV_ModStart> ) ; * <S2SV_ModEnd> level = <S2SV_ModStart> if ( * <S2SV_ModEnd> profile == <S2SV_ModStart> 0 && * <S2SV_ModEnd> level == <S2SV_ModStart> ) { * <S2SV_ModEnd> level =
<S2SV_ModStart> > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE
<S2SV_ModStart> gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0
<S2SV_ModStart> 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> continue ; <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> ) { <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if (
<S2SV_ModStart> pixel_ptr = - 4 <S2SV_ModEnd> ; int <S2SV_ModStart> ) { ADVANCE_BLOCK ( ) <S2SV_ModStart> ; } <S2SV_ModEnd> } break <S2SV_ModStart> ) { ADVANCE_BLOCK ( ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> } break <S2SV_ModStart> return ; ADVANCE_BLOCK ( ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> break ;
<S2SV_ModStart> if ( samples_in_chunk < 1 ) { av_log ( s , AV_LOG_ERROR , "fatal<S2SV_blank>error,<S2SV_blank>input<S2SV_blank>packet<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>samples\\n" ) ; return AVERROR_PATCHWELCOME ; } if (
<S2SV_ModStart> if ( bpp == 1 && <S2SV_ModStart> if ( bpp == 8 &&
<S2SV_ModStart> w - ( int )
<S2SV_ModStart> w - ( int )
<S2SV_ModStart> pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> ret ; if ( ret == 1 ) { ret = AVERROR_INVALIDDATA ; goto fail ; } <S2SV_ModStart> s -> <S2SV_ModEnd> max_ra ==
<S2SV_ModStart> ) ; if ( s -> ref && sh -> first_slice_in_pic_flag ) { av_log ( s -> avctx , AV_LOG_ERROR , "Two<S2SV_blank>slices<S2SV_blank>reporting<S2SV_blank>being<S2SV_blank>the<S2SV_blank>first<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame.\\n" ) ; return 1 ; }
<S2SV_ModStart> ) { int chroma_planes , chroma_h_shift , chroma_v_shift , transparency ; <S2SV_ModStart> ) ; <S2SV_ModEnd> chroma_planes = <S2SV_ModStart> ) ; <S2SV_ModEnd> chroma_h_shift = <S2SV_ModStart> ) ; <S2SV_ModEnd> chroma_v_shift = <S2SV_ModStart> ) ; <S2SV_ModEnd> transparency = <S2SV_ModStart> state ) ; if ( f -> plane_count ) { if ( chroma_planes != f -> chroma_planes || chroma_h_shift != f -> chroma_h_shift || chroma_v_shift != f -> chroma_v_shift || transparency != f -> transparency ) { av_log ( f -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>change<S2SV_blank>of<S2SV_blank>global<S2SV_blank>parameters\\n" ) ; return AVERROR_INVALIDDATA ; } } f -> chroma_planes = chroma_planes ; f -> chroma_h_shift = chroma_h_shift ; f -> chroma_v_shift = chroma_v_shift ; f -> transparency = transparency
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> read_quant_matrix_ext ( <S2SV_ModStart> ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) { if ( get_bits_left ( gb ) < 64 * 8 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; return 0 ;
<S2SV_ModStart> 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> continue ; <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> ) { <S2SV_ModEnd> remaining = <S2SV_ModStart> if ( <S2SV_ModEnd> remaining <= <S2SV_ModStart> 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if (
<S2SV_ModStart> sc -> drefs_count = 0 ; sc ->
<S2SV_ModStart> * prev_frame ; av_assert0 ( avctx -> pix_fmt == AV_PIX_FMT_YUVA420P || avctx -> pix_fmt == AV_PIX_FMT_YUV420P )
<S2SV_ModStart> ) ; if ( par -> codec_type == AVMEDIA_TYPE_AUDIO && ! pkt -> size ) { av_log ( s , AV_LOG_WARNING , "Empty<S2SV_blank>audio<S2SV_blank>Packet\\n" ) ; return AVERROR ( EINVAL ) ; }
<S2SV_ModStart> ) ; if ( s -> image_offset_x || s -> image_offset_y ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>image<S2SV_blank>offsets" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> ) { if ( y >= avctx -> height ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> if ( prev_pkt [ channel_id ] . read && size != prev_pkt [ channel_id ] . size ) { av_log ( NULL , AV_LOG_ERROR , "RTMP<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>mismatch<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>%d\\n" , size , prev_pkt [ channel_id ] . size ) ; ff_rtmp_packet_destroy ( & prev_pkt [ channel_id ] ) ; prev_pkt [ channel_id ] . read = 0 ; } if (
<S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> int just_opened = 0 ; int reload_count <S2SV_ModStart> reload : reload_count ++ ; if ( reload_count > c -> max_reload ) return AVERROR_EOF ;
<S2SV_ModStart> ) ; avio_skip ( pb , name_len <S2SV_ModEnd> ) ; <S2SV_ModStart> int name_len ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA
<S2SV_ModStart> -> tile_width <S2SV_ModEnd> , 16 <S2SV_ModStart> 16 ) * 3
<S2SV_ModStart> if ( ! ape -> totalframes ) { av_log ( s , AV_LOG_ERROR , "No<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>the<S2SV_blank>file!\\n" ) ; return AVERROR ( EINVAL ) ; } if (
<S2SV_ModStart> ) ; print_primaries ( w , <S2SV_ModEnd> frame -> <S2SV_ModStart> -> color_primaries <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; print_primaries ( w , <S2SV_ModEnd> par -> <S2SV_ModStart> -> color_primaries <S2SV_ModEnd> ) ;
<S2SV_ModStart> w - ( int )
<S2SV_ModStart> ) ; if ( s -> diff_start + s -> diff_height > cur_blk_height ) { av_log ( avctx , AV_LOG_ERROR , "Block<S2SV_blank>parameters<S2SV_blank>invalid\\n" ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
<S2SV_ModStart> -> width || <S2SV_ModEnd> s ->
<S2SV_ModStart> if ( segment -> nb_index_entries && length < 11 ) return AVERROR_INVALIDDATA ; if ( <S2SV_ModStart> ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> ) { if ( band -> prec ) { <S2SV_ModStart> ; } }
<S2SV_ModStart> band = av_calloc <S2SV_ModEnd> ( reslevel <S2SV_ModStart> prec = av_calloc <S2SV_ModEnd> ( reslevel
<S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 0xFFFF ; }
<S2SV_ModStart> if ( avio_feof ( pb ) ) { return AVERROR_EOF ; } if (
<S2SV_ModStart> & JPEG2000_CBLK_VSC ; av_assert0 ( width <= JPEG2000_MAX_CBLKW ) ; av_assert0 ( height <= JPEG2000_MAX_CBLKH )
<S2SV_ModStart> ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , "cblk<S2SV_blank>size<S2SV_blank>><S2SV_blank>64" ) ; return AVERROR_PATCHWELCOME ; }
<S2SV_ModStart> offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> > 65536 || item_num < 0
<S2SV_ModStart> -> nreslevels <= <S2SV_ModEnd> s -> <S2SV_ModStart> reduction_factor ) { av_log ( s -> avctx , AV_LOG_ERROR , "reduction_factor<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>this<S2SV_blank>bitstream,<S2SV_blank>max<S2SV_blank>is<S2SV_blank>%d\\n" , c -> nreslevels - 1 ) ; s -> reduction_factor = c -> nreslevels - 1 ; return AVERROR ( EINVAL ) ; } <S2SV_ModEnd> c ->
<S2SV_ModStart> -> chunk_size <= 0 ) { c -> chunk_size = 0 ; goto fail ; } <S2SV_ModEnd> c -> <S2SV_ModStart> else { av_assert0 ( len <= c -> chunk_size ) ;
<S2SV_ModStart> if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ; if (
<S2SV_ModStart> size2 , NULL <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; if ( avio_feof ( s -> pb ) ) { ret = AVERROR_INVALIDDATA ; goto end ; }
<S2SV_ModStart> , transparency , colorspace , bits_per_raw_sample <S2SV_ModStart> ; } <S2SV_ModEnd> colorspace = <S2SV_ModStart> ) ; bits_per_raw_sample = <S2SV_ModEnd> f -> <S2SV_ModStart> > 0 ? get_symbol ( c , state , 0 ) : <S2SV_ModEnd> f -> <S2SV_ModStart> -> bits_per_raw_sample ; chroma_planes = get_rac ( c , state ) ; chroma_h_shift <S2SV_ModStart> ) ; chroma_v_shift = get_symbol ( c , state , 0 ) ; transparency <S2SV_ModEnd> = get_rac <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> if ( colorspace != f -> colorspace || bits_per_raw_sample != f -> avctx -> bits_per_raw_sample || <S2SV_ModStart> } } f -> colorspace = colorspace ; f -> avctx -> bits_per_raw_sample = bits_per_raw_sample ;
<S2SV_ModStart> if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c
<S2SV_ModStart> ) { if ( s -> codec_id == AV_CODEC_ID_MPEG4 ) s -> idsp . mpeg4_studio_profile = s -> studio_profile ;
<S2SV_ModStart> int blockstodecode ; uint64_t decoded_buffer_size <S2SV_ModStart> > INT_MAX / 2 / sizeof ( * s -> decoded_buffer ) - 8 <S2SV_ModStart> samples ; decoded_buffer_size = 2LL * FFALIGN ( blockstodecode , 8 ) * sizeof ( * s -> decoded_buffer ) ; av_assert0 ( decoded_buffer_size <= INT_MAX ) ; <S2SV_ModStart> decoded_size , decoded_buffer_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( mxf -> fc
<S2SV_ModStart> . field_picture <S2SV_ModEnd> ) return
<S2SV_ModStart> frame_end : if ( ! s -> studio_profile )
<S2SV_ModStart> ) { MpegEncContext * s = avctx -> priv_data ; <S2SV_ModStart> av_assert1 ( s -> studio_profile <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { <S2SV_ModEnd> if (
<S2SV_ModStart> ++ ) { if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> size ; }
<S2SV_ModStart> if ( * value == 0 ||
<S2SV_ModStart> ptrptr && <S2SV_ModEnd> nmemb && <S2SV_ModStart> && size <S2SV_ModEnd> ) return
<S2SV_ModStart> ] ; len = FFMIN ( FFMAX ( len , 0 ) , sizeof ( color_name ) - 1 ) ;
<S2SV_ModStart> ) ; av_freep ( & x -> buf ) ; x -> buf_size = 0 ;
<S2SV_ModStart> * ptr <S2SV_ModEnd> ; int <S2SV_ModStart> AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , <S2SV_ModEnd> avpkt -> <S2SV_ModStart> avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> + avpkt <S2SV_ModStart> while ( end - ptr > 9 && <S2SV_ModStart> 9 ) ) ptr ++ ; if ( <S2SV_ModEnd> end - <S2SV_ModStart> end - ptr <= 9 <S2SV_ModEnd> ) { <S2SV_ModStart> size *= 95 <S2SV_ModEnd> ; if <S2SV_ModStart> 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < cpp <S2SV_ModEnd> ) return <S2SV_ModStart> 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> if ( end - ptr < cpp <S2SV_ModEnd> ) return
<S2SV_ModStart> ) { if ( end - p >= ( sizeof ( ff_asf_guid ) * 3 + 26 ) ) { <S2SV_ModStart> } } } <S2SV_ModStart> 46 ; if ( chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; }
<S2SV_ModStart> == AV_NOPTS_VALUE || av_fifo_size ( s -> fifo ) <= 0
<S2SV_ModStart> run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> -> width + 15 <S2SV_ModEnd> , 16 <S2SV_ModStart> 16 ) * 3 ; aligned_height = <S2SV_ModEnd> c -> <S2SV_ModStart> -> height + 15 <S2SV_ModEnd> ; av_free
<S2SV_ModStart> ) { int64_t <S2SV_ModEnd> hours ,
<S2SV_ModStart> <= 8 && c -> format != CHUNKY
<S2SV_ModStart> bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { <S2SV_ModStart> = buf_size - 1
<S2SV_ModStart> 0 ; <S2SV_ModEnd> plane < <S2SV_ModStart> < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart> 0 ; <S2SV_ModEnd> plane < <S2SV_ModStart> < 4 && in -> data [ plane ] && in -> linesize [ plane ]
<S2SV_ModStart> -> data [ plane ] && in -> linesize
<S2SV_ModStart> -> data [ plane ] && src -> linesize
<S2SV_ModStart> plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> p ] && in -> linesize [ p ]
<S2SV_ModStart> plane ] && in -> linesize [ plane ]
<S2SV_ModStart> 0 ; <S2SV_ModEnd> plane < <S2SV_ModStart> < 4 && inpic -> data [ plane ] && inpic -> linesize [ plane ]
<S2SV_ModStart> plane ] && in -> linesize [ plane ]
<S2SV_ModStart> i ] && out -> linesize [ i ]
<S2SV_ModStart> plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> -> data [ plane ] && frame -> linesize <S2SV_ModStart> plane ] && frame -> linesize [ plane ]
<S2SV_ModStart> -> data [ plane ] && in -> linesize
<S2SV_ModStart> y ; av_assert0 ( s -> bit_depth > 1 ) ;
<S2SV_ModStart> i ; if ( ! ( s -> state & PNG_IHDR ) ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>before<S2SV_blank>IHDR\\n" ) ; return AVERROR_INVALIDDATA ; } if ( s -> state & PNG_IDAT ) { av_log ( avctx , AV_LOG_ERROR , "trns<S2SV_blank>after<S2SV_blank>IDAT\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_ModStart> 6 ) || s -> bit_depth == 1
<S2SV_ModStart> ) ; memset ( h -> delayed_pic , 0 , sizeof ( h -> delayed_pic ) ) ;
<S2SV_ModStart> st ; int ret ; <S2SV_ModStart> ) ; ret = <S2SV_ModStart> ) ; if ( ret != 4 ) return AVERROR_INVALIDDATA ;
<S2SV_ModStart> new_buffer ) { pc -> index = 0 ; <S2SV_ModStart> ) ; } <S2SV_ModStart> new_buffer ) { pc -> overread_index = pc -> index = 0 ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> width + 4 <S2SV_ModEnd> ) return
<S2SV_ModStart> > UINT16_MAX || ! track -> par -> channels
<S2SV_ModStart> + y / s -> cdy [ compno ] <S2SV_ModStart> + x / s -> cdx [ compno ] <S2SV_ModStart> + y / s -> cdy [ compno ] <S2SV_ModStart> ( x / s -> cdx [ compno ]
<S2SV_ModStart> ) { GetByteContext gb <S2SV_ModEnd> ; if <S2SV_ModStart> if ( data >= data_end <S2SV_ModEnd> ) return <S2SV_ModStart> 1 ; bytestream2_init <S2SV_ModEnd> ( & <S2SV_ModStart> ( & gb , data , data_end - <S2SV_ModStart> ) ; return amf_get_field_value2 ( & gb <S2SV_ModEnd> , name <S2SV_ModStart> name , <S2SV_ModEnd> dst , <S2SV_ModStart> , dst_size ) <S2SV_ModEnd> ; }
<S2SV_ModStart> # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC
<S2SV_ModStart> # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> bgp_packet_mpattr_tea (
<S2SV_ModStart> # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC
<S2SV_ModStart> rc = foreach_shareopt <S2SV_ModEnd> ( shareopts
<S2SV_ModStart> SecBuffer ) ) ; SecInvalidateHandle ( & credssp -> context
<S2SV_ModStart> ) ; rdp -> nego -> transport -> credssp = NULL ;
<S2SV_ModStart> ) ; transport -> credssp = NULL ;
<S2SV_ModStart> ) ; transport -> credssp = NULL ;
<S2SV_ModStart> ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> ! handle || ! SecIsValidHandle ( handle )
<S2SV_ModStart> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> length = size <S2SV_ModEnd> ; bitmap
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ) { const UINT64 offset = ( UINT64 ) <S2SV_ModEnd> fields -> <S2SV_ModStart> BufferOffset + ( UINT64 ) <S2SV_ModStart> -> Len ; if ( offset <S2SV_ModEnd> > Stream_Length
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ) { UINT32 <S2SV_ModEnd> count = <S2SV_ModStart> 2 ; BITMAP_DATA *
<S2SV_ModStart> ) ; if ( ! <S2SV_ModStart> rdp ) ) return FALSE
<S2SV_ModStart> ) { if ( rdp -> rc4_decrypt_key == NULL ) return FALSE ;
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_decode ( <S2SV_ModStart> UINT16 rw ; BYTE shift ; BYTE * bmpdata ; size_t pos = 0 ; if ( ! context ) return FALSE ; rw <S2SV_ModStart> ) ; <S2SV_ModEnd> shift = <S2SV_ModStart> 1 ; <S2SV_ModEnd> bmpdata = <S2SV_ModStart> -> BitmapData ; if ( ! bmpdata ) return FALSE <S2SV_ModStart> cg_val ; if ( pos + 4 > context -> BitmapDataLength ) return FALSE ; pos += 4 ; <S2SV_ModStart> } } return TRUE ;
<S2SV_ModStart> FALSE ; { BOOL rc ; <S2SV_ModStart> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> prof_nsc_decode ) rc = <S2SV_ModStart> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decode ( <S2SV_ModStart> * out , UINT32 outSize <S2SV_ModStart> ) { if ( outSize < 1 ) return FALSE ; outSize -- ; <S2SV_ModStart> ; } if ( outSize < len ) return FALSE ; outSize -= len ; <S2SV_ModStart> else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } if ( ( outSize < 4 ) || ( left < 4 ) ) return FALSE ; memcpy ( out , in , 4 ) ; return TRUE <S2SV_ModEnd> ; }
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_rle_decompress_data ( <S2SV_ModStart> originalSize ; if ( ! context ) return FALSE ; <S2SV_ModStart> 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModStart> ) ; } <S2SV_ModStart> originalSize ) { if ( ! <S2SV_ModStart> ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; <S2SV_ModEnd> CopyMemory ( <S2SV_ModStart> ) ; } <S2SV_ModStart> ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nsc_encode ( <S2SV_ModStart> ) { if ( ! context || ! bmpdata || ( rowstride == 0 ) ) return FALSE ; if ( ! <S2SV_ModStart> rowstride ) ) return FALSE <S2SV_ModStart> ) { if ( ! <S2SV_ModStart> context ) ) return FALSE <S2SV_ModStart> ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_argb_to_aycocg ( <S2SV_ModStart> UINT32 tempWidth ; if ( ! context || data || ( scanline == 0 ) ) return FALSE <S2SV_ModStart> ColorLossLevel ; if ( context -> priv -> PlaneBuffersLength < rw * scanline ) return FALSE ; if ( rw < scanline * 2 ) return FALSE ; <S2SV_ModStart> ; } return TRUE ;
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( <S2SV_ModStart> y ; <S2SV_ModEnd> UINT32 tempWidth <S2SV_ModStart> UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ) { BYTE * <S2SV_ModStart> ) ; BYTE * <S2SV_ModStart> ) ; const INT8 * <S2SV_ModStart> tempWidth ; const INT8 * <S2SV_ModStart> tempWidth ; const INT8 * <S2SV_ModStart> tempWidth ; const INT8 * <S2SV_ModStart> } } return TRUE ;
<S2SV_ModStart> nsc_rle_encode ( const
<S2SV_ModStart> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( <S2SV_ModStart> ; } return TRUE ;
<S2SV_ModStart> ; } <S2SV_ModEnd> } else <S2SV_ModStart> ; } <S2SV_ModEnd> } else <S2SV_ModStart> ; } <S2SV_ModEnd> } else <S2SV_ModStart> } else <S2SV_ModEnd> { g_set_error
<S2SV_ModStart> * filename = NULL ; gint file_handle <S2SV_ModStart> ) ; file_handle = g_file_open_tmp ( "gimp-test-XXXXXX.xcf" , & filename , NULL ) ; g_assert ( file_handle != - 1 ) ; close ( file_handle <S2SV_ModEnd> ) ;
<S2SV_ModStart> conn ; <S2SV_ModEnd> g_debug (
<S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) ; <S2SV_ModEnd> set_description (
<S2SV_ModStart> GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn <S2SV_ModEnd> ) { <S2SV_ModStart> ) { IceSetShutdownNegotiation ( ice_conn , FALSE <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; IceCloseConnection <S2SV_ModEnd> ( ice_conn <S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ice_conn ; GsmClient <S2SV_ModEnd> * client <S2SV_ModStart> * client ; GsmIceConnectionWatch * data <S2SV_ModStart> ) ; data <S2SV_ModEnd> = ice_conn <S2SV_ModStart> context ; free_ice_connection_watch ( data ) ; client = gsm_xsmp_client_new ( ice_conn ) ; gsm_store_add ( server -> priv -> client_store , gsm_client_peek_id <S2SV_ModEnd> ( client <S2SV_ModStart> ( client ) , G_OBJECT ( client ) ) ; g_object_unref ( client <S2SV_ModEnd> ) ; <S2SV_ModStart> gsm_xsmp_client_connect ( GSM_XSMP_CLIENT ( client ) <S2SV_ModEnd> , sms_conn
<S2SV_ModStart> ) { dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart> ) ; <S2SV_ModEnd> } else
<S2SV_ModStart> 0 ) { xmlFreeInputStream ( input ) ; <S2SV_ModStart> return ; }
<S2SV_ModStart> -> cur ) ; } if ( ( ( ctxt -> inputNr > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> inputNr > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; while ( ctxt -> inputNr > 1 ) xmlFreeInputStream ( inputPop ( ctxt ) ) ; return ( - 1
<S2SV_ModStart> ) ; <S2SV_ModEnd> } } <S2SV_ModStart> , "Name" ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , "unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"
<S2SV_ModStart> res ; g_autofree gchar * trusted = NULL ; <S2SV_ModStart> ; } trusted = nautilus_file_get_metadata ( file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL ) ; <S2SV_ModStart> file ) && trusted != NULL
<S2SV_ModStart> ) { mark_desktop_file_executable <S2SV_ModEnd> ( job
<S2SV_ModStart> _ ( "_Cancel" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL <S2SV_ModEnd> ) ; <S2SV_ModStart> _ ( "Trust<S2SV_blank>and<S2SV_blank>_Launch" ) , GTK_RESPONSE_OK <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> g_signal_connect (
<S2SV_ModStart> { case GTK_RESPONSE_OK <S2SV_ModEnd> : { <S2SV_ModStart> : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , "yes" ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> g_object_unref (
<S2SV_ModStart> ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
<S2SV_ModStart> guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
<S2SV_ModStart> columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t <S2SV_ModStart> ThreadResource ) ) <S2SV_ModStart> AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i <S2SV_ModStart> ssize_t ) rows <S2SV_ModEnd> ; i
<S2SV_ModStart> END_OF_READING : <S2SV_ModEnd> CloseBlob ( <S2SV_ModStart> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
<S2SV_ModStart> size_t ) floor <S2SV_ModStart> size_t ) floor <S2SV_ModStart> size_t ) floor <S2SV_ModStart> size_t ) floor <S2SV_ModStart> size_t ) floor
<S2SV_ModStart> if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( <S2SV_ModStart> if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels
<S2SV_ModStart> if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count
<S2SV_ModStart> if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( count
<S2SV_ModStart> ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) <S2SV_ModStart> CorruptImageError , "UnexpectedEndOfFile" <S2SV_ModEnd> , image <S2SV_ModStart> -> filename <S2SV_ModEnd> ) ;
<S2SV_ModStart> defined ( MAGICKCORE_WINDOWS_SUPPORT ) && <S2SV_ModEnd> defined ( <S2SV_ModStart> defined ( _DEBUG ) "<S2SV_blank>Debug" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) "<S2SV_blank>Cipher" <S2SV_ModEnd> # endif <S2SV_ModStart> ) "<S2SV_blank>HDRI" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) "<S2SV_blank>Modules" <S2SV_ModStart> # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) "<S2SV_blank>Zero-configuration" # endif
<S2SV_ModStart> if ( ( <S2SV_ModStart> == q ) || ( <S2SV_ModEnd> size < <S2SV_ModStart> < 16 ) || ( <S2SV_ModEnd> size > <S2SV_ModStart> > 256 )
<S2SV_ModStart> . size ; if ( ~ length < 16 ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" )
<S2SV_ModStart> ( imsx , imsy <S2SV_ModEnd> ) ; <S2SV_ModStart> background_color_index , ( size_t ) <S2SV_ModStart> ( dmsx , dmsy <S2SV_ModEnd> ) ; <S2SV_ModStart> background_color_index , ( size_t ) <S2SV_ModStart> imbuf + ( size_t ) <S2SV_ModStart> ( dmsx , dmsy <S2SV_ModEnd> ) ; <S2SV_ModStart> background_color_index , ( size_t ) <S2SV_ModStart> imbuf + ( size_t ) <S2SV_ModStart> imbuf + ( size_t ) <S2SV_ModStart> ( dmsx , dmsy <S2SV_ModEnd> ) )
<S2SV_ModStart> ) ; pixel = 0 ;
<S2SV_ModStart> VFF_TYP_BIT ) { if ( CheckMemoryOverflow <S2SV_ModEnd> ( ( <S2SV_ModStart> >> 3UL , <S2SV_ModEnd> image -> <S2SV_ModStart> -> rows ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModEnd> max_packets = <S2SV_ModStart> ) ; }
<S2SV_ModStart> message ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> char explicit_vr <S2SV_ModStart> if ( length > ( size_t ) GetBlobSize ( image ) ) ThrowDCMException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if (
<S2SV_ModStart> extent , height , <S2SV_ModStart> ) ; <S2SV_ModEnd> height = <S2SV_ModStart> ) ; if ( sun_info . type == RT_ENCODED ) <S2SV_ModStart> ) ; <S2SV_ModEnd> p =
<S2SV_ModStart> ) ; ( void ) ResetMagickMemory ( pixels , 0 , pixel_info_length ) ;
<S2SV_ModStart> n ) \\\n{ <S2SV_ModEnd> sum = <S2SV_ModStart> ; } \\\n} <S2SV_ModEnd> typedef struct <S2SV_ModStart> ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
<S2SV_ModStart> / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p <S2SV_ModStart> 0 ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } <S2SV_ModEnd> * p
<S2SV_ModStart> ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
<S2SV_ModStart> ; } if ( image -> depth > 1 ) { SetPSDPixel ( image , channels , type , packet_size , pixel , q , exception ) ; q += GetPixelChannels ( image ) ; } else <S2SV_ModEnd> { ssize_t <S2SV_ModStart> ) { SetPSDPixel ( image , channels , type , packet_size <S2SV_ModEnd> , ( <S2SV_ModStart> , q , exception <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } if ( x != image -> columns ) <S2SV_ModStart> } } <S2SV_ModEnd> return (
<S2SV_ModStart> , number_planes , number_planes_filled <S2SV_ModStart> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> number_pixels * number_planes_filled <S2SV_ModEnd> ) != <S2SV_ModStart> number_pixels * number_planes_filled <S2SV_ModEnd> ) ) <S2SV_ModStart> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info
<S2SV_ModStart> ( pixels_length + image -> rows
<S2SV_ModStart> ) { CheckNumberCompactPixels ; <S2SV_ModStart> } } <S2SV_ModEnd> compact_pixels ++
<S2SV_ModStart> , option ) ; page_geometry = DestroyString ( page_geometry
<S2SV_ModStart> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> * sizeof <S2SV_ModStart> rows * MagickMax ( number_planes_filled , 4 ) <S2SV_ModEnd> ; pixels
<S2SV_ModStart> packets + 257UL <S2SV_ModEnd> , image
<S2SV_ModStart> x += 4 <S2SV_ModEnd> ) {
<S2SV_ModStart> "enter" ) ; quantum_info = ( QuantumInfo * ) NULL <S2SV_ModStart> ) ; if ( quantum_info != ( QuantumInfo * ) NULL )
<S2SV_ModStart> ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> <S2SV_ModStart> -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException <S2SV_ModStart> break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image <S2SV_ModStart> -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> rows ) <S2SV_ModEnd> == MagickFalse <S2SV_ModStart> MagickFalse ) ) ThrowReaderException ( ImageError , "WidthOrHeightExceedsLimit" ) ; <S2SV_ModEnd> status =
<S2SV_ModStart> ) { case RMT_NONE : break ;
<S2SV_ModStart> height ; if ( ( max_value == 0 ) || ( max_value > 4294967295 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_ModStart> ++ ) <S2SV_ModEnd> ; image
<S2SV_ModStart> . RecordLength ) ; if ( Rec . RecordLength > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> ) { if ( image -> colors < tga_info . colormap_index ) image -> colors = tga_info . colormap_index ;
<S2SV_ModStart> ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ;
<S2SV_ModStart> ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
<S2SV_ModStart> : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> : { if ( data == ( unsigned char * ) NULL ) break ; <S2SV_ModStart> ; i <= <S2SV_ModEnd> ( ssize_t <S2SV_ModStart> ssize_t ) <S2SV_ModEnd> GetQuantumRange ( <S2SV_ModStart> ( depth <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { if ( pixel . red <= GetQuantumRange ( depth ) ) <S2SV_ModStart> ] ; if ( pixel . green <= GetQuantumRange ( depth ) ) <S2SV_ModStart> ] ; if ( pixel . blue <= GetQuantumRange ( depth ) )
<S2SV_ModStart> ( ( ( <S2SV_ModStart> / 8 ) * GetPSDPacketSize ( image )
<S2SV_ModStart> code ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ; } \\\n} <S2SV_ModEnd> Quantum index <S2SV_ModStart> ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if
<S2SV_ModStart> ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; <S2SV_ModStart> ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; <S2SV_ModStart> ResourceLimitError , "ImproperImageHeader" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; else { if ( sun_info . length > ( height * bytes_per_line ) ) ThrowReaderException ( ResourceLimitError , "ImproperImageHeader" ) ; ( void ) CopyMagickMemory ( sun_pixels , sun_data , sun_info . length ) ; }
<S2SV_ModStart> EOF ) if ( <S2SV_ModEnd> fputc ( <S2SV_ModStart> file ) != c ) break
<S2SV_ModStart> message ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> char explicit_vr <S2SV_ModStart> ; } if ( <S2SV_ModEnd> fputc ( <S2SV_ModStart> file ) != c ) break
<S2SV_ModStart> message ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> char geometry <S2SV_ModStart> break ; if ( <S2SV_ModEnd> fputc ( <S2SV_ModStart> file ) != c ) break
<S2SV_ModStart> break ; if ( <S2SV_ModEnd> fputc ( <S2SV_ModStart> file ) != c ) break
<S2SV_ModStart> one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y <S2SV_ModStart> if ( ( offset < 0 ) || ( <S2SV_ModStart> > pixel_info_length ) <S2SV_ModStart> plane ; if ( ( offset < 0 ) || ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; } <S2SV_ModStart> offset ; <S2SV_ModEnd> for (
<S2SV_ModStart> ( sixel_buffer ) ; sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels
<S2SV_ModStart> ) ; bytes_per_line = sun_info . width * sun_info . depth ; <S2SV_ModStart> size_t ) MagickMax ( <S2SV_ModStart> length , bytes_per_line * sun_info . width ) , <S2SV_ModStart> . height <S2SV_ModEnd> ; if
<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if (
<S2SV_ModStart> length ) { quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> mask ; }
<S2SV_ModStart> ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> EOFOp 0x07 # define ThrowRLEException ( exception , message ) \\\n{ if ( colormap != ( unsigned char * ) NULL ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; if ( pixel_info != ( MemoryInfo * ) NULL ) pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} <S2SV_ModStart> ) ; colormap = ( unsigned char * ) NULL ; pixel_info = ( MemoryInfo * ) NULL ; <S2SV_ModStart> x = ( ssize_t ) <S2SV_ModStart> y = ( ssize_t ) <S2SV_ModStart> ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , <S2SV_ModStart> , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> colormap = <S2SV_ModStart> ++ ) { <S2SV_ModStart> ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> MagickFalse ) ThrowRLEException ( <S2SV_ModEnd> CorruptImageError , <S2SV_ModStart> , "UnexpectedEndOfFile" ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> 0x40 ) { <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> 0x40 ) { <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> 0x40 ) { <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> offset = ( ssize_t ) ( <S2SV_ModStart> + plane ) <S2SV_ModStart> || ( ( <S2SV_ModStart> offset + <S2SV_ModEnd> operand * <S2SV_ModStart> ) > ( ssize_t ) <S2SV_ModStart> ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; if ( opcode <S2SV_ModStart> 0x40 ) { <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; } <S2SV_ModStart> offset = ( ssize_t ) ( <S2SV_ModStart> + plane ) <S2SV_ModStart> || ( ( <S2SV_ModStart> offset + <S2SV_ModEnd> operand * <S2SV_ModStart> ) > ( ssize_t ) <S2SV_ModStart> ) ; if ( opcode == EOF ) ThrowRLEException ( CorruptImageError , "UnexpectedEndOfFile" ) ; <S2SV_ModStart> image , ( ssize_t ) ( <S2SV_ModStart> & mask ) <S2SV_ModStart> , ( ssize_t <S2SV_ModEnd> ) ( <S2SV_ModStart> image , ( ssize_t ) <S2SV_ModStart> image , ( ssize_t ) <S2SV_ModStart> image , ( ssize_t )
<S2SV_ModStart> } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> = extent ; if ( length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" )
<S2SV_ModStart> ) ) { <S2SV_ModStart> MATLAB_KO : clone_info = DestroyImageInfo ( clone_info ) ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> bitmapDC =
<S2SV_ModStart> , height <S2SV_ModEnd> ; ssize_t <S2SV_ModStart> ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , <S2SV_ModEnd> image -> <S2SV_ModStart> -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> <S2SV_ModStart> -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( <S2SV_ModEnd> image -> <S2SV_ModStart> 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if <S2SV_ModEnd> ( bytes_per_line <S2SV_ModStart> ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns <S2SV_ModEnd> ; for <S2SV_ModStart> ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( <S2SV_ModEnd> * p <S2SV_ModStart> p ++ ) <S2SV_ModStart> ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } <S2SV_ModStart> ( ( <S2SV_ModEnd> ( bytes_per_pixel
<S2SV_ModStart> ) ; count = <S2SV_ModEnd> ReadBlob ( <S2SV_ModStart> . name ) ; if ( count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" <S2SV_ModStart> ) ; if ( count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) <S2SV_ModEnd> ; image <S2SV_ModStart> if ( <S2SV_ModEnd> ( image_info
<S2SV_ModStart> output ; MagickBooleanType status ; <S2SV_ModStart> ; } status = MagickTrue ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> input = <S2SV_ModStart> ) ) if ( fputc ( ( char ) c , output ) != c ) status = MagickFalse ; <S2SV_ModStart> void ) fclose ( input <S2SV_ModEnd> ) ; <S2SV_ModStart> void ) remove_utf8 ( argv [ i ] ) ; } ( void ) <S2SV_ModStart> fclose ( <S2SV_ModEnd> output ) <S2SV_ModStart> return ( status <S2SV_ModEnd> ) ;
<S2SV_ModStart> '\\0' ) && ( c != EOF ) <S2SV_ModStart> ] ; if ( <S2SV_ModEnd> sscanf ( <S2SV_ModStart> ] ) == 8 ) { <S2SV_ModEnd> image -> <S2SV_ModStart> ] ; } <S2SV_ModStart> width ; if ( <S2SV_ModEnd> sscanf ( <S2SV_ModStart> width ) == 2 ) { <S2SV_ModEnd> image -> <S2SV_ModStart> height ; }
<S2SV_ModStart> message ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> char explicit_vr <S2SV_ModStart> ) ) ThrowDCMException <S2SV_ModEnd> ( CorruptImageError
<S2SV_ModStart> , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( global_colormap , 0 , 3 * MagickMax ( global_colors , 256 ) * sizeof ( * global_colormap )
<S2SV_ModStart> void ) strncpy <S2SV_ModEnd> ( clone_info
<S2SV_ModStart> AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof
<S2SV_ModStart> } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; }
<S2SV_ModStart> Image * images <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const Image * next ; <S2SV_ModStart> ; size_t columns , <S2SV_ModStart> ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ssize_t ) <S2SV_ModEnd> columns ;
<S2SV_ModStart> ) ; ( void ) CloneString ( & <S2SV_ModStart> -> geometry , <S2SV_ModEnd> geometry )
<S2SV_ModStart> ) ; ( void ) CloneString ( & <S2SV_ModStart> -> geometry , <S2SV_ModEnd> geometry )
<S2SV_ModStart> message ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> char geometry <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( <S2SV_ModStart> ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ( image ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" <S2SV_ModStart> ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length <S2SV_ModStart> length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( length > <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; <S2SV_ModStart> ) ; if ( length > GetBlobSize ( image ) ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ;
<S2SV_ModStart> x += 4 <S2SV_ModEnd> ) {
<S2SV_ModStart> * image ; int c <S2SV_ModStart> , padding <S2SV_ModEnd> , version <S2SV_ModStart> ) { c <S2SV_ModEnd> = XBMInteger <S2SV_ModStart> hex_digits ) ; if ( c < 0 ) break <S2SV_ModStart> char ) c <S2SV_ModEnd> ; if <S2SV_ModStart> ) ( c <S2SV_ModEnd> >> 8 <S2SV_ModStart> ) ; if ( c < 0 ) break ; <S2SV_ModStart> char ) c ; } if ( EOFBlob ( image ) != MagickFalse ) { data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) <S2SV_ModEnd> ; } <S2SV_ModStart> = ( unsigned int <S2SV_ModEnd> ) (
<S2SV_ModStart> <S2SV_null> static <S2SV_ModEnd> int XBMInteger <S2SV_ModStart> return ( - 1 <S2SV_ModEnd> ) ; <S2SV_ModStart> return ( - 1 <S2SV_ModEnd> ) ; <S2SV_ModStart> return ( ( int )
<S2SV_ModStart> ) && ( ( number_pixels * <S2SV_ModEnd> sun_info . <S2SV_ModStart> . depth ) > ( 8 * <S2SV_ModEnd> sun_info . <S2SV_ModStart> . length ) <S2SV_ModStart> bytes_per_line + bytes_per_line <S2SV_ModEnd> % 2
<S2SV_ModStart> image -> <S2SV_ModEnd> colors = <S2SV_ModStart> 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> case RMT_EQUAL_RGB <S2SV_ModStart> * sun_colormap <S2SV_ModEnd> ; sun_colormap
<S2SV_ModStart> ) ldblk + 1
<S2SV_ModStart> AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , <S2SV_ModEnd> bytes_per_pixel *
<S2SV_ModStart> ) count + 1
<S2SV_ModStart> <S2SV_null> static MagickBooleanType <S2SV_ModEnd> InsertRow ( <S2SV_ModStart> , ssize_t bpp <S2SV_ModEnd> , unsigned <S2SV_ModStart> ) { int <S2SV_ModEnd> bit ; <S2SV_ModStart> bit ; Quantum index <S2SV_ModEnd> ; register <S2SV_ModStart> register Quantum * q ; ssize_t x ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return ( MagickFalse ) <S2SV_ModEnd> ; switch <S2SV_ModStart> switch ( bpp <S2SV_ModEnd> ) { <S2SV_ModStart> : { <S2SV_ModEnd> for ( <S2SV_ModStart> = ( <S2SV_ModEnd> ( * <S2SV_ModStart> >> bit <S2SV_ModEnd> ) ? <S2SV_ModStart> ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> < ( ssize_t ) ( <S2SV_ModStart> = ( <S2SV_ModEnd> ( * <S2SV_ModStart> >> bit <S2SV_ModEnd> ) ? <S2SV_ModStart> ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> break ; <S2SV_ModStart> : { for ( x = 0 ; x < ( ( ssize_t ) <S2SV_ModEnd> image -> <S2SV_ModStart> -> columns - 3 ) ; x += 4 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 1 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 <S2SV_ModEnd> , exception <S2SV_ModStart> ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; if ( ( image -> columns % 4 ) > 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } <S2SV_ModEnd> break ; <S2SV_ModStart> break ; } case 4 : { <S2SV_ModStart> p >> 4 <S2SV_ModEnd> ) & <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> , exception <S2SV_ModStart> ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_ModStart> * p <S2SV_ModEnd> ) & <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> , exception <S2SV_ModStart> ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> image ) <S2SV_ModEnd> ; } <S2SV_ModStart> ) & 0x0f <S2SV_ModEnd> , exception <S2SV_ModStart> ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> break ; <S2SV_ModStart> : { for ( x = 0 ; x < ( ssize_t ) <S2SV_ModEnd> image -> <S2SV_ModStart> -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p <S2SV_ModEnd> , exception <S2SV_ModStart> ) ; SetPixelIndex ( image , index , q ) ; if ( index < image -> colors ) SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } } <S2SV_ModEnd> break ; <S2SV_ModStart> break ; case 24 : <S2SV_ModStart> ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } break ; } if ( ! SyncAuthenticPixels ( image <S2SV_ModEnd> , exception <S2SV_ModStart> exception ) ) return ( MagickFalse ) ; return ( MagickTrue ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> tag ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> Image * <S2SV_ModStart> NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> ( image ) ; if ( ( iris_info . dimension == 0 ) || ( iris_info . dimension > 3 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader"
<S2SV_ModStart> , MaxTextExtent - 1
<S2SV_ModStart> ) ; if ( GetNextImageInList ( image ) != ( Image * ) NULL )

<S2SV_ModStart> 1.0f / MagickMax ( w . x , MagickMax <S2SV_ModEnd> ( w
<S2SV_ModStart> y , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> ) , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> } } return ( <S2SV_ModStart> , 8 , exception ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> y , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> ) , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> } } return ( <S2SV_ModStart> , 16 , exception ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> y , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> ) , MagickMin <S2SV_ModEnd> ( 4 <S2SV_ModStart> } } return ( <S2SV_ModStart> , 16 , exception ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ; } return ( <S2SV_ModStart> , 4 , exception ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ; } return ( <S2SV_ModStart> , 3 , exception ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> x = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f <S2SV_ModStart> y = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f <S2SV_ModStart> z = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f
<S2SV_ModStart> x = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f <S2SV_ModStart> y = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f <S2SV_ModStart> z = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f <S2SV_ModStart> w = MagickMin <S2SV_ModEnd> ( 1.0f <S2SV_ModStart> 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f
<S2SV_ModStart> arg ) \\\n{ <S2SV_ModEnd> ssize_t component <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> # define <S2SV_ModStart> arg2 ) \\\n{ <S2SV_ModEnd> ssize_t component <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> typedef struct <S2SV_ModStart> if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> 4 ) ; if ( components < 0 ) break
<S2SV_ModStart> ] ; unsigned int <S2SV_ModEnd> value ; <S2SV_ModStart> = ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 24 <S2SV_ModEnd> ; value <S2SV_ModStart> value |= ( unsigned int ) <S2SV_ModStart> value |= ( unsigned int ) <S2SV_ModStart> value |= ( unsigned int ) <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffffffff <S2SV_ModEnd> ; return
<S2SV_ModStart> short ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 <S2SV_ModEnd> ; value <S2SV_ModStart> value |= ( unsigned short ) <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffff <S2SV_ModEnd> ; return
<S2SV_ModStart> int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 0 ] <S2SV_ModEnd> ; quantum <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffffffff <S2SV_ModEnd> ; return <S2SV_ModStart> int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 3 ] <S2SV_ModEnd> ; quantum <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffffffff <S2SV_ModEnd> ; return
<S2SV_ModStart> short ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 0 ] <S2SV_ModEnd> ; quantum <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffff <S2SV_ModEnd> ; return <S2SV_ModStart> short ) buffer <S2SV_ModEnd> [ 0 <S2SV_ModStart> << 8 ; value |= <S2SV_ModEnd> ( unsigned <S2SV_ModStart> ( unsigned short <S2SV_ModEnd> ) buffer <S2SV_ModStart> ) buffer <S2SV_ModEnd> [ 1 <S2SV_ModStart> 1 ] <S2SV_ModEnd> ; quantum <S2SV_ModStart> unsigned_value = <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffff <S2SV_ModEnd> ; return
<S2SV_ModStart> int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 0 ] <S2SV_ModEnd> ; return <S2SV_ModStart> return ( <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffffffff <S2SV_ModEnd> ) ; <S2SV_ModStart> int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 24 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 16 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned int ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 3 ] <S2SV_ModEnd> ; return <S2SV_ModStart> ; return <S2SV_ModEnd> ( value <S2SV_ModStart> 0xffffffff ) <S2SV_ModEnd> ; }
<S2SV_ModStart> short ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ <S2SV_ModStart> 0 ] <S2SV_ModEnd> ; return <S2SV_ModStart> return ( <S2SV_ModEnd> value & <S2SV_ModStart> & 0xffff <S2SV_ModEnd> ) ; <S2SV_ModStart> short ) buffer <S2SV_ModEnd> [ 0 <S2SV_ModStart> << 8 ; value |= <S2SV_ModEnd> ( unsigned <S2SV_ModStart> short ) buffer [ 1 ] ; return <S2SV_ModStart> 0xffff ) <S2SV_ModEnd> ; }
<S2SV_ModStart> columns - 3 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; q ++ ; p <S2SV_ModEnd> ++ ; <S2SV_ModStart> 4 ) > <S2SV_ModEnd> 1 ) <S2SV_ModStart> 4 ) > <S2SV_ModEnd> 2 )
<S2SV_ModStart> rows = 1 <S2SV_ModEnd> ; image <S2SV_ModStart> BImgBuff ) <S2SV_ModEnd> ; break
<S2SV_ModStart> if ( ( MagickSizeType ) <S2SV_ModStart> break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . <S2SV_ModStart> . ba_offset ; if ( offset <S2SV_ModStart> 0 ) if ( <S2SV_ModEnd> ( offset <S2SV_ModStart> offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException <S2SV_ModStart> ) ; * magick = '\\0' ; <S2SV_ModEnd> count =
<S2SV_ModStart> char * last_row <S2SV_ModEnd> , * <S2SV_ModStart> ) ; last_row <S2SV_ModEnd> = ( <S2SV_ModStart> ) { last_row <S2SV_ModEnd> = ( <S2SV_ModStart> ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( <S2SV_ModStart> ] = last_row <S2SV_ModEnd> [ i <S2SV_ModStart> CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( <S2SV_ModStart> RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( <S2SV_ModStart> RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( <S2SV_ModStart> RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( ( count < 0 ) || ( ( size_t ) count > length ) ) { length = 0 ; continue ; } if ( (
<S2SV_ModStart> / 3 ) ThrowReaderException ( CorruptImageError , "InvalidColormapIndex" ) ; if ( WPG_Palette . StartIndex > WPG_Palette . NumOfEntries
<S2SV_ModStart> ssize_t ) ConstrainColormapIndex ( image , <S2SV_ModStart> , q ) , exception
<S2SV_ModStart> ; } if ( ( ( MagickSizeType ) image -> columns * image -> rows ) > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ;
<S2SV_ModStart> MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
<S2SV_ModStart> ( image ) ; if ( bmp_info . number_colors > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile"
<S2SV_ModStart> ) ; <S2SV_ModEnd> if (
<S2SV_ModStart> NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> NULL ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ;
<S2SV_ModStart> sizeof ( double <S2SV_ModEnd> ) )
<S2SV_ModStart> MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ;
<S2SV_ModStart> if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , "InsufficientImageDataInFile" , image -> filename ) ; } if (
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> -> ping != MagickFalse <S2SV_ModStart> ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> -> ping != MagickFalse <S2SV_ModStart> Finish ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
<S2SV_ModStart> ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList
<S2SV_ModStart> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status =
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> 8 ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
<S2SV_ModStart> if ( EOFBlob ( image ) ) break ; if (
<S2SV_ModStart> while ( filepos < GetBlobSize ( image ) && <S2SV_ModStart> ( filepos > GetBlobSize ( image ) || filepos < 0 <S2SV_ModEnd> ) break <S2SV_ModStart> filepos ) >= <S2SV_ModEnd> GetBlobSize ( <S2SV_ModStart> 1 ) ) ; ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile"
<S2SV_ModStart> UnpackRaster : status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; <S2SV_ModStart> . Height ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break <S2SV_ModStart> } } <S2SV_ModEnd> Finish :
<S2SV_ModStart> MagickFalse ; break <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { status = MagickFalse ; break <S2SV_ModEnd> ; }
<S2SV_ModStart> code ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ; } \\\n} <S2SV_ModEnd> IndexPacket index <S2SV_ModStart> ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if
<S2SV_ModStart> tag ) \\\n{ <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; \\\n} <S2SV_ModEnd> Image * <S2SV_ModStart> NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
<S2SV_ModStart> Image * images <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const Image * next ; <S2SV_ModStart> ; size_t columns , <S2SV_ModStart> ) ; columns = images -> columns ; <S2SV_ModStart> for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModStart> AcquireQuantumMemory ( <S2SV_ModEnd> columns , <S2SV_ModStart> ssize_t ) <S2SV_ModEnd> columns ; <S2SV_ModStart> GetMagickPixelPacket ( images <S2SV_ModEnd> , &
<S2SV_ModStart> , option ) ; geometry = DestroyString ( geometry
<S2SV_ModStart> columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t <S2SV_ModStart> ThreadResource ) ) <S2SV_ModStart> AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i <S2SV_ModStart> ssize_t ) rows <S2SV_ModEnd> ; i
<S2SV_ModStart> if ( <S2SV_ModEnd> g_path_is_absolute (
<S2SV_ModStart> i ] ) ; log_debug ( ZONE , "sx<S2SV_blank>sasl<S2SV_blank>callback:<S2SV_blank>check<S2SV_blank>mech<S2SV_blank>(mech=%s)" , mechbuf
<S2SV_ModStart> mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
<S2SV_ModStart> >= 0 && xhash_get ( out -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> >= 0 && xhash_get ( in -> states , rkey ) == ( void * ) conn_INPROGRESS
<S2SV_ModStart> ) { <S2SV_ModEnd> const void <S2SV_ModStart> * data , * raw <S2SV_ModStart> u_int32_t vendor ; unsigned char type ; size_t data_len <S2SV_ModStart> , & raw <S2SV_ModEnd> , & <S2SV_ModStart> ; } if ( <S2SV_ModEnd> rad_get_vendor_attr ( <S2SV_ModStart> , & type , & <S2SV_ModStart> data , & data_len , raw , <S2SV_ModEnd> len ) <S2SV_ModStart> len ) <S2SV_ModEnd> == - <S2SV_ModStart> "attr" , type <S2SV_ModEnd> ) ; <S2SV_ModStart> data , data_len <S2SV_ModEnd> , 1
<S2SV_ModStart> * vendor , unsigned char * type <S2SV_ModStart> * len , const void * raw , size_t raw_len <S2SV_ModStart> attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> * ) raw <S2SV_ModEnd> ; * <S2SV_ModStart> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }
<S2SV_ModStart> ue ; if <S2SV_ModEnd> ( tree_root <S2SV_ModStart> NULL ) return 0
<S2SV_ModStart> ) { int ret_value = 0 ; <S2SV_ModStart> ) ; ret_value = <S2SV_ModEnd> write_output ( <S2SV_ModStart> ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled." , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( "Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>" <S2SV_ModEnd> , EF_GBL_OPTIONS
<S2SV_ModStart> - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID
<S2SV_ModStart> hmi_data ; uint32_t data_siz ; <S2SV_ModStart> * note <S2SV_ModEnd> ; if <S2SV_ModStart> if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( <S2SV_ModStart> hmi_tmp ; hmi_tmp += 4 ; <S2SV_ModStart> 4 ; hmi_tmp = 8 ; } else { hmi_tmp = <S2SV_ModEnd> 4 ; <S2SV_ModStart> 4 ; } hmi_data <S2SV_ModEnd> += 4 <S2SV_ModStart> 4 ; hmi_track_offset [ i ] += 4 ; if ( hmi_tmp > data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } data_siz -= hmi_tmp ; <S2SV_ModStart> , hmi_data , data_siz <S2SV_ModStart> setup_ret ; data_siz -= setup_ret ; <S2SV_ModStart> if ( data_siz && <S2SV_ModStart> do { if ( ! data_siz ) break ; <S2SV_ModStart> ++ ; data_siz -- ; <S2SV_ModStart> 0x7F ) ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end <S2SV_ModStart> ++ ; data_siz -- ; <S2SV_ModStart> setup_ret ; data_siz -= setup_ret ; } } if ( data_siz && <S2SV_ModEnd> * hmi_data <S2SV_ModStart> do { if ( ! data_siz ) break ; <S2SV_ModStart> ++ ; data_siz -- ; <S2SV_ModStart> ; } if ( ! data_siz ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmi_end ; } <S2SV_ModStart> hmi_data ++ ; data_siz --
<S2SV_ModStart> + chunk_length [ i ] ; chunk_length [ i ] -= chunk_ofs <S2SV_ModStart> 3 ; chunk_length [ i ] -= 3 ; <S2SV_ModStart> , hmp_chunk [ i ] , chunk_length <S2SV_ModStart> = 1 ; chunk_length [ i ] -= 3 <S2SV_ModStart> setup_ret ; chunk_length [ i ] -= setup_ret ; <S2SV_ModStart> if ( chunk_length [ i ] && <S2SV_ModStart> do { if ( ! chunk_length [ i ] ) break ; <S2SV_ModStart> ++ ; chunk_length [ i ] -- ; <S2SV_ModStart> ; } if ( ! chunk_length [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMP , "file<S2SV_blank>too<S2SV_blank>short" , 0 ) ; goto _hmp_end ; } <S2SV_ModStart> ] ++ ; chunk_length [ i ] --
<S2SV_ModStart> midi_type ; uint8_t * * tracks ; uint32_t * track_size <S2SV_ModEnd> ; uint32_t <S2SV_ModStart> ) ; track_size = malloc ( sizeof ( uint32_t ) * no_tracks ) ; <S2SV_ModStart> 4 ; tmp_val <S2SV_ModEnd> = * <S2SV_ModStart> 24 ; tmp_val <S2SV_ModEnd> |= * <S2SV_ModStart> 16 ; tmp_val <S2SV_ModEnd> |= * <S2SV_ModStart> 8 ; tmp_val <S2SV_ModEnd> |= * <S2SV_ModStart> midi_size < tmp_val <S2SV_ModEnd> ) { <S2SV_ModStart> if ( tmp_val <S2SV_ModEnd> < 3 <S2SV_ModStart> midi_data [ tmp_val <S2SV_ModEnd> - 3 <S2SV_ModStart> midi_data [ tmp_val <S2SV_ModEnd> - 2 <S2SV_ModStart> midi_data [ tmp_val <S2SV_ModEnd> - 1 <S2SV_ModStart> midi_data ; track_size [ i ] = tmp_val ; <S2SV_ModStart> midi_data += tmp_val <S2SV_ModEnd> ; midi_size <S2SV_ModStart> midi_size -= tmp_val <S2SV_ModEnd> ; track_end <S2SV_ModStart> ++ ; track_size [ i ] -- ; <S2SV_ModStart> ] ++ ; track_size [ i ] -- <S2SV_ModStart> ] , track_size [ i ] , <S2SV_ModStart> 3 ; track_size [ i ] -= 3 ; <S2SV_ModStart> setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ++ ; track_size [ i ] -- ; <S2SV_ModStart> ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> ] ++ ; track_size [ i ] -- <S2SV_ModStart> ] , track_size [ i ] , <S2SV_ModStart> setup_ret ; track_size [ i ] -= setup_ret ; <S2SV_ModStart> do { if ( ! track_size [ i ] ) break ; <S2SV_ModStart> ++ ; track_size [ i ] -- ; <S2SV_ModStart> ; } if ( ! track_size [ i ] ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(too<S2SV_blank>short)" , 0 ) ; goto _end ; } <S2SV_ModStart> ] ++ ; track_size [ i ] -- <S2SV_ModStart> ) ; free ( track_size ) ;
<S2SV_ModStart> 0.0 ; # define MUS_SZ 4 <S2SV_ModStart> mus_event [ MUS_SZ <S2SV_ModStart> ) mus_event , MUS_SZ
<S2SV_ModStart> xmi_data , xmi_size ,

<S2SV_ModStart> res ; <S2SV_ModEnd> res =
<S2SV_ModStart> if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } if ( <S2SV_ModStart> ( EXIT_FAILURE <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { int fh ; struct stat st ; <S2SV_ModStart> ( ( fh = open ( debug_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) return ERROR ; if ( ( <S2SV_ModStart> debug_file_fp = fdopen ( fh <S2SV_ModEnd> , "a+" <S2SV_ModStart> ERROR ; if ( ( fstat ( fh , & st ) ) == - 1 ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { debug_file_fp = NULL ; close ( fh ) ; return ERROR ; } <S2SV_ModStart> fcntl ( fh <S2SV_ModEnd> , F_SETFD
<S2SV_ModStart> ) { int fh ; struct stat st ; if ( log_fp ) return log_fp ; if ( ( fh = open ( log_file , O_RDWR | O_APPEND | O_CREAT | O_NOFOLLOW , S_IRUSR | S_IWUSR ) ) == - 1 ) { if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>open<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>writing\\n" , log_file ) ; return NULL ; } log_fp = fdopen ( fh <S2SV_ModEnd> , "a+" <S2SV_ModStart> FALSE ) <S2SV_ModEnd> printf ( <S2SV_ModStart> ) ; return NULL ; } if ( ( fstat ( fh , & st ) ) == - 1 ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>fstat<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , log_file ) ; return NULL ; } if ( st . st_nlink != 1 || ( st . st_mode & S_IFMT ) != S_IFREG ) { log_fp = NULL ; close ( fh ) ; if ( daemon_mode == FALSE ) printf ( "Warning:<S2SV_blank>log<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>mode\\n" , log_file ) ; <S2SV_ModEnd> return NULL
<S2SV_ModStart> res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> malloc ( alloc_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , num_params , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> malloc ( alloc_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; <S2SV_ModStart> 0 , ROUNDUP ( size , granularity ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> , & end_addr <S2SV_ModEnd> ) ) <S2SV_ModStart> a = ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> ; a <S2SV_ModStart> a < end_addr <S2SV_ModEnd> ; a
<S2SV_ModStart> res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> malloc ( alloc_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> TEE_ERROR_NOT_SUPPORTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> malloc ( alloc_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> TEE_ERROR_NOT_IMPLEMENTED ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , attr_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> malloc ( alloc_size <S2SV_ModEnd> ) ;
<S2SV_ModStart> res ; res = <S2SV_ModStart> utee_param_to_param ( utc , <S2SV_ModStart> callee_params ) ; if ( res != TEE_SUCCESS ) return res
<S2SV_ModStart> <S2SV_null> static TEE_Result <S2SV_ModEnd> utee_param_to_param ( <S2SV_ModStart> utee_param_to_param ( struct user_ta_ctx * utc , <S2SV_ModStart> ] ; uint32_t flags = TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER ; <S2SV_ModStart> { case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : flags |= TEE_MEMORY_ACCESS_WRITE ; case TEE_PARAM_TYPE_MEMREF_INPUT <S2SV_ModEnd> : p <S2SV_ModStart> b ; if ( tee_mmu_check_access_rights ( utc , flags , a , b ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_ModStart> } } return TEE_SUCCESS ;
<S2SV_ModStart> ) { size_t req_size = 0 ; <S2SV_ModStart> ) ; if ( ADD_OVERFLOW ( mem -> offs , mem -> size , & req_size ) || mem -> mobj -> size < req_size ) return TEE_ERROR_SECURITY ;
<S2SV_ModStart> cac_id , serial -> len <S2SV_ModEnd> ) ;
<S2SV_ModStart> id ; if ( bufLen < 2 ) break ; <S2SV_ModStart> 2 ; bufLen -= 2 ;
<S2SV_ModStart> ) { size_t <S2SV_ModEnd> j , <S2SV_ModStart> 0x84 : file -> namelen = MIN ( sizeof file -> name , len ) ; <S2SV_ModStart> d , <S2SV_ModEnd> file -> <S2SV_ModStart> -> namelen ) <S2SV_ModEnd> ; break
<S2SV_ModStart> buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) <S2SV_ModEnd> ] =
<S2SV_ModStart> == 0x01 && i < gemsafe_cert_max
<S2SV_ModStart> ) ; if ( len > 0 ) { <S2SV_ModStart> len ; }
<S2SV_ModStart> == NULL || sec_attr_len
<S2SV_ModStart> bufsize = MIN ( <S2SV_ModStart> -> size , sizeof buf )
<S2SV_ModStart> bufsize = MIN ( <S2SV_ModStart> -> size , sizeof buf )
<S2SV_ModStart> = file && file -> size > 0
<S2SV_ModStart> ; } strncat ( line , buf , sizeof line ) ; strncat <S2SV_ModEnd> ( line <S2SV_ModStart> , "<S2SV_blank>" , sizeof line <S2SV_ModStart> line [ ( sizeof <S2SV_ModEnd> line ) <S2SV_ModStart> ] = '\\0' ; line [ strlen ( line ) - 1 ] =
<S2SV_ModStart> ; int i , count = 0 ; int zero_bits ; size_t octets_left ; if ( outlen < octets_left ) return SC_ERROR_BUFFER_TOO_SMALL ; if ( inlen < 1 ) return SC_ERROR_INVALID_ASN1_OBJECT ; <S2SV_ModStart> 0x07 ; <S2SV_ModEnd> octets_left = <S2SV_ModStart> 1 ; in ++ ; memset ( outbuf , 0 , outlen ) ; while ( octets_left ) { int bits_to_go ; * out = 0 ; if ( octets_left == 1 ) bits_to_go = 8 - zero_bits ; else bits_to_go = 8 ; if ( invert ) for ( i = 0 ; i < bits_to_go ; i ++ ) { * out |= ( ( * in >> ( 7 - i ) ) & 1 ) << i ; } else { * out = * in ; } out ++ ; in ++ ; octets_left -- ; count ++ ; } return ( count * 8 <S2SV_ModEnd> ) -
<S2SV_ModStart> ) && objlen > 1 && <S2SV_ModStart> == 0x00 <S2SV_ModEnd> ) {
<S2SV_ModStart> unsigned char * signature = NULL <S2SV_ModEnd> ; unsigned <S2SV_ModStart> int siglen <S2SV_ModEnd> ; const <S2SV_ModStart> if ( NULL == privkey ) goto err ; siglen = EVP_PKEY_size ( privkey ) ; if ( siglen <= 0 ) goto err ; signature = malloc ( siglen ) ; if ( NULL == signature ) goto err ; if ( <S2SV_ModStart> err : free ( signature ) ;
<S2SV_ModStart> len ; <S2SV_ModEnd> WCHAR * <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto err <S2SV_ModEnd> ; } <S2SV_ModStart> len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL <S2SV_ModStart> NULL ; <S2SV_ModEnd> free ( <S2SV_ModStart> ; return FALSE <S2SV_ModEnd> ; }
<S2SV_ModStart> fd = _open_as_other ( path_name , req <S2SV_ModEnd> ) ) <S2SV_ModStart> error ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s:<S2SV_blank>Permission<S2SV_blank>denied" , path_name <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ) ; alloc_array ( t1_buf , strlen ( t1_line_array ) + strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE ) ; <S2SV_ModStart> , t1_line_array ) ; alloc_array ( t1_line , strlen ( t1_buf_array ) + 1 , T1_BUF_SIZE
<S2SV_ModStart> ) { HTChunk * target = NULL ; <S2SV_ModStart> HTML_TITLE : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> title <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_STYLE : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> style_block <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_SCRIPT : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> script <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_OBJECT : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> object <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_TEXTAREA : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> textarea <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_OPTION : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> option <S2SV_ModEnd> ; break <S2SV_ModStart> HTML_MATH : target = <S2SV_ModEnd> & me <S2SV_ModStart> -> math <S2SV_ModEnd> ; break <S2SV_ModStart> } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , "BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }
<S2SV_ModStart> ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , "Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL." ) ; return HTTP_BAD_REQUEST ; }
<S2SV_ModStart> function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> # endif assert ( sp == 0 ) ; <S2SV_ModStart> ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . <S2SV_ModStart> . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; <S2SV_ModEnd> stop = <S2SV_ModStart> stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; <S2SV_ModStart> ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
<S2SV_ModStart> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> ; break <S2SV_ModStart> OBJECT_TYPE_STRING : if ( <S2SV_ModStart> * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break
<S2SV_ModStart> assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL
<S2SV_ModStart> # line 113 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1337 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 122 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1345 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 126 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModStart> # line 1360 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 137 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> . re_node ) ; incr_ast_levels ( <S2SV_ModStart> # line 1424 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 201 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1432 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 205 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> "hex_grammar.y" { incr_ast_levels ( ) ; <S2SV_ModStart> # line 1447 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 220 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1455 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 224 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1464 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 233 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1481 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 246 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1489 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 250 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1498 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 259 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1525 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 282 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1561 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 314 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1587 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 336 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1607 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 356 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1615 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 360 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> ) ; incr_ast_levels ( ) ; <S2SV_ModStart> # line 1631 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 375 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1643 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 383 <S2SV_ModEnd> "hex_grammar.y" { <S2SV_ModStart> # line 1667 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 1671 <S2SV_ModEnd> "hex_grammar.c" default
<S2SV_ModStart> # line 101 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 102 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 103 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 104 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 107 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 106 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> "hex_grammar.c" break <S2SV_ModStart> # line 105 "hex_grammar.y" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> "hex_grammar.c" break
<S2SV_ModStart> lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; <S2SV_ModStart> lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ; <S2SV_ModStart> lex_env , "illegal<S2SV_blank>escape<S2SV_blank>sequence" <S2SV_ModEnd> ) ;
<S2SV_ModStart> == EOF || text [ 1 ] == 0 <S2SV_ModStart> if ( ! isxdigit ( <S2SV_ModStart> 2 ] ) <S2SV_ModEnd> ) return <S2SV_ModStart> if ( ! isxdigit ( <S2SV_ModStart> 3 ] ) <S2SV_ModEnd> ) return
<S2SV_ModStart> ) ; assert_regexp_syntax_error ( "\\\\x0" ) ; assert_regexp_syntax_error ( "\\\\x" ) ; assert_regexp_syntax_error ( "\\\\xxy" ) ;
<S2SV_ModStart> ) ; set_integer ( 256 , module_object , "integer_array[%i]" , 256 ) ;
<S2SV_ModStart> count = 64 ; while ( count <= index ) count *= 2 <S2SV_ModEnd> ; array <S2SV_ModStart> 2 ; while ( count <= index ) count *= 2 ;
<S2SV_ModStart> assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\"\\"<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\"baz\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"foo\\"]<S2SV_blank>==<S2SV_blank>\\"foo\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\"bar\\"]<S2SV_blank>==<S2SV_blank>\\"bar\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\"dummy\\")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL <S2SV_ModStart> assert_false_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"foo\\")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\"bar\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" , NULL ) ; assert_true_rule ( "import<S2SV_blank>\\"tests\\"<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\"FOO\\\\nBAR\\")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}" <S2SV_ModEnd> , NULL
<S2SV_ModStart> length , 0 ,
<S2SV_ModStart> , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int <S2SV_ModStart> define prolog { if ( <S2SV_ModEnd> ( bytes_matched <S2SV_ModStart> max_bytes_matched ) || ( character_size == 2 && * ( input + 1 ) != 0 ) ) { action = ACTION_KILL ; break ; } <S2SV_ModEnd> } # <S2SV_ModStart> e ) { <S2SV_ModStart> ; } } <S2SV_ModStart> ) { max_bytes_matched = ( int ) yr_min ( input_backwards_size , RE_SCAN_LIMIT ) ; <S2SV_ModStart> ; } else { <S2SV_ModStart> yr_min ( input_forwards_size <S2SV_ModEnd> , RE_SCAN_LIMIT <S2SV_ModStart> ) ; } <S2SV_ModStart> match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; <S2SV_ModStart> = ! _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) ; <S2SV_ModStart> 0 && input_backwards_size < character_size ) { <S2SV_ModEnd> match = <S2SV_ModStart> TRUE ; } <S2SV_ModStart> max_bytes_matched ) { <S2SV_ModStart> TRUE ; } else { assert ( input < input_data + input_forwards_size ) ; assert ( input >= input_data - input_backwards_size ) ; assert <S2SV_ModEnd> ( input <S2SV_ModStart> - input_incr < input_data + input_forwards_size ) ; assert ( input - input_incr >= input_data - input_backwards_size ) ; match = _yr_re_is_word_char ( input , character_size <S2SV_ModEnd> ) != <S2SV_ModStart> ) != _yr_re_is_word_char ( input - input_incr , character_size ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> kill = input_backwards_size <S2SV_ModEnd> > ( <S2SV_ModStart> kill = input_backwards_size > 0 <S2SV_ModEnd> || ( <S2SV_ModStart> RE_FLAGS_BACKWARDS || input_forwards_size <S2SV_ModEnd> > ( <S2SV_ModStart> ; } <S2SV_ModEnd> } input
<S2SV_ModStart> , size_t input_forwards_size , size_t input_backwards_size <S2SV_ModEnd> , int <S2SV_ModStart> int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? input_backwards_size : input_forwards_size <S2SV_ModEnd> ; input_incr
<S2SV_ModStart> ) , 0 ,
<S2SV_ModStart> , offset , <S2SV_ModEnd> flags , <S2SV_ModStart> , offset , <S2SV_ModEnd> flags , <S2SV_ModStart> data + offset , data_size -
<S2SV_ModStart> ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "\\ta\\0b\\0c\\0" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\0a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "x\\ta\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0x\\0" ) ; assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "a\\0b\\0c\\0b\\t" ) ; assert_false_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}" , "abc" ) ; <S2SV_ModStart> assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE <S2SV_ModStart> assert_true_rule_blob ( "rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}" <S2SV_ModEnd> , PE32_FILE
<S2SV_ModStart> ) -> levels = 0 ; ( * re_ast ) ->
<S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ) break ; next_input = input + i * input_incr <S2SV_ModStart> min ; bytes_matched = yr_min ( bytes_matched , max_bytes_matched ) ;
<S2SV_ModStart> -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
<S2SV_ModStart> ) { int offs = sizeof ( nonce ) <S2SV_ModEnd> ; if <S2SV_ModStart> ( resplen < 17 ) { return U2FH_SIZE_ERROR ; } if ( memcmp ( nonce , resp , sizeof ( nonce ) ) != 0 ) { return U2FH_TRANSPORT_ERROR ; } <S2SV_ModEnd> dev -> <S2SV_ModStart> cid = resp [ offs ] << 24 | resp [ offs + 1 ] << 16 | resp [ offs + 2 ] << 8 | resp [ offs + 3 ] ; offs += 4 <S2SV_ModEnd> ; dev <S2SV_ModStart> versionInterface = resp [ offs ++ ] <S2SV_ModEnd> ; dev <S2SV_ModStart> versionMajor = resp [ offs ++ ] <S2SV_ModEnd> ; dev <S2SV_ModStart> versionMinor = resp [ offs ++ ] ; dev -> versionBuild = resp [ offs ++ ] <S2SV_ModEnd> ; dev <S2SV_ModStart> capFlags = resp [ offs ++ ] <S2SV_ModEnd> ; }
<S2SV_ModStart> | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
<S2SV_ModStart> ) { struct stat st ; FILE * file = NULL ; int fd = - 1 ; <S2SV_ModStart> else { fd = open <S2SV_ModEnd> ( filename <S2SV_ModStart> ( filename , O_WRONLY | O_APPEND | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY ) ; if ( fd >= 0 && ( fstat ( fd <S2SV_ModStart> 0 ) && <S2SV_ModEnd> S_ISREG ( <S2SV_ModStart> file = fdopen ( fd <S2SV_ModEnd> , "a" <S2SV_ModStart> file ; cfg -> is_custom_debug_file = 1 ; file = NULL ; fd = - 1 ; <S2SV_ModEnd> } } <S2SV_ModStart> ; } if ( fd != - 1 ) close ( fd ) ; if ( file != NULL ) fclose ( file ) ;
<S2SV_ModStart> , O_RDONLY | O_CLOEXEC | O_NOCTTY <S2SV_ModEnd> ) ; <S2SV_ModStart> goto err ; } else { fd = - 1 <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( fd != - 1 <S2SV_ModEnd> ) close
<S2SV_ModStart> int openasuser = 0 <S2SV_ModStart> = 0 ; PAM_MODUTIL_DEF_PRIVS ( privs ) <S2SV_ModStart> ; } openasuser = geteuid ( ) == 0 ? 1 : 0 ; <S2SV_ModStart> ) ; if ( ! openasuser ) { DBG ( "WARNING:<S2SV_blank>not<S2SV_blank>dropping<S2SV_blank>privileges<S2SV_blank>when<S2SV_blank>reading<S2SV_blank>%s,<S2SV_blank>please<S2SV_blank>" "consider<S2SV_blank>setting<S2SV_blank>openasuser=1<S2SV_blank>in<S2SV_blank>the<S2SV_blank>module<S2SV_blank>configuration" <S2SV_ModEnd> , buf <S2SV_ModStart> ) ; } } DBG ( "Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s" , buf ) ; <S2SV_ModStart> ; } if ( ! openasuser ) { openasuser <S2SV_ModEnd> = geteuid <S2SV_ModStart> openasuser ; } <S2SV_ModStart> ) { DBG ( "Dropping<S2SV_blank>privileges" ) ; if ( pam_modutil_drop_priv ( pamh , & privs , pw <S2SV_ModEnd> ) ) <S2SV_ModStart> "Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) <S2SV_ModStart> "Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i" , pw -> <S2SV_ModEnd> pw_uid ) <S2SV_ModStart> if ( pam_modutil_regain_priv ( pamh , & privs ) ) { DBG ( "could<S2SV_blank>not<S2SV_blank>restore<S2SV_blank>privileges" <S2SV_ModEnd> ) ; <S2SV_ModStart> DBG ( "Restored<S2SV_blank>privileges" <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; fclose ( opwfile ) ;
<S2SV_ModStart> ; } # if 0 <S2SV_ModStart> } } # endif
<S2SV_ModStart> ) ; unlink ( path ) ; <S2SV_ModStart> O_CREAT | O_EXCL <S2SV_ModEnd> , 0600
<S2SV_ModStart> fsuid , <S2SV_ModEnd> NULL )
<S2SV_ModStart> ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR "/abrt-tmp-debuginfo.XXXXXX" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory" ) ; log_info ( "Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] = "--tmpdir" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( "fork" ) ; if ( pid == 0 ) { <S2SV_ModStart> ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( "waitpid" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( "Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( "Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( "Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d" , WTERMSIG ( status ) ) ; error_msg_and_die ( "Child<S2SV_blank>exit<S2SV_blank>failed" ) ; }
<S2SV_ModStart> int source_base_ofs , uid_t uid , gid_t gid <S2SV_ModStart> ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; }
<S2SV_ModStart> ) ; copy_file_ext <S2SV_ModEnd> ( source_filename <S2SV_ModStart> dest_filename , 0640 <S2SV_ModEnd> , dd <S2SV_ModStart> -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; copy_file_ext <S2SV_ModEnd> ( source_filename <S2SV_ModStart> dest_filename , 0640 <S2SV_ModEnd> , dd <S2SV_ModStart> -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; copy_file_ext <S2SV_ModEnd> ( source_filename <S2SV_ModStart> dest_filename , 0640 <S2SV_ModEnd> , dd <S2SV_ModStart> -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> dump_fd_info ( <S2SV_ModStart> , source_base_ofs <S2SV_ModEnd> , dd <S2SV_ModStart> -> dd_gid <S2SV_ModEnd> ) ;
<S2SV_ModStart> path , g_settings_privatereports ? 0 :
<S2SV_ModStart> ; } if ( g_settings_privatereports ) { struct stat statbuf ; if ( lstat ( dirname , & statbuf ) != 0 || ! S_ISDIR ( statbuf . st_mode ) ) { error_msg ( "Path<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>directory" , dirname ) ; return 404 ; } struct group * gr = getgrnam ( "abrt" ) ; if ( ! gr ) { error_msg ( "Group<S2SV_blank>\'abrt\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist" ) ; return 500 ; } if ( statbuf . st_uid != 0 || ! ( statbuf . st_gid == 0 || statbuf . st_gid == gr -> gr_gid ) || statbuf . st_mode & 07 ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>isn\'t<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>root:abrt<S2SV_blank>or<S2SV_blank>others<S2SV_blank>are<S2SV_blank>not<S2SV_blank>restricted<S2SV_blank>from<S2SV_blank>access" , dirname ) ; return 403 ; } struct dump_dir * dd = dd_opendir ( dirname , DD_OPEN_READONLY ) ; const bool complete = dd && problem_dump_dir_is_complete ( dd ) ; dd_close ( dd ) ; if ( complete ) { error_msg ( "Problem<S2SV_blank>directory<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>already<S2SV_blank>been<S2SV_blank>processed" , dirname ) ; return 403 ; } } else
<S2SV_ModStart> } } const uid_t dduid = g_settings_privatereports ? 0 : fsuid ; <S2SV_ModStart> path , dduid <S2SV_ModEnd> , DEFAULT_DUMP_DIR_MODE
<S2SV_ModStart> 0 ; value = get_map_string_item_or_NULL ( settings , "PrivateReports" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , "PrivateReports" ) ; }
<S2SV_ModStart> dump_dir * dd = NULL ; if ( g_settings_privatereports ) dd = create_dump_dir_from_problem_data_ext ( pd , g_settings_dump_location , 0 ) ; else
<S2SV_ModStart> ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( "Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
<S2SV_ModStart> dest_filename , "wx" <S2SV_ModEnd> ) ;
<S2SV_ModStart> , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0
<S2SV_ModStart> ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> GTK_RESPONSE_OK ) { <S2SV_ModStart> ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0 ) ; }
<S2SV_ModStart> | O_CREAT | O_NOFOLLOW
<S2SV_ModStart> pidfd = open <S2SV_ModEnd> ( pid_file <S2SV_ModStart> ( pid_file , O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC
<S2SV_ModStart> filepath , "r" <S2SV_ModEnd> ) ;
<S2SV_ModStart> file = fopen_safe <S2SV_ModEnd> ( "/tmp/keepalived.json"
<S2SV_ModStart> tf = fopen_safe <S2SV_ModEnd> ( tfile
<S2SV_ModStart> file = fopen_safe <S2SV_ModEnd> ( dump_file
<S2SV_ModStart> * file = fopen_safe <S2SV_ModEnd> ( stats_file <S2SV_ModStart> "w" ) <S2SV_ModEnd> ; element <S2SV_ModStart> vrrp ; if ( ! file ) { log_message ( LOG_INFO , "Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e <S2SV_ModEnd> ) { <S2SV_ModStart> ) { <S2SV_ModEnd> fprintf (
<S2SV_ModStart> log_file = fopen_safe <S2SV_ModEnd> ( file_name
<S2SV_ModStart> | O_NONBLOCK | O_NOFOLLOW
<S2SV_ModStart> ; return 0
<S2SV_ModStart> ) ; conf_write ( fp , "<S2SV_blank>umask<S2SV_blank>=<S2SV_blank>0%o" , global_data -> umask ) ;
<S2SV_ModStart> # endif install_keyword ( "umask" , & umask_handler ) ;
<S2SV_ModStart> # endif umask ( 022 ) ; <S2SV_ModStart> ) ; global_data -> umask = umask_val ; <S2SV_ModStart> ; } <S2SV_ModEnd> # ifdef
<S2SV_ModStart> unsigned facility ; mode_t new_umask_val <S2SV_ModStart> } , { "umask" , required_argument , NULL , 'u' } , <S2SV_ModStart> argv , ":vhlndu:DRS:f:p:i:mM::g::Gt::" <S2SV_ModEnd> # if <S2SV_ModStart> ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case
<S2SV_ModStart> ) ; fprintf ( stderr , "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--umask=MASK<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>umask<S2SV_blank>for<S2SV_blank>file<S2SV_blank>creation<S2SV_blank>(in<S2SV_blank>numeric<S2SV_blank>form)\\n" ) ;
<S2SV_ModStart> Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * <S2SV_ModStart> * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree (
<S2SV_ModStart> ) ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; }
<S2SV_ModStart> * len && plen > 0
<S2SV_ModStart> 2 ; if ( plen < 0 ) return 0 ;
<S2SV_ModStart> LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> s ) { tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> 1 ; tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> 1 ; tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> 5 ; tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> 5 ; tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> 4 ; tmp2 <S2SV_ModEnd> = ( <S2SV_ModStart> if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
<S2SV_ModStart> 1 ; int n = 0 ; <S2SV_ModStart> & h <S2SV_ModEnd> ) ; <S2SV_ModStart> L , 2 <S2SV_ModEnd> , "too<S2SV_blank>many<S2SV_blank>results" <S2SV_ModStart> ) ; n ++ ; <S2SV_ModStart> ) ; n ++ ; <S2SV_ModStart> ) ; n ++ ; <S2SV_ModStart> if ( n == 0 || <S2SV_ModStart> L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; n -- ; <S2SV_ModStart> L , <S2SV_ModEnd> size <= <S2SV_ModStart> <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , <S2SV_ModStart> size ) ; n ++ <S2SV_ModStart> ) ; n ++ ; <S2SV_ModStart> ; return n + 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> getnum ( <S2SV_ModEnd> fmt ,
<S2SV_ModStart> getnum ( <S2SV_ModEnd> const char <S2SV_ModStart> do { <S2SV_ModEnd> a =
<S2SV_ModStart> getnum ( <S2SV_ModEnd> fmt , <S2SV_ModStart> getnum ( <S2SV_ModEnd> fmt ,
<S2SV_ModStart> , "MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input." ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , "Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."
<S2SV_ModStart> ( L ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_decode_to_lua_array"
<S2SV_ModStart> ) ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array" ) ;
<S2SV_ModStart> = 0 ; luaL_checkstack ( L , 3 , "in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map" )
<S2SV_ModStart> ) { luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_check" ) ;
<S2SV_ModStart> left ; luaL_checkstack ( L , 1 , "in<S2SV_blank>function<S2SV_blank>mp_unpack_full" ) ;
<S2SV_ModStart> ) { int class = <S2SV_ModEnd> getClientTypeByName ( <S2SV_ModStart> ] ) ; if ( class <S2SV_ModStart> - 1 || class == CLIENT_TYPE_MASTER
<S2SV_ModStart> - 1 || class == CLIENT_TYPE_MASTER ) { err = "Unrecognized<S2SV_blank>client<S2SV_blank>limit<S2SV_blank>class:<S2SV_blank>the<S2SV_blank>user<S2SV_blank>specified<S2SV_blank>" "an<S2SV_blank>invalid<S2SV_blank>one,<S2SV_blank>or<S2SV_blank>\'master\'<S2SV_blank>which<S2SV_blank>has<S2SV_blank>no<S2SV_blank>buffer<S2SV_blank>limits." <S2SV_ModEnd> ; goto
<S2SV_ModStart> flags & ( CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP ) <S2SV_ModEnd> ) break
<S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> return ; sds prompt = sdsempty ( ) ; <S2SV_ModStart> NULL ) { prompt = sdscatfmt ( prompt , "redis<S2SV_blank>%s" , config . hostsocket ) ; } else { char addr [ 256 ] ; anetFormatAddr ( addr , sizeof ( addr ) , config . hostip , config . hostport ) ; prompt = sdscatlen ( prompt , addr , strlen ( addr ) ) ; } if ( config . dbnum != 0 ) prompt = sdscatfmt ( prompt , "[%i]" , config . dbnum ) ; prompt = sdscatlen ( prompt , "><S2SV_blank>" , 2 ) ; <S2SV_ModEnd> snprintf ( <S2SV_ModStart> ) , "%s" , prompt <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; sdsfree ( prompt <S2SV_ModEnd> ) ;
<S2SV_ModStart> == NULL || checkType ( c , o , OBJ_STREAM )
<S2SV_ModStart> 1 ) ; luaL_argcheck ( L , pos > 0 , 3 , "offset<S2SV_blank>must<S2SV_blank>be<S2SV_blank>1<S2SV_blank>or<S2SV_blank>greater" ) ; pos -- <S2SV_ModEnd> ; int <S2SV_ModStart> L , <S2SV_ModEnd> size <= <S2SV_ModStart> <= ld && pos <= ld - size , <S2SV_ModEnd> 2 ,
<S2SV_ModStart> = ( <S2SV_ModEnd> luaY_parser )
<S2SV_ModStart> APLOG_MARK , APLOG_DEBUG <S2SV_ModEnd> , 0 <S2SV_ModStart> ) ; if ( status == APR_ECONNRESET ) { ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , status , session -> c , "h2-stream(%ld-%d):<S2SV_blank>on_header,<S2SV_blank>reset<S2SV_blank>stream" , session -> id , stream -> id ) ; nghttp2_submit_rst_stream ( ngh2 , NGHTTP2_FLAG_NONE , stream -> id , NGHTTP2_INTERNAL_ERROR ) ; } else
<S2SV_ModStart> ) { int error = 0 ; <S2SV_ModStart> if ( <S2SV_ModEnd> stream -> <S2SV_ModStart> ) { return APR_EINVAL ; } ++ stream -> request_headers_added ; <S2SV_ModStart> ) ; error = HTTP_REQUEST_URI_TOO_LARGE <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 ) { if ( stream -> request_headers_added > stream -> session -> s -> limit_req_fields + 4 + 100 ) { return APR_ECONNRESET ; } ap_log_cerror ( APLOG_MARK , APLOG_TRACE1 , 0 , stream -> session -> c , "h2_stream(%ld-%d):<S2SV_blank>too<S2SV_blank>many<S2SV_blank>header<S2SV_blank>lines" , stream -> session -> id , stream -> id ) ; error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE ; } if ( h2_stream_is_scheduled ( stream ) ) { return add_trailer ( stream , name , nlen , value , vlen ) ; } else if ( error ) { <S2SV_ModStart> stream , error <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; SSL_set_verify ( ssl , verify_old , ssl_callback_SSLVerify ) ;
<S2SV_ModStart> ; const lua_authz_provider_func * prov_func = parsed_require_line ; const <S2SV_ModStart> prov_spec = prov_func -> spec <S2SV_ModEnd> ; int <S2SV_ModStart> if ( prov_func <S2SV_ModEnd> -> args <S2SV_ModStart> L , prov_func <S2SV_ModEnd> -> args <S2SV_ModStart> i < prov_func <S2SV_ModEnd> -> args <S2SV_ModStart> APR_ARRAY_IDX ( prov_func <S2SV_ModEnd> -> args <S2SV_ModStart> nargs = prov_func <S2SV_ModEnd> -> args
<S2SV_ModStart> * spec ; lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) <S2SV_ModStart> ) ; func -> spec = spec ; <S2SV_ModStart> arg ; func <S2SV_ModEnd> -> args <S2SV_ModStart> APR_ARRAY_PUSH ( func <S2SV_ModEnd> -> args <S2SV_ModStart> parsed_require_line = func <S2SV_ModEnd> ; return
<S2SV_ModStart> ; int do_read = 1 ; int <S2SV_ModStart> connection ) ; while ( do_read ) { do_read = 0 <S2SV_ModStart> ) ; do_read = 1 ; } <S2SV_ModEnd> } }
<S2SV_ModStart> 02555 ) "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;<S2SV_blank>" "using<S2SV_blank>read-until-close" <S2SV_ModEnd> , tenc <S2SV_ModStart> ; return APR_EINVAL <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; apr_brigade_cleanup ( bb ) ; <S2SV_ModStart> : case BODY_CHUNK_LF : case BODY_CHUNK_END : case BODY_CHUNK_END_LF <S2SV_ModEnd> : { <S2SV_ModStart> ) { return read_chunked_trailers ( ctx , f , b , conf -> merge_trailers <S2SV_ModEnd> == AP_MERGE_TRAILERS_ENABLE <S2SV_ModStart> == AP_MERGE_TRAILERS_ENABLE <S2SV_ModEnd> ) ; <S2SV_ModStart> : { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , f -> r , APLOGNO ( 02901 ) "Unexpected<S2SV_blank>body<S2SV_blank>state<S2SV_blank>(%i)" , ( int ) ctx -> state ) ; return APR_EGENERAL <S2SV_ModEnd> ; }
<S2SV_ModStart> == BODY_CHUNK_END || ctx -> state == BODY_CHUNK_END_LF <S2SV_ModStart> = BODY_CHUNK ; } else if ( c == CR && ctx -> state == BODY_CHUNK_END ) { ctx -> state = BODY_CHUNK_END_LF ; } else { return APR_EINVAL <S2SV_ModStart> { return APR_EINVAL <S2SV_ModEnd> ; } <S2SV_ModStart> sizeof ( apr_off_t <S2SV_ModEnd> ) * <S2SV_ModStart> c == LF ) { if ( ctx -> remaining ) { ctx -> state = BODY_CHUNK_DATA ; } else { ctx -> state = BODY_CHUNK_TRAILER ; } } else if ( ctx -> state == BODY_CHUNK_LF ) { return APR_EINVAL ; } else if ( c == CR ) { ctx -> state = BODY_CHUNK_LF ; } else if ( c == ';' <S2SV_ModEnd> ) { <S2SV_ModStart> if ( ctx -> state == BODY_CHUNK_EXT ) { if ( c != '\\t' && apr_iscntrl ( c ) ) { return APR_EINVAL ; } } else if ( ctx -> state == BODY_CHUNK_PART <S2SV_ModEnd> ) { <S2SV_ModStart> int xvalue <S2SV_ModEnd> ; if <S2SV_ModStart> ; continue ; } ctx -> chunkbits -= 4 ; if ( ctx -> chunkbits < 0 ) { return APR_ENOSPC <S2SV_ModStart> { return APR_EINVAL <S2SV_ModEnd> ; } <S2SV_ModStart> xvalue ; if ( <S2SV_ModEnd> ctx -> <S2SV_ModStart> ; } } else { return APR_EGENERAL ;
<S2SV_ModStart> ; } attr = ippFindAttribute ( con -> request , "requesting-user-name" , IPP_TAG_NAME ) ; if ( attr && ! ippValidateAttribute ( attr ) ) { send_ipp_status ( con , IPP_ATTRIBUTES , _ ( "Bad<S2SV_blank>requesting-user-name<S2SV_blank>value:<S2SV_blank>%s" ) , cupsLastErrorString ( ) ) ; if ( ( attr = ippCopyAttribute ( con -> response , attr , 0 ) ) != NULL ) attr -> group_tag = IPP_TAG_UNSUPPORTED_GROUP ; return ( NULL ) ; } <S2SV_ModStart> , job <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) || <S2SV_ModEnd> ! strcmp
<S2SV_ModStart> if ( caplentoobig ) { printf ( "\\n\\nCapture<S2SV_blank>file<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>damaged<S2SV_blank>or<S2SV_blank>corrupt.\\n" "Contains<S2SV_blank>packet<S2SV_blank>of<S2SV_blank>size<S2SV_blank>%u,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>snap<S2SV_blank>length<S2SV_blank>%u\\n" , caplen , pcap_fh . snaplen ) ; close ( fd ) ; break ; } if ( <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; }
<S2SV_ModStart> } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer
<S2SV_ModStart> ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; del_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table ) ;
<S2SV_ModStart> ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ;
<S2SV_ModStart> if ( anope_flags_compat && <S2SV_ModStart> if ( anope_flags_compat && <S2SV_ModStart> if ( anope_flags_compat &&
<S2SV_ModStart> ) && ( alloc > 2 ) &&
<S2SV_ModStart> char * cooke_domain <S2SV_ModEnd> , const <S2SV_ModStart> char * hostname <S2SV_ModEnd> ) { <S2SV_ModStart> { size_t cookie_domain_len <S2SV_ModEnd> = strlen <S2SV_ModStart> strlen ( cooke_domain <S2SV_ModEnd> ) ; <S2SV_ModStart> ; size_t hostname_len <S2SV_ModEnd> = strlen <S2SV_ModStart> strlen ( hostname <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( hostname_len < cookie_domain_len <S2SV_ModEnd> ) return <S2SV_ModStart> FALSE ; if ( ! <S2SV_ModEnd> Curl_raw_equal ( <S2SV_ModStart> Curl_raw_equal ( cooke_domain , hostname + hostname_len - cookie_domain_len ) ) return FALSE ; if ( hostname_len == cookie_domain_len ) return TRUE ; if ( '.' == * ( hostname + hostname_len - cookie_domain_len - 1 ) ) return TRUE ; return <S2SV_ModEnd> FALSE ;
<S2SV_ModStart> alloc ; size_t <S2SV_ModEnd> strindex =
<S2SV_ModStart> ) { char * str = NULL ; size_t inputlen = length ; size_t outputlen <S2SV_ModEnd> ; CURLcode <S2SV_ModStart> CURLcode res = Curl_urldecode <S2SV_ModEnd> ( handle <S2SV_ModStart> handle , string , inputlen , & str , & outputlen , FALSE <S2SV_ModEnd> ) ; <S2SV_ModStart> res ) <S2SV_ModEnd> return NULL <S2SV_ModStart> return NULL <S2SV_ModEnd> ; if <S2SV_ModStart> olen = curlx_uztosi ( outputlen ) <S2SV_ModEnd> ; return <S2SV_ModStart> ; return str <S2SV_ModEnd> ; }
<S2SV_ModStart> path ; <S2SV_ModEnd> if ( <S2SV_ModStart> "INBOX" ; return Curl_urldecode <S2SV_ModEnd> ( data <S2SV_ModStart> , & <S2SV_ModEnd> imapc -> <S2SV_ModStart> -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; }
<S2SV_ModStart> path ; return Curl_urldecode <S2SV_ModEnd> ( data <S2SV_ModStart> 0 , & <S2SV_ModEnd> pop3c -> <S2SV_ModStart> -> mailbox , NULL , TRUE ) <S2SV_ModEnd> ; }
<S2SV_ModStart> . path <S2SV_ModEnd> ; char <S2SV_ModStart> ; } result = Curl_urldecode ( conn -> data , path , 0 , & <S2SV_ModStart> -> domain , NULL , TRUE ) ; if ( result <S2SV_ModEnd> ) return <S2SV_ModStart> ) return result <S2SV_ModEnd> ; state
<S2SV_ModStart> ) ; if ( ! px -> ft ) { return FALSE ; }
<S2SV_ModStart> -> ft_in_start && bu
<S2SV_ModStart> strlen ( cp <S2SV_ModEnd> ) -
<S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> ) ; <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> / 512 <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } n = scsi_init_iovec ( r ) ; bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_READ ) ; r -> req . aiocb = bdrv_aio_readv ( s -> bs , r -> sector , <S2SV_ModEnd> & r <S2SV_ModStart> qiov , n , scsi_read_complete , r ) ; if ( <S2SV_ModEnd> r -> <S2SV_ModStart> . aiocb <S2SV_ModEnd> == NULL
<S2SV_ModStart> ; uint32_t <S2SV_ModEnd> n ; <S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> / 512 <S2SV_ModStart> else { scsi_init_iovec ( r ) <S2SV_ModEnd> ; DPRINTF <S2SV_ModStart> tag , r -> qiov . size <S2SV_ModEnd> ) ; <S2SV_ModStart> req , r -> qiov . size <S2SV_ModEnd> ) ;
<S2SV_ModStart> r -> qiov . size <S2SV_ModEnd> / 512 <S2SV_ModStart> ; } <S2SV_ModEnd> bdrv_acct_start (
<S2SV_ModStart> * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; <S2SV_ModEnd> uint8_t * <S2SV_ModStart> * outbuf ; int buflen = 0 ; if ( ! r -> iov . iov_base ) { if ( req -> cmd . xfer > 65536 ) { goto illegal_request ; } r -> buflen = MAX ( 4096 , req -> cmd . xfer ) ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } outbuf = r -> iov . iov_base <S2SV_ModEnd> ; switch
<S2SV_ModStart> ( r <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ; } }
<S2SV_ModStart> ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> 512 , r -> buflen <S2SV_ModEnd> ) ;
<S2SV_ModStart> req ; <S2SV_ModEnd> req = <S2SV_ModStart> ) ; <S2SV_ModEnd> return req
<S2SV_ModStart> command ; <S2SV_ModEnd> int rc <S2SV_ModStart> 0 ] <S2SV_ModEnd> ; DPRINTF <S2SV_ModStart> ( r <S2SV_ModEnd> ) ;
<S2SV_ModStart> blksize ; size_t <S2SV_ModEnd> blocks ; <S2SV_ModStart> ; } if ( blksize != 0 ) { <S2SV_ModStart> 1 ; } if ( size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0 ) { LOGE ( "invalid<S2SV_blank>data<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>file:<S2SV_blank>size<S2SV_blank>%zu,<S2SV_blank>blksize<S2SV_blank>%u,<S2SV_blank>range_count<S2SV_blank>%u\\n" , size , blksize , range_count ) ; return - 1 ; } <S2SV_ModStart> ranges = calloc ( range_count , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( pMap <S2SV_ModStart> -> ranges == NULL ) { LOGE ( "calloc(%u,<S2SV_blank>%zu)<S2SV_blank>failed:<S2SV_blank>%s\\n" , range_count , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> MappedRange ) , strerror ( errno ) ) ; return - 1 ; } <S2SV_ModEnd> unsigned char <S2SV_ModStart> ) ; free ( pMap -> ranges ) ; <S2SV_ModStart> - 1 ; } int fd = open ( block_dev , O_RDONLY ) ; if ( fd < 0 ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>block<S2SV_blank>device<S2SV_blank>%s:<S2SV_blank>%s\\n" , block_dev , strerror ( errno ) ) ; munmap ( reserve , blocks * blksize ) ; free ( pMap -> ranges ) ; return - 1 ; } unsigned char * next = reserve ; size_t remaining_size = blocks * blksize ; bool success = true ; for ( i = 0 ; i < range_count ; ++ i ) { size_t start , end ; if ( fscanf ( mapf , "%zu<S2SV_blank>%zu\\n" , & start , & end ) != 2 ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>range<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map\\n" , i ) ; success = false ; break ; } size_t length = ( end - start ) * blksize ; if ( end <= start || ( end - start ) > SIZE_MAX / blksize || length > remaining_size ) { LOGE ( "unexpected<S2SV_blank>range<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map:<S2SV_blank>%zu<S2SV_blank>%zu\\n" , start , end ) ; success = false ; break ; } void * addr = mmap64 ( next , length , PROT_READ , MAP_PRIVATE | MAP_FIXED , fd , ( ( off64_t ) start ) * blksize ) ; if ( addr == MAP_FAILED ) { LOGW ( "failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>block<S2SV_blank>%d:<S2SV_blank>%s\\n" , i , strerror ( errno ) ) ; success = false ; break <S2SV_ModStart> ranges [ i <S2SV_ModEnd> ] . <S2SV_ModStart> addr = addr <S2SV_ModEnd> ; pMap <S2SV_ModStart> ranges [ i <S2SV_ModEnd> ] . <S2SV_ModStart> length = length <S2SV_ModEnd> ; next <S2SV_ModStart> next += length ; remaining_size -= length ; } if ( success && remaining_size != 0 ) { LOGE ( "ranges<S2SV_blank>in<S2SV_blank>block<S2SV_blank>map<S2SV_blank>are<S2SV_blank>invalid:<S2SV_blank>remaining_size<S2SV_blank>=<S2SV_blank>%zu\\n" , remaining_size ) ; success = false ; } if ( ! success ) { close ( fd ) ; munmap ( reserve , blocks * blksize ) ; free ( <S2SV_ModStart> -> ranges ) ; return - 1 ; } close ( fd ) ; pMap -> addr = reserve ; pMap -> length <S2SV_ModEnd> = size
<S2SV_ModStart> ) ; if ( pMap -> ranges == NULL ) { LOGE ( "malloc<S2SV_blank>failed:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; munmap ( memPtr , length ) ; return - 1 ; }
<S2SV_ModStart> ) ; fclose ( mapf ) ;
<S2SV_ModStart> ; } Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * const stanza_from = xmpp_stanza_get_from ( stanza ) ; Jid * msg_jid = jid_create ( stanza_from ) ; if ( g_strcmp0 ( my_jid -> barejid , msg_jid -> barejid ) != 0 ) { log_warning ( "Invalid<S2SV_blank>carbon<S2SV_blank>received,<S2SV_blank>from:<S2SV_blank>%s" , stanza_from ) ; return TRUE ; } <S2SV_ModStart> ( to <S2SV_ModEnd> ) ;
<S2SV_ModStart> stbbr_send ( "<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>" <S2SV_ModEnd> "<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>" "<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"
<S2SV_ModStart> 0 ) { <S2SV_ModStart> space = 4 ; } else { const guint max_space = MIN ( G_MAXINT , G_MAXSIZE / MAX ( sizeof ( PangoGlyphInfo ) , sizeof ( gint ) ) ) ; guint more_space = ( guint ) <S2SV_ModEnd> string -> <S2SV_ModStart> -> space * <S2SV_ModEnd> 2 ; <S2SV_ModStart> if ( more_space > max_space <S2SV_ModEnd> ) { <S2SV_ModStart> ) { more_space = max_space ; if ( ( guint ) new_len > max_space ) { g_error ( "%s:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>glyph<S2SV_blank>string<S2SV_blank>of<S2SV_blank>length<S2SV_blank>%i\\n" , G_STRLOC , new_len <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; } } <S2SV_ModEnd> string -> <S2SV_ModStart> space = more_space <S2SV_ModEnd> ; }
<S2SV_ModStart> ; int result ; int <S2SV_ModStart> } } result = <S2SV_ModEnd> js_regexec ( <S2SV_ModStart> opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> { int result ; int <S2SV_ModStart> } } result = <S2SV_ModEnd> js_regexec ( <S2SV_ModStart> opts ) ; if ( result < 0 ) js_error ( J , "regexec<S2SV_blank>failed" ) ; if ( result == 0
<S2SV_ModStart> if ( js_doregexec ( J , <S2SV_ModEnd> re ->
<S2SV_ModStart> if ( js_doregexec ( J , <S2SV_ModEnd> re -> <S2SV_ModStart> ( ! js_doregexec ( J , <S2SV_ModEnd> re ->
<S2SV_ModStart> ( ! js_doregexec ( J , <S2SV_ModEnd> re ->
<S2SV_ModStart> if ( js_doregexec ( J , <S2SV_ModEnd> re -> <S2SV_ModStart> if ( js_doregexec ( J , <S2SV_ModEnd> re ->
<S2SV_ModStart> * out , int depth <S2SV_ModStart> ; int result ; int <S2SV_ModStart> c ; if ( depth > MAXREC ) return - 1 ; <S2SV_ModStart> : return 0 <S2SV_ModEnd> ; case <S2SV_ModStart> out ; result = <S2SV_ModEnd> match ( <S2SV_ModStart> & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 <S2SV_ModEnd> ) { <S2SV_ModStart> ; return 0 <S2SV_ModEnd> ; } <S2SV_ModStart> I_PLA : result = <S2SV_ModEnd> match ( <S2SV_ModStart> , out , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 1 ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> out ; result = <S2SV_ModEnd> match ( <S2SV_ModStart> & scratch , depth + 1 ) ; if ( result == - 1 ) return - 1 ; if ( result == 0 ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; if <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; if <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; if <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; if <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; } <S2SV_ModStart> } return 1 <S2SV_ModEnd> ; case <S2SV_ModStart> } return 1 <S2SV_ModEnd> ; case <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> ) return 1 <S2SV_ModEnd> ; pc <S2SV_ModStart> : return 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> ; return <S2SV_ModEnd> match ( <S2SV_ModStart> , sub , 0
<S2SV_ModStart> ) ; emit ( J , F , OP_ENDTRY ) ;
<S2SV_ModStart> buf [ 100 <S2SV_ModEnd> ] ; <S2SV_ModStart> "0123456789abcdefghijklmnopqrstuvwxyz" ; <S2SV_ModEnd> double number
<S2SV_ModStart> buf [ 50 <S2SV_ModEnd> ] ,
<S2SV_ModStart> , "Mixing<S2SV_blank>client<S2SV_blank>and<S2SV_blank>server<S2SV_blank>protocol" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { exit_client ( client_p , client_p , client_p , "Malformed<S2SV_blank>AUTHENTICATE"
<S2SV_ModStart> user ) || cherokee_buffer_is_empty ( & conn -> validator -> passwd )
<S2SV_ModStart> ; } if ( pattern [ end ] == 0 ) break ;
<S2SV_ModStart> Mymr_C_VIRAMA ; if ( len > 0 )
<S2SV_ModStart> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> dict ) && xmlDictOwns ( ctxt -> dict , value )
<S2SV_ModStart> if ( ctxt -> instate == XML_PARSER_EOF ) return ; if (
<S2SV_ModStart> ) ; if ( ctxt -> instate != XML_PARSER_EOF ) <S2SV_ModStart> ; } if ( <S2SV_ModStart> -> instate != XML_PARSER_EOF ) ctxt -> instate
<S2SV_ModStart> * window ; char * window_size_string = NULL <S2SV_ModStart> ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if (
<S2SV_ModStart> window , window_width , window_height <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { png_size_t <S2SV_ModEnd> copy = <S2SV_ModStart> if ( ( png_size_t ) <S2SV_ModStart> copy = ( png_size_t )
<S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pParse
<S2SV_ModStart> addModuleArgument ( Parse * pParse <S2SV_ModEnd> , Table <S2SV_ModStart> ) { sqlite3_int64 <S2SV_ModEnd> nBytes = <S2SV_ModStart> azModuleArg ; sqlite3 * db = pParse -> db ; if ( pTable -> nModuleArg + 3 >= db -> aLimit [ SQLITE_LIMIT_COLUMN ] ) { sqlite3ErrorMsg ( pParse , "too<S2SV_blank>many<S2SV_blank>columns<S2SV_blank>on<S2SV_blank>%s" , pTable -> zName ) ; }
<S2SV_ModStart> ifdef SQLITE_TEST_REALLOC_STRESS sqlite3_int64 <S2SV_ModEnd> nNew = <S2SV_ModStart> 512 ? 2 * ( sqlite3_int64 ) v -> nOpAlloc : ( sqlite3_int64 ) <S2SV_ModEnd> v -> <S2SV_ModStart> # else sqlite3_int64 <S2SV_ModEnd> nNew = <S2SV_ModStart> nOpAlloc ? 2 * ( sqlite3_int64 ) v -> nOpAlloc <S2SV_ModEnd> : ( <S2SV_ModStart> : ( sqlite3_int64 ) <S2SV_ModEnd> 1024 / <S2SV_ModStart> ( Op <S2SV_ModEnd> ) )
<S2SV_ModStart> aVTrans ; sqlite3_int64 <S2SV_ModEnd> nBytes = <S2SV_ModStart> * ( ( sqlite3_int64 )
<S2SV_ModStart> sz * ( sqlite3_int64 )
<S2SV_ModStart> z ; sqlite3_int64 <S2SV_ModEnd> n = <S2SV_ModStart> ) { sqlite3_int64 <S2SV_ModEnd> sz =
<S2SV_ModStart> 2 * ( sqlite3_int64 )
<S2SV_ModStart> pNew ; sqlite3_int64 nAlloc = 2 * ( sqlite3_int64 ) pSrc -> nSrc <S2SV_ModEnd> + nExtra
<S2SV_ModStart> ) { sqlite3_int64 <S2SV_ModEnd> nAlloc = <S2SV_ModStart> pIn ? 2 * ( sqlite3_int64 ) pIn [ 0 ] <S2SV_ModEnd> : 10
<S2SV_ModStart> aMemory ; sqlite3_int64 nNew = 2 * ( sqlite3_int64 ) <S2SV_ModEnd> pSorter -> <S2SV_ModStart> -> nMemory <S2SV_ModEnd> ; while
<S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTable <S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTable <S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTable
<S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTab <S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTab <S2SV_ModStart> addModuleArgument ( pParse <S2SV_ModEnd> , pTab
<S2SV_ModStart> ) { sqlite3_int64 <S2SV_ModEnd> nByte =
<S2SV_ModStart> aNew ; sqlite3_int64 <S2SV_ModEnd> nNew = <S2SV_ModStart> 128 , 2 * ( sqlite3_int64 ) <S2SV_ModStart> -> nAlloc <S2SV_ModEnd> ) ;
<S2SV_ModStart> pRet ; sqlite3_int64 <S2SV_ModEnd> nByte = <S2SV_ModStart> 2 * ( sqlite3_int64 ) <S2SV_ModStart> ) ; sqlite3_int64 <S2SV_ModEnd> nStr = <S2SV_ModStart> nStr = <S2SV_ModEnd> strlen ( <S2SV_ModStart> pRet = sqlite3_malloc64 <S2SV_ModEnd> ( nByte
<S2SV_ModStart> zInput = sqlite3_malloc64 <S2SV_ModEnd> ( nByte
<S2SV_ModStart> ) { sqlite3_int64 <S2SV_ModEnd> nNew = <S2SV_ModStart> * ) sqlite3_realloc64 <S2SV_ModEnd> ( (
<S2SV_ModStart> while ( ( len > 0 ) && ( <S2SV_ModStart> 0x20 ) )
<S2SV_ModStart> month - 1U <S2SV_ModEnd> ) % <S2SV_ModStart> month - 1U <S2SV_ModEnd> ) % <S2SV_ModStart> month - 1U <S2SV_ModEnd> ) %
<S2SV_ModStart> ) PNG_STRING_NEWLINE "libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015" PNG_STRING_NEWLINE "Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson" <S2SV_ModEnd> PNG_STRING_NEWLINE "Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger" <S2SV_ModStart> png_charp ) "libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc." <S2SV_ModEnd> ) ;
<S2SV_ModStart> info_ptr ; if ( info_ptr == NULL ) return ;
<S2SV_ModStart> png_structp p ; png_uint_32 save_flags ; png_uint_32 num_bytes ; if ( png_ptr == NULL ) return ( NULL ) ; p <S2SV_ModStart> png_ptr ; <S2SV_ModEnd> save_flags = <S2SV_ModStart> -> flags <S2SV_ModEnd> ; if
<S2SV_ModStart> if ( ctxt -> error ) return ; if (
<S2SV_ModStart> buffer , i +
<S2SV_ModStart> xmlNodePtr cur = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart> ) { <S2SV_ModEnd> xmlNodeSetPtr nodelist <S2SV_ModStart> ; } <S2SV_ModEnd> } else <S2SV_ModStart> ; } if ( obj ) xmlXPathFreeObject ( obj ) ;
<S2SV_ModStart> ( split_flag && size >= MIN_BLOCK_SIZE
<S2SV_ModStart> , stream ) ; decoder_info -> log2_sb_size = clip ( decoder_info -> log2_sb_size , log2i ( MIN_BLOCK_SIZE ) , log2i ( MAX_SB_SIZE )
<S2SV_ModStart> if ( ( len > 12 ) && <S2SV_ModStart> if ( ( len > 9 ) &&
<S2SV_ModStart> ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { <S2SV_ModStart> LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { <S2SV_ModStart> LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( ! valid_hex ( job_id ) <S2SV_ModEnd> || ! <S2SV_ModStart> || ! valid_hex ( prev_hash ) <S2SV_ModEnd> || ! <S2SV_ModStart> || ! valid_hex ( coinbase1 ) || ! valid_hex ( coinbase2 ) <S2SV_ModEnd> || ! <S2SV_ModStart> || ! valid_hex ( bbversion ) <S2SV_ModEnd> || ! <S2SV_ModStart> || ! valid_hex ( nbit ) || ! valid_hex ( <S2SV_ModEnd> ntime ) <S2SV_ModStart> ntime ) ) { free <S2SV_ModEnd> ( job_id <S2SV_ModStart> job_id ) ; <S2SV_ModStart> free ( <S2SV_ModEnd> coinbase1 ) <S2SV_ModStart> coinbase1 ) ; <S2SV_ModEnd> free (
<S2SV_ModStart> stratum_port ; snprintf ( address , 254 <S2SV_ModEnd> , "%s:%s"
<S2SV_ModStart> pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> pkg_length ; buffer_size -= ( size_t ) pkg_length ; <S2SV_ModStart> pkg_length ; buffer_size -= ( size_t ) pkg_length ;
<S2SV_ModStart> ( "snmp<S2SV_blank>plugin:<S2SV_blank>all<S2SV_blank>variables<S2SV_blank>have<S2SV_blank>left<S2SV_blank>their<S2SV_blank>subtree" ) ; snmp_free_pdu ( req <S2SV_ModStart> NULL ; <S2SV_ModEnd> sfree ( <S2SV_ModStart> if ( <S2SV_ModEnd> status ==
<S2SV_ModStart> size < 5 + 1 <S2SV_ModEnd> ) ASSERT <S2SV_ModStart> ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , "DEADBEEF" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , "%2.0f" , 1.6314159265358979e+125 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , "163141592653589790215729350939528493057529598899734151772468186268423257777068536614838678161083520756952076273094236944990208" ) == 0 ) ; ASSERT ( length == 126 ) ; if ( size < 126 + 1 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & "DEADBEEF" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; }
<S2SV_ModStart> data = instance -> private_key <S2SV_ModEnd> ; hash_param <S2SV_ModStart> len = instance -> private_key_len <S2SV_ModEnd> ; hash_slot
<S2SV_ModStart> * ptr && ptr [ 1 ]
<S2SV_ModStart> ) { if ( width >= ( long ) sizeof ( work ) ) width = sizeof ( work ) - 1 ; <S2SV_ModStart> ) { size_t maxprec = sizeof ( work ) - 2 ; double val = p -> data . dnum ; while ( val >= 10.0 ) { val /= 10 ; maxprec -- ; } if ( prec > ( long ) maxprec ) prec = maxprec - 1 ; <S2SV_ModStart> ) ; # ifdef CURLDEBUG assert ( strlen ( work ) <= sizeof ( work ) ) ; # endif
<S2SV_ModStart> ) ; errors += test_float_formatting ( ) ;
<S2SV_ModStart> multi_easy ) { <S2SV_ModStart> ) ; data -> multi_easy = NULL ; }
<S2SV_ModStart> 2 * UPLOAD_BUFSIZE <S2SV_ModEnd> ) ; <S2SV_ModStart> } } DEBUGASSERT ( UPLOAD_BUFSIZE >= nread ) ;
<S2SV_ModStart> -= cut + 1
<S2SV_ModStart> SIZE_T_MAX / 4 <S2SV_ModEnd> ) ||
<S2SV_ModStart> ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> if ( ! imapd_userisadmin ) goto badcmd ; if ( <S2SV_ModStart> ) { if ( ! imapd_userisadmin ) goto badcmd ;
<S2SV_ModStart> * base <S2SV_ModEnd> = isarchive <S2SV_ModStart> ) ; <S2SV_ModEnd> assert (
<S2SV_ModStart> ( prefixlen <= <S2SV_ModEnd> len )
<S2SV_ModStart> ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> ) ; raptor_sax2_set_option ( rss_parser -> sax2 , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES ) ) ;
<S2SV_ModStart> : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
<S2SV_ModStart> case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling
<S2SV_ModStart> case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId <S2SV_ModStart> NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling :
<S2SV_ModStart> NPNVPluginElementNPObject : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling :
<S2SV_ModStart> ) ; _ ( NPNVprivateModeBool ) ; _ ( NPNVsupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> ) ; _ ( NPPVpluginUrlRequestsDisplayedBool ) ; _ ( NPPVpluginWantsAllNetworkStreams ) ; _ ( NPPVpluginNativeAccessibleAtkPlugId ) ; _ ( NPPVpluginCancelSrcStream ) ; _ ( NPPVSupportsAdvancedKeyHandling ) ;
<S2SV_ModStart> i ; if ( ! config -> sample_rate ) { strcpy ( wpc -> error_message , "sample<S2SV_blank>rate<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>zero!" ) ; return FALSE ; }
<S2SV_ModStart> , got_ds64 = 0 , format_chunk <S2SV_ModStart> format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> WaveHeader ; int format_chunk = 0 ; <S2SV_ModStart> format ; if ( format_chunk ++ ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> uint32_t bcount ; CLEAR ( WaveHeader )
<S2SV_ModStart> char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total" , ( int ) dff_chunk_header . ckDataSize ) ;
<S2SV_ModStart> ( bytecnt >= 2 <S2SV_ModStart> ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
<S2SV_ModStart> uint16_t numChannels = 0 <S2SV_ModStart> < 1 || numChannels > 256 <S2SV_ModStart> ) { if ( ! config -> num_channels ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff
<S2SV_ModStart> char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> * caf_channel_layout <S2SV_ModEnd> ; if <S2SV_ModStart> ) || caf_chunk_header . mChunkSize > 1024 ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( <S2SV_ModStart> else { uint32_t <S2SV_ModEnd> bytes_to_copy = <S2SV_ModStart> char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; }
<S2SV_ModStart> * dp <S2SV_ModEnd> != ( <S2SV_ModStart> ) || dp [ 1 ] <S2SV_ModEnd> != ( <S2SV_ModStart> ) || dp [ 2 ] <S2SV_ModEnd> != ( <S2SV_ModStart> ) || dp [ 3 ] <S2SV_ModEnd> != ( <S2SV_ModStart> * dp <S2SV_ModEnd> != ( <S2SV_ModStart> ) || dp [ 1 ] <S2SV_ModEnd> != (
<S2SV_ModStart> uint32_t sampleRate = 0 <S2SV_ModStart> -> num_channels || ! config -> sample_rate
<S2SV_ModStart> ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & <S2SV_ModStart> bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { <S2SV_ModStart> ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) )
<S2SV_ModStart> = 1 , table_length = 0 <S2SV_ModStart> DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ) ; <S2SV_ModEnd> total_riff_bytes += <S2SV_ModStart> total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModStart> ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , "dmmy" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk
<S2SV_ModStart> uint32_t chan_chunk = 0 , desc_chunk <S2SV_ModStart> CAFAudioFormatFormat ) ; desc_chunk = 1 <S2SV_ModStart> ( ! desc_chunk || !
<S2SV_ModStart> ; static size_t <S2SV_ModEnd> len =
<S2SV_ModStart> str [ j <S2SV_ModEnd> ] ;
<S2SV_ModStart> if ( strlen ( token ) > 4 &&
<S2SV_ModStart> res ; clist * list ; <S2SV_ModStart> = r ; goto free_display_name ; } list = clist_new ( ) ; if ( list == NULL ) { res = MAILIMF_ERROR_MEMORY ; goto free_display_name ; } mailbox_list = mailimf_mailbox_list_new ( list ) ; if ( mailbox_list == NULL ) { res = MAILIMF_ERROR_MEMORY ; clist_free ( list )
<S2SV_ModStart> -> clusters + <S2SV_ModEnd> 1 )
<S2SV_ModStart> printf ( "%10lld<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>FAT<S2SV_blank>(=<S2SV_blank>%llu<S2SV_blank>sectors)\\n" , ( long long ) <S2SV_ModEnd> fs -> <S2SV_ModStart> fat_size , ( long long )
<S2SV_ModStart> sectors ; off_t <S2SV_ModEnd> fat_length ; <S2SV_ModStart> ) ; if ( ! fat_length ) die ( "FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero." ) ; <S2SV_ModStart> -> data_start ; if ( data_size < fs -> cluster_size ) die ( "Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters" )
<S2SV_ModStart> security_options . acl_file = config -> default_listener . security_options . acl_file ; config -> listeners [ config -> listener_count - 1 ] . security_options .
<S2SV_ModStart> , NULL ) ; gss_release_buffer ( & min , & in <S2SV_ModStart> ; } gss_release_buffer ( & min , & out ) ;
<S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto bail <S2SV_ModEnd> ; } <S2SV_ModStart> 2 ; bail : free ( tmpbuf ) ; tmpbuf = NULL ; return - 1 ;
<S2SV_ModStart> dname = safe_calloc <S2SV_ModEnd> ( strlen
<S2SV_ModStart> new_fname = safe_calloc <S2SV_ModEnd> ( strlen
<S2SV_ModStart> ascii = safe_calloc <S2SV_ModEnd> ( strlen <S2SV_ModStart> ascii = safe_calloc <S2SV_ModEnd> ( str_len
<S2SV_ModStart> ) { <S2SV_ModEnd> char * <S2SV_ModStart> * header = safe_calloc ( <S2SV_ModEnd> 1024 ) <S2SV_ModStart> ) ; long
<S2SV_ModStart> data = safe_calloc ( <S2SV_ModEnd> blk_sz *
<S2SV_ModStart> entries = safe_calloc ( <S2SV_ModEnd> xref ->
<S2SV_ModStart> daddy = safe_calloc <S2SV_ModEnd> ( sizeof
<S2SV_ModStart> buf = safe_calloc <S2SV_ModEnd> ( sz
<S2SV_ModStart> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof (
<S2SV_ModStart> pdf = safe_calloc ( <S2SV_ModEnd> sizeof ( <S2SV_ModStart> name = safe_calloc <S2SV_ModEnd> ( strlen <S2SV_ModStart> name = safe_calloc <S2SV_ModEnd> ( strlen
<S2SV_ModStart> dst_name = safe_calloc <S2SV_ModEnd> ( strlen
<S2SV_ModStart> port , server -> connrec -> address ,
<S2SV_ModStart> ssize_t count ; if ( bytes == 0 || items == 0 ) return 0
<S2SV_ModStart> 30 ; if ( rsrc . map_offset + 28 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>map<S2SV_blank>offset.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; <S2SV_ModStart> ) { if ( <S2SV_ModEnd> rsrc . <S2SV_ModStart> * 8 > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>rsrc<S2SV_blank>marker.\\n" ) ; goto parse_rsrc_fork_cleanup ; } ; marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8
<S2SV_ModStart> 10 ; if ( psf -> fileoffset < psf -> filelength ) { <S2SV_ModStart> } ; } ;
<S2SV_ModStart> chanmap_size = SF_MIN ( <S2SV_ModStart> . channels , layout_tag & 0xffff )
<S2SV_ModStart> ) { espruino_snprintf <S2SV_ModEnd> ( str <S2SV_ModStart> str , len , "ID:%s" <S2SV_ModEnd> , jslGetTokenValueAsString <S2SV_ModStart> ( ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { espruino_snprintf <S2SV_ModEnd> ( str <S2SV_ModStart> str , len , "String:\'%s\'" <S2SV_ModEnd> , jslGetTokenValueAsString <S2SV_ModStart> ( ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; espruino_snprintf ( str , len , "?[%d]" , token <S2SV_ModEnd> ) ;
<S2SV_ModStart> else { strcpy <S2SV_ModEnd> ( result <S2SV_ModStart> , "undefined" <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { assert ( len > 9 ) ; <S2SV_ModStart> ) ) strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "NaN" <S2SV_ModEnd> ) ; <S2SV_ModStart> 0 ) strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "-Infinity" <S2SV_ModEnd> ) ; <S2SV_ModStart> ; else strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "Infinity" <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; else { jsExceptionHere ( JSET_ERROR , <S2SV_ModEnd> "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) <S2SV_ModStart> ) ; return 0 ; } if ( gfx . data . height & 7 ) { jsExceptionHere ( JSET_ERROR , "height<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8<S2SV_blank>when<S2SV_blank>using<S2SV_blank>vertical_byte\\n" ) ; return 0 ; }
<S2SV_ModStart> idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
<S2SV_ModStart> ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count
<S2SV_ModStart> ) { assert ( len > 28 ) ; <S2SV_ModStart> LEX_EOF : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "EOF" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_ID : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "ID" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_INT : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "INT" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_FLOAT : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "FLOAT" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_STR : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "STRING" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_UNFINISHED_STR : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "UNFINISHED<S2SV_blank>STRING" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_UNFINISHED_TEMPLATE_LITERAL : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_REGEX : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "REGEX" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_UNFINISHED_REGEX : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "UNFINISHED<S2SV_blank>REGEX" <S2SV_ModEnd> ) ; <S2SV_ModStart> LEX_UNFINISHED_COMMENT : strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> , "UNFINISHED<S2SV_blank>COMMENT" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; strcpy <S2SV_ModEnd> ( str <S2SV_ModStart> p ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> espruino_snprintf (
<S2SV_ModStart> if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if ( <S2SV_ModStart> if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) return exit_client ( cptr , sptr , sptr , "Malformed<S2SV_blank>AUTHENTICATE" ) ; if (
<S2SV_ModStart> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec
<S2SV_ModStart> if ( <S2SV_ModEnd> i_status !=
<S2SV_ModStart> } } <S2SV_ModEnd> } else
<S2SV_ModStart> u1_first_slice_in_stream && <S2SV_ModEnd> ps_dec -> <S2SV_ModStart> -> u4_first_slice_in_pic <S2SV_ModEnd> ) { <S2SV_ModStart> -> u4_first_slice_in_pic == 0 <S2SV_ModEnd> ) { <S2SV_ModStart> -> u4_first_slice_in_pic <S2SV_ModEnd> ) { <S2SV_ModStart> else { <S2SV_ModEnd> prev_slice_err = <S2SV_ModStart> prev_slice_err = 2 <S2SV_ModEnd> ; num_mb_skipped <S2SV_ModStart> num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( <S2SV_ModStart> << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) <S2SV_ModEnd> { prev_slice_err <S2SV_ModStart> num_mb_skipped = <S2SV_ModEnd> ( u2_first_mb_in_slice <S2SV_ModStart> u1_mbaff ) - <S2SV_ModEnd> ps_dec -> <S2SV_ModStart> -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( <S2SV_ModEnd> ( u2_first_mb_in_slice <S2SV_ModStart> u1_mbaff ) <S2SV_ModEnd> < ps_dec <S2SV_ModStart> -> u4_first_slice_in_pic <S2SV_ModEnd> ) { <S2SV_ModStart> -> u4_first_slice_in_pic <S2SV_ModEnd> ) { <S2SV_ModStart> ps_dec -> <S2SV_ModEnd> u1_first_slice_in_stream =
<S2SV_ModStart> pu4_wts_ofsts_mat ; ps_dec -> u4_first_slice_in_pic = 0 ;
<S2SV_ModStart> = 2 ; ps_dec -> u1_first_pb_nal_in_pic = 1
<S2SV_ModStart> WORD32 ret <S2SV_ModEnd> ; ps_dec
<S2SV_ModStart> , buf_size - 8
<S2SV_ModStart> ; } if ( ( u2_pic_wd << ps_seq -> u1_mb_aff_flag ) > H264_MAX_FRAME_WIDTH ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; }
<S2SV_ModStart> , u1_seq_parameter_set_id , u1_mb_aff_flag = 0 <S2SV_ModStart> u1_frm ) u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ( ps_dec -> i4_header_decoded & 1 ) && ( ps_seq -> u1_mb_aff_flag != u1_mb_aff_flag ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ! u1_frm ) <S2SV_ModStart> u1_mb_aff_flag = u1_mb_aff_flag <S2SV_ModEnd> ; COPYTHECONTEXT
<S2SV_ModStart> 1 ; <S2SV_ModEnd> ps_dec -> <S2SV_ModStart> ) ; <S2SV_ModEnd> } if <S2SV_ModStart> } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } }
<S2SV_ModStart> ret ; UNUSED ( u1_is_idr_slice ) ; <S2SV_ModStart> u2_frame_num ; <S2SV_ModEnd> { WORD32
<S2SV_ModStart> * ps_dec <S2SV_ModEnd> ) { <S2SV_ModStart> WORD32 ret <S2SV_ModEnd> ; { <S2SV_ModStart> ret ; <S2SV_ModEnd> H264_MUTEX_UNLOCK (
<S2SV_ModStart> ( ! ps_dec -> u1_first_slice_in_stream && ( ps_dec -> u4_first_slice_in_pic == 2 ) ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! <S2SV_ModStart> ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } <S2SV_ModStart> 0 ; <S2SV_ModEnd> if (
<S2SV_ModStart> } u1_num_mbs <S2SV_ModEnd> ++ ; <S2SV_ModStart> ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> ++ ; <S2SV_ModEnd> u1_num_mbs_next = <S2SV_ModStart> ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ <S2SV_ModStart> ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ <S2SV_ModStart> ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ <S2SV_ModStart> ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
<S2SV_ModStart> ) { ih264d_create_ip_t * ps_create_ip ; <S2SV_ModStart> WORD32 ret ; ps_create_ip = ( ih264d_create_ip_t * ) pv_api_ip <S2SV_ModStart> 0 ; dec_hdl = NULL ; <S2SV_ModStart> if ( <S2SV_ModEnd> IV_FAIL == <S2SV_ModStart> ret ) { if ( <S2SV_ModEnd> dec_hdl ) <S2SV_ModStart> dec_hdl ) { if ( dec_hdl -> pv_codec_handle <S2SV_ModStart> ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , dec_hdl ) ; } }
<S2SV_ModStart> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps =
<S2SV_ModStart> ps_dpb_cmds = & ( ps_dec -> s_dpb_cmds_scratch ) <S2SV_ModEnd> ; dec_slice_params_t
<S2SV_ModStart> ret ; if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } }
<S2SV_ModStart> 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ;
<S2SV_ModStart> ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; <S2SV_ModEnd> break ; <S2SV_ModStart> ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T )
<S2SV_ModStart> ) ; if ( ! uc_more_data_flag && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> ) ; if ( ! uc_more_data_flag && ! i2_mb_skip_run && ( 0 == ( i2_cur_mb_addr & 1 ) ) ) { return ERROR_EOB_FLUSHBITS_T ; }
<S2SV_ModStart> i1_is_end_of_poc = 1 ; <S2SV_ModEnd> ps_dec -> <S2SV_ModStart> MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_ModEnd> } u1_mbaff
<S2SV_ModStart> ) { if ( j >= MAX_REF_BUFS ) { ALOGE ( "b/25818142" ) ; android_errorWriteLog ( 0x534e4554 , "25818142" ) ; ps_dpb_cmds -> u1_num_of_commands = 0 ; return - 1 ; }
<S2SV_ModStart> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm
<S2SV_ModStart> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_dec
<S2SV_ModStart> u1_dpb_commands_read ) { i_temp = ih264d_read_mmco_commands ( ps_dec ) ; if ( i_temp < 0 ) { return ERROR_DBP_MANAGER_T ; } <S2SV_ModStart> u4_bitoffset = i_temp ; } <S2SV_ModEnd> else ps_bitstrm
<S2SV_ModStart> { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; }
<S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT <S2SV_ModStart> { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } <S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; if <S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u2_frame_num <S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT <S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; s_tmp_poc <S2SV_ModStart> ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u1_redundant_pic_cnt
<S2SV_ModStart> ; } i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ; <S2SV_ModStart> ; } i1_intra_pred = CLIP3 ( 0 , 8 , i1_intra_pred ) ;
<S2SV_ModStart> -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk
<S2SV_ModStart> ) ; if ( ( ps_dec -> u2_total_mbs_coded != 0 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; }
<S2SV_ModStart> } } ps_dec -> u4_first_slice_in_pic = 0 ; <S2SV_ModStart> ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; <S2SV_ModStart> ++ ; } <S2SV_ModEnd> ps_dec ->
<S2SV_ModStart> 0 ) { <S2SV_ModStart> ++ ; ps_dec -> u2_cur_slice_num ++ ; } <S2SV_ModStart> ps_dec -> <S2SV_ModEnd> i2_prev_slice_mbx =
<S2SV_ModStart> ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> <S2SV_ModStart> ps_dec -> <S2SV_ModEnd> u2_cur_slice_num_dec_thread =
<S2SV_ModStart> ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ;
<S2SV_ModStart> ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ;
<S2SV_ModStart> ; WORD16 ai2_level_arr [ 7 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ;
<S2SV_ModStart> ) ; memset ( ps_dec -> ps_cur_slice , 0 , sizeof ( dec_slice_params_t ) ) ;
<S2SV_ModStart> ps_cur_slice -> <S2SV_ModEnd> u1_slice_type =
<S2SV_ModStart> ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ;
<S2SV_ModStart> pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; }
<S2SV_ModStart> ; { ps_dec -> ps_cur_slice -> u1_bottom_field_flag = 0 ; ps_dec -> ps_cur_slice -> u1_field_pic_flag = 0 ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; <S2SV_ModStart> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ;
<S2SV_ModStart> ; } <S2SV_ModEnd> if (
<S2SV_ModStart> 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ;
<S2SV_ModStart> , size + EXTRA_BS_OFFSET
<S2SV_ModStart> == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> == u4_bits && ! EXCEED_OFFSET ( ps_bitstrm ) <S2SV_ModStart> == ih264d_check_byte_aligned ( ps_bitstrm ) && ! EXCEED_OFFSET
<S2SV_ModStart> * ps_cur_poc ; WORD32 size ; size = sizeof ( pred_info_t ) * 2 * 32 ; memset ( ps_dec -> ps_pred , 0 , size ) ; size = sizeof ( disp_mgr_t ) ; memset ( ps_dec -> pv_disp_buf_mgr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_pic_buf_mgr , 0 , size ) ; size = sizeof ( dec_err_status_t ) ; memset ( ps_dec -> ps_dec_err_status , 0 , size ) ; size = sizeof ( sei ) ; memset ( ps_dec -> ps_sei , 0 , size ) ; size = sizeof ( dpb_commands_t ) ; memset ( ps_dec -> ps_dpb_cmds , 0 , size ) ; size = sizeof ( dec_bit_stream_t ) ; memset ( ps_dec -> ps_bitstrm , 0 , size ) ; size = sizeof ( dec_slice_params_t ) ; memset ( ps_dec -> ps_cur_slice , 0 , size ) ; size = MAX ( sizeof ( dec_seq_params_t ) , sizeof ( dec_pic_params_t ) ) ; memset ( ps_dec -> pv_scratch_sps_pps , 0 , size ) ; size = sizeof ( ctxt_inc_mb_info_t ) ; memset ( ps_dec -> ps_left_mb_ctxt_info , 0 , size ) ; size = ( sizeof ( neighbouradd_t ) << 2 ) ; memset ( ps_dec -> ps_left_mvpred_addr , 0 , size ) ; size = sizeof ( buf_mgr_t ) + ithread_get_mutex_lock_size ( ) ; memset ( ps_dec -> pv_mv_buf_mgr , 0 , size )
<S2SV_ModStart> 0 ; <S2SV_ModEnd> { ps_dec
<S2SV_ModStart> ( bin && ( numones <= 16 ) <S2SV_ModStart> -= 1 <S2SV_ModEnd> ; if
<S2SV_ModStart> ; } if ( cu_qp_delta_abs < MIN_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) || cu_qp_delta_abs > MAX_CU_QP_DELTA_ABS ( ps_sps -> i1_bit_depth_luma_minus8 ) ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> 1 ; if ( ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] > MAX_DPB_SIZE ) { return IHEVCD_INVALID_PARAMETER ; } <S2SV_ModStart> value ; if ( ps_sps -> ai1_sps_max_num_reorder_pics [ i ] > ps_sps -> ai1_sps_max_dec_pic_buffering [ i ] ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
<S2SV_ModStart> { WORD32 <S2SV_ModEnd> tu_coeff_data_reset_size ; <S2SV_ModStart> tu_coeff_data_reset_size ; <S2SV_ModEnd> ps_codec -> <S2SV_ModStart> = i4_pic_pu_idx <S2SV_ModEnd> ; tu_coeff_data_reset_size <S2SV_ModStart> pu1_tu_coeff_data ; ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> ; ps_codec <S2SV_ModStart> else { ihevcd_set_ctb_skip ( ps_codec ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { ihevcd_cxa_create_ip_t * ps_create_ip ; <S2SV_ModStart> ps_codec ; ps_create_ip = ( ihevcd_cxa_create_ip_t * ) pv_api_ip ; <S2SV_ModStart> 0 ; ps_codec_obj = NULL ; <S2SV_ModStart> ; if <S2SV_ModEnd> ( IV_FAIL <S2SV_ModStart> ret ) { if <S2SV_ModEnd> ( NULL <S2SV_ModStart> ps_codec_obj ) { if ( ps_codec_obj -> pv_codec_handle <S2SV_ModStart> ) ; } else { void ( * pf_aligned_free ) ( void * pv_mem_ctxt , void * pv_buf ) ; void * pv_mem_ctxt ; pf_aligned_free = ps_create_ip -> s_ivd_create_ip_t . pf_aligned_free ; pv_mem_ctxt = ps_create_ip -> s_ivd_create_ip_t . pv_mem_ctxt ; pf_aligned_free ( pv_mem_ctxt , ps_codec_obj ) ; } }
<S2SV_ModStart> ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) { return IHEVCD_INVALID_PARAMETER ; }
<S2SV_ModStart> WORD32 slice_address ; WORD32 prev_slice_incomplete_flag = 0 <S2SV_ModStart> ) { prev_slice_incomplete_flag = 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; prev_slice_incomplete_flag = 1 ; ASSERT ( ps_codec -> s_parse . i4_cur_slice_idx == 1 ) <S2SV_ModEnd> ; ps_slice_hdr_prev <S2SV_ModStart> } } if ( prev_slice_incomplete_flag ) { ps_codec -> i4_slice_error = 1 ; ps_codec -> s_parse . i4_cur_slice_idx -- ; if ( ps_codec -> s_parse . i4_cur_slice_idx < 0 ) ps_codec -> s_parse . i4_cur_slice_idx = 0 ; }
<S2SV_ModStart> ps_codec -> <S2SV_ModEnd> pu1_inp_bitsbuf +=
<S2SV_ModStart> WORD32 i , j <S2SV_ModStart> for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) <S2SV_ModStart> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF
<S2SV_ModStart> WORD32 i , j <S2SV_ModStart> for ( j = 0 ; j < ps_codec -> i4_max_dpb_size ; j <S2SV_ModEnd> ++ ) <S2SV_ModStart> pv_mv_buf_mgr , j <S2SV_ModEnd> , BUF_MGR_REF
<S2SV_ModStart> ++ ; ps_codec -> i4_max_dpb_size = max_dpb_size ;
<S2SV_ModStart> 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> ) ; } <S2SV_ModStart> 1 ; if ( ps_parse -> s_sei_params . i4_sei_user_data_cnt >= USER_DATA_MAX ) { for ( i = 0 ; i < u4_payload_size / 4 ; i ++ ) { ihevcd_bits_flush ( ps_bitstrm , 4 * 8 ) ; } ihevcd_bits_flush ( ps_bitstrm , ( u4_payload_size - i * 4 ) * 8 ) ; } else { <S2SV_ModStart> ) ; }
<S2SV_ModStart> else { ret = <S2SV_ModStart> ) ; if ( ( WORD32 ) IHEVCD_SUCCESS != ret ) { return ret ; }
<S2SV_ModStart> ps_codec -> s_parse . i4_cur_slice_idx = MAX ( 0 , ( ps_codec -> s_parse . i4_cur_slice_idx - 1 ) ) ; ps_codec ->
<S2SV_ModStart> ) ; if ( ps_cabac -> u4_ofst >= ps_cabac -> u4_range ) { return ( ( IHEVCD_ERROR_T ) IHEVCD_FAIL ) ; }
<S2SV_ModStart> ) { ret = <S2SV_ModStart> ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> } { ret = <S2SV_ModStart> ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ) { ret = <S2SV_ModStart> ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> else { ret = <S2SV_ModStart> ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> ) ; ps_codec -> i4_slice_error = 0 ;
<S2SV_ModStart> ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> i1_num_tile_columns > max_tile_cols <S2SV_ModEnd> ) || <S2SV_ModStart> i1_num_tile_rows > max_tile_rows <S2SV_ModEnd> ) )
<S2SV_ModStart> u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; } <S2SV_ModStart> u4_sym_len ) lead_zeros = CLZ ( u4_bits ) - 15 ; if ( lead_zeros > 11 ) { return IMPEG2D_MB_DATA_DECODE_ERR ; }
<S2SV_ModStart> ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
<S2SV_ModStart> ps_dec -> u2_forw_f_code = 7 ; ps_dec -> u2_back_f_code = 7 ; ps_dec ->
<S2SV_ModStart> u4_y_offset ; WORD32 ret ; <S2SV_ModStart> B_PIC ) ret = <S2SV_ModStart> ; else ret = <S2SV_ModStart> ps_dec ) ; if ( ret ) return IMPEG2D_MB_TEX_DECODE_ERR
<S2SV_ModStart> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_p_mb_params ( <S2SV_ModStart> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> } } return 0 ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> WORD32 <S2SV_ModEnd> impeg2d_dec_pnb_mb_params ( <S2SV_ModStart> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> s_mb_type ; if ( NULL == ps_dec_mb_params -> pf_func_mb_params ) return - 1 ; <S2SV_ModStart> } } return 0 ;
<S2SV_ModStart> IMPEG2D_MB_TEX_DECODE_ERR ; if ( 0 >= ps_dec -> u2_num_mbs_left ) { break ; }
<S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ; } } IBITS_GET ( u4_buf , u4_buf_nxt , u4_offset , u4_bits , pu4_buf_aligned , u4_sym_len ) <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> IMPEG2D_MB_TEX_DECODE_ERR ; }
<S2SV_ModStart> ) && ( <S2SV_ModStart> > 0 ) && ( 1 == ps_dec_state -> u2_header_done )
<S2SV_ModStart> IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = ps_dec -> u2_vertical_size ; ps_dec -> u2_reinit_max_width = ps_dec -> u2_horizontal_size ; return e_error <S2SV_ModEnd> ; }
<S2SV_ModStart> e_error ; if ( IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec -> u2_header_done = 0 ; ps_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec -> u2_reinit_max_height ; ps_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec -> u2_reinit_max_width ; }
<S2SV_ModStart> if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , "26070014" ) ; } if (
<S2SV_ModStart> ( i4_prev_row < <S2SV_ModEnd> i4_row ) <S2SV_ModStart> ; } else if ( i4_prev_row > i4_row ) { android_errorWriteLog ( 0x534e4554 , "26070014" ) ; }
<S2SV_ModStart> u2_height ; } else { <S2SV_ModStart> ps_dec -> i4_pic_count ) { return ( IMPEG2D_ERROR_CODES_T ) IMPEG2D_FRM_HDR_DECODE_ERR ; <S2SV_ModEnd> } else <S2SV_ModStart> } else if ( ( u2_width > ps_dec -> u2_create_max_width ) || ( u2_height > ps_dec -> u2_create_max_height ) ) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS ; ps_dec -> u2_reinit_max_height = u2_height ; ps_dec -> u2_reinit_max_width = u2_width ; return e_error <S2SV_ModEnd> ; } <S2SV_ModStart> ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH <S2SV_ModEnd> ) || <S2SV_ModStart> || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS <S2SV_ModEnd> ; } <S2SV_ModStart> return e_error ; } if ( ( ps_dec -> u2_horizontal_size < MIN_WIDTH ) || ( ps_dec -> u2_vertical_size < MIN_HEIGHT ) ) { return IMPEG2D_UNSUPPORTED_DIMENSIONS
<S2SV_ModStart> 0 ; if ( 0 == ps_dec -> u4_frm_buf_stride ) { ps_dec -> u4_frm_buf_stride = ps_dec -> u2_horizontal_size ; }
<S2SV_ModStart> ) ; if ( ps_dec -> u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE ) { return IMPEG2D_FRM_HDR_DECODE_ERR ; }
<S2SV_ModStart> == MB_STUFFING_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> == e_error && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> while ( ( <S2SV_ModStart> != START_CODE_PREFIX ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> while ( ( <S2SV_ModStart> == USER_DATA_START_CODE ) && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset ) <S2SV_ModStart> != START_CODE_PREFIX && ( ps_stream -> u4_offset < ps_stream -> u4_max_offset )
<S2SV_ModStart> u4_start_code_val ) && <S2SV_ModEnd> ( ps_dec <S2SV_ModStart> . u4_offset < <S2SV_ModEnd> ps_dec ->
<S2SV_ModStart> . u4_offset < <S2SV_ModEnd> ps_dec ->
<S2SV_ModStart> == MB_ESCAPE_CODE && ps_stream -> u4_offset < ps_stream -> u4_max_offset
<S2SV_ModStart> ] , silk_ADD_SAT16 ( NLSF_Q15 [ i - 1 ] , NDeltaMin_Q15 [ i ] ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> 0 ; ctx -> si . w = 0 ; ctx -> si . h = 0 ;
<S2SV_ModStart> -> h && <S2SV_ModEnd> si -> <S2SV_ModStart> res = VPX_CODEC_CORRUPT_FRAME ; } else { res = <S2SV_ModStart> ; } <S2SV_ModEnd> } return
<S2SV_ModStart> clear_buffer [ 10 <S2SV_ModEnd> ] ; <S2SV_ModStart> ; } if ( data_sz < 1 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModStart> if ( vpx_rb_read_bit ( & rb ) ) { if ( profile > <S2SV_ModEnd> 2 && <S2SV_ModStart> && data_sz < 2 ) return VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_ModEnd> vpx_rb_read_literal ( <S2SV_ModStart> ( data_sz < 10 <S2SV_ModEnd> ) return
<S2SV_ModStart> ; } w = d_w ; h = d_h ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; if ( ! img ) { img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { uint64_t alloc_size ; <S2SV_ModStart> s ; <S2SV_ModEnd> alloc_size =
<S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> , target_height ; exec_name = argv [ 0 ] <S2SV_ModStart> usage ( <S2SV_ModEnd> ) ; <S2SV_ModStart> usage ( <S2SV_ModEnd> ) ; <S2SV_ModStart> usage ( <S2SV_ModEnd> ) ; <S2SV_ModStart> usage ( <S2SV_ModEnd> ) ; <S2SV_ModStart> usage ( <S2SV_ModEnd> ) ;
<S2SV_ModStart> usage ( <S2SV_ModEnd> ) { <S2SV_ModStart> "%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>" , exec_name <S2SV_ModEnd> ) ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( <S2SV_ModStart> ) { int got_pkts = 0 ; <S2SV_ModStart> ) { got_pkts = 1 ; <S2SV_ModStart> } } return got_pkts ;
<S2SV_ModStart> vpx_codec_ctx_t codec <S2SV_ModEnd> ; vpx_codec_enc_cfg_t <S2SV_ModStart> vpx_codec_enc_cfg_t cfg <S2SV_ModEnd> ; int <S2SV_ModStart> vpx_image_t raw <S2SV_ModEnd> ; vpx_codec_err_t <S2SV_ModStart> VpxVideoInfo info <S2SV_ModEnd> ; VpxVideoWriter <S2SV_ModStart> ) ; memset ( & info , 0 , sizeof ( info ) ) ; <S2SV_ModStart> if ( encoder == NULL ) { <S2SV_ModEnd> die ( <S2SV_ModStart> ( "Unsupported<S2SV_blank>codec." ) ; } assert ( encoder != NULL <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> ; } while ( <S2SV_ModStart> writer ) ) { } <S2SV_ModEnd> printf (
<S2SV_ModStart> = { 0 , 0 ,
<S2SV_ModStart> vpx_roi_map_t roi ; memset ( & roi , 0 , sizeof ( roi ) ) <S2SV_ModEnd> ; roi
<S2SV_ModStart> = { 0 , 0 ,
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( <S2SV_ModStart> ) { int got_pkts = 0 ; <S2SV_ModStart> ) { got_pkts = 1 ; <S2SV_ModStart> } } return got_pkts ;
<S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> ; } while ( <S2SV_ModStart> writer ) ) { }
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( <S2SV_ModStart> ) { int got_pkts = 0 ; <S2SV_ModStart> ) { got_pkts = 1 ; <S2SV_ModStart> } } return got_pkts ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> get_frame_stats ( <S2SV_ModStart> ) { int got_pkts = 0 ; <S2SV_ModStart> ) { got_pkts = 1 ; <S2SV_ModStart> } } return got_pkts ;
<S2SV_ModStart> NULL ; int w , h <S2SV_ModEnd> ; vpx_codec_ctx_t <S2SV_ModStart> vpx_fixed_buf_t stats <S2SV_ModEnd> ; const <S2SV_ModStart> = NULL <S2SV_ModEnd> ; const <S2SV_ModStart> ) ; w <S2SV_ModEnd> = strtol <S2SV_ModStart> ) ; h <S2SV_ModEnd> = strtol <S2SV_ModStart> if ( w <S2SV_ModEnd> <= 0 <S2SV_ModStart> 0 || h <S2SV_ModEnd> <= 0 <S2SV_ModStart> 0 || ( w <S2SV_ModEnd> % 2 <S2SV_ModStart> 0 || ( h <S2SV_ModEnd> % 2 <S2SV_ModStart> 0 ) <S2SV_ModEnd> die ( <S2SV_ModStart> "Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d" , w , h ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> VPX_IMG_FMT_I420 , w , h <S2SV_ModEnd> , 1 <S2SV_ModStart> ) ) <S2SV_ModEnd> die ( <S2SV_ModStart> "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image" , w , h ) ; printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config." ) ; cfg . g_w = w ; cfg . g_h = h ; cfg . g_timebase . num = 1 ; cfg . g_timebase . den = fps ; cfg . rc_target_bitrate = bitrate ; if ( ! ( infile = fopen ( infile_arg , "rb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading" , infile_arg ) ; cfg . g_pass = VPX_RC_FIRST_PASS ; stats = pass0 ( & raw , infile , encoder , & cfg ) ; rewind ( infile ) ; cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; pass1 ( & raw , infile , <S2SV_ModEnd> outfile_arg , <S2SV_ModStart> outfile_arg , encoder , & cfg ) ; free ( stats . buf ) ; vpx_img_free <S2SV_ModEnd> ( & <S2SV_ModStart> & raw ) ; <S2SV_ModEnd> fclose ( <S2SV_ModStart> ( infile <S2SV_ModEnd> ) ;
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> ] ; FILE * downsampled_input [ NUM_ENCODERS - 1 ] ; char filename [ 50 ] ; <S2SV_ModStart> ] ; int <S2SV_ModEnd> frame_cnt = <S2SV_ModStart> ; int length_frame ; int <S2SV_ModStart> ; int layer_id = 0 ; int layer_flags [ VPX_TS_MAX_PERIODICITY * NUM_ENCODERS ] = { 0 } ; int flag_periodicity ; int <S2SV_ModStart> 0 ; int key_frame_insert = 0 ; <S2SV_ModStart> 0 } ; double cx_time = 0 ; struct timeval tv1 , tv2 , difftv <S2SV_ModStart> } ; unsigned int num_temporal_layers [ NUM_ENCODERS ] = { 3 , 3 , 3 } ; <S2SV_ModStart> != ( 7 + 3 * <S2SV_ModEnd> NUM_ENCODERS ) <S2SV_ModStart> die ( "Usage:<S2SV_blank>%s<S2SV_blank><width><S2SV_blank><height><S2SV_blank><frame_rate><S2SV_blank><S2SV_blank><infile><S2SV_blank><outfile(s)><S2SV_blank>" "<rate_encoder(s)><S2SV_blank><temporal_layer(s)><S2SV_blank><key_frame_insert><S2SV_blank><output<S2SV_blank>psnr?><S2SV_blank>\\n" <S2SV_ModEnd> , argv <S2SV_ModStart> [ 2 ] , NULL , 0 ) ; framerate = strtol ( argv [ 3 <S2SV_ModStart> argv [ 4 <S2SV_ModEnd> ] , <S2SV_ModStart> argv [ 4 <S2SV_ModEnd> ] ) <S2SV_ModStart> i + 5 <S2SV_ModEnd> ] , <S2SV_ModStart> ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { target_bitrate [ i ] <S2SV_ModEnd> = strtol <S2SV_ModStart> NUM_ENCODERS + 5 + i <S2SV_ModEnd> ] , <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { num_temporal_layers [ i ] = strtol ( argv [ 2 * NUM_ENCODERS + 5 + i ] , NULL , 0 ) ; if ( num_temporal_layers [ i ] < 1 || num_temporal_layers [ i ] > 3 ) die ( "Invalid<S2SV_blank>temporal<S2SV_blank>layers:<S2SV_blank>%d,<S2SV_blank>Must<S2SV_blank>be<S2SV_blank>1,<S2SV_blank>2,<S2SV_blank>or<S2SV_blank>3.<S2SV_blank>\\n" , num_temporal_layers ) ; } for ( i = 0 ; i < NUM_ENCODERS - 1 ; i ++ ) { if ( sprintf ( filename , "ds%d.yuv" , NUM_ENCODERS - i ) < 0 ) { <S2SV_ModEnd> return EXIT_FAILURE <S2SV_ModStart> ; } downsampled_input [ i ] = fopen ( filename , "wb" ) ; } key_frame_insert = strtol ( argv [ 3 * NUM_ENCODERS + 5 ] , NULL , 0 ) ; show_psnr = strtol ( argv [ 3 * NUM_ENCODERS + 6 ] , NULL , 0 ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { res [ i ] = vpx_codec_enc_config_default ( interface , & cfg [ i ] , 0 ) ; if ( res [ i ] ) { printf ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n" , vpx_codec_err_to_string ( res [ i ] ) ) ; return EXIT_FAILURE ; } <S2SV_ModStart> ] . <S2SV_ModEnd> rc_dropframe_thresh = <S2SV_ModStart> rc_dropframe_thresh = 0 <S2SV_ModEnd> ; cfg <S2SV_ModStart> rc_min_quantizer = 2 <S2SV_ModEnd> ; cfg <S2SV_ModStart> rc_undershoot_pct = 100 <S2SV_ModEnd> ; cfg <S2SV_ModStart> rc_overshoot_pct = 15 <S2SV_ModEnd> ; cfg <S2SV_ModStart> ) ) <S2SV_ModEnd> ; cfg <S2SV_ModStart> ; } cfg [ 0 ] . g_threads = 2 ; cfg [ 1 ] . g_threads = 1 ; cfg [ 2 ] . g_threads = 1 ; <S2SV_ModStart> ) ; for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { set_temporal_layer_pattern ( num_temporal_layers [ i ] , & cfg [ i ] , cfg [ i ] . rc_target_bitrate , & layer_flags [ i * VPX_TS_MAX_PERIODICITY ] ) ; } <S2SV_ModStart> if ( i == NUM_ENCODERS - 1 ) speed = - 4 ; if ( <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>cpu_used" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_STATIC_THRESHOLD , 1 ) ) die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" ) ; } if ( vpx_codec_control ( & codec [ 0 ] , VP8E_SET_NOISE_SENSITIVITY , 1 ) ) die_codec ( & codec [ 0 ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; for ( i = 1 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_NOISE_SENSITIVITY , 0 ) ) die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>noise_sensitivity" ) ; } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { if ( vpx_codec_control ( & codec [ i ] , VP8E_SET_TOKEN_PARTITIONS , 1 ) ) die_codec ( & codec [ i ] , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" <S2SV_ModStart> unsigned int max_intra_size_pct = ( int ) ( ( ( double ) cfg [ 0 ] . rc_buf_optimal_sz * 0.5 ) * framerate / 10 ) <S2SV_ModEnd> ; if <S2SV_ModStart> ] , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct <S2SV_ModEnd> ) ) <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>static<S2SV_blank>threshold" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; length_frame = cfg [ i ] . g_w * cfg [ i ] . g_h * 3 / 2 ; if ( fwrite ( raw [ i ] . planes [ 0 ] , 1 , length_frame , downsampled_input [ NUM_ENCODERS - i - 1 ] ) != length_frame ) { return EXIT_FAILURE ; } } } for ( i = 0 ; i < NUM_ENCODERS ; i ++ ) { layer_id = cfg [ i ] . ts_layer_id [ frame_cnt % cfg [ i ] . ts_periodicity ] ; flags = 0 ; flag_periodicity = periodicity_to_num_layers [ num_temporal_layers [ i ] - 1 ] ; flags = layer_flags [ i * VPX_TS_MAX_PERIODICITY + frame_cnt % flag_periodicity ] ; if ( frame_cnt == 0 ) { flags |= VPX_EFLAG_FORCE_KF ; } if ( frame_cnt > 0 && frame_cnt == key_frame_insert ) { flags = VPX_EFLAG_FORCE_KF ; } vpx_codec_control ( & codec [ i ] , VP8E_SET_FRAME_FLAGS , flags ) ; vpx_codec_control ( & codec [ i ] , VP8E_SET_TEMPORAL_LAYER_ID , layer_id ) ; } gettimeofday ( & tv1 , NULL ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> 1 , 0 <S2SV_ModEnd> , arg_deadline <S2SV_ModStart> ) ) { <S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame" ) ; } gettimeofday ( & tv2 , NULL ) ; timersub ( & tv2 , & tv1 , & difftv ) ; cx_time += ( double ) ( difftv . tv_sec * 1000000 + difftv . tv_usec <S2SV_ModStart> "K" : "" <S2SV_ModEnd> ) ; <S2SV_ModStart> ( "\\n" ) ; printf ( "FPS<S2SV_blank>for<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>%f<S2SV_blank>%f<S2SV_blank>\\n" , frame_cnt , ( float ) cx_time / 1000000 , 1000000 * ( double ) frame_cnt / ( double ) cx_time
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> encode_frame ( <S2SV_ModStart> ) { int got_pkts = 0 ; <S2SV_ModStart> ) { got_pkts = 1 ; <S2SV_ModStart> } } return got_pkts ;
<S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> encoder -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> ; } while ( <S2SV_ModStart> writer ) ) { } <S2SV_ModEnd> printf (
<S2SV_ModStart> usage_exit ( void
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> return ; if ( ! cfg -> rc_target_bitrate ) return ;
<S2SV_ModStart> 0 ; const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> w = vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> ) ; <S2SV_ModStart> h = vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> ) ; <S2SV_ModStart> = w * bytespp
<S2SV_ModStart> plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) <S2SV_ModStart> ) != ( size_t )
<S2SV_ModStart> plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> 0 ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( oci
<S2SV_ModStart> RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci
<S2SV_ModStart> d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { <S2SV_ModStart> uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <S2SV_ModEnd> d28u32 = <S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ <S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [
<S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ <S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [
<S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ <S2SV_ModStart> vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [
<S2SV_ModStart> "\\n" ) <S2SV_ModEnd> ; fprintf <S2SV_ModStart> ) ; <S2SV_ModEnd> fprintf (
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( input
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( pc
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( p
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( x <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( x <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( x
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( dest_ptr1 <S2SV_ModStart> ) ; memcpy ( dest_ptr1 + el , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dest_ptr2 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr1 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr2
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q
<S2SV_ModStart> = ( vpx_variance16x16 <S2SV_ModEnd> ( yd <S2SV_ModStart> = ( vpx_variance16x16 <S2SV_ModEnd> ( y <S2SV_ModStart> ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> = ( sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 <S2SV_ModEnd> ( y <S2SV_ModStart> , yd_stride ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 <S2SV_ModStart> sse ) <S2SV_ModEnd> + 32 <S2SV_ModStart> 6 ; <S2SV_ModEnd> act = <S2SV_ModStart> = ( vpx_variance8x8 <S2SV_ModEnd> ( y <S2SV_ModStart> ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> = ( sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 <S2SV_ModEnd> ( y <S2SV_ModStart> , yd_stride ) <S2SV_ModEnd> + 32 <S2SV_ModStart> = ( vpx_sad4x4 <S2SV_ModEnd> ( u <S2SV_ModStart> , uvd_stride ) <S2SV_ModEnd> + 8 <S2SV_ModStart> = ( vpx_sad4x4 <S2SV_ModEnd> ( v <S2SV_ModStart> , uvd_stride <S2SV_ModEnd> ) + <S2SV_ModStart> uvd_stride ) memcpy <S2SV_ModEnd> ( udp <S2SV_ModStart> uvd_stride ) memcpy <S2SV_ModEnd> ( vdp
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( udp <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( vdp
<S2SV_ModStart> 256 * gaussian <S2SV_ModEnd> ( sigma
<S2SV_ModStart> int flag , int uvfilter <S2SV_ModStart> ) { int mbr ; <S2SV_ModStart> mb_rows = cm -> mb_rows <S2SV_ModEnd> ; int <S2SV_ModStart> mb_cols = cm -> mb_cols <S2SV_ModEnd> ; unsigned <S2SV_ModStart> ; ; <S2SV_ModEnd> ( void <S2SV_ModStart> flag ; memset <S2SV_ModEnd> ( limits <S2SV_ModStart> ) ; if ( uvfilter == 1 ) { <S2SV_ModStart> limits , 8 ) ; } <S2SV_ModEnd> } }
<S2SV_ModStart> i = 0 ; i < 17 ; i ++ ) s [ i + cols <S2SV_ModEnd> ] =
<S2SV_ModStart> i = 0 ; i < 17 ; i ++ ) s [ ( i + rows ) <S2SV_ModEnd> * pitch
<S2SV_ModStart> , j ; ( void ) bothclamp
<S2SV_ModStart> ) { memcpy ( dst , src , 16 ) ; <S2SV_ModEnd> src +=
<S2SV_ModStart> ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src +=
<S2SV_ModStart> ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src +=
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( upred_ptr <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( vpred_ptr <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( upred_ptr <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( vpred_ptr <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( upred_ptr <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( vpred_ptr
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( ypred_ptr <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( ypred_ptr
<S2SV_ModStart> ) { <S2SV_ModEnd> once (
<S2SV_ModStart> i ; memset <S2SV_ModEnd> ( ybf <S2SV_ModStart> 129 ; memset <S2SV_ModEnd> ( ybf <S2SV_ModStart> 129 ; memset <S2SV_ModEnd> ( ybf
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( ybf <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( ybf <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( ybf
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( q
<S2SV_ModStart> VP8_BD_VALUE_SIZE - CHAR_BIT <S2SV_ModEnd> - ( <S2SV_ModStart> count + CHAR_BIT <S2SV_ModEnd> ) ; <S2SV_ModStart> n = MIN ( sizeof ( decrypted ) , bytes_left ) <S2SV_ModEnd> ; br
<S2SV_ModStart> source_sz , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb ,
<S2SV_ModStart> ; # else ( void ) mb_idx ; # <S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> mb_skip_coeff ) memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b
<S2SV_ModStart> above_context ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> recon_uvoffset ; if ( xd -> mode_info_context -> mbmi . ref_frame >= LAST_FRAME ) { const MV_REFERENCE_FRAME ref = xd -> mode_info_context -> mbmi . ref_frame ; <S2SV_ModStart> ref_buffer [ ref <S2SV_ModEnd> ] [ <S2SV_ModStart> ref_buffer [ ref <S2SV_ModEnd> ] [ <S2SV_ModStart> ref_buffer [ ref <S2SV_ModEnd> ] [ <S2SV_ModStart> recon_uvoffset ; } else { xd -> pre . y_buffer = 0 ; xd -> pre . u_buffer = 0 ; xd -> pre . v_buffer = 0 ; }
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( pc <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> SEGMENT_DELTADATA ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( xd
<S2SV_ModStart> int ) MIN ( sizeof ( clear_buffer ) , <S2SV_ModEnd> data_end - <S2SV_ModStart> data ) <S2SV_ModEnd> ; pbi <S2SV_ModStart> 7 ; <S2SV_ModEnd> } else <S2SV_ModStart> else { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> } } memset <S2SV_ModEnd> ( xd <S2SV_ModStart> # endif memset <S2SV_ModEnd> ( pc <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr2 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr2 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr2
<S2SV_ModStart> ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 <S2SV_ModStart> ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2 <S2SV_ModStart> ) { memset ( dest_ptr1 , src_ptr1 [ 0 ] , Border ) ; memset <S2SV_ModEnd> ( dest_ptr2
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr1 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr1 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dest_ptr1
<S2SV_ModStart> ) { ( void ) mbmi ;
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( a_ctx <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( l_ctx
<S2SV_ModStart> mb_col ; memset <S2SV_ModEnd> ( overlaps
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> NULL ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> # else ( void ) oxcf ;
<S2SV_ModStart> # else ( void ) flags ;
<S2SV_ModStart> ) { <S2SV_ModEnd> VP8_COMMON * <S2SV_ModStart> 1 ; ( void ) size ; ( void ) source ; <S2SV_ModStart> retcode ; <S2SV_ModEnd> cm -> <S2SV_ModStart> decode_exit : <S2SV_ModEnd> pbi -> <S2SV_ModStart> 0 ; vp8_clear_system_state ( ) ;
<S2SV_ModStart> ; # else ( void ) mb_idx ; # <S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> mb_skip_coeff ) memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( b
<S2SV_ModStart> above_context ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( (
<S2SV_ModStart> mb_segement_abs_delta ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ] ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( mbd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( mbd
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( pbi
<S2SV_ModStart> vp8_denoiser_filter_neon ( unsigned char * mc_running_avg_y , int mc_running_avg_y_stride , unsigned char * running_avg_y , int running_avg_y_stride , <S2SV_ModEnd> unsigned char <S2SV_ModStart> * sig , <S2SV_ModEnd> int sig_stride <S2SV_ModStart> int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { int shift_inc = ( increase_denoising && motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 1 : 0 ; const uint8x16_t v_level1_adjustment = vmovq_n_u8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 4 + shift_inc : 3 ) ; const uint8x16_t v_delta_level_1_and_2 = vdupq_n_u8 ( 1 ) ; const uint8x16_t v_delta_level_2_and_3 = vdupq_n_u8 ( 2 ) ; const uint8x16_t v_level1_threshold = vmovq_n_u8 ( 4 + shift_inc ) ; const uint8x16_t v_level2_threshold = vdupq_n_u8 ( 8 ) ; const uint8x16_t v_level3_threshold = vdupq_n_u8 ( 16 ) ; int64x2_t v_sum_diff_total = vdupq_n_s64 ( 0 ) ; int r <S2SV_ModEnd> ; for <S2SV_ModStart> for ( r <S2SV_ModEnd> = 0 <S2SV_ModStart> 0 ; r <S2SV_ModEnd> < 16 <S2SV_ModStart> ; ++ r ) { const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_level1_mask = vcleq_u8 ( v_level1_threshold , v_abs_diff ) ; const uint8x16_t v_level2_mask = vcleq_u8 ( v_level2_threshold , v_abs_diff ) ; const uint8x16_t v_level3_mask = vcleq_u8 ( v_level3_threshold , v_abs_diff ) ; const uint8x16_t v_level2_adjustment = vandq_u8 ( v_level2_mask , v_delta_level_1_and_2 ) ; const uint8x16_t v_level3_adjustment = vandq_u8 ( v_level3_mask , v_delta_level_2_and_3 ) ; const uint8x16_t v_level1and2_adjustment = vaddq_u8 ( v_level1_adjustment , v_level2_adjustment ) ; const uint8x16_t v_level1and2and3_adjustment = vaddq_u8 ( v_level1and2_adjustment , v_level3_adjustment ) ; const uint8x16_t v_abs_adjustment = vbslq_u8 ( v_level1_mask , v_level1and2and3_adjustment , v_abs_diff ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; uint8x16_t v_running_avg_y = vqaddq_u8 ( v_sig , v_pos_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const <S2SV_ModEnd> int8x16_t v_sum_diff <S2SV_ModStart> v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_pos_adjustment ) , vreinterpretq_s8_u8 ( v_neg_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) <S2SV_ModEnd> ; } <S2SV_ModStart> ; } { int64x1_t x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; int sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; int sum_diff_thresh = SUM_DIFF_THRESHOLD ; <S2SV_ModStart> if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if <S2SV_ModEnd> ( sum_diff <S2SV_ModStart> ( sum_diff > sum_diff_thresh ) { int delta = ( ( sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const uint8x16_t k_delta = vmovq_n_u8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_running_avg_y_stride * 16 ; running_avg_y -= running_avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { uint8x16_t v_running_avg_y = vld1q_u8 ( running_avg_y ) ; const uint8x16_t v_sig = vld1q_u8 ( sig ) ; const uint8x16_t v_mc_running_avg_y = vld1q_u8 ( mc_running_avg_y ) ; const uint8x16_t v_abs_diff = vabdq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_pos_mask = vcltq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_diff_neg_mask = vcgtq_u8 ( v_sig , v_mc_running_avg_y ) ; const uint8x16_t v_abs_adjustment = vminq_u8 ( v_abs_diff , ( k_delta ) ) ; const uint8x16_t v_pos_adjustment = vandq_u8 ( v_diff_pos_mask , v_abs_adjustment ) ; const uint8x16_t v_neg_adjustment = vandq_u8 ( v_diff_neg_mask , v_abs_adjustment ) ; v_running_avg_y = vqsubq_u8 ( v_running_avg_y , v_pos_adjustment ) ; v_running_avg_y = vqaddq_u8 ( v_running_avg_y , v_neg_adjustment ) ; vst1q_u8 ( running_avg_y , v_running_avg_y ) ; { const int8x16_t v_sum_diff = vqsubq_s8 ( vreinterpretq_s8_u8 ( v_neg_adjustment ) , vreinterpretq_s8_u8 ( v_pos_adjustment ) ) ; const int16x8_t fe_dc_ba_98_76_54_32_10 = vpaddlq_s8 ( v_sum_diff ) ; const int32x4_t fedc_ba98_7654_3210 = vpaddlq_s16 ( fe_dc_ba_98_76_54_32_10 ) ; const int64x2_t fedcba98_76543210 = vpaddlq_s32 ( fedc_ba98_7654_3210 ) ; v_sum_diff_total = vqaddq_s64 ( v_sum_diff_total , fedcba98_76543210 ) ; } sig += sig_stride ; mc_running_avg_y += mc_running_avg_y_stride ; running_avg_y += running_avg_y_stride ; } { x = vqadd_s64 ( vget_high_s64 ( v_sum_diff_total ) , vget_low_s64 ( v_sum_diff_total ) ) ; sum_diff = vget_lane_s32 ( vabs_s32 ( vreinterpret_s32_s64 ( x ) ) , 0 ) ; if ( sum_diff > sum_diff_thresh ) { <S2SV_ModEnd> return COPY_BLOCK <S2SV_ModStart> COPY_BLOCK ; } } } else { return COPY_BLOCK ; } } } running_avg_y -= running_avg_y_stride * 16 ; sig -= sig_stride * 16 ; <S2SV_ModStart> vp8_copy_mem16x16 ( running_avg_y <S2SV_ModEnd> , running_avg_y_stride <S2SV_ModStart> running_avg_y_stride , sig <S2SV_ModEnd> , sig_stride
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) { memmove <S2SV_ModEnd> ( dp <S2SV_ModStart> # endif vp8_pack_tokens <S2SV_ModEnd> ( &
<S2SV_ModStart> int height , int num_mb_rows , int num_mb_cols , int mode <S2SV_ModStart> denoiser ) ; denoiser -> num_mb_cols = num_mb_cols <S2SV_ModStart> ; } memset <S2SV_ModEnd> ( denoiser <S2SV_ModStart> ; } memset <S2SV_ModEnd> ( denoiser <S2SV_ModStart> ) ; if ( vp8_yv12_alloc_frame_buffer ( & denoiser -> yv12_last_source , width , height , VP8BORDERINPIXELS ) < 0 ) { vp8_denoiser_free ( denoiser ) ; return 1 ; } memset ( denoiser -> yv12_last_source . buffer_alloc , 0 , denoiser -> yv12_last_source . frame_size ) ; denoiser -> denoise_state = vpx_calloc ( ( num_mb_rows * num_mb_cols ) , 1 ) ; memset ( denoiser -> denoise_state , 0 , ( num_mb_rows * num_mb_cols ) ) ; vp8_denoiser_set_parameters ( denoiser , mode ) ; denoiser -> nmse_source_diff = 0 ; denoiser -> nmse_source_diff_count = 0 ; denoiser -> qp_avg = 0 ; denoiser -> qp_threshold_up = 80 ; denoiser -> qp_threshold_down = 128 ; denoiser -> bitrate_threshold = 400000 ; denoiser -> threshold_aggressive_mode = 80 ; if ( width * height > 1280 * 720 ) { denoiser -> bitrate_threshold = 3000000 ; denoiser -> threshold_aggressive_mode = 200 ; } else if ( width * height > 960 * 540 ) { denoiser -> bitrate_threshold = 1200000 ; denoiser -> threshold_aggressive_mode = 120 ; } else if ( width * height > 640 * 480 ) { denoiser -> bitrate_threshold = 600000 ; denoiser -> threshold_aggressive_mode = 100 ; } return <S2SV_ModEnd> 0 ;
<S2SV_ModStart> int recon_uvoffset , loop_filter_info_n * lfi_n , int mb_row , int mb_col , int block_index <S2SV_ModStart> unsigned int motion_threshold ; unsigned int motion_magnitude2 ; unsigned int sse_thresh ; int sse_diff_thresh = 0 ; int apply_spatial_loop_filter = 1 <S2SV_ModEnd> ; MV_REFERENCE_FRAME <S2SV_ModStart> FILTER_BLOCK ; enum vp8_denoiser_decision decision_u = COPY_BLOCK ; enum vp8_denoiser_decision decision_v = COPY_BLOCK ; <S2SV_ModStart> ; int sse_diff = 0 ; const int zero_bias = denoiser -> denoise_pars . denoise_mv_bias ; zero_mv_sse = ( unsigned int ) ( ( int64_t ) zero_mv_sse * zero_bias / 100 ) ; <S2SV_ModStart> if ( ( unsigned int ) ( mv_row * mv_row + mv_col * mv_col ) <= NOISE_MOTION_THRESHOLD ) sse_diff_thresh = ( int ) SSE_DIFF_THRESHOLD ; if ( <S2SV_ModStart> INTRA_FRAME || sse_diff <= sse_diff_thresh ) { x -> denoise_zeromv = 1 ; mbmi -> ref_frame = x -> best_zeromv_reference_frame ; src = & denoiser -> yv12_running_avg [ zero_frame ] ; mbmi -> mode = ZEROMV ; mbmi -> mv . as_int = 0 ; x -> best_sse_inter_mode = ZEROMV ; x -> best_sse_mv . as_int = 0 ; best_sse = zero_mv_sse ; } saved_pre = filter_xd -> pre ; saved_dst = filter_xd -> dst ; filter_xd -> pre . y_buffer = src -> y_buffer + recon_yoffset ; filter_xd -> pre . u_buffer = src -> u_buffer + recon_uvoffset ; filter_xd -> pre . v_buffer = src -> v_buffer + recon_uvoffset ; filter_xd -> dst . y_buffer = dst -> y_buffer + recon_yoffset ; filter_xd -> dst . u_buffer = dst -> u_buffer + recon_uvoffset ; filter_xd -> dst . v_buffer = dst -> v_buffer + recon_uvoffset ; if ( ! x -> skip ) { vp8_build_inter_predictors_mb ( filter_xd ) ; } else { vp8_build_inter16x16_predictors_mb ( filter_xd , filter_xd -> dst . y_buffer , filter_xd -> dst . u_buffer , filter_xd -> dst . v_buffer , filter_xd -> dst . y_stride , filter_xd -> dst . uv_stride ) ; } filter_xd -> pre = saved_pre ; filter_xd -> dst = saved_dst ; * mbmi = saved_mbmi ; } mv_row = x -> best_sse_mv . as_mv . row ; mv_col = x -> best_sse_mv . as_mv . col ; motion_magnitude2 = mv_row * mv_row <S2SV_ModEnd> + mv_col <S2SV_ModStart> * mv_col ; motion_threshold = denoiser -> denoise_pars . scale_motion_thresh * NOISE_MOTION_THRESHOLD ; if ( x -> is_skin ) motion_threshold = 1 ; if ( motion_magnitude2 < denoiser -> denoise_pars . scale_increase_filter * NOISE_MOTION_THRESHOLD ) x -> increase_denoising = 1 ; sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD ; if ( x -> increase_denoising ) sse_thresh = denoiser -> denoise_pars . scale_sse_thresh * SSE_THRESHOLD_HIGH <S2SV_ModEnd> ; if <S2SV_ModStart> best_sse > sse_thresh <S2SV_ModEnd> || motion_magnitude2 <S2SV_ModStart> motion_magnitude2 > motion_threshold ) <S2SV_ModEnd> decision = <S2SV_ModStart> COPY_BLOCK ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) { unsigned char * mc_running_avg_y = denoiser -> yv12_mc_running_avg . y_buffer + recon_yoffset ; int mc_avg_y_stride = denoiser -> yv12_mc_running_avg . y_stride ; unsigned char * running_avg_y = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset ; int avg_y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; <S2SV_ModStart> vp8_denoiser_filter ( mc_running_avg_y , mc_avg_y_stride , running_avg_y , avg_y_stride , x -> thismb , 16 , motion_magnitude2 , x -> increase_denoising ) ; denoiser -> denoise_state [ block_index ] = motion_magnitude2 > 0 ? kFilterNonZeroMV : kFilterZeroMV ; if ( denoiser -> denoiser_mode != kDenoiserOnYOnly && motion_magnitude2 == 0 && decision == FILTER_BLOCK ) { unsigned char * mc_running_avg_u = <S2SV_ModEnd> denoiser -> <S2SV_ModStart> -> yv12_mc_running_avg . u_buffer + recon_uvoffset ; unsigned char * running_avg_u = denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset ; unsigned char * mc_running_avg_v = denoiser -> yv12_mc_running_avg . v_buffer + recon_uvoffset ; unsigned char * running_avg_v = denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset ; int mc_avg_uv_stride = denoiser -> yv12_mc_running_avg . uv_stride ; int avg_uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int signal_stride = x -> block [ 16 ] . src_stride ; decision_u = vp8_denoiser_filter_uv ( mc_running_avg_u , mc_avg_uv_stride , running_avg_u , avg_uv_stride , x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , signal_stride , <S2SV_ModEnd> motion_magnitude2 , <S2SV_ModStart> motion_magnitude2 , 0 ) ; decision_v = vp8_denoiser_filter_uv ( mc_running_avg_v , mc_avg_uv_stride , running_avg_v , avg_uv_stride , x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , signal_stride , motion_magnitude2 , 0 ) ; } <S2SV_ModEnd> } if <S2SV_ModStart> ) { x -> denoise_zeromv = 0 ; <S2SV_ModStart> ) ; denoiser -> denoise_state [ block_index ] = kNoFilter ; } if ( denoiser -> denoiser_mode != kDenoiserOnYOnly ) { if ( decision_u == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . u_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } if ( decision_v == COPY_BLOCK ) { vp8_copy_mem8x8 ( x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src , x -> block [ 16 ] . src_stride , denoiser -> yv12_running_avg [ INTRA_FRAME ] . v_buffer + recon_uvoffset , denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ) ; } } if ( apply_spatial_loop_filter ) { loop_filter_info lfi ; int apply_filter_col = 0 ; int apply_filter_row = 0 ; int apply_filter = 0 ; int y_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_stride ; int uv_stride = denoiser -> yv12_running_avg [ INTRA_FRAME ] . uv_stride ; int filter_level = 48 ; int hev_index = lfi_n -> hev_thr_lut [ INTER_FRAME ] [ filter_level ] ; lfi . mblim = lfi_n -> mblim [ filter_level ] ; lfi . blim = lfi_n -> blim [ filter_level ] ; lfi . lim = lfi_n -> lim [ filter_level ] ; lfi . hev_thr = lfi_n -> hev_thr [ hev_index ] ; if ( mb_col > 0 ) { apply_filter_col = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - 1 ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_col ) { apply_filter = 1 ; vp8_loop_filter_mbv ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( mb_row > 0 ) { apply_filter_row = ! ( ( denoiser -> denoise_state [ block_index ] == denoiser -> denoise_state [ block_index - denoiser -> num_mb_cols ] ) && denoiser -> denoise_state [ block_index ] != kFilterNonZeroMV ) ; if ( apply_filter_row ) { apply_filter = 1 ; vp8_loop_filter_mbh ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , NULL , NULL , y_stride , uv_stride , & lfi ) ; } } if ( apply_filter ) { vp8_copy_mem16x16 ( denoiser -> yv12_running_avg [ INTRA_FRAME ] . y_buffer + recon_yoffset , y_stride , x -> thismb , 16 ) ; }
<S2SV_ModStart> vp8_denoiser_filter_c ( <S2SV_ModEnd> unsigned char <S2SV_ModStart> * mc_running_avg_y , <S2SV_ModEnd> int mc_avg_y_stride <S2SV_ModStart> int mc_avg_y_stride , <S2SV_ModEnd> unsigned char <S2SV_ModStart> * running_avg_y , <S2SV_ModEnd> int avg_y_stride <S2SV_ModStart> int avg_y_stride , unsigned char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; int sum_diff_thresh <S2SV_ModEnd> ; int <S2SV_ModStart> , c <S2SV_ModEnd> ; int <S2SV_ModStart> , 6 } ; int shift_inc1 = 0 ; int shift_inc2 = 1 ; int col_sum [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 <S2SV_ModStart> ) { if ( increase_denoising ) { shift_inc1 = 1 ; shift_inc2 = 2 ; } <S2SV_ModEnd> adj_val [ <S2SV_ModStart> adj_val [ 0 ] += shift_inc2 ; adj_val [ 1 ] += shift_inc2 ; adj_val [ 2 ] += shift_inc2 <S2SV_ModEnd> ; } <S2SV_ModStart> <= 3 + shift_inc1 <S2SV_ModStart> ] ; col_sum [ c ] <S2SV_ModEnd> += diff <S2SV_ModStart> >= 4 + shift_inc1 <S2SV_ModStart> adjustment ; col_sum [ c ] += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = sig [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } <S2SV_ModStart> sum_diff += col_sum [ c ] ; } sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs ( sum_diff ) > sum_diff_thresh ) { int delta = ( ( abs ( sum_diff ) - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = mc_running_avg_y <S2SV_ModEnd> [ c <S2SV_ModStart> ] - sig [ c ] ; int adjustment = abs ( diff ) ; if ( adjustment > delta ) adjustment = delta ; if ( diff > 0 ) { if ( running_avg_y [ c ] - adjustment < 0 ) running_avg_y [ c ] = 0 ; else running_avg_y [ c ] = running_avg_y [ c ] - adjustment ; col_sum [ c ] -= adjustment ; } else if ( diff < 0 ) { if ( running_avg_y [ c ] + adjustment > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = running_avg_y [ c ] + adjustment ; col_sum [ c ] += adjustment ; } } sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } sum_diff = 0 ; for ( c = 0 ; c < 16 ; ++ c ) { if ( col_sum [ c ] >= 128 ) { col_sum [ c ] = 127 ; } sum_diff += col_sum [ c ] <S2SV_ModEnd> ; } <S2SV_ModStart> ) > sum_diff_thresh <S2SV_ModEnd> ) return <S2SV_ModStart> COPY_BLOCK ; } else { return COPY_BLOCK ; } } <S2SV_ModStart> vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> , avg_y_stride <S2SV_ModStart> avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride
<S2SV_ModStart> ) ; vp8_yv12_de_alloc_frame_buffer ( & denoiser -> yv12_last_source ) ; vpx_free ( denoiser -> denoise_state ) ;
<S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( sortlist
<S2SV_ModStart> if ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> 0 ) { if <S2SV_ModEnd> ( xd <S2SV_ModStart> == ZEROMV && <S2SV_ModEnd> xd -> <S2SV_ModStart> LAST_FRAME ) { if ( cpi -> consec_zero_last [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last [ map_index + mb_col ] += 1 ; if ( cpi -> consec_zero_last_mvbias [ map_index + mb_col ] < 255 ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] += 1 ; } else { cpi -> consec_zero_last [ map_index + mb_col ] = 0 ; cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( x -> zero_last_dot_suppress ) cpi -> consec_zero_last_mvbias [ map_index + mb_col ] = 0 ; } if ( ( cpi -> current_layer == 0 ) && ( cpi -> cyclic_refresh_mode_enabled && xd -> segmentation_enabled ) ) { cpi -> segmentation_map [ map_index + mb_col ] = xd -> mode_info_context -> mbmi . segment_id ; if ( xd -> mode_info_context -> mbmi . segment_id ) cpi -> cyclic_refresh_map [ map_index + mb_col ] = - 1 ; else if ( ( xd -> mode_info_context -> mbmi . mode == ZEROMV ) && ( xd -> mode_info_context -> mbmi . ref_frame == LAST_FRAME ) <S2SV_ModStart> tp_start ; vp8_pack_tokens <S2SV_ModEnd> ( w
<S2SV_ModStart> mvc ; memset <S2SV_ModEnd> ( cm
<S2SV_ModStart> } # else ( void ) cpi ; #
<S2SV_ModStart> sse ; ( void ) cpi ; <S2SV_ModStart> act = vpx_variance16x16 <S2SV_ModEnd> ( x
<S2SV_ModStart> # endif memset <S2SV_ModEnd> ( segment_counts <S2SV_ModStart> i ; memset <S2SV_ModEnd> ( xd
<S2SV_ModStart> x -> <S2SV_ModEnd> zbin_mode_boost_enabled = <S2SV_ModStart> & intra_error , mb_row , mb_col <S2SV_ModStart> = vp8_regular_quantize_b <S2SV_ModEnd> ; }
<S2SV_ModStart> intra_pred_var = vpx_get_mb_ss <S2SV_ModEnd> ( x
<S2SV_ModStart> ] ; <S2SV_ModEnd> dequant_ptr =
<S2SV_ModStart> tl ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> return ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> return ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> motion_pct ; ( void ) cpi ;
<S2SV_ModStart> stats_in ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( this_frame
<S2SV_ModStart> } ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> 1 ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> coded_error ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> 2 ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> = 0.0 <S2SV_ModEnd> ; for <S2SV_ModStart> int projected_buffer_level <S2SV_ModEnd> ; int
<S2SV_ModStart> vf = vpx_mse16x16 <S2SV_ModEnd> ; xd
<S2SV_ModStart> -> pcnt_motion ; ( void ) cpi
<S2SV_ModStart> pkt ; ( void ) cpi ;
<S2SV_ModStart> next_iiratio ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { ( void ) cpi ;
<S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( cm
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> per_frame_bandwidth ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> else { memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> y_stride ; ( void ) cpi ; <S2SV_ModStart> ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr <S2SV_ModStart> ) ; vpx_mse16x16 <S2SV_ModEnd> ( src_ptr
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> . row *= 8 <S2SV_ModEnd> ; bestmv <S2SV_ModStart> . col *= 8 <S2SV_ModEnd> ; startmv
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> distance ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , unsigned int <S2SV_ModEnd> , sad_array8 <S2SV_ModStart> , sad_array8 [ 8 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> 3 ; ( void ) mvcost ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> ; # else ( void ) search_param ; # <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) + <S2SV_ModStart> , in_what_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> sse ; vpx_mse16x16 <S2SV_ModEnd> ( orig
<S2SV_ModStart> 2 ; if ( cpi -> oxcf . screen_content_mode ) { int qp_thresh = ( cpi -> oxcf . screen_content_mode == 2 ) ? 80 : 100 ; if ( Q >= qp_thresh ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } else if ( cpi -> frames_since_key > 250 && Q < 20 && cpi -> mb . skip_true_count > ( int ) ( 0.95 * mbs_in_frame ) ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = 0 ; } else { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; } memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> != KEY_FRAME && block_count > 0 <S2SV_ModStart> i ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { if ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive && Q < ( int ) cpi -> denoiser . denoise_pars . qp_thresh && ( cpi -> frames_since_key > 2 * cpi -> denoiser . denoise_pars . consec_zerolast ) ) { cpi -> cyclic_refresh_q = Q ; lf_adjustment = - 40 ; for ( i = 0 ; i < mbs_in_frame ; ++ i ) { seg_map [ i ] = ( cpi -> consec_zero_last [ i ] > cpi -> denoiser . denoise_pars . consec_zerolast ) ? 1 : 0 ; } } } # endif
<S2SV_ModStart> KEY_FRAME ; <S2SV_ModEnd> # if <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) { vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ; } # endif } # if <S2SV_ModStart> oxcf . mr_total_resolutions > 1 ) <S2SV_ModEnd> { LOWER_RES_FRAME_INFO <S2SV_ModStart> mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { <S2SV_ModStart> ) ; } } if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . mr_encoder_id ) { if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) { unsigned int i ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target = lc -> starting_buffer_level ; lc -> buffer_level = lc -> starting_buffer_level ; } } cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ; } else { low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ; } } } # endif cpi -> closest_reference_frame = LAST_FRAME ; if ( cm -> frame_type != KEY_FRAME ) { int i ; MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { closest_ref = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) { closest_ref = GOLDEN_FRAME ; } else <S2SV_ModStart> VP8_ALTR_FRAME ) { closest_ref = ALTREF_FRAME ; } for ( i = 1 ; i <= 3 ; i ++ ) { vpx_ref_frame_type_t ref_frame_type = ( vpx_ref_frame_type_t ) ( ( i == 3 ) ? 4 : i ) ; if ( cpi -> ref_frame_flags & ref_frame_type ) { if ( ( cm -> current_video_frame - <S2SV_ModEnd> cpi -> <S2SV_ModStart> current_ref_frames [ i ] ) < ( cm -> current_video_frame - cpi -> current_ref_frames [ closest_ref <S2SV_ModEnd> ] ) <S2SV_ModStart> ] ) ) { closest_ref = i ; } } } cpi -> closest_reference_frame = closest_ref ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> ) { int disable_cr_gf = ( cpi -> oxcf . screen_content_mode == 2 && cm -> refresh_golden_frame ) ; <S2SV_ModStart> == 0 && cpi -> force_maxqp == 0 && ! disable_cr_gf <S2SV_ModStart> ) ; # if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) { if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) { vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 0 ) ; } } # endif <S2SV_ModStart> , 0 , 1 <S2SV_ModStart> , 0 , 1 <S2SV_ModStart> vp8_write_yuv_frame ( yuv_file , <S2SV_ModStart> ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; if ( cpi -> oxcf . screen_content_mode == 2 ) { if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ; } <S2SV_ModStart> == ZEROMV && tmp -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { cpi -> mse_source_denoised = measure_square_diff_partial ( <S2SV_ModEnd> & cpi <S2SV_ModStart> cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi -> Source , cpi ) ; } if ( cpi -> oxcf . noise_sensitivity == 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { process_denoiser_mode_change ( cpi ) ; } <S2SV_ModEnd> # endif <S2SV_ModStart> # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) { sem_post ( & cpi -> h_event_start_lpf ) ; cpi -> b_lpf_running = 1 ; } else # endif <S2SV_ModStart> ) ; # ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; # endif <S2SV_ModStart> bits_off_target = cpi -> oxcf . maximum_buffer_size ; if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = -
<S2SV_ModStart> ) ; if ( oxcf -> timebase . num > 0 ) { <S2SV_ModStart> ) ; } else { cpi -> framerate = 30 ; } <S2SV_ModStart> framerate ; cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; cm -> refresh_golden_frame = 0 ; cm -> refresh_last_frame = 1 ; cm -> refresh_entropy_probs = 1 ;
<S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi
<S2SV_ModStart> abs_delta ; memcpy <S2SV_ModEnd> ( cpi
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( cpi
<S2SV_ModStart> 0 ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi
<S2SV_ModStart> ; } memset <S2SV_ModEnd> ( cpi
<S2SV_ModStart> ; } memset <S2SV_ModEnd> ( cpi
<S2SV_ModStart> -> number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) {
<S2SV_ModStart> new_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> current_video_frame ; <S2SV_ModEnd> } else <S2SV_ModStart> new_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> current_video_frame ; <S2SV_ModEnd> } else <S2SV_ModStart> lst_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> ] ; <S2SV_ModEnd> } } <S2SV_ModStart> gld_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> ] ; <S2SV_ModEnd> } } <S2SV_ModStart> new_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> current_video_frame ; <S2SV_ModEnd> } else <S2SV_ModStart> lst_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> ] ; <S2SV_ModEnd> } } <S2SV_ModStart> alt_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> ] ; <S2SV_ModEnd> } } <S2SV_ModStart> new_fb_idx ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> current_video_frame ; <S2SV_ModEnd> } # <S2SV_ModStart> i ; for ( i = LAST_FRAME <S2SV_ModEnd> ; i <S2SV_ModStart> < MAX_REF_FRAMES ; ++ i <S2SV_ModEnd> ) vp8_yv12_copy_frame <S2SV_ModStart> vp8_yv12_copy_frame ( cpi -> Source <S2SV_ModEnd> , & <S2SV_ModStart> } } if ( cpi -> oxcf . noise_sensitivity == 4 ) vp8_yv12_copy_frame ( cpi -> Source , & cpi -> denoiser . yv12_last_source ) ;
<S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { vp8_denoiser_free ( & cpi -> denoiser ) ; vp8_denoiser_allocate ( & cpi -> denoiser , width , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity ) ; } # endif
<S2SV_ModStart> Total += vpx_mse16x16 <S2SV_ModEnd> ( src
<S2SV_ModStart> DEFAULT_GF_INTERVAL ; <S2SV_ModEnd> # if <S2SV_ModStart> ) { if ( cpi -> temporal_layer_id > 0 ) { cpi -> temporal_layer_id = 0 ; } <S2SV_ModStart> ; } if ( ! cpi -> initial_width ) { cpi -> initial_width = cpi -> oxcf . Width ; cpi -> initial_height = cpi -> oxcf . Height ; } cm -> Width = cpi -> oxcf . Width <S2SV_ModEnd> ; cm <S2SV_ModStart> . Height ; assert ( cm -> Width <= cpi -> initial_width ) ; assert ( cm -> Height <= cpi -> initial_height ) <S2SV_ModStart> , height , cm -> mb_rows , cm -> mb_cols , cpi -> oxcf . noise_sensitivity
<S2SV_ModStart> common ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> cpi -> temporal_layer_id = - 1 ; cpi -> <S2SV_ModStart> cpi -> mse_source_denoised = 0 ; cpi -> <S2SV_ModStart> 5 ; if ( cpi -> oxcf . number_of_layers == 1 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 20 ; } else if ( cpi -> oxcf . number_of_layers == 2 ) { cpi -> cyclic_refresh_mode_max_mbs_perframe = ( cpi -> common . mb_rows * cpi -> common . mb_cols ) / 10 ; } <S2SV_ModStart> NULL ; CHECK_MEM_ERROR ( cpi -> consec_zero_last , vpx_calloc ( cm -> mb_rows * cm -> mb_cols , 1 ) ) ; CHECK_MEM_ERROR ( cpi -> consec_zero_last_mvbias , vpx_calloc ( ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , 1 ) ) ; <S2SV_ModStart> cpi -> force_maxqp = 0 ; cpi -> <S2SV_ModStart> endif # ifdef OUTPUT_YUV_DENOISED yuv_denoised_file = fopen ( "denoised.yuv" , "ab" ) ; # endif # <S2SV_ModStart> sdf = vpx_sad16x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> vf = vpx_variance16x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf = vpx_sub_pixel_variance16x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf_halfpix_h = vpx_variance_halfpixvar16x16_h <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf_halfpix_v = vpx_variance_halfpixvar16x16_v <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf_halfpix_hv = vpx_variance_halfpixvar16x16_hv <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx3f = vpx_sad16x16x3 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx8f = vpx_sad16x16x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx4df = vpx_sad16x16x4d <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdf = vpx_sad16x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> vf = vpx_variance16x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf = vpx_sub_pixel_variance16x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx3f = vpx_sad16x8x3 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx8f = vpx_sad16x8x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx4df = vpx_sad16x8x4d <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdf = vpx_sad8x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> vf = vpx_variance8x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf = vpx_sub_pixel_variance8x16 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx3f = vpx_sad8x16x3 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx8f = vpx_sad8x16x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx4df = vpx_sad8x16x4d <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdf = vpx_sad8x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> vf = vpx_variance8x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf = vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx3f = vpx_sad8x8x3 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx8f = vpx_sad8x8x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx4df = vpx_sad8x8x4d <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdf = vpx_sad4x4 <S2SV_ModEnd> ; cpi <S2SV_ModStart> vf = vpx_variance4x4 <S2SV_ModEnd> ; cpi <S2SV_ModStart> svf = vpx_sub_pixel_variance4x4 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx3f = vpx_sad4x4x3 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx8f = vpx_sad4x4x8 <S2SV_ModEnd> ; cpi <S2SV_ModStart> sdx4df = vpx_sad4x4x4d <S2SV_ModEnd> ; #
<S2SV_ModStart> ) { <S2SV_ModEnd> VP8_COMMON * <S2SV_ModStart> 0 ; vp8_clear_system_state ( ) ; <S2SV_ModStart> 1 ; <S2SV_ModEnd> vpx_usec_timer_start ( <S2SV_ModStart> # endif <S2SV_ModEnd> return - <S2SV_ModStart> ; } # if CONFIG_MULTI_RES_ENCODING if ( cpi -> oxcf . mr_total_resolutions > 1 ) { LOWER_RES_FRAME_INFO * low_res_frame_info = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { cpi -> ref_framerate = low_res_frame_info -> low_res_framerate ; } else { low_res_frame_info -> low_res_framerate = cpi -> ref_framerate ; } } # endif <S2SV_ModStart> . number_of_layers && i < VPX_TS_MAX_LAYERS ; ++ i <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; if ( cpi -> temporal_layer_id >= 0 ) { layer = cpi -> temporal_layer_id ; } else { <S2SV_ModStart> ] ; } <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> refresh_alt_ref_frame ) memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> refresh_golden_frame ) memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> refresh_last_frame ) memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> frame_to_show ; unsigned int y_width = cpi -> common . Width ; unsigned int y_height = cpi -> common . Height ; unsigned int uv_width = ( y_width + 1 ) / 2 ; unsigned int uv_height = ( y_height + 1 ) / 2 ; <S2SV_ModStart> y_samples = <S2SV_ModEnd> y_height * <S2SV_ModStart> y_height * <S2SV_ModEnd> y_width ; <S2SV_ModStart> uv_samples = <S2SV_ModEnd> uv_height * <S2SV_ModStart> uv_height * <S2SV_ModEnd> uv_width ; <S2SV_ModStart> double sq_error <S2SV_ModEnd> ; ye <S2SV_ModStart> y_stride , y_width , y_height ) ; ue = calc_plane_error ( <S2SV_ModStart> orig -> u_buffer <S2SV_ModEnd> , orig <S2SV_ModStart> orig -> uv_stride , recon -> u_buffer , recon -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> = calc_plane_error <S2SV_ModStart> orig -> v_buffer <S2SV_ModEnd> , orig <S2SV_ModStart> recon -> v_buffer <S2SV_ModEnd> , recon <S2SV_ModStart> uv_stride , <S2SV_ModEnd> uv_width , <S2SV_ModStart> uv_width , <S2SV_ModEnd> uv_height ) <S2SV_ModStart> ; double sq_error2 ; double <S2SV_ModStart> y_stride , y_width , y_height ) ; ue = calc_plane_error ( <S2SV_ModStart> orig -> u_buffer <S2SV_ModEnd> , orig <S2SV_ModStart> orig -> uv_stride , pp -> u_buffer , pp -> uv_stride , uv_width , uv_height ) ; ve <S2SV_ModEnd> = calc_plane_error <S2SV_ModStart> orig -> v_buffer <S2SV_ModEnd> , orig <S2SV_ModStart> pp -> v_buffer <S2SV_ModEnd> , pp <S2SV_ModStart> uv_stride , <S2SV_ModEnd> uv_width , <S2SV_ModStart> uv_width , <S2SV_ModEnd> uv_height ) <S2SV_ModStart> frame_ssim2 = vpx_calc_ssim <S2SV_ModEnd> ( cpi <S2SV_ModStart> -> post_proc_buffer <S2SV_ModEnd> , & <S2SV_ModStart> frame_all = vpx_calc_ssimg <S2SV_ModEnd> ( cpi <S2SV_ModStart> # endif <S2SV_ModEnd> cpi ->
<S2SV_ModStart> # else ( void ) flags ;
<S2SV_ModStart> frame_type ; int update_any_ref_buffers = 1 ; if ( cpi -> common . refresh_last_frame == 0 && cpi -> common . refresh_golden_frame == 0 && cpi -> common . refresh_alt_ref_frame == 0 ) { update_any_ref_buffers = 0 ; } <S2SV_ModStart> 0 ) { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { <S2SV_ModStart> vp8cx_pick_filter_level_fast ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level_fast ( <S2SV_ModStart> ) ; } # else vp8cx_pick_filter_level_fast ( cpi -> Source , cpi ) ; # endif } else { # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity && cm -> frame_type != KEY_FRAME ) { <S2SV_ModEnd> vp8cx_pick_filter_level ( <S2SV_ModStart> vp8cx_pick_filter_level ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi ) ; } else { vp8cx_pick_filter_level ( <S2SV_ModStart> ) ; } # else vp8cx_pick_filter_level ( cpi -> Source , cpi ) ; # endif } <S2SV_ModStart> > 0 && update_any_ref_buffers
<S2SV_ModStart> ) { <S2SV_ModEnd> struct vpx_usec_timer <S2SV_ModStart> 0 ; <S2SV_ModEnd> vpx_usec_timer_start ( <S2SV_ModStart> ) ; <S2SV_ModEnd> return res
<S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ] * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double <S2SV_ModStart> count * cpi -> common . Width * cpi -> common . Height <S2SV_ModEnd> ; double <S2SV_ModStart> ) ; vpx_free ( cpi -> consec_zero_last ) ; vpx_free ( cpi -> consec_zero_last_mvbias ) ; <S2SV_ModStart> endif # ifdef OUTPUT_YUV_DENOISED fclose ( yuv_denoised_file ) ; # endif #
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( cpi
<S2SV_ModStart> 0 ; cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> ) ; if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> 0 ; memset <S2SV_ModEnd> ( cpi <S2SV_ModStart> vp8_regular_quantize_b ; } else { <S2SV_ModStart> mb . <S2SV_ModEnd> quantize_b = <S2SV_ModStart> = vp8_fast_quantize_b <S2SV_ModEnd> ; }
<S2SV_ModStart> int this_rd ; int denoise_aggressive = 0 <S2SV_ModStart> ) ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) { denoise_aggressive = ( cpi -> denoiser . denoiser_mode == kDenoiserOnYUVAggressive ) ? 1 : 0 ; } # endif if ( ! cpi -> oxcf . screen_content_mode && <S2SV_ModEnd> this_mode == <S2SV_ModStart> == ZEROMV && x -> e_mbd . mode_info_context -> mbmi . ref_frame == LAST_FRAME && ( denoise_aggressive || ( cpi -> closest_reference_frame == LAST_FRAME ) ) <S2SV_ModStart> if ( x -> is_skin <S2SV_ModEnd> ) rd_adj
<S2SV_ModStart> ; return vpx_get4x4sse_cs <S2SV_ModEnd> ( sptr
<S2SV_ModStart> sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse <S2SV_ModStart> best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # <S2SV_ModStart> zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse <S2SV_ModStart> best_sse = UINT_MAX <S2SV_ModEnd> ; # <S2SV_ModStart> improved_mv_pred ; # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> 0 ; int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; <S2SV_ModStart> # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> parent_ref_valid = <S2SV_ModStart> -> mr_low_res_mv_avail <S2SV_ModEnd> ; if <S2SV_ModStart> & VP8_GOLD_FRAME <S2SV_ModEnd> ) ; <S2SV_ModStart> 0 ; if ( dot_artifact_candidate ) parent_ref_valid = 0 ; <S2SV_ModStart> # endif { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { } # endif <S2SV_ModStart> 0 ; memset <S2SV_ModEnd> ( mode_mv_sb <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> ; } <S2SV_ModEnd> x -> <S2SV_ModStart> INTRA_FRAME ; if ( cpi -> Speed < 12 ) { <S2SV_ModStart> ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * <S2SV_ModStart> distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * <S2SV_ModStart> . mr_encoder_id <S2SV_ModEnd> ) sf_improved_mv_pred <S2SV_ModStart> parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> ) { <S2SV_ModStart> parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> && dissim <S2SV_ModStart> ! parent_ref_valid || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> as_int ; vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <S2SV_ModStart> ) { int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> < zero_mv_sse && ! skip_old_reference <S2SV_ModStart> < best_sse && ! skip_old_reference <S2SV_ModStart> this_rd ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> ; } if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = <S2SV_ModEnd> ( best_mbmode <S2SV_ModStart> == INTRA_FRAME ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModStart> best_zeromv_reference_frame ; rd_adjustment = 100 ; <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> skip ) memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> distortion = vpx_variance16x16 <S2SV_ModEnd> ( *
<S2SV_ModStart> void ) mb ; ( void )
<S2SV_ModStart> Total += vpx_mse16x16 <S2SV_ModEnd> ( src
<S2SV_ModStart> int filt_mid <S2SV_ModEnd> ; int <S2SV_ModStart> frame_to_show ; memset <S2SV_ModEnd> ( ss_err
<S2SV_ModStart> int best_filt_val <S2SV_ModEnd> ; YV12_BUFFER_CONFIG <S2SV_ModStart> filt_val ; yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame <S2SV_ModStart> ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame <S2SV_ModStart> ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame
<S2SV_ModStart> ) ) { Adjustment = <S2SV_ModEnd> ( cpi <S2SV_ModStart> * Adjustment ; if ( Adjustment > ( 10 * cpi -> this_frame_target ) / 100 ) Adjustment = ( 10 * cpi -> this_frame_target ) / 100 ; cpi -> this_frame_target += Adjustment ; } <S2SV_ModEnd> else cpi
<S2SV_ModStart> active_worst_quality ; if ( cpi -> force_maxqp == 1 ) { cpi -> active_worst_quality = cpi -> worst_quality ; return cpi -> worst_quality ; }
<S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( cpi <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( uptr <S2SV_ModStart> ) ; vpx_sub_pixel_variance8x8 <S2SV_ModEnd> ( vptr <S2SV_ModStart> else { vpx_variance8x8 <S2SV_ModEnd> ( uptr <S2SV_ModStart> ) ; vpx_variance8x8 <S2SV_ModEnd> ( vptr
<S2SV_ModStart> var = vpx_variance16x16 <S2SV_ModEnd> ( *
<S2SV_ModStart> tl_b ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> tl_s ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> this_rd ; memcpy <S2SV_ModEnd> ( ta_b <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( tl_b <S2SV_ModStart> } } memcpy <S2SV_ModEnd> ( ta <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( tl
<S2SV_ModStart> tl ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> ) { ( void ) cpi ; ( void ) fullpixel ;
<S2SV_ModStart> l ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , best_predictor [ <S2SV_ModEnd> 16 * <S2SV_ModStart> * 4 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , best_dqcoeff [ 16 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( best_dqcoeff
<S2SV_ModStart> bmode_costs ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> this_rd ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> . y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> . y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> . y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> . y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> . y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , pre_y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , pre_y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , pre_y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , pre_y_stride <S2SV_ModEnd> ) ; <S2SV_ModStart> , pre_y_stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> ] ; <S2SV_ModEnd> * sr
<S2SV_ModStart> bsi ; memset <S2SV_ModEnd> ( &
<S2SV_ModStart> * returnintra , int mb_row , int mb_col <S2SV_ModStart> zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse <S2SV_ModStart> best_sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse <S2SV_ModStart> best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # <S2SV_ModStart> INT_MAX ; memset <S2SV_ModEnd> ( mode_mv_sb <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> . as_int <S2SV_ModEnd> ; further_steps <S2SV_ModStart> ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; <S2SV_ModStart> , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index <S2SV_ModStart> ) { <S2SV_ModEnd> * returnrate <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> as_int ; memcpy <S2SV_ModEnd> ( x
<S2SV_ModStart> tl ; memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( cpi
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( x <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( x <S2SV_ModStart> else { memset <S2SV_ModEnd> ( x <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( x
<S2SV_ModStart> vp8_denoiser_filter_sse2 ( <S2SV_ModEnd> unsigned char <S2SV_ModStart> char * mc_running_avg_y , int mc_avg_y_stride , <S2SV_ModEnd> unsigned char <S2SV_ModStart> char * running_avg_y , int avg_y_stride , <S2SV_ModEnd> unsigned char <S2SV_ModStart> char * sig , int sig_stride , unsigned int motion_magnitude , int increase_denoising ) { unsigned char * running_avg_y_start = running_avg_y ; unsigned char * sig_start = sig ; unsigned int sum_diff_thresh <S2SV_ModEnd> ; int <S2SV_ModStart> r ; int shift_inc = ( increase_denoising && <S2SV_ModEnd> motion_magnitude <= <S2SV_ModStart> ) ? 1 : 0 ; __m128i acc_diff = _mm_setzero_si128 ( ) ; const __m128i k_0 = _mm_setzero_si128 ( ) ; const __m128i k_4 = _mm_set1_epi8 ( 4 + shift_inc ) ; const __m128i k_8 = _mm_set1_epi8 ( 8 ) ; const __m128i k_16 = _mm_set1_epi8 ( 16 ) ; const __m128i l3 = _mm_set1_epi8 ( ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) ? 7 + shift_inc <S2SV_ModEnd> : 6 <S2SV_ModStart> } { unsigned int abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) ; sum_diff_thresh = SUM_DIFF_THRESHOLD ; if ( increase_denoising ) sum_diff_thresh = SUM_DIFF_THRESHOLD_HIGH ; if ( abs_sum_diff > sum_diff_thresh ) { int delta = ( ( abs_sum_diff - sum_diff_thresh ) >> 8 ) + 1 ; if ( delta < 4 ) { const __m128i k_delta = _mm_set1_epi8 ( delta ) ; sig -= sig_stride * 16 ; mc_running_avg_y -= mc_avg_y_stride * 16 ; running_avg_y -= avg_y_stride * 16 ; for ( r <S2SV_ModEnd> = 0 <S2SV_ModStart> 0 ; r < 16 ; ++ r ) { __m128i v_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & running_avg_y <S2SV_ModEnd> [ 0 <S2SV_ModStart> 0 ] ) ) ; const __m128i v_sig = _mm_loadu_si128 ( ( __m128i * ) ( & sig [ 0 ] ) ) ; const __m128i v_mc_running_avg_y = _mm_loadu_si128 ( ( __m128i * ) ( & mc_running_avg_y [ 0 ] ) ) ; const __m128i pdiff = _mm_subs_epu8 ( v_mc_running_avg_y , v_sig ) ; const __m128i ndiff = _mm_subs_epu8 ( v_sig , v_mc_running_avg_y ) ; const __m128i diff_sign = _mm_cmpeq_epi8 ( pdiff , k_0 ) ; const __m128i adj = _mm_min_epu8 ( _mm_or_si128 ( pdiff , ndiff ) , k_delta ) ; __m128i padj , nadj ; padj = _mm_andnot_si128 ( diff_sign , adj ) ; nadj = _mm_and_si128 ( diff_sign , adj ) ; v_running_avg_y = _mm_subs_epu8 ( v_running_avg_y , padj ) ; v_running_avg_y = _mm_adds_epu8 ( v_running_avg_y , nadj ) ; _mm_storeu_si128 ( ( __m128i * ) running_avg_y , v_running_avg_y ) ; acc_diff = _mm_subs_epi8 ( acc_diff , padj ) ; acc_diff = _mm_adds_epi8 ( acc_diff , nadj ) ; sig += sig_stride ; mc_running_avg_y += mc_avg_y_stride ; running_avg_y += avg_y_stride ; } abs_sum_diff = abs_sum_diff_16x1 ( acc_diff ) <S2SV_ModEnd> ; if <S2SV_ModStart> if ( abs_sum_diff > sum_diff_thresh ) <S2SV_ModEnd> { return <S2SV_ModStart> } } else { return COPY_BLOCK ; } } } <S2SV_ModStart> vp8_copy_mem16x16 ( running_avg_y_start <S2SV_ModEnd> , avg_y_stride <S2SV_ModStart> avg_y_stride , sig_start <S2SV_ModEnd> , sig_stride
<S2SV_ModStart> ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_crop_width = y_w <S2SV_ModEnd> ; yv12 <S2SV_ModStart> y_crop_height = y_h <S2SV_ModEnd> ; yv12 <S2SV_ModStart> y_width = y_w <S2SV_ModEnd> ; yv12 <S2SV_ModStart> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h <S2SV_ModEnd> ; yv12 <S2SV_ModStart> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> w <S2SV_ModEnd> ) / <S2SV_ModStart> 2 ; <S2SV_ModEnd> return res
<S2SV_ModStart> } # else ( void ) mr_cfg ; # <S2SV_ModStart> . tuning ; oxcf -> screen_content_mode = vp8_cfg . screen_content_mode
<S2SV_ModStart> 1 , 1000000000 <S2SV_ModEnd> ) ; <S2SV_ModStart> , 63 ) ; RANGE_CHECK_HI ( vp8_cfg , screen_content_mode , 2 <S2SV_ModStart> 1 ] && cfg -> rc_target_bitrate > 0
<S2SV_ModStart> ) ; vpx_free <S2SV_ModEnd> ( ctx
<S2SV_ModStart> if ( ! flags ) { flags = ctx -> control_frame_flags ; } ctx -> control_frame_flags = 0 ; res = set_reference_and_update ( ctx , flags ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> vpx_codec_pts_t ) 10000000 <S2SV_ModEnd> * ctx
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> VPX_CODEC_OK ; vp8_rtcd ( ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; if ( ! ctx -> priv ) { <S2SV_ModStart> * priv = <S2SV_ModEnd> ( struct <S2SV_ModStart> struct vpx_codec_alg_priv * ) vpx_calloc ( 1 , sizeof ( * priv <S2SV_ModStart> priv = ( vpx_codec_priv_t * ) <S2SV_ModEnd> priv ; <S2SV_ModStart> ) { priv <S2SV_ModEnd> -> cfg <S2SV_ModStart> = & priv -> cfg ; } <S2SV_ModEnd> priv -> <S2SV_ModStart> vp8_cfg = default_extracfg <S2SV_ModEnd> ; priv <S2SV_ModStart> ( & priv <S2SV_ModEnd> -> oxcf <S2SV_ModStart> oxcf , priv -> cfg , priv <S2SV_ModEnd> -> vp8_cfg <S2SV_ModStart> ) ; priv -> cpi <S2SV_ModEnd> = vp8_create_compressor <S2SV_ModStart> ( & priv <S2SV_ModEnd> -> oxcf <S2SV_ModStart> ( ! priv -> cpi <S2SV_ModEnd> ) res <S2SV_ModStart> VPX_CODEC_MEM_ERROR ; <S2SV_ModEnd> } }
<S2SV_ModStart> } # else ( void ) cfg ; ( void ) mem_loc ; #
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> if ( <S2SV_ModEnd> cfg -> <S2SV_ModStart> . g_w || <S2SV_ModEnd> cfg -> <S2SV_ModStart> g_h ) { if <S2SV_ModEnd> ( cfg <S2SV_ModStart> VPX_RC_ONE_PASS ) <S2SV_ModEnd> ERROR ( <S2SV_ModStart> ) ; if ( ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) ERROR ( "Cannot<S2SV_blank>increase<S2SV_blank>width<S2SV_blank>or<S2SV_blank>height<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>their<S2SV_blank>initial<S2SV_blank>values" ) ; }
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list <S2SV_ModStart> * ) <S2SV_ModEnd> ; if <S2SV_ModStart> void ) <S2SV_ModEnd> args ;
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> y_crop_width = y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - <S2SV_ModStart> -> d_w ) <S2SV_ModEnd> / 2 <S2SV_ModStart> 2 ; <S2SV_ModEnd> return res
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( ctx <S2SV_ModStart> . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( ! ctx -> fragments . enabled
<S2SV_ModStart> if ( ! ctx -> fragments . enabled && ( data == NULL && data_sz == 0 ) ) { return 0 ; } if ( <S2SV_ModStart> res && ! <S2SV_ModEnd> ctx -> <S2SV_ModStart> -> decoder_init <S2SV_ModEnd> ) { <S2SV_ModStart> ctx -> decoder_init = 1 ; } if ( ctx -> decoder_init ) { ctx -> <S2SV_ModStart> -> decrypt_state <S2SV_ModEnd> ; } <S2SV_ModStart> 0 ; vp8_clear_system_state ( ) ;
<S2SV_ModStart> ) { <S2SV_ModEnd> vp8_remove_decoder_instances ( <S2SV_ModStart> ) ; vpx_free <S2SV_ModEnd> ( ctx <S2SV_ModStart> ( ctx <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> return VPX_CODEC_OK
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list <S2SV_ModStart> ) { const YV12_BUFFER_CONFIG * const frame <S2SV_ModEnd> = pbi <S2SV_ModStart> . frame_to_show ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> VPX_CODEC_OK ; vpx_codec_alg_priv_t * priv = NULL ; <S2SV_ModStart> ) ; vpx_dsp_rtcd ( ) ; vpx_scale_rtcd ( ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> vp8_init_ctx ( <S2SV_ModStart> ( ctx <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> -> priv ; priv <S2SV_ModEnd> -> fragments <S2SV_ModStart> 0 ; priv <S2SV_ModEnd> -> fragments <S2SV_ModStart> = ( priv <S2SV_ModEnd> -> base <S2SV_ModStart> ) ; } else { priv = ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> -> priv <S2SV_ModEnd> ; } <S2SV_ModStart> ; } priv <S2SV_ModEnd> -> yv12_frame_buffers <S2SV_ModStart> priv -> <S2SV_ModEnd> init_flags & <S2SV_ModStart> ) ; priv <S2SV_ModEnd> -> yv12_frame_buffers <S2SV_ModStart> if ( priv <S2SV_ModEnd> -> yv12_frame_buffers <S2SV_ModStart> priv -> <S2SV_ModEnd> init_flags & <S2SV_ModStart> VPX_CODEC_USE_ERROR_CONCEALMENT ) || <S2SV_ModEnd> ( ctx <S2SV_ModStart> priv -> <S2SV_ModEnd> init_flags &
<S2SV_ModStart> * ctx <S2SV_ModEnd> ) { <S2SV_ModStart> ) { vpx_codec_alg_priv_t * priv = ( vpx_codec_alg_priv_t * ) vpx_calloc ( 1 , sizeof ( * priv ) ) <S2SV_ModEnd> ; ctx <S2SV_ModStart> priv = ( vpx_codec_priv_t * ) priv <S2SV_ModEnd> ; ctx <S2SV_ModStart> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> decrypt_cb = NULL ; priv -> decrypt_state = NULL ; <S2SV_ModStart> ) { priv <S2SV_ModEnd> -> cfg <S2SV_ModStart> = & priv <S2SV_ModEnd> -> cfg
<S2SV_ModStart> si , vpx_decrypt_cb <S2SV_ModEnd> decrypt_cb , <S2SV_ModStart> n = MIN ( sizeof ( clear_buffer ) , data_sz ) <S2SV_ModEnd> ; decrypt_cb <S2SV_ModStart> 0x2a ) return <S2SV_ModEnd> VPX_CODEC_UNSUP_BITSTREAM ;
<S2SV_ModStart> si ; ( void ) flags ;
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ) { vpx_decrypt_init <S2SV_ModEnd> * init <S2SV_ModStart> args , vpx_decrypt_init <S2SV_ModEnd> * )
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list <S2SV_ModStart> # else ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> img -> bit_depth = 8 ; img ->
<S2SV_ModStart> ) { vp9_free_context_buffers <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; vpx_free ( <S2SV_ModEnd> cm -> <S2SV_ModStart> cm -> fc ) ; cm -> fc = NULL ; vpx_free ( cm -> frame_contexts ) ; cm -> frame_contexts = NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_above_block_mode (
<S2SV_ModStart> MAX_MB_PLANE ; ++ plane <S2SV_ModEnd> ) vp9_foreach_transformed_block_in_plane
<S2SV_ModStart> ( mbmi , pd <S2SV_ModStart> int i = 0 , r , c ; const int max_blocks_wide = num_4x4_w + <S2SV_ModEnd> ( xd <S2SV_ModStart> -> mb_to_right_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> <S2SV_ModStart> ) ; const int max_blocks_high = num_4x4_h + <S2SV_ModEnd> ( xd <S2SV_ModStart> -> mb_to_bottom_edge >= 0 ? 0 : <S2SV_ModEnd> xd -> <S2SV_ModStart> ) ; const int extra_step = ( ( num_4x4_w - max_blocks_wide ) >> tx_size ) * step <S2SV_ModEnd> ; for <S2SV_ModStart> 0 ; <S2SV_ModEnd> r < <S2SV_ModStart> < max_blocks_high ; r += ( 1 << tx_size ) ) { for ( c = 0 ; <S2SV_ModEnd> c < <S2SV_ModStart> < max_blocks_wide ; c += ( 1 << tx_size ) ) { <S2SV_ModEnd> visit ( <S2SV_ModStart> ; } i += extra_step <S2SV_ModEnd> ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> PREDICTION_MODE <S2SV_ModEnd> vp9_left_block_mode (
<S2SV_ModStart> else { memset <S2SV_ModEnd> ( a <S2SV_ModStart> else { memset <S2SV_ModEnd> ( l
<S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> int mi_row , mi_col <S2SV_ModEnd> ; MODE_INFO <S2SV_ModStart> * * mi <S2SV_ModEnd> = cm <S2SV_ModStart> file ) <S2SV_ModEnd> ; for <S2SV_ModStart> ( & mi [ 0 <S2SV_ModEnd> ] -> <S2SV_ModStart> ) ; mi <S2SV_ModEnd> ++ ; <S2SV_ModStart> ) ; mi <S2SV_ModEnd> += 8
<S2SV_ModStart> mi_col ; <S2SV_ModEnd> FILE * <S2SV_ModStart> * * mi <S2SV_ModEnd> = cm <S2SV_ModStart> mvs , "Ref<S2SV_blank>frame:" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ; print_mi_data ( cm , mvs , "Transform:" , offsetof ( MB_MODE_INFO , tx_size ) ) ; print_mi_data ( cm , mvs , "UV<S2SV_blank>Modes:" , offsetof ( MB_MODE_INFO , uv_mode ) ) ; log_frame_info ( cm , "Skips:" <S2SV_ModEnd> , mvs <S2SV_ModStart> mvs , "S<S2SV_blank>" <S2SV_ModEnd> ) ; <S2SV_ModStart> mvs , "%2d<S2SV_blank>" , mi [ 0 <S2SV_ModEnd> ] -> <S2SV_ModStart> mbmi . skip ) ; mi <S2SV_ModEnd> ++ ; <S2SV_ModStart> ) ; mi <S2SV_ModEnd> += 8 <S2SV_ModStart> ) ; log_frame_info ( cm , "Vectors<S2SV_blank>" , mvs ) ; mi = cm -> mi_grid_visible ; for ( mi_row = 0 ; mi_row < rows ; mi_row ++ ) { fprintf ( mvs , "V<S2SV_blank>" ) ; for ( mi_col = 0 ; mi_col < cols ; mi_col ++ ) { fprintf ( mvs , "%4d:%4d<S2SV_blank>" , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv . col ) ; mi ++ ; } fprintf ( mvs , "\\n" ) ; mi += 8 ; } fprintf ( mvs , "\\n" ) ;
<S2SV_ModStart> -> fc -> <S2SV_ModEnd> coef_probs [
<S2SV_ModStart> extend_to_full_distribution ( vpx_prob <S2SV_ModEnd> * probs <S2SV_ModStart> probs , vpx_prob <S2SV_ModEnd> p ) <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( probs <S2SV_ModStart> sizeof ( vpx_prob <S2SV_ModEnd> ) )
<S2SV_ModStart> -> fc -> <S2SV_ModEnd> coef_probs [ <S2SV_ModStart> -> fc -> <S2SV_ModEnd> coef_probs [ <S2SV_ModStart> -> fc -> <S2SV_ModEnd> coef_probs [ <S2SV_ModStart> -> fc -> <S2SV_ModEnd> coef_probs [
<S2SV_ModStart> ( const vpx_prob <S2SV_ModEnd> * model <S2SV_ModStart> model , vpx_prob <S2SV_ModEnd> * full <S2SV_ModStart> model ) memcpy <S2SV_ModEnd> ( full <S2SV_ModStart> sizeof ( vpx_prob <S2SV_ModEnd> ) *
<S2SV_ModStart> fc = <S2SV_ModEnd> cm -> <S2SV_ModStart> ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc <S2SV_ModStart> ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc <S2SV_ModStart> ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_fc <S2SV_ModStart> ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> <S2SV_ModStart> ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_inter_mode_tree <S2SV_ModStart> ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree <S2SV_ModStart> i ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_intra_mode_tree <S2SV_ModStart> ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_partition_tree <S2SV_ModStart> ++ ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_switchable_interp_tree <S2SV_ModStart> ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> <S2SV_ModStart> ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> <S2SV_ModStart> ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc -> <S2SV_ModStart> ] = mode_mv_merge_probs ( <S2SV_ModEnd> pre_fc ->
<S2SV_ModStart> -> last_frame_seg_map && ! cm -> frame_parallel_decode ) memset <S2SV_ModEnd> ( cm <S2SV_ModStart> -> last_frame_seg_map , 0 , ( cm -> mi_rows * cm -> mi_cols ) ) ; if ( cm -> current_frame_seg_map ) memset ( cm -> current_frame_seg_map <S2SV_ModStart> ) ; init_mode_probs ( <S2SV_ModEnd> cm -> <S2SV_ModStart> cm ) ; cm -> fc -> initialized = 1 <S2SV_ModStart> ] = * <S2SV_ModStart> ] = * <S2SV_ModStart> cm ) && <S2SV_ModEnd> cm -> <S2SV_ModStart> -> prev_mip && ! cm -> frame_parallel_decode ) memset ( cm -> prev_mip , 0 , <S2SV_ModEnd> cm -> <S2SV_ModStart> -> prev_mip <S2SV_ModEnd> ) )
<S2SV_ModStart> -> fc -> <S2SV_ModEnd> nmvc ; <S2SV_ModStart> mv ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_joint_tree <S2SV_ModStart> sign = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp <S2SV_ModStart> ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class_tree <S2SV_ModStart> ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_class0_tree <S2SV_ModStart> ] = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp <S2SV_ModStart> j ) vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree <S2SV_ModStart> ) ; vpx_tree_merge_probs <S2SV_ModEnd> ( vp9_mv_fp_tree <S2SV_ModStart> class0_hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp <S2SV_ModStart> hp = mode_mv_merge_probs <S2SV_ModEnd> ( pre_comp
<S2SV_ModStart> -> fc -> <S2SV_ModEnd> nmvc =
<S2SV_ModStart> 1 ; memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;
<S2SV_ModStart> cb_priv ; if ( int_fb )
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> 1 ) vpx_idct16x16_1_add <S2SV_ModEnd> ( input <S2SV_ModStart> 10 ) vpx_idct16x16_10_add <S2SV_ModEnd> ( input <S2SV_ModStart> ; else vpx_idct16x16_256_add <S2SV_ModEnd> ( input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> 1 ) vpx_idct32x32_1_add <S2SV_ModEnd> ( input <S2SV_ModStart> 34 ) vpx_idct32x32_34_add <S2SV_ModEnd> ( input <S2SV_ModStart> ; else vpx_idct32x32_1024_add <S2SV_ModEnd> ( input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> 1 ) vpx_idct4x4_16_add <S2SV_ModEnd> ( input <S2SV_ModStart> ; else vpx_idct4x4_1_add <S2SV_ModEnd> ( input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> 1 ) vpx_idct8x8_1_add <S2SV_ModEnd> ( input <S2SV_ModStart> eob <= 12 ) vpx_idct8x8_12_add <S2SV_ModEnd> ( input <S2SV_ModStart> ; else vpx_idct8x8_64_add <S2SV_ModEnd> ( input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * outptr <S2SV_ModStart> out ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) { <S2SV_ModStart> ] = clip_pixel_add ( <S2SV_ModEnd> dest [ <S2SV_ModStart> i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) ) ; } <S2SV_ModEnd> } }
<S2SV_ModStart> , const tran_low_t <S2SV_ModEnd> * input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> { { idct4_c , idct4_c } , { iadst4_c , idct4_c } , { idct4_c , iadst4_c } , { iadst4_c , iadst4_c <S2SV_ModEnd> } } <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * outptr <S2SV_ModStart> out ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) { <S2SV_ModStart> ] = clip_pixel_add ( <S2SV_ModEnd> dest [ <S2SV_ModStart> i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) ) ; } <S2SV_ModEnd> } }
<S2SV_ModStart> , const tran_low_t <S2SV_ModEnd> * input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * outptr <S2SV_ModStart> out ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) { <S2SV_ModStart> ] = clip_pixel_add ( <S2SV_ModEnd> dest [ <S2SV_ModStart> i ] , ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) ) ; } <S2SV_ModEnd> } }
<S2SV_ModStart> , const tran_low_t <S2SV_ModEnd> * input
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> 1 ) vpx_iwht4x4_16_add <S2SV_ModEnd> ( input <S2SV_ModStart> ; else vpx_iwht4x4_1_add <S2SV_ModEnd> ( input
<S2SV_ModStart> tx_size_uv = get_uv_tx_size_impl ( tx_size_y , block_size , 1 , 1 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( & <S2SV_ModStart> ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) <<
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( & <S2SV_ModStart> ] & 0xffffffffffffffffULL <S2SV_ModEnd> ) <<
<S2SV_ModStart> ) { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_horizontal_16 <S2SV_ModEnd> ( s <S2SV_ModStart> ) ; vpx_lpf_horizontal_8_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s <S2SV_ModStart> 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_horizontal_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s <S2SV_ModStart> ) ; vpx_lpf_horizontal_4_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_horizontal_4_dual ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , lfin -> mblim , lfin -> lim , lfin -> hev_thr ) ; } else { if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s <S2SV_ModStart> 2 ) vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_horizontal_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; if ( mask_4x4_int & 1 ) vpx_lpf_horizontal_4 ( s + 4 * pitch , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } else if ( mask_4x4_int & 1 ) { vpx_lpf_horizontal_4 <S2SV_ModEnd> ( s
<S2SV_ModStart> ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vpx_lpf_vertical_4 <S2SV_ModEnd> ( s
<S2SV_ModStart> filter_selectively_vert_row2 ( int subsampling_factor <S2SV_ModEnd> , uint8_t <S2SV_ModStart> mask_shift = subsampling_factor <S2SV_ModEnd> ? 4 <S2SV_ModStart> mask_cutoff = subsampling_factor <S2SV_ModEnd> ? 0xf <S2SV_ModStart> lfl_forward = subsampling_factor <S2SV_ModEnd> ? 4 <S2SV_ModStart> ) { vpx_lpf_vertical_16_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_vertical_16 <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_8_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_vertical_8 <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_4_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_4_dual <S2SV_ModEnd> ( s <S2SV_ModStart> ) { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s <S2SV_ModStart> else { vpx_lpf_vertical_4 <S2SV_ModEnd> ( s
<S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( lfi <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( lfi
<S2SV_ModStart> vp9_loop_filter_frame ( YV12_BUFFER_CONFIG * frame , <S2SV_ModStart> vp9_loop_filter_rows ( frame <S2SV_ModEnd> , cm <S2SV_ModStart> , xd -> plane
<S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> data = get_segdata <S2SV_ModEnd> ( seg <S2SV_ModStart> ) { memset <S2SV_ModEnd> ( lfi
<S2SV_ModStart> ++ ) memset <S2SV_ModEnd> ( lfi
<S2SV_ModStart> vp9_loop_filter_rows ( <S2SV_ModEnd> YV12_BUFFER_CONFIG * <S2SV_ModStart> cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , int <S2SV_ModStart> MAX_MB_PLANE ; enum lf_path path <S2SV_ModEnd> ; LOOP_FILTER_MASK <S2SV_ModStart> ; int mi_row , mi_col ; if ( y_only ) path = LF_PATH_444 ; else if ( planes <S2SV_ModEnd> [ 1 <S2SV_ModStart> 1 && planes <S2SV_ModEnd> [ 1 <S2SV_ModStart> 1 ) path = LF_PATH_420 ; else if ( planes [ 1 ] . subsampling_y == 0 && planes [ 1 ] . subsampling_x == 0 ) path = LF_PATH_444 ; else path = LF_PATH_SLOW <S2SV_ModStart> * * mi <S2SV_ModEnd> = cm <S2SV_ModStart> vp9_setup_dst_planes ( planes <S2SV_ModEnd> , frame_buffer <S2SV_ModStart> ) ; <S2SV_ModEnd> vp9_setup_mask ( <S2SV_ModStart> mi_col , mi <S2SV_ModEnd> + mi_col <S2SV_ModStart> ) ; vp9_filter_block_plane_ss00 ( cm , & planes [ 0 ] , mi_row , & lfm ) ; <S2SV_ModStart> plane = 1 <S2SV_ModEnd> ; plane <S2SV_ModStart> ) { switch ( path ) { case LF_PATH_420 : vp9_filter_block_plane_ss11 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_444 : vp9_filter_block_plane_ss00 ( cm , & planes [ plane ] , mi_row , & lfm ) ; break ; case LF_PATH_SLOW : vp9_filter_block_plane_non420 ( cm , & planes [ plane ] , mi <S2SV_ModEnd> + mi_col <S2SV_ModStart> ) ; break ; }
<S2SV_ModStart> vp9_loop_filter_worker ( <S2SV_ModEnd> LFWorkerData * <S2SV_ModStart> const lf_data , void * unused ) { <S2SV_ModEnd> ( void <S2SV_ModStart> void ) unused <S2SV_ModEnd> ; vp9_loop_filter_rows <S2SV_ModStart> cm , <S2SV_ModEnd> lf_data -> <S2SV_ModStart> lf_data -> planes <S2SV_ModEnd> , lf_data
<S2SV_ModStart> * * mi <S2SV_ModEnd> , const <S2SV_ModStart> mip = mi <S2SV_ModEnd> ; MODE_INFO <S2SV_ModStart> mip2 = mi <S2SV_ModEnd> ; const <S2SV_ModStart> * lfm ) ; assert ( mip [ 0 ] != NULL <S2SV_ModStart> ) * 0x0101010101010101ULL <S2SV_ModEnd> ; const <S2SV_ModStart> ] &= 0xfefefefefefefefeULL <S2SV_ModEnd> ; lfm
<S2SV_ModStart> int delta , vpx_bit_depth_t bit_depth <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModStart> ] ; case VPX_BITS_10 : return ac_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return ac_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> int delta , vpx_bit_depth_t bit_depth <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModStart> ] ; case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
<S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> data = get_segdata <S2SV_ModEnd> ( seg
<S2SV_ModStart> kernel = vp9_filter_kernels [ <S2SV_ModEnd> mi -> <S2SV_ModStart> . interp_filter ] <S2SV_ModEnd> ; int <S2SV_ModStart> BLOCK_8X8 ? average_split_mvs ( pd , mi , ref , block <S2SV_ModEnd> ) : <S2SV_ModStart> subpel_y ; const int is_scaled = vp9_is_scaled ( sf ) ; <S2SV_ModStart> if ( is_scaled <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { high_inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys , xd -> bd ) ; } else { <S2SV_ModStart> ) ; } # else inter_predictor ( pre , pre_buf -> stride , dst , dst_buf -> stride , subpel_x , subpel_y , sf , w , h , ref , kernel , xs , ys ) ; # endif
<S2SV_ModStart> vp9_setup_dst_planes ( struct macroblockd_plane planes [ MAX_MB_PLANE ] <S2SV_ModEnd> , const <S2SV_ModStart> buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = <S2SV_ModStart> -> v_buffer <S2SV_ModEnd> } ; <S2SV_ModStart> strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = <S2SV_ModStart> -> uv_stride <S2SV_ModEnd> } ; <S2SV_ModStart> = & planes <S2SV_ModEnd> [ i
<S2SV_ModStart> buffers [ MAX_MB_PLANE <S2SV_ModEnd> ] = <S2SV_ModStart> -> v_buffer <S2SV_ModEnd> } ; <S2SV_ModStart> strides [ MAX_MB_PLANE <S2SV_ModEnd> ] = <S2SV_ModStart> -> uv_stride <S2SV_ModEnd> } ;
<S2SV_ModStart> dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> i ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ] ; <S2SV_ModEnd> if ( <S2SV_ModStart> y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( <S2SV_ModStart> } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> x0 + <S2SV_ModEnd> bs <= <S2SV_ModStart> ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width <S2SV_ModStart> x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else <S2SV_ModStart> else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> if ( <S2SV_ModStart> && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ <S2SV_ModStart> ; } else { memset <S2SV_ModEnd> ( above_row <S2SV_ModStart> 127 ; }
<S2SV_ModStart> , int <S2SV_ModEnd> bwl_in , <S2SV_ModStart> tx_size , PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> const int bw <S2SV_ModEnd> = ( <S2SV_ModStart> 1 << bwl_in ) ; const int txw = ( 1 << tx_size ) <S2SV_ModEnd> ; const <S2SV_ModStart> have_top = loff <S2SV_ModEnd> || xd <S2SV_ModStart> have_left = aoff || xd -> left_available ; const int have_right = ( aoff + txw ) < bw ; const int x = aoff * 4 ; const int y = loff * 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { build_intra_predictors_high ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane , xd -> bd ) ; return ; } # endif <S2SV_ModEnd> build_intra_predictors (
<S2SV_ModStart> ) { <S2SV_ModEnd> once (
<S2SV_ModStart> ) { # endif <S2SV_ModStart> ( ! valid_ref_frame_size <S2SV_ModEnd> ( other_w <S2SV_ModStart> ] = vpx_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_convolve8_avg_horiz <S2SV_ModEnd> ; } <S2SV_ModStart> ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d <S2SV_ModEnd> ; } <S2SV_ModStart> ] = vpx_scaled_horiz ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_horiz <S2SV_ModEnd> ; } <S2SV_ModStart> ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vpx_scaled_avg_2d ; } } if ( ( sf -> x_step_q4 != 16 ) || ( sf -> y_step_q4 != 16 ) ) { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_scaled_2d ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_scaled_avg_2d ; } else { sf -> predict [ 1 ] [ 1 ] [ 0 ] = vpx_convolve8 ; sf -> predict [ 1 ] [ 1 ] [ 1 ] = vpx_convolve8_avg ; } # if CONFIG_VP9_HIGHBITDEPTH if ( use_highbd ) { if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve_copy ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8_vert ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg_vert ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } else { if ( sf -> y_step_q4 == 16 ) { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8_horiz ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg_horiz ; } else { sf -> highbd_predict [ 0 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 0 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 0 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; sf -> highbd_predict [ 1 ] [ 0 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 0 ] [ 1 ] = vpx_highbd_convolve8_avg ; } } sf -> highbd_predict [ 1 ] [ 1 ] [ 0 ] = vpx_highbd_convolve8 ; sf -> highbd_predict [ 1 ] [ 1 ] [ 1 ] = vpx_highbd_convolve8_avg ; } # endif <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> const int sb64_cols <S2SV_ModEnd> = mi_cols_aligned_to_sb <S2SV_ModStart> MI_BLOCK_SIZE_LOG2 ; <S2SV_ModEnd> * min_log2_tile_cols <S2SV_ModStart> min_log2_tile_cols = get_min_log2_tile_cols ( sb64_cols ) <S2SV_ModEnd> ; * <S2SV_ModStart> max_log2_tile_cols = get_max_log2_tile_cols ( sb64_cols ) ; assert ( * min_log2_tile_cols <= * max_log2_tile_cols ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { vp9_tile_set_row ( tile <S2SV_ModEnd> , cm <S2SV_ModStart> , cm , row <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; vp9_tile_set_col ( tile <S2SV_ModEnd> , cm <S2SV_ModStart> , cm , col <S2SV_ModEnd> ) ;

<S2SV_ModStart> b ; return ( int ) ( buf2 -> size - <S2SV_ModEnd> buf1 -> <S2SV_ModStart> -> size ) <S2SV_ModEnd> ; } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> tile_col ; int mi_row , mi_col ; TileData * tile_data <S2SV_ModEnd> = NULL <S2SV_ModStart> NULL ; if ( cm -> lf . filter_level && ! cm -> skip_loop_filter && pbi -> lf_worker . data1 == NULL ) { CHECK_MEM_ERROR ( cm , pbi -> lf_worker . data1 , vpx_memalign ( 32 , sizeof ( LFWorkerData ) ) ) ; pbi -> lf_worker . hook = ( VPxWorkerHook ) vp9_loop_filter_worker ; if ( pbi -> max_threads > 1 && ! winterface -> reset ( & pbi -> lf_worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , "Loop<S2SV_blank>filter<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; vp9_loop_filter_data_reset ( lf_data , get_frame_new_buffer ( cm ) , cm , pbi -> mb . plane ) ; } <S2SV_ModEnd> assert ( <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; if ( pbi -> tile_data == NULL || ( tile_cols * tile_rows ) != pbi -> total_tiles ) { vpx_free ( pbi -> tile_data ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_data , vpx_memalign ( 32 , tile_cols * tile_rows * ( sizeof ( * pbi -> tile_data ) ) ) ) ; pbi -> total_tiles = tile_rows * tile_cols ; } <S2SV_ModStart> { const TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; tile_data = pbi -> tile_data + tile_cols * tile_row + tile_col ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? NULL : & cm -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( & tile_data -> xd . tile , tile_data -> cm , tile_row , tile_col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { TileInfo tile ; vp9_tile_set_row ( & tile , cm , tile_row ) ; for ( mi_row = tile . mi_row_start ; mi_row < tile . mi_row_end ; mi_row += MI_BLOCK_SIZE ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; tile_data = pbi -> tile_data + tile_cols * tile_row + col ; vp9_tile_set_col ( & tile , tile_data -> cm , col ) ; vp9_zero ( tile_data -> xd . left_context ) ; vp9_zero ( tile_data -> xd . left_seg_context ) ; for ( mi_col = tile . mi_col_start ; mi_col < tile . mi_col_end ; mi_col += MI_BLOCK_SIZE ) { decode_partition ( pbi , & tile_data -> xd , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 , 4 ) ; } pbi -> mb . corrupted |= tile_data -> xd . corrupted ; if ( pbi -> mb . corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>tile<S2SV_blank>data" ) ; } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { const int lf_start = mi_row - MI_BLOCK_SIZE ; LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; if ( lf_start < 0 ) continue ; if ( mi_row + MI_BLOCK_SIZE >= cm -> mi_rows ) continue ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_start ; lf_data -> stop = mi_row ; if ( pbi -> max_threads > 1 ) { winterface -> launch ( & pbi -> lf_worker ) ; } else { winterface -> execute ( & pbi -> lf_worker ) ; } } if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , mi_row << MI_BLOCK_SIZE_LOG2 ) ; } } if ( cm -> lf . filter_level && ! cm -> skip_loop_filter ) { LFWorkerData * const lf_data = ( LFWorkerData * ) pbi -> lf_worker . data1 ; winterface -> sync ( & pbi -> lf_worker ) ; lf_data -> start = lf_data -> stop ; lf_data -> stop = cm -> mi_rows ; winterface -> execute ( & pbi -> lf_worker ) ; } tile_data = pbi -> tile_data + tile_cols * <S2SV_ModEnd> tile_rows - <S2SV_ModStart> - 1 ; if ( pbi -> frame_parallel_decode ) vp9_frameworker_broadcast ( pbi -> cur_buf , INT_MAX ) ; return vpx_reader_find_end ( & tile_data -> bit_reader ) <S2SV_ModEnd> ; }
<S2SV_ModStart> -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> pbi -> <S2SV_ModEnd> max_threads & <S2SV_ModStart> [ 1 ] [ 1 <S2SV_ModStart> pbi -> <S2SV_ModEnd> max_threads & <S2SV_ModStart> -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> ) { VPxWorker <S2SV_ModEnd> * const <S2SV_ModStart> num_tile_workers ; winterface -> init ( worker <S2SV_ModEnd> ) ; <S2SV_ModStart> && ! winterface -> reset <S2SV_ModEnd> ( worker <S2SV_ModStart> ) { VPxWorker * const worker = & <S2SV_ModStart> n ] ; winterface -> sync ( worker ) ; worker -> <S2SV_ModEnd> hook = <S2SV_ModStart> = ( VPxWorkerHook <S2SV_ModEnd> ) tile_worker_hook <S2SV_ModStart> tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start <S2SV_ModEnd> < tile_cols <S2SV_ModStart> < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers <S2SV_ModStart> ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <S2SV_ModEnd> n == <S2SV_ModStart> - 1 ) { winterface -> execute <S2SV_ModEnd> ( worker <S2SV_ModStart> else { winterface -> launch <S2SV_ModEnd> ( worker <S2SV_ModStart> ) { VPxWorker <S2SV_ModEnd> * const <S2SV_ModStart> |= ! winterface -> sync <S2SV_ModEnd> ( worker <S2SV_ModStart> bit_reader_end = vpx_reader_find_end <S2SV_ModEnd> ( & <S2SV_ModStart> 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }
<S2SV_ModStart> ( struct vpx_read_bit_buffer <S2SV_ModEnd> * rb <S2SV_ModStart> data = vpx_rb_read_literal <S2SV_ModEnd> ( rb
<S2SV_ModStart> predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> , TX_SIZE <S2SV_ModStart> TX_SIZE tx_size <S2SV_ModEnd> ) { <S2SV_ModStart> ) { <S2SV_ModEnd> struct macroblockd_plane <S2SV_ModStart> ] ; PREDICTION_MODE <S2SV_ModEnd> mode = <S2SV_ModStart> ) ? mbmi -> mode : mbmi -> <S2SV_ModEnd> uv_mode ; <S2SV_ModStart> uv_mode ; <S2SV_ModEnd> uint8_t * <S2SV_ModStart> dst ; <S2SV_ModEnd> dst = <S2SV_ModStart> 4 * row <S2SV_ModEnd> * pd <S2SV_ModStart> 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> << 1 <S2SV_ModStart> 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> , plane <S2SV_ModStart> ( ! mbmi -> <S2SV_ModEnd> skip ) <S2SV_ModStart> { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> eob )
<S2SV_ModStart> fc = cm -> fc ; vpx_reader <S2SV_ModEnd> r ; <S2SV_ModStart> if ( vpx_reader_init <S2SV_ModEnd> ( & <S2SV_ModStart> , partition_size , pbi -> decrypt_cb , pbi -> decrypt_state <S2SV_ModStart> } return vpx_reader_has_error <S2SV_ModEnd> ( &
<S2SV_ModStart> cm , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> { return vpx_read_bit <S2SV_ModEnd> ( r <S2SV_ModStart> ? ( vpx_read_bit <S2SV_ModEnd> ( r
<S2SV_ModStart> cm , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> fc = <S2SV_ModEnd> cm ->
<S2SV_ModStart> fc , vpx_reader <S2SV_ModEnd> * r
<S2SV_ModStart> allow_hp , vpx_reader <S2SV_ModEnd> * r
<S2SV_ModStart> fc , vpx_reader <S2SV_ModEnd> * r
<S2SV_ModStart> read_tx_mode ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> tx_mode = vpx_read_literal <S2SV_ModEnd> ( r <S2SV_ModStart> tx_mode += vpx_read_bit <S2SV_ModEnd> ( r
<S2SV_ModStart> tx_probs , vpx_reader <S2SV_ModEnd> * r
<S2SV_ModStart> , struct vpx_read_bit_buffer <S2SV_ModEnd> * rb <S2SV_ModStart> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; int i , mask , ref_index = 0 ; <S2SV_ModStart> sz ; <S2SV_ModEnd> cm -> <S2SV_ModStart> frame_type ; cm -> last_intra_only = cm -> intra_only ; if ( vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> profile = vp9_read_profile ( rb ) ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; # else if ( cm -> profile >= PROFILE_2 ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Unsupported<S2SV_blank>bitstream<S2SV_blank>profile" ) ; # endif <S2SV_ModStart> show_existing_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> ref_frame_map [ vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> ] ; lock_buffer_pool ( pool ) ; if ( frame_to_show < 0 || <S2SV_ModEnd> frame_bufs [ <S2SV_ModStart> 1 ) { unlock_buffer_pool ( pool ) ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , <S2SV_ModStart> , frame_to_show ) ; unlock_buffer_pool ( pool <S2SV_ModStart> 1 ; if ( pbi -> frame_parallel_decode ) { for ( i = 0 ; i < REF_FRAMES ; ++ i ) cm -> next_ref_frame_map [ i ] = cm -> ref_frame_map [ i ] ; } <S2SV_ModStart> FRAME_TYPE ) vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> show_frame = vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> error_resilient_mode = vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> ) { if ( ! vp9_read_sync_code ( rb ) ) <S2SV_ModEnd> vpx_internal_error ( <S2SV_ModStart> VPX_CODEC_UNSUP_BITSTREAM , "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; read_bitdepth_colorspace_sampling ( cm , rb ) ; <S2SV_ModEnd> pbi -> <S2SV_ModStart> idx = INVALID_IDX <S2SV_ModEnd> ; cm <S2SV_ModStart> buf = NULL <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> 0 : vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> 0 : vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> ) { if ( ! vp9_read_sync_code ( rb ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , "Invalid<S2SV_blank>frame<S2SV_blank>sync<S2SV_blank>code" ) ; if ( cm -> profile > PROFILE_0 ) { read_bitdepth_colorspace_sampling ( cm , rb ) ; } else { cm -> color_space = VPX_CS_BT_601 ; cm -> subsampling_y = cm -> subsampling_x = 1 ; cm -> bit_depth = VPX_BITS_8 ; # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth = 0 ; # endif } <S2SV_ModEnd> pbi -> <S2SV_ModStart> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> ) ; if ( pbi -> need_resync ) { memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; pbi -> need_resync = 0 ; } <S2SV_ModStart> } else if ( pbi -> need_resync != 1 ) <S2SV_ModStart> refresh_frame_flags = vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> ref = vpx_rb_read_literal <S2SV_ModEnd> ( rb <S2SV_ModStart> ] ; RefBuffer * const ref_frame = & <S2SV_ModStart> i ] ; ref_frame -> <S2SV_ModEnd> idx = <S2SV_ModStart> idx ; ref_frame -> buf = & frame_bufs [ idx <S2SV_ModEnd> ] . <S2SV_ModStart> . buf <S2SV_ModEnd> ; cm <S2SV_ModStart> ] = vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> allow_high_precision_mv = vpx_rb_read_bit <S2SV_ModEnd> ( rb <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame <S2SV_ModEnd> ( & <S2SV_ModStart> -> sf , <S2SV_ModEnd> ref_buf -> <S2SV_ModStart> -> buf -> y_crop_width , ref_buf -> buf -> y_crop_height , cm -> width , cm -> height ) ; # endif } } } # if CONFIG_VP9_HIGHBITDEPTH get_frame_new_buffer ( cm ) -> bit_depth = cm -> bit_depth ; # endif get_frame_new_buffer ( cm ) -> color_space = cm -> color_space ; if ( pbi -> need_resync ) { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Keyframe<S2SV_blank>/<S2SV_blank>intra-only<S2SV_blank>frame<S2SV_blank>required<S2SV_blank>to<S2SV_blank>reset<S2SV_blank>decoder" "<S2SV_blank>state" ) ; <S2SV_ModEnd> } if <S2SV_ModStart> cm -> refresh_frame_context = vpx_rb_read_bit ( rb ) ; cm -> frame_parallel_decoding_mode = vpx_rb_read_bit ( rb ) ; } else { cm -> refresh_frame_context = 0 ; cm -> frame_parallel_decoding_mode <S2SV_ModEnd> = 1 <S2SV_ModStart> 1 ; } cm -> frame_context_idx = vpx_rb_read_literal ( rb , FRAME_CONTEXTS_LOG2 ) ; lock_buffer_pool ( pool ) ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { if ( mask & 1 ) { cm -> next_ref_frame_map [ ref_index ] = cm -> new_fb_idx ; ++ frame_bufs [ cm -> new_fb_idx ] . ref_count <S2SV_ModEnd> ; } <S2SV_ModStart> cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; } if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES ; ++ ref_index ) { cm -> next_ref_frame_map [ ref_index ] = cm -> ref_frame_map [ ref_index ] ; if ( cm -> ref_frame_map [ ref_index ] >= 0 ) ++ frame_bufs [ cm -> ref_frame_map [ ref_index ] ] . ref_count ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf <S2SV_ModEnd> = 1 <S2SV_ModStart> 1 ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; setup_segmentation_dequant ( cm ) ; <S2SV_ModStart> sz = vpx_rb_read_literal <S2SV_ModEnd> ( rb
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> reconstruct_inter_block ( <S2SV_ModStart> reconstruct_inter_block ( <S2SV_ModEnd> MACROBLOCKD * <S2SV_ModStart> const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane <S2SV_ModStart> ] ; const scan_order * sc = & vp9_default_scan_orders [ tx_size ] ; const int <S2SV_ModEnd> eob = <S2SV_ModStart> = vp9_decode_block_tokens <S2SV_ModEnd> ( xd <S2SV_ModStart> plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_inter ( xd , plane <S2SV_ModEnd> , tx_size <S2SV_ModStart> 4 * row <S2SV_ModEnd> * pd <S2SV_ModStart> 4 * col <S2SV_ModEnd> ] , <S2SV_ModStart> ) ; return <S2SV_ModEnd> eob ;
<S2SV_ModStart> tile_worker_hook ( <S2SV_ModEnd> TileWorkerData * <S2SV_ModStart> const tile_data , <S2SV_ModEnd> const TileInfo <S2SV_ModStart> const tile ) { <S2SV_ModEnd> int mi_row <S2SV_ModStart> , mi_col ; if ( setjmp ( tile_data -> error_info . jmp ) ) { tile_data -> error_info . setjmp = 0 ; tile_data -> xd . corrupted = 1 ; return 0 ; } tile_data -> error_info . setjmp = 1 ; tile_data -> xd . error_info = & tile_data -> error_info <S2SV_ModStart> tile_data -> pbi <S2SV_ModEnd> , & <S2SV_ModStart> -> xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> , BLOCK_64X64 , 4
<S2SV_ModStart> update_mv_probs ( vpx_prob <S2SV_ModEnd> * p <S2SV_ModStart> n , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> if ( vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> = ( vpx_read_literal <S2SV_ModEnd> ( r
<S2SV_ModStart> <S2SV_null> <S2SV_null> void vp9_decode_frame ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end , const uint8_t * * p_data_end ) { VP9_COMMON * const cm = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; struct vpx_read_bit_buffer rb ; int context_updated = 0 ; uint8_t clear_data [ MAX_VP9_HEADER_SIZE ] <S2SV_ModEnd> ; const <S2SV_ModStart> pbi , init_read_bit_buffer ( pbi , <S2SV_ModStart> & rb , data , data_end , clear_data ) ) <S2SV_ModEnd> ; const <S2SV_ModStart> data + ( cm -> profile <= PROFILE_2 ? 1 : 2 ) <S2SV_ModEnd> ; return <S2SV_ModStart> ; return ; } <S2SV_ModEnd> data += <S2SV_ModStart> data += vpx_rb_bytes_read <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> last_intra_only && cm -> last_show_frame && ( cm -> last_frame_type != KEY_FRAME ) ; vp9_setup_block_planes ( xd , cm -> subsampling_x , cm -> subsampling_y ) ; * cm -> fc = cm -> frame_contexts [ cm -> frame_context_idx ] ; if ( ! cm -> fc -> initialized ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Uninitialized<S2SV_blank>entropy<S2SV_blank>context." ) ; vp9_zero ( cm -> counts ) ; xd -> corrupted = 0 ; new_fb -> corrupted = read_compressed_header ( pbi , data , first_partition_size ) ; if ( new_fb -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>header<S2SV_blank>is<S2SV_blank>corrupted." ) ; if ( <S2SV_ModEnd> cm -> <S2SV_ModStart> . filter_level && ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_init ( cm , cm -> lf . filter_level ) ; } if ( pbi -> frame_parallel_decode && cm -> frame_parallel_decoding_mode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; if ( cm -> refresh_frame_context ) { context_updated = 1 ; cm -> frame_contexts [ cm -> frame_context_idx ] = * cm -> fc ; } vp9_frameworker_lock_stats ( worker ) ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } if ( pbi -> <S2SV_ModEnd> max_threads > <S2SV_ModStart> 1 && <S2SV_ModEnd> tile_rows == <S2SV_ModStart> > 1 <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; if ( ! xd -> corrupted ) { if ( ! cm -> skip_loop_filter ) { vp9_loop_filter_frame_mt ( new_fb , cm , pbi -> mb . plane , cm -> lf . filter_level , 0 , 0 , pbi -> tile_workers , pbi -> num_tile_workers , & pbi -> lf_row_sync ) ; } } else { vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted." ) ; } <S2SV_ModStart> ; } if ( ! xd <S2SV_ModEnd> -> corrupted <S2SV_ModStart> -> corrupted ) { if ( ! cm -> error_resilient_mode && ! cm -> frame_parallel_decoding_mode ) { vp9_adapt_coef_probs ( cm ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_adapt_mode_probs ( cm ) ; vp9_adapt_mv_probs ( cm , cm -> allow_high_precision_mv ) ; } } else { debug_check_frame_counts ( cm ) ; } } else { <S2SV_ModEnd> vpx_internal_error ( <S2SV_ModStart> VPX_CODEC_CORRUPT_FRAME , "Decode<S2SV_blank>failed.<S2SV_blank>Frame<S2SV_blank>data<S2SV_blank>is<S2SV_blank>corrupted." <S2SV_ModEnd> ) ; <S2SV_ModStart> -> refresh_frame_context && ! context_updated <S2SV_ModStart> ] = * <S2SV_ModStart> fc ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> xd , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> REFERENCE_MODE ) vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> -> fc -> <S2SV_ModEnd> comp_inter_prob [ <S2SV_ModStart> ) ; FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ) ++ counts -> <S2SV_ModEnd> comp_inter [
<S2SV_ModStart> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_inter_mode ( <S2SV_ModStart> cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> mode = vpx_read_tree <S2SV_ModEnd> ( r <S2SV_ModStart> -> fc -> <S2SV_ModEnd> inter_mode_probs [ <S2SV_ModStart> ) ; FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ) ++ counts -> <S2SV_ModEnd> inter_mode [
<S2SV_ModStart> mi_col , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> mbmi ; int predicted_segment_id , segment_id ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) <S2SV_ModEnd> ; if <S2SV_ModStart> predicted_segment_id = <S2SV_ModEnd> cm -> <S2SV_ModStart> -> last_frame_seg_map ? dec_get_segment_id ( cm , cm -> last_frame_seg_map , mi_offset , x_mis , y_mis ) : 0 <S2SV_ModEnd> ; if <S2SV_ModStart> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> predicted_segment_id ; } <S2SV_ModStart> { const vpx_prob <S2SV_ModEnd> pred_prob = <S2SV_ModStart> seg_id_predicted = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id
<S2SV_ModStart> mi_col , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> xd -> above_mi <S2SV_ModEnd> ; const <S2SV_ModStart> xd -> left_mi <S2SV_ModEnd> ; const <S2SV_ModStart> i ; const int mi_offset = mi_row * cm -> mi_cols + mi_col ; const int bw = xd -> plane [ 0 ] . n4_w >> 1 ; const int bh = xd -> plane [ 0 ] . n4_h >> 1 ; const int x_mis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int y_mis = MIN ( cm -> mi_rows - mi_row , bh ) ; <S2SV_ModStart> cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , r <S2SV_ModStart> , xd <S2SV_ModEnd> , 1
<S2SV_ModStart> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode ( <S2SV_ModStart> read_intra_mode ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * p <S2SV_ModStart> return ( PREDICTION_MODE ) vpx_read_tree <S2SV_ModEnd> ( r
<S2SV_ModStart> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_uv ( <S2SV_ModStart> cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> r , PREDICTION_MODE <S2SV_ModEnd> y_mode ) <S2SV_ModStart> { const PREDICTION_MODE <S2SV_ModEnd> uv_mode = <S2SV_ModStart> -> fc -> <S2SV_ModEnd> uv_mode_prob [ <S2SV_ModStart> ) ; FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ) ++ counts -> <S2SV_ModEnd> uv_mode [
<S2SV_ModStart> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_y ( <S2SV_ModStart> cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> { const PREDICTION_MODE <S2SV_ModEnd> y_mode = <S2SV_ModStart> -> fc -> <S2SV_ModEnd> y_mode_prob [ <S2SV_ModStart> ) ; FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ) ++ counts -> <S2SV_ModEnd> y_mode [
<S2SV_ModStart> cm , int mi_offset <S2SV_ModEnd> , int <S2SV_ModStart> , int x_mis <S2SV_ModEnd> , int <S2SV_ModStart> , int y_mis , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> -> seg <S2SV_ModEnd> ; int <S2SV_ModStart> update_map ) { copy_segment_id ( cm , cm -> last_frame_seg_map , cm -> current_frame_seg_map , mi_offset , x_mis , y_mis ) ; <S2SV_ModStart> 0 ; } <S2SV_ModStart> cm , mi_offset , x_mis , y_mis <S2SV_ModEnd> , segment_id
<S2SV_ModStart> read_mv ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> MV_JOINT_TYPE ) vpx_read_tree <S2SV_ModEnd> ( r
<S2SV_ModStart> read_mv_component ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> sign = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> mv_class = vpx_read_tree <S2SV_ModEnd> ( r <S2SV_ModStart> d = vpx_read_tree <S2SV_ModEnd> ( r <S2SV_ModStart> class0 ) ; mag = 0 <S2SV_ModStart> d |= vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> i ; mag = CLASS0_SIZE << ( mv_class + 2 ) ; <S2SV_ModStart> fr = vpx_read_tree <S2SV_ModEnd> ( r <S2SV_ModStart> usehp ? vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> ; mag += ( <S2SV_ModEnd> ( d
<S2SV_ModStart> xd , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> fc = cm -> fc ; FRAME_COUNTS * counts = xd -> counts ; if ( segfeature_active ( <S2SV_ModStart> cm -> <S2SV_ModEnd> seg , <S2SV_ModStart> MV_REFERENCE_FRAME ) get_segdata <S2SV_ModEnd> ( & <S2SV_ModStart> bit = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> bit0 = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> bit1 = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++
<S2SV_ModStart> read_segment_id ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> { return vpx_read_tree <S2SV_ModEnd> ( r
<S2SV_ModStart> max_tx_size , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> ctx = get_tx_size_context <S2SV_ModEnd> ( xd <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> * tx_probs <S2SV_ModStart> -> fc -> <S2SV_ModEnd> tx_probs ) <S2SV_ModStart> tx_size = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> tx_size += vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> tx_size += vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> , & counts -> <S2SV_ModEnd> tx )
<S2SV_ModStart> segment_id , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( & <S2SV_ModStart> skip = vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> -> fc -> <S2SV_ModEnd> skip_probs [ <S2SV_ModStart> ) ; FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ) ++ counts -> <S2SV_ModEnd> skip [
<S2SV_ModStart> xd , <S2SV_ModEnd> int allow_select <S2SV_ModStart> allow_select , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> ) { TX_MODE tx_mode = cm -> tx_mode ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;
<S2SV_ModStart> cm , int mi_offset <S2SV_ModEnd> , int <S2SV_ModStart> , int x_mis <S2SV_ModEnd> , int <S2SV_ModStart> , int y_mis <S2SV_ModEnd> , int <S2SV_ModStart> ) { <S2SV_ModEnd> int x <S2SV_ModStart> y < y_mis <S2SV_ModEnd> ; y <S2SV_ModStart> x < x_mis <S2SV_ModEnd> ; x <S2SV_ModStart> cm -> current_frame_seg_map <S2SV_ModEnd> [ mi_offset
<S2SV_ModStart> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; lock_buffer_pool ( pool ) ; <S2SV_ModStart> ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( <S2SV_ModEnd> ( mask <S2SV_ModStart> 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) <S2SV_ModStart> ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; cm -> ref_frame_map [ ref_index ] = cm -> next_ref_frame_map [ ref_index ] ; } unlock_buffer_pool ( pool ) ; pbi -> hold_ref_buf = 0 ; cm -> frame_to_show = get_frame_new_buffer ( cm ) ; if ( ! pbi -> frame_parallel_decode || ! cm -> show_frame ) { lock_buffer_pool ( pool ) ; -- frame_bufs [ <S2SV_ModEnd> cm -> <S2SV_ModStart> -> new_fb_idx <S2SV_ModEnd> ] . <S2SV_ModStart> . ref_count ; unlock_buffer_pool ( pool ) ; } <S2SV_ModEnd> for ( <S2SV_ModStart> idx = - 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> cfg = get_ref_frame ( cm , 0 ) ; if ( cfg == NULL ) { vpx_internal_error ( <S2SV_ModStart> cm -> error , VPX_CODEC_ERROR , "No<S2SV_blank>\'last\'<S2SV_blank>reference<S2SV_blank>frame" ) ; return VPX_CODEC_ERROR ; } <S2SV_ModEnd> if (
<S2SV_ModStart> vp9_decoder_create ( BufferPool * const pool <S2SV_ModEnd> ) { <S2SV_ModStart> VP9Decoder * volatile <S2SV_ModStart> VP9_COMMON * volatile <S2SV_ModStart> 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> ( & <S2SV_ModStart> ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <S2SV_ModStart> pbi -> <S2SV_ModEnd> ready_for_new_data = <S2SV_ModStart> pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <S2SV_ModEnd> = 0 <S2SV_ModStart> 0 ; vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> ( &
<S2SV_ModStart> ) { <S2SV_ModEnd> int i <S2SV_ModStart> i ; vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> ( & <S2SV_ModStart> . data1 ) ; vpx_free ( pbi -> tile_data <S2SV_ModStart> ) { VPxWorker <S2SV_ModEnd> * const <S2SV_ModStart> ] ; vpx_get_worker_interface ( ) -> end <S2SV_ModEnd> ( worker <S2SV_ModStart> ) ; } <S2SV_ModStart> vpx_free ( pbi -> tile_worker_data <S2SV_ModEnd> ) ; <S2SV_ModStart> vpx_free ( pbi -> tile_worker_info <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> vpx_free ( <S2SV_ModStart> -> num_tile_workers > 0 <S2SV_ModStart> ) { <S2SV_ModEnd> vp9_loop_filter_dealloc ( <S2SV_ModStart> -> lf_row_sync <S2SV_ModEnd> ) ;
<S2SV_ModStart> sd , <S2SV_ModEnd> vp9_ppflags_t * <S2SV_ModStart> ) { VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> ret ; pbi -> ready_for_new_data = 1 ; <S2SV_ModStart> if ( ! cm -> show_frame <S2SV_ModEnd> ) return <S2SV_ModStart> 1 ; <S2SV_ModEnd> # if <S2SV_ModStart> if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> vp9_post_proc_frame ( cm <S2SV_ModEnd> , sd <S2SV_ModStart> ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> = * cm -> frame_to_show <S2SV_ModEnd> ; ret <S2SV_ModStart> # endif vpx_clear_system_state <S2SV_ModEnd> ( )
<S2SV_ModStart> * psource <S2SV_ModEnd> ) { <S2SV_ModStart> VP9_COMMON * volatile <S2SV_ModStart> -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <S2SV_ModEnd> cm -> <S2SV_ModStart> ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && <S2SV_ModEnd> cm -> <S2SV_ModStart> 0 && <S2SV_ModEnd> frame_bufs [ <S2SV_ModStart> 0 ) pool <S2SV_ModEnd> -> release_fb_cb <S2SV_ModStart> release_fb_cb ( pool <S2SV_ModEnd> -> cb_priv <S2SV_ModStart> , & <S2SV_ModEnd> frame_bufs [ <S2SV_ModStart> if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <S2SV_ModStart> ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; <S2SV_ModStart> 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <S2SV_ModEnd> ; return <S2SV_ModStart> 1 ; <S2SV_ModEnd> vp9_decode_frame ( <S2SV_ModStart> ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } <S2SV_ModEnd> cm -> <S2SV_ModStart> error . <S2SV_ModEnd> setjmp = <S2SV_ModStart> = 0 <S2SV_ModEnd> ; return <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> = NULL ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> ) ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; -- <S2SV_ModEnd> frame_bufs [ <S2SV_ModStart> . ref_count <S2SV_ModEnd> ; ref_cnt_fb <S2SV_ModStart> ref_cnt_fb ( <S2SV_ModEnd> frame_bufs , <S2SV_ModStart> = & <S2SV_ModEnd> frame_bufs [
<S2SV_ModStart> decode_coefs ( <S2SV_ModEnd> const MACROBLOCKD <S2SV_ModStart> type , tran_low_t <S2SV_ModEnd> * dqcoeff <S2SV_ModStart> nb , vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModEnd> const int <S2SV_ModStart> fc = xd <S2SV_ModEnd> -> fc <S2SV_ModStart> -> fc <S2SV_ModEnd> ; const <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> ( * <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> * prob <S2SV_ModStart> 1 ] ; unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; uint8_t token_cache [ 32 * 32 ] ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v , token ; int16_t dqv = dq [ 0 ] ; const uint8_t * cat1_prob ; const uint8_t * cat2_prob ; const uint8_t * cat3_prob ; const uint8_t * cat4_prob ; const uint8_t * cat5_prob ; const uint8_t * cat6_prob ; if ( counts ) { coef_counts = <S2SV_ModEnd> counts -> <S2SV_ModStart> ] ; eob_branch_count = <S2SV_ModEnd> counts -> <S2SV_ModStart> ] ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> bd > VPX_BITS_8 ) { if ( xd -> bd == VPX_BITS_10 ) { cat1_prob = vp9_cat1_prob_high10 ; cat2_prob = vp9_cat2_prob_high10 ; cat3_prob = vp9_cat3_prob_high10 ; cat4_prob = vp9_cat4_prob_high10 ; cat5_prob = vp9_cat5_prob_high10 ; cat6_prob = vp9_cat6_prob_high10 ; } else { cat1_prob = vp9_cat1_prob_high12 ; cat2_prob = vp9_cat2_prob_high12 ; cat3_prob = vp9_cat3_prob_high12 ; cat4_prob = vp9_cat4_prob_high12 ; cat5_prob = vp9_cat5_prob_high12 ; cat6_prob = vp9_cat6_prob_high12 ; } } else { cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; } # else cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; # endif <S2SV_ModEnd> while ( <S2SV_ModStart> int val = - 1 <S2SV_ModStart> if ( counts <S2SV_ModEnd> ) ++ <S2SV_ModStart> ( ! vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> ( ! vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> ( ! vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> ) ; token = ONE_TOKEN ; val = 1 ; } else { <S2SV_ModEnd> INCREMENT_COUNT ( <S2SV_ModStart> ) ; token = vpx_read_tree ( r , vp9_coef_con_tree , <S2SV_ModEnd> vp9_pareto8_full [ <S2SV_ModStart> 1 ] ) ; switch ( token ) { case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ; break ; case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; break ; case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; break ; case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; break ; case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; break ; case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; break ; case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) { case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; break ; case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; break ; case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; break ; default : assert ( 0 ) ; return - 1 ; } # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; # endif break ; } } v = ( val * dqv ) >> dq_shift ; # if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ; # else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; # endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; # endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; ++ c ; ctx = get_coef_context ( nb , token_cache , c ) ; dqv = dq [ 1 ] <S2SV_ModEnd> ; }
<S2SV_ModStart> vp9_decode_block_tokens ( <S2SV_ModEnd> MACROBLOCKD * <S2SV_ModStart> plane , const scan_order * sc <S2SV_ModEnd> , int <S2SV_ModStart> tx_size , vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> * r , int seg_id <S2SV_ModStart> [ plane ] ; const int16_t * const dequant = pd -> seg_dequant [ seg_id <S2SV_ModStart> ; const <S2SV_ModEnd> int eob <S2SV_ModStart> decode_coefs ( <S2SV_ModEnd> xd , <S2SV_ModStart> plane_type , <S2SV_ModEnd> pd -> <S2SV_ModStart> dqcoeff , <S2SV_ModEnd> tx_size , <S2SV_ModStart> tx_size , <S2SV_ModEnd> dequant , <S2SV_ModStart> ctx , sc <S2SV_ModEnd> -> scan <S2SV_ModStart> scan , sc <S2SV_ModEnd> -> neighbors <S2SV_ModStart> ) ; dec_set_contexts <S2SV_ModEnd> ( xd <S2SV_ModStart> , pd <S2SV_ModEnd> , tx_size
<S2SV_ModStart> decode_term_subexp ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> ( ! vpx_read_bit <S2SV_ModEnd> ( r <S2SV_ModStart> ) return vpx_read_literal <S2SV_ModEnd> ( r <S2SV_ModStart> ( ! vpx_read_bit <S2SV_ModEnd> ( r <S2SV_ModStart> ) return vpx_read_literal <S2SV_ModEnd> ( r <S2SV_ModStart> ( ! vpx_read_bit <S2SV_ModEnd> ( r <S2SV_ModStart> ) return vpx_read_literal <S2SV_ModEnd> ( r
<S2SV_ModStart> decode_uniform ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> v = vpx_read_literal <S2SV_ModEnd> ( r <S2SV_ModStart> m + vpx_read_bit <S2SV_ModEnd> ( r
<S2SV_ModStart> ; return ( v & 1 ) <S2SV_ModEnd> ? m <S2SV_ModStart> m - ( <S2SV_ModStart> 1 ) >> 1 ) <S2SV_ModEnd> : m <S2SV_ModStart> m + ( v >> 1 ) <S2SV_ModEnd> ; }
<S2SV_ModStart> [ MAX_PROB <S2SV_ModEnd> ] = <S2SV_ModStart> = { 7 , 20 , 33 , 46 , 59 , 72 , 85 , 98 , 111 , 124 , 137 , 150 , 163 , 176 , 189 , 202 , 215 , 228 , 241 , 254 , 1 , 2 , 3 , 4 , 5 , <S2SV_ModStart> 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , <S2SV_ModStart> 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , <S2SV_ModStart> 32 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , <S2SV_ModStart> 45 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , <S2SV_ModStart> 58 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , <S2SV_ModStart> 71 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , <S2SV_ModStart> 84 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , <S2SV_ModStart> 97 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , <S2SV_ModStart> 110 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , <S2SV_ModStart> 123 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , <S2SV_ModStart> 136 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , <S2SV_ModStart> 149 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , <S2SV_ModStart> 162 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , <S2SV_ModStart> 175 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , <S2SV_ModStart> 188 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , <S2SV_ModStart> 201 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , <S2SV_ModStart> 214 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , <S2SV_ModStart> 227 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , <S2SV_ModStart> 240 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , <S2SV_ModStart> 253 , 253 <S2SV_ModEnd> } ; <S2SV_ModStart> } ; assert ( v < ( int ) ( sizeof ( inv_map_table ) / sizeof ( inv_map_table [ 0 ] ) ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ( v <S2SV_ModEnd> , m <S2SV_ModStart> ( v <S2SV_ModEnd> , MAX_PROB
<S2SV_ModStart> vp9_diff_update_prob ( vpx_reader <S2SV_ModEnd> * r <S2SV_ModStart> r , vpx_prob <S2SV_ModEnd> * p <S2SV_ModStart> if ( vpx_read <S2SV_ModEnd> ( r <S2SV_ModStart> = ( vpx_prob <S2SV_ModEnd> ) inv_remap_prob
<S2SV_ModStart> seg ; vpx_clear_system_state <S2SV_ModEnd> ( ) <S2SV_ModStart> segment ; <S2SV_ModEnd> const int <S2SV_ModStart> const int aq_strength = get_aq_c_strength ( cm -> base_qindex , cm -> bit_depth ) ; memset ( cpi -> segmentation_map , DEFAULT_AQ2_SEG , cm -> mi_rows * cm -> mi_cols ) ; vp9_clearall_segfeatures ( seg ) ; if ( cpi -> rc . sb64_target_rate < 256 ) { vp9_disable_segmentation ( seg ) ; return ; } vp9_enable_segmentation ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , DEFAULT_AQ2_SEG , SEG_LVL_ALT_Q ) ; for ( segment = 0 ; segment < AQ_C_SEGMENTS ; ++ segment ) { int qindex_delta ; if ( segment == DEFAULT_AQ2_SEG ) continue ; <S2SV_ModStart> base_qindex , aq_c_q_adj_factor [ aq_strength ] [ segment ] , cm -> bit_depth ) ; if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( ( cm -> base_qindex + qindex_delta ) > 0 ) { <S2SV_ModEnd> vp9_enable_segfeature ( <S2SV_ModStart> } } }
<S2SV_ModStart> factor = 0.25 <S2SV_ModEnd> ; const <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> < factor
<S2SV_ModStart> mbmi , int64_t rate , int64_t dist , int bsize <S2SV_ModEnd> ) { <S2SV_ModStart> ) { MV mv = <S2SV_ModEnd> mbmi -> <S2SV_ModStart> ] . as_mv ; if ( dist <S2SV_ModEnd> > cr <S2SV_ModStart> -> thresh_dist_sb && ( mv . row > cr -> motion_thresh || mv . row < - cr -> motion_thresh || mv . col > cr -> motion_thresh || mv . col < - cr -> motion_thresh <S2SV_ModEnd> || ! <S2SV_ModStart> ) ) ) return CR_SEGMENT_ID_BASE <S2SV_ModEnd> ; else <S2SV_ModStart> ; else <S2SV_ModEnd> if ( <S2SV_ModStart> ( bsize >= BLOCK_16X16 && rate <S2SV_ModStart> cr -> thresh_rate_sb && is_inter_block ( mbmi ) && <S2SV_ModEnd> mbmi -> <S2SV_ModStart> . as_int == 0 && cr -> rate_boost_fac > 10 <S2SV_ModEnd> ) return <S2SV_ModStart> ) return CR_SEGMENT_ID_BOOST2 <S2SV_ModEnd> ; else <S2SV_ModStart> else return CR_SEGMENT_ID_BOOST1 <S2SV_ModEnd> ; } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { size_t last_coded_q_map_size ; <S2SV_ModStart> ; } last_coded_q_map_size = mi_rows * mi_cols * sizeof ( * cr -> last_coded_q_map ) ; cr -> last_coded_q_map = vpx_malloc ( last_coded_q_map_size ) ; if ( cr -> last_coded_q_map == NULL ) { vpx_free ( cr ) ; return NULL ; } assert ( MAXQ <= 255 ) ; memset ( cr -> last_coded_q_map , MAXQ , last_coded_q_map_size ) ;
<S2SV_ModStart> ( cr -> last_coded_q_map ) ; vpx_free ( cr
<S2SV_ModStart> seg ; <S2SV_ModEnd> const int <S2SV_ModStart> rc ) ; if ( cm -> current_video_frame == 0 ) cr -> low_content_avg = 0.0 <S2SV_ModStart> 0 ) || ( cpi -> svc . spatial_layer_id > 0 ) <S2SV_ModStart> ) { unsigned char * const seg_map = cpi -> segmentation_map ; memset <S2SV_ModEnd> ( seg_map <S2SV_ModStart> KEY_FRAME ) { memset ( cr -> last_coded_q_map , MAXQ , cm -> mi_rows * cm -> mi_cols * sizeof ( * cr -> last_coded_q_map ) ) ; <S2SV_ModStart> 0 ; } <S2SV_ModStart> ; int <S2SV_ModEnd> qindex2 ; <S2SV_ModStart> ; const double q = vp9_convert_qindex_to_q ( cm -> base_qindex , cm -> bit_depth ) ; vpx_clear_system_state ( ) ; cr -> thresh_rate_sb = ( ( int64_t ) ( rc -> sb64_target_rate ) << 8 ) << 2 ; cr -> thresh_dist_sb = ( ( int64_t ) ( q * q ) ) << 2 ; vp9_enable_segmentation ( & cm -> seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , CR_SEGMENT_ID_BASE , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST1 , SEG_LVL_ALT_Q ) ; vp9_enable_segfeature ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , cr -> rate_ratio_qdelta ) ; cr -> qindex_delta [ 1 ] = qindex_delta <S2SV_ModEnd> ; qindex2 <S2SV_ModStart> seg , CR_SEGMENT_ID_BOOST1 <S2SV_ModEnd> , SEG_LVL_ALT_Q <S2SV_ModStart> ) ; qindex_delta = compute_deltaq ( cpi , cm -> base_qindex , <S2SV_ModEnd> MIN ( <S2SV_ModStart> MIN ( CR_MAX_RATE_TARGET_RATIO , 0.1 * cr -> rate_boost_fac * cr -> rate_ratio_qdelta ) ) ; cr -> qindex_delta [ 2 ] = qindex_delta ; vp9_set_segdata ( seg , CR_SEGMENT_ID_BOOST2 , SEG_LVL_ALT_Q , qindex_delta ) ; cyclic_refresh_update_map ( cpi ) <S2SV_ModEnd> ; }
<S2SV_ModStart> bsize , int64_t rate , int64_t dist , int skip <S2SV_ModEnd> ) { <S2SV_ModStart> mbmi , rate , dist , bsize <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] <S2SV_ModEnd> == 1 <S2SV_ModStart> 1 ) <S2SV_ModEnd> new_map_value = <S2SV_ModStart> ) { int map_offset = <S2SV_ModEnd> block_index + <S2SV_ModStart> + x ; cr -> map [ map_offset <S2SV_ModStart> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> avg ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { aq_highbd_8_variance <S2SV_ModEnd> ( x <S2SV_ModStart> stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , bw , bh , & sse , & avg ) ; sse >>= 2 * ( xd -> bd - 8 ) ; avg >>= ( xd -> bd - 8 ) ; } else { aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> ) ; } # else aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; # endif <S2SV_ModStart> else { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , & sse ) ; } else { var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> ) ; } # else var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ; # endif
<S2SV_ModStart> energy ; double energy_midpoint ; vpx_clear_system_state ( ) ; energy_midpoint = ( cpi -> oxcf . pass == 2 ) ? cpi -> twopass . mb_av_energy : DEFAULT_E_MIDPOINT ; energy = vp9_log_block_var <S2SV_ModEnd> ( cpi <S2SV_ModStart> bs ) - energy_midpoint <S2SV_ModEnd> ; return
<S2SV_ModStart> -> seg <S2SV_ModEnd> ; int <S2SV_ModStart> SEGMENT_DELTADATA ; vpx_clear_system_state <S2SV_ModEnd> ( ) <S2SV_ModStart> i = 0 ; i < MAX_SEGMENTS ; ++ i <S2SV_ModEnd> ) { <S2SV_ModStart> int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , rate_ratio [ i ] , cm -> bit_depth ) <S2SV_ModEnd> ; if <S2SV_ModStart> if ( ( cm -> base_qindex != 0 ) && ( ( cm -> base_qindex + qindex_delta <S2SV_ModEnd> ) == <S2SV_ModStart> ) == 0 ) ) { qindex_delta = - cm -> base_qindex + 1 ; } if ( rate_ratio [ i ] == 1.0 ) { <S2SV_ModEnd> continue ; <S2SV_ModStart> ; } <S2SV_ModEnd> vp9_set_segdata ( <S2SV_ModStart> seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q <S2SV_ModStart> seg , i <S2SV_ModEnd> , SEG_LVL_ALT_Q <S2SV_ModStart> ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> * coef_branch_ct , <S2SV_ModEnd> vp9_coeff_probs_model * <S2SV_ModStart> * coef_probs ) { vp9_coeff_count * coef_counts <S2SV_ModStart> cpi -> td . rd_counts . <S2SV_ModEnd> coef_counts [
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> i ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ] ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> delta ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ] ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> delta ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb
<S2SV_ModStart> encode_quantization ( const <S2SV_ModStart> VP9_COMMON * const <S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> encode_segmentation ( VP9_COMMON * cm , MACROBLOCKD * xd <S2SV_ModEnd> , struct <S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> j ; const <S2SV_ModStart> = & cm -> seg ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> return ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> vp9_choose_segmap_coding_method ( cm , xd <S2SV_ModEnd> ) ; <S2SV_ModStart> MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> MAX_PROB ; vpx_wb_write_bit ( wb , update ) ; if ( update ) vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> } } vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> active = segfeature_active ( seg , i , j ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> data = get_segdata <S2SV_ModEnd> ( seg <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb
<S2SV_ModStart> common ; vpx_writer <S2SV_ModEnd> residual_bc ; <S2SV_ModStart> ; TOKENEXTRA <S2SV_ModEnd> * tok_end <S2SV_ModStart> log2_tile_rows ; memset <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ; for ( tile_row = 0 ; tile_row < tile_rows ; tile_row ++ ) { for ( tile_col = 0 ; tile_col < tile_cols ; tile_col ++ ) { int tile_idx = tile_row * tile_cols + tile_col ; TOKENEXTRA * tok = cpi -> tile_tok [ tile_row ] [ tile_col ] <S2SV_ModEnd> ; tok_end <S2SV_ModStart> tok_end = cpi -> tile_tok [ tile_row ] [ tile_col ] + <S2SV_ModEnd> cpi -> <S2SV_ModStart> 1 ) vpx_start_encode <S2SV_ModEnd> ( & <S2SV_ModStart> ; else vpx_start_encode <S2SV_ModEnd> ( & <S2SV_ModStart> , & cpi -> tile_data [ tile_idx ] . tile_info , <S2SV_ModEnd> & residual_bc <S2SV_ModStart> & tok <S2SV_ModEnd> , tok_end <S2SV_ModStart> ( tok <S2SV_ModEnd> == tok_end <S2SV_ModStart> ) ; vpx_stop_encode <S2SV_ModEnd> ( &
<S2SV_ModStart> cm , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> * w , FRAME_COUNTS * counts ) { vpx_write_literal <S2SV_ModEnd> ( w <S2SV_ModStart> ALLOW_32X32 ) vpx_write_bit <S2SV_ModEnd> ( w <S2SV_ModStart> tx_counts_to_branch_counts_8x8 ( counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> -> fc -> <S2SV_ModEnd> tx_probs . <S2SV_ModStart> tx_counts_to_branch_counts_16x16 ( counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> -> fc -> <S2SV_ModEnd> tx_probs . <S2SV_ModStart> tx_counts_to_branch_counts_32x32 ( counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> -> fc -> <S2SV_ModEnd> tx_probs .
<S2SV_ModStart> ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> * cm , FRAME_COUNTS * counts <S2SV_ModStart> ] += counts -> <S2SV_ModEnd> switchable_interp [
<S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> if ( vp9_preserve_existing_gf ( cpi ) <S2SV_ModEnd> ) { <S2SV_ModStart> ) { <S2SV_ModEnd> return ( <S2SV_ModStart> alt_fb_idx ; if ( <S2SV_ModEnd> ( cpi <S2SV_ModStart> cpi -> oxcf . pass == 2 ) && cpi -> multi_arf_allowed <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const GF_GROUP * const gf_group = & <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> twopass . gf_group <S2SV_ModEnd> ; arf_idx <S2SV_ModStart> arf_idx = gf_group -> arf_update_idx [ gf_group -> index <S2SV_ModEnd> ] ; <S2SV_ModStart> ; } <S2SV_ModEnd> return (
<S2SV_ModStart> mi , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> -> fc -> nmvc ; const MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; <S2SV_ModStart> ; const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const PREDICTION_MODE <S2SV_ModEnd> mode = <S2SV_ModStart> seg_id_predicted ; vpx_prob <S2SV_ModEnd> pred_prob = <S2SV_ModStart> ) ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> write_skip ( cm , xd <S2SV_ModEnd> , segment_id <S2SV_ModStart> ( ! segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> ) ) vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> is_inter && skip <S2SV_ModEnd> ) ) <S2SV_ModStart> write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w <S2SV_ModStart> -> fc -> <S2SV_ModEnd> y_mode_prob [ <S2SV_ModStart> { const PREDICTION_MODE <S2SV_ModEnd> b_mode = <S2SV_ModStart> -> fc -> <S2SV_ModEnd> y_mode_prob [ <S2SV_ModStart> -> fc -> <S2SV_ModEnd> uv_mode_prob [ <S2SV_ModStart> mode_ctx = mbmi_ext <S2SV_ModEnd> -> mode_context <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> * const <S2SV_ModStart> -> fc -> <S2SV_ModEnd> inter_mode_probs [ <S2SV_ModStart> write_ref_frames ( cm , xd <S2SV_ModEnd> , w <S2SV_ModStart> ( ! segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> ) ; <S2SV_ModEnd> } } <S2SV_ModStart> -> fc -> <S2SV_ModEnd> switchable_interp_prob [ <S2SV_ModStart> ] ) ; ++ cpi -> interp_filter_selected [ 0 ] [ mbmi -> interp_filter ] <S2SV_ModStart> ; const PREDICTION_MODE <S2SV_ModEnd> b_mode = <S2SV_ModStart> inter_probs ) <S2SV_ModEnd> ; if <S2SV_ModStart> , & mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> , & mbmi_ext <S2SV_ModEnd> -> ref_mvs
<S2SV_ModStart> pack_mb_tokens ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> TOKENEXTRA * const stop , vpx_bit_depth_t bit_depth <S2SV_ModEnd> ) { <S2SV_ModStart> ] ; int i = 0 ; int v = a -> value ; int n = a -> len ; # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> vp9_extra_bit * b ; if ( bit_depth == VPX_BITS_12 ) b = & vp9_extra_bits_high12 [ t ] ; else if ( bit_depth == VPX_BITS_10 ) b = & vp9_extra_bits_high10 [ t ] ; else <S2SV_ModEnd> b = <S2SV_ModStart> ] ; # else const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; ( void ) bit_depth ; # endif <S2SV_ModEnd> if ( <S2SV_ModStart> 1 ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> ; } vpx_write_bit <S2SV_ModEnd> ( w
<S2SV_ModStart> ( const vpx_tree_index <S2SV_ModEnd> * tree <S2SV_ModStart> tree , vpx_prob <S2SV_ModEnd> probs [ <S2SV_ModStart> n , vpx_writer <S2SV_ModEnd> * w
<S2SV_ModStart> cpi , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> tx_size ; <S2SV_ModEnd> for ( <S2SV_ModStart> tx_size ) { vp9_coeff_stats frame_branch_ct [ PLANE_TYPES ] ; vp9_coeff_probs_model frame_coef_probs [ PLANE_TYPES ] ; if ( cpi -> td . counts -> tx . tx_totals [ tx_size ] <= 20 || ( tx_size >= TX_16X16 && cpi -> sf . tx_size_search_method == USE_TX_8X8 ) ) { vpx_write_bit ( w , 0 ) ; } else { build_tree_distribution ( cpi , tx_size , frame_branch_ct , frame_coef_probs ) ; <S2SV_ModStart> , frame_branch_ct , frame_coef_probs <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } } }
<S2SV_ModStart> update_coef_probs_common ( vpx_writer <S2SV_ModEnd> * const <S2SV_ModStart> * frame_branch_ct , <S2SV_ModEnd> vp9_coeff_probs_model * <S2SV_ModStart> vp9_coeff_probs_model * new_coef_probs ) { <S2SV_ModEnd> vp9_coeff_probs_model * <S2SV_ModStart> vp9_coeff_probs_model * old_coef_probs = <S2SV_ModEnd> cpi -> <S2SV_ModStart> . fc -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> ; switch <S2SV_ModStart> ) { vpx_prob newp = new_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> ; const vpx_prob oldp = old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> ] , old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> , upd , stepsize <S2SV_ModStart> ) { vpx_write_bit <S2SV_ModEnd> ( bc <S2SV_ModStart> ; } vpx_write_bit <S2SV_ModEnd> ( bc <S2SV_ModStart> ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> upd = <S2SV_ModStart> ] , old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> , upd , stepsize <S2SV_ModStart> 1 ; vpx_write <S2SV_ModEnd> ( bc <S2SV_ModStart> ; } <S2SV_ModEnd> case ONE_LOOP_REDUCED <S2SV_ModStart> : { int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> ; ++ <S2SV_ModStart> ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> 0 ; <S2SV_ModEnd> if ( <S2SV_ModStart> PIVOT_NODE ) { <S2SV_ModStart> ] , old_coef_probs <S2SV_ModEnd> [ i <S2SV_ModStart> , upd , stepsize ) ; } else { <S2SV_ModEnd> s = <S2SV_ModStart> ) ; } <S2SV_ModStart> 1 ; <S2SV_ModEnd> updates += <S2SV_ModStart> v ; vpx_write_bit <S2SV_ModEnd> ( bc <S2SV_ModStart> v ) vpx_write <S2SV_ModEnd> ( bc <S2SV_ModStart> ; } vpx_write <S2SV_ModEnd> ( bc <S2SV_ModStart> ) { vpx_write_bit <S2SV_ModEnd> ( bc
<S2SV_ModStart> cm , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> * w , FRAME_COUNTS * counts <S2SV_ModStart> -> fc -> <S2SV_ModEnd> skip_probs [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> skip [
<S2SV_ModStart> cm , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> * w , FRAME_COUNTS * counts <S2SV_ModStart> -> fc -> <S2SV_ModEnd> switchable_interp_prob [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> switchable_interp [
<S2SV_ModStart> ; struct vpx_write_bit_buffer <S2SV_ModEnd> wb = <S2SV_ModStart> ; struct vpx_write_bit_buffer <S2SV_ModEnd> saved_wb ; <S2SV_ModStart> wb ; vpx_wb_write_literal <S2SV_ModEnd> ( & <S2SV_ModStart> uncompressed_hdr_size = vpx_wb_bytes_written <S2SV_ModEnd> ( & <S2SV_ModStart> uncompressed_hdr_size ; vpx_clear_system_state <S2SV_ModEnd> ( ) <S2SV_ModStart> first_part_size ; vpx_wb_write_literal <S2SV_ModEnd> ( &
<S2SV_ModStart> cpi -> td . <S2SV_ModStart> fc = cm -> fc ; FRAME_COUNTS * counts = cpi -> td . counts ; vpx_writer header_bc ; vpx_start_encode <S2SV_ModEnd> ( & <S2SV_ModStart> & header_bc , counts <S2SV_ModStart> & header_bc , counts <S2SV_ModStart> -> fc -> <S2SV_ModEnd> inter_mode_probs [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> inter_mode [ <S2SV_ModStart> & header_bc <S2SV_ModEnd> ) ; <S2SV_ModStart> & header_bc , counts <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> intra_inter [ <S2SV_ModStart> if ( cpi <S2SV_ModEnd> -> allow_comp_inter_inter <S2SV_ModStart> REFERENCE_MODE_SELECT ; vpx_write_bit <S2SV_ModEnd> ( & <S2SV_ModStart> ) { vpx_write_bit <S2SV_ModEnd> ( & <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> comp_inter [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> single_ref [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> single_ref [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> comp_ref [ <S2SV_ModStart> -> fc -> <S2SV_ModEnd> y_mode_prob [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> y_mode [ <S2SV_ModStart> ] , counts -> <S2SV_ModEnd> partition [ <S2SV_ModStart> & header_bc , & counts -> mv <S2SV_ModStart> ; } vpx_stop_encode <S2SV_ModEnd> ( &
<S2SV_ModStart> ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> else { vpx_wb_write_bit <S2SV_ModEnd> ( wb
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> display_height ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) ; if ( cpi -> use_svc && ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( cpi -> svc . number_spatial_layers > 1 && cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . is_key_frame ) || ( is_two_pass_svc ( cpi ) && cpi -> svc . encode_empty_frame_state == ENCODING && cpi -> svc . layer_context [ 0 ] . frames_from_key_frame < cpi -> svc . number_temporal_layers + 1 ) ) ) { found = 0 ; } else if ( cfg != NULL ) { <S2SV_ModStart> y_crop_height ; } vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> write_inter_mode ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> w , PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * probs
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> } ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> SWITCHABLE ) vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> write_intra_mode ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> w , PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * probs
<S2SV_ModStart> ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> MODE_INFO * <S2SV_ModStart> mi_8x8 , vpx_writer * w ) { <S2SV_ModEnd> const struct <S2SV_ModStart> above_mi = xd -> above_mi <S2SV_ModEnd> ; const <S2SV_ModStart> xd -> left_mi <S2SV_ModEnd> ; const <S2SV_ModStart> write_skip ( cm , xd <S2SV_ModEnd> , mbmi <S2SV_ModStart> write_selected_tx_size ( cm , xd <S2SV_ModEnd> , w
<S2SV_ModStart> tile , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> tok , const <S2SV_ModStart> TOKENEXTRA * const <S2SV_ModStart> ) { const VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; <S2SV_ModStart> , mi_col ; set_partition_probs ( cm , xd ) <S2SV_ModStart> vp9_zero ( xd -> <S2SV_ModEnd> left_seg_context )
<S2SV_ModStart> tile , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> tok , const <S2SV_ModStart> TOKENEXTRA * const <S2SV_ModStart> ) { const <S2SV_ModStart> cpi -> td . <S2SV_ModStart> ] ; cpi -> td . mb . mbmi_ext = cpi -> td . mb . mbmi_ext_base + ( mi_row * cm -> mi_cols + mi_col ) ; <S2SV_ModStart> write_mb_modes_kf ( cm , xd <S2SV_ModEnd> , xd <S2SV_ModStart> , tok_end , cm -> bit_depth
<S2SV_ModStart> tile , vpx_writer * w , <S2SV_ModEnd> TOKENEXTRA * <S2SV_ModStart> tok , const <S2SV_ModStart> TOKENEXTRA * const <S2SV_ModStart> ) { const <S2SV_ModStart> cpi -> td . <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const <S2SV_ModStart> subsize ; const <S2SV_ModStart> MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModStart> mi_col ] <S2SV_ModEnd> ; partition
<S2SV_ModStart> write_partition ( const <S2SV_ModStart> VP9_COMMON * const <S2SV_ModStart> cm , const <S2SV_ModStart> MACROBLOCKD * const <S2SV_ModStart> bsize , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ; const vpx_prob * const probs = xd -> partition_probs [ ctx ] <S2SV_ModEnd> ; const <S2SV_ModStart> ) ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> ) ; vpx_write <S2SV_ModEnd> ( w
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { switch <S2SV_ModEnd> ( profile <S2SV_ModStart> ( profile ) { case PROFILE_0 : vpx_wb_write_literal ( wb , 0 , 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; break ; case PROFILE_1 : vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> wb , 2 , 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; break ; case PROFILE_2 : vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> wb , 1 , 2 ) ; break ; case PROFILE_3 : vpx_wb_write_literal ( wb , 6 , 3 ) ; break ; default : assert ( 0 <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } }
<S2SV_ModStart> ( const <S2SV_ModEnd> VP9_COMMON * <S2SV_ModStart> VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi <S2SV_ModEnd> = & <S2SV_ModStart> = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> <S2SV_ModStart> ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ! is_compound == <S2SV_ModEnd> ( cm <S2SV_ModStart> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) <S2SV_ModStart> ) { vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w
<S2SV_ModStart> write_segment_id ( vpx_writer <S2SV_ModEnd> * w
<S2SV_ModStart> ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) { TX_SIZE tx_size = xd -> mi [ 0 ] -> mbmi . tx_size ; BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; <S2SV_ModStart> ; const vpx_prob <S2SV_ModEnd> * const <S2SV_ModStart> , & cm -> fc -> <S2SV_ModEnd> tx_probs ) <S2SV_ModStart> ) ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> ) { vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> TX_32X32 ) vpx_write <S2SV_ModEnd> ( w
<S2SV_ModStart> ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> int segment_id <S2SV_ModStart> mi , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( & <S2SV_ModStart> ( & cm -> <S2SV_ModEnd> seg , <S2SV_ModStart> skip ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> vp9_get_skip_prob ( cm <S2SV_ModEnd> , xd
<S2SV_ModStart> ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb
<S2SV_ModStart> write_tile_info ( const <S2SV_ModStart> VP9_COMMON * const <S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> -- ) vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> max_log2_tile_cols ) vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> 0 ) vpx_wb_write_bit <S2SV_ModEnd> ( wb
<S2SV_ModStart> , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb <S2SV_ModStart> common ; MACROBLOCKD * const xd = & cpi -> td . mb . e_mbd ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { write_sync_code ( wb ) ; write_bitdepth_colorspace_sampling ( cm , wb ) ; write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm -> intra_only ) { <S2SV_ModEnd> write_sync_code ( <S2SV_ModStart> profile > PROFILE_0 ) { write_bitdepth_colorspace_sampling ( cm , wb ) ; } vpx_wb_write_literal ( wb , get_refresh_mask ( cpi ) , REF_FRAMES ) ; write_frame_size ( cm , wb ) ; <S2SV_ModEnd> } else <S2SV_ModStart> else { <S2SV_ModEnd> MV_REFERENCE_FRAME ref_frame <S2SV_ModStart> ref_frame ; vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> ) { assert ( get_ref_frame_map_idx ( cpi , ref_frame ) != INVALID_IDX ) ; vpx_wb_write_literal ( wb , get_ref_frame_map_idx <S2SV_ModEnd> ( cpi <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ( cm , cpi -> td . counts <S2SV_ModStart> ) { vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ) ; vpx_wb_write_bit <S2SV_ModEnd> ( wb <S2SV_ModStart> ; } vpx_wb_write_literal <S2SV_ModEnd> ( wb <S2SV_ModStart> encode_segmentation ( cm , xd <S2SV_ModEnd> , wb
<S2SV_ModStart> costs , vpx_tree <S2SV_ModEnd> tree , <S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * probs <S2SV_ModStart> { const vpx_prob <S2SV_ModEnd> prob = <S2SV_ModStart> ; const vpx_tree_index <S2SV_ModEnd> ii =
<S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * probs <S2SV_ModStart> probs , vpx_tree <S2SV_ModEnd> tree )
<S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * probs <S2SV_ModStart> probs , vpx_tree <S2SV_ModEnd> tree )
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { tran_high_t <S2SV_ModEnd> s0 , <S2SV_ModStart> , s8 ; tran_high_t <S2SV_ModEnd> s9 , <S2SV_ModStart> s15 ; tran_high_t <S2SV_ModEnd> x0 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x1 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x2 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x3 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x4 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x5 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x6 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x7 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x8 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x9 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x10 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x11 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x12 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x13 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x14 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x15 = <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t )
<S2SV_ModStart> ( const tran_low_t * input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { tran_high_t x0 , x1 , x2 , x3 ; tran_high_t <S2SV_ModEnd> s0 , <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t )
<S2SV_ModStart> ( const tran_low_t * input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t <S2SV_ModEnd> x0 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x1 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x2 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x3 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x4 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x5 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x6 = <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> x7 = <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t )
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> in [ <S2SV_ModStart> ] , tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ) { tran_high_t <S2SV_ModEnd> step1 [ <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> step2 [ <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> step3 [ <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> input [ <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> temp1 , <S2SV_ModStart> ; { tran_high_t <S2SV_ModEnd> s0 , <S2SV_ModStart> s7 ; tran_high_t <S2SV_ModEnd> t0 , <S2SV_ModStart> t3 ; tran_high_t <S2SV_ModEnd> x0 , <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] * cospi_24_64 + <S2SV_ModEnd> step3 [ <S2SV_ModStart> ] * cospi_8_64 - <S2SV_ModEnd> step3 [ <S2SV_ModStart> 3 ] + step2 [ 2 ] ; step1 [ 3 ] = step3 [ 3 ] - step2 [ 2 ] ; step1 [ 4 ] = step3 [ 4 ] - step2 [ 5 ] ; step1 [ 5 ] = step3 [ 4 ] + <S2SV_ModEnd> step2 [ <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t )
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * input <S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { tran_high_t <S2SV_ModEnd> step [ <S2SV_ModStart> ] ; tran_high_t <S2SV_ModEnd> temp1 , <S2SV_ModStart> ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 2 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( <S2SV_ModStart> ] = ( tran_low_t ) fdct_round_shift ( temp1 ) ; output [ 3 ] = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift (
<S2SV_ModStart> ( const tran_low_t * input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { tran_high_t <S2SV_ModEnd> s0 , <S2SV_ModStart> s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t <S2SV_ModEnd> x0 , <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> t2 = ( tran_low_t ) fdct_round_shift ( t0 ) ; t3 = ( tran_low_t ) <S2SV_ModEnd> fdct_round_shift ( <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t )
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { vpx_fdct16x16_c <S2SV_ModEnd> ( input <S2SV_ModStart> else { tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; <S2SV_ModEnd> int i <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) out <S2SV_ModEnd> [ j
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { vpx_fdct4x4_c <S2SV_ModEnd> ( input <S2SV_ModStart> else { tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; <S2SV_ModEnd> int i <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) out <S2SV_ModEnd> [ j
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { vpx_fdct8x8_c <S2SV_ModEnd> ( input <S2SV_ModStart> else { tran_low_t <S2SV_ModEnd> out [ <S2SV_ModStart> ] ; <S2SV_ModEnd> int i <S2SV_ModStart> j ; tran_low_t <S2SV_ModEnd> temp_in [ <S2SV_ModStart> j ) out <S2SV_ModEnd> [ j
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> i ; tran_high_t <S2SV_ModEnd> a1 , <S2SV_ModStart> int16_t * ip_pass0 <S2SV_ModEnd> = input <S2SV_ModStart> input ; const tran_low_t * ip = NULL ; tran_low_t <S2SV_ModEnd> * op <S2SV_ModStart> a1 = ip_pass0 [ 0 * stride ] ; b1 = ip_pass0 [ 1 * stride ] ; c1 = ip_pass0 <S2SV_ModEnd> [ 2 <S2SV_ModStart> d1 = ip_pass0 <S2SV_ModEnd> [ 3 <S2SV_ModStart> ] = ( tran_low_t ) a1 ; op [ 4 ] = ( tran_low_t ) <S2SV_ModEnd> c1 ; <S2SV_ModStart> ] = ( tran_low_t ) <S2SV_ModStart> ] = ( tran_low_t ) b1 ; ip_pass0 <S2SV_ModEnd> ++ ; <S2SV_ModStart> ] = ( tran_low_t ) ( <S2SV_ModStart> * UNIT_QUANT_FACTOR ) ; op [ 1 ] = ( tran_low_t ) ( <S2SV_ModEnd> c1 * <S2SV_ModStart> * UNIT_QUANT_FACTOR ) <S2SV_ModStart> ] = ( tran_low_t ) ( <S2SV_ModStart> * UNIT_QUANT_FACTOR ) <S2SV_ModStart> ] = ( tran_low_t ) ( <S2SV_ModStart> * UNIT_QUANT_FACTOR )
<S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( &
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> choose_partitioning ( <S2SV_ModStart> tile , <S2SV_ModEnd> MACROBLOCK * <S2SV_ModStart> * x , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common <S2SV_ModEnd> ; MACROBLOCKD <S2SV_ModStart> = & x -> <S2SV_ModEnd> e_mbd ; <S2SV_ModStart> , k , m <S2SV_ModStart> v64x64 vt ; v16x16 vt2 [ 16 ] ; int force_split [ 21 ] <S2SV_ModStart> 64 ; int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; const int use_4x4_partition = is_key_frame ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; int variance4x4downsample [ 16 ] ; int segment_id = CR_SEGMENT_ID_BASE ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; set_vbp_thresholds ( cpi , thresholds , q ) ; } } set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; unsigned int uv_sad <S2SV_ModEnd> ; const <S2SV_ModStart> ; const YV12_BUFFER_CONFIG * yv12_g = NULL ; unsigned int y_sad , y_sad_g ; const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; assert ( yv12 != NULL ) ; if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; } else { y_sad_g = UINT_MAX ; } vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , <S2SV_ModEnd> & cm <S2SV_ModStart> . sf ) ; mbmi -> ref_frame [ 0 ] = LAST_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> sb_type = BLOCK_64X64 ; mbmi -> mv [ 0 ] . as_int = 0 ; mbmi -> interp_filter = BILINEAR ; y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize <S2SV_ModEnd> , mi_row <S2SV_ModStart> , mi_col ) ; if ( y_sad_g < y_sad ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; mbmi -> mv [ 0 ] . as_int = 0 ; y_sad = y_sad_g ; } else { x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col <S2SV_ModStart> ) ; for ( i = 1 ; i <= 2 ; ++ i ) { struct macroblock_plane * p = & x -> plane [ i ] ; struct macroblockd_plane * pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ; else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ; x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; } d = xd -> plane [ 0 ] . dst . buf ; dp = xd -> plane [ 0 ] . dst . stride ; if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) { const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> mi_col , BLOCK_64X64 ) ; return 0 ; } } } else { <S2SV_ModEnd> d = <S2SV_ModStart> d = VP9_VAR_OFFS <S2SV_ModEnd> ; dp <S2SV_ModStart> dp = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( xd -> bd ) { case 10 : <S2SV_ModEnd> d = <S2SV_ModStart> d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; break ; case 12 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; break ; case 8 : default : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; break ; } } # endif } force_split [ 0 ] = 0 ; <S2SV_ModEnd> for ( <S2SV_ModStart> ) ; const int i2 = i << 2 ; force_split [ i + 1 ] = 0 ; <S2SV_ModStart> 4 ) ; const int split_index = 5 + i2 + j <S2SV_ModStart> ] ; force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 0 ; if ( ! is_key_frame ) { fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high ) ; if ( minmax > cpi -> vbp_threshold_minmax ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( is_key_frame || ( low_res && ! cpi -> use_svc && vt . split [ i ] . split [ j ] . part_variances . none . variance > ( thresholds [ 1 ] << 1 ) ) ) { force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 1 ; <S2SV_ModStart> { int x8_idx <S2SV_ModEnd> = x16_idx <S2SV_ModStart> ; int y8_idx <S2SV_ModEnd> = y16_idx <S2SV_ModStart> ) ; v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : & vt2 [ i2 + j ] . split [ k ] ; fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; } <S2SV_ModEnd> } } <S2SV_ModStart> ) { const int i2 = i << 2 ; <S2SV_ModStart> ) { if ( variance4x4downsample [ i2 + j ] == 1 ) { v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; for ( m = 0 ; m < 4 ; m ++ ) <S2SV_ModStart> ( & vtemp -> split [ m ] , BLOCK_8X8 ) ; fill_variance_tree ( vtemp , BLOCK_16X16 ) ; } } fill_variance_tree ( & <S2SV_ModStart> i ] , BLOCK_32X32 ) ; if ( ! force_split [ i + 1 ] ) { get_variance ( & vt <S2SV_ModStart> split [ i ] . part_variances . none ) ; if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( ! force_split [ 0 ] ) { <S2SV_ModEnd> fill_variance_tree ( <S2SV_ModStart> & vt , BLOCK_64X64 ) ; get_variance <S2SV_ModEnd> ( & <S2SV_ModStart> & vt . part_variances . none ) ; } if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || <S2SV_ModEnd> ! set_vt_partitioning <S2SV_ModStart> cpi , x , xd , <S2SV_ModStart> vt , <S2SV_ModEnd> BLOCK_64X64 , <S2SV_ModStart> mi_col , thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ; const int i2 = i << 2 ; <S2SV_ModStart> cpi , x , xd , <S2SV_ModStart> ] , <S2SV_ModEnd> BLOCK_32X32 , <S2SV_ModStart> ) , thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ; v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , <S2SV_ModEnd> mi_row + <S2SV_ModStart> + y16_idx , mi_col <S2SV_ModEnd> + x32_idx <S2SV_ModStart> + x16_idx , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) <S2SV_ModEnd> { for <S2SV_ModStart> ) ; if ( use_4x4_partition ) { <S2SV_ModEnd> if ( <S2SV_ModStart> cpi , x , xd , & vtemp -> <S2SV_ModEnd> split [ <S2SV_ModStart> split [ k ] , BLOCK_8X8 , <S2SV_ModEnd> mi_row + <S2SV_ModStart> + y16_idx + y8_idx , <S2SV_ModEnd> mi_col + <S2SV_ModStart> + x16_idx + x8_idx , thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { set_block_size ( cpi , x , xd , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_4X4 ) ; } } else { <S2SV_ModEnd> set_block_size ( <S2SV_ModStart> cpi , x , xd <S2SV_ModEnd> , ( <S2SV_ModStart> } } } } } } } return 0 ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> VP9_COMMON * <S2SV_ModEnd> cm , <S2SV_ModStart> MACROBLOCKD * <S2SV_ModEnd> xd ,
<S2SV_ModStart> const tile , ThreadData * td <S2SV_ModStart> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> mb ; <S2SV_ModEnd> set_offsets ( <S2SV_ModStart> , tile , x <S2SV_ModStart> cpi , td , ctx <S2SV_ModEnd> , mi_row <S2SV_ModStart> ( cpi , td <S2SV_ModStart> , bsize , ctx <S2SV_ModStart> update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ;
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> mb ; <S2SV_ModEnd> set_offsets ( <S2SV_ModStart> , tile , x <S2SV_ModStart> cpi , td , ctx <S2SV_ModEnd> , mi_row <S2SV_ModStart> ) ; # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && output_enabled && cpi -> common . frame_type != KEY_FRAME ) { vp9_denoiser_denoise ( & cpi -> denoiser , x , mi_row , mi_col , MAX ( BLOCK_8X8 , bsize ) , ctx ) ; } # endif <S2SV_ModStart> ( cpi , td <S2SV_ModStart> , bsize , ctx <S2SV_ModStart> update_stats ( & cpi -> common , td <S2SV_ModEnd> ) ;
<S2SV_ModStart> sf ; ThreadData * const td = & cpi -> td ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> e_mbd ; RD_COUNTS * const rdc = & cpi -> td . rd_counts ; <S2SV_ModStart> vp9_zero ( * td <S2SV_ModEnd> -> counts <S2SV_ModStart> vp9_zero ( rdc <S2SV_ModEnd> -> coef_counts <S2SV_ModStart> vp9_zero ( rdc -> comp_pred_diff <S2SV_ModEnd> ) ; <S2SV_ModStart> vp9_zero ( rdc -> filter_diff ) ; xd -> <S2SV_ModEnd> lossless = <S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) x -> fwd_txm4x4 = xd -> lossless ? vp9_highbd_fwht4x4 : vpx_highbd_fdct4x4 ; else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; x -> highbd_itxm_add = xd -> lossless ? vp9_highbd_iwht4x4_add : vp9_highbd_idct4x4_add ; # else x -> fwd_txm4x4 = xd -> lossless ? vp9_fwht4x4 : vpx_fdct4x4 ; # endif x -> itxm_add = xd -> lossless ? vp9_iwht4x4_add : vp9_idct4x4_add ; if ( xd -> lossless ) x -> optimize = 0 ; cm -> tx_mode = select_tx_mode <S2SV_ModEnd> ( cpi <S2SV_ModStart> cpi , xd <S2SV_ModEnd> ) ; <S2SV_ModStart> cpi , x , <S2SV_ModStart> ) ; cm -> use_prev_frame_mvs = ! cm -> error_resilient_mode && cm -> width == cm -> last_width && cm -> height == cm -> last_height && ! cm -> intra_only && cm -> last_show_frame <S2SV_ModEnd> ; cm <S2SV_ModStart> prev_mi = cm -> use_prev_frame_mvs ? cm -> prev_mip + cm -> mi_stride + 1 : NULL ; x -> quant_fp = cpi -> sf . use_quant_fp ; vp9_zero ( x -> skip_txfm <S2SV_ModEnd> ) ; <S2SV_ModStart> cpi -> td . pc_root -> none <S2SV_ModEnd> ; for <S2SV_ModStart> if ( cm -> frame_type != KEY_FRAME && cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) cpi -> ref_frame_flags &= ( ~ VP9_GOLD_FLAG ) ; if ( sf -> <S2SV_ModEnd> partition_search_type == <S2SV_ModStart> == SOURCE_VAR_BASED_PARTITION ) source_var_based_partition_search_method ( cpi ) ; <S2SV_ModEnd> } { <S2SV_ModStart> ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { input_fpmb_stats ( & cpi -> twopass . firstpass_mb_stats , cm , & cpi -> twopass . this_frame_mb_stats ) ; } # endif if ( MIN ( cpi -> oxcf . max_threads , <S2SV_ModEnd> 1 << <S2SV_ModStart> -> log2_tile_cols ) > 1 ) vp9_encode_tiles_mt ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> ; else encode_tiles ( cpi ) ; <S2SV_ModEnd> vpx_usec_timer_mark ( <S2SV_ModStart> ; } <S2SV_ModEnd> sf -> <S2SV_ModStart> sf -> skip_encode_frame = sf -> skip_encode_sb ? get_skip_encode_frame ( cm , td ) : 0 ; <S2SV_ModEnd> # if
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { SPEED_FEATURES * const sf = & cpi -> sf ; VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * <S2SV_ModStart> * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> <S2SV_ModStart> -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> xd -> left_seg_context <S2SV_ModEnd> ) ) <S2SV_ModStart> mi_col = tile_info <S2SV_ModEnd> -> mi_col_start <S2SV_ModStart> mi_col < tile_info <S2SV_ModEnd> -> mi_col_end <S2SV_ModStart> ) { const struct segmentation * const seg = & cm -> seg ; RD_COST dummy_rdc <S2SV_ModEnd> ; const <S2SV_ModStart> * * mi <S2SV_ModEnd> = cm <S2SV_ModStart> idx_str ; PARTITION_SEARCH_TYPE partition_search_type = sf -> partition_search_type <S2SV_ModEnd> ; BLOCK_SIZE <S2SV_ModStart> BLOCK_SIZE bsize = BLOCK_64X64 ; int seg_skip = 0 ; x -> <S2SV_ModEnd> source_variance = <S2SV_ModStart> vp9_zero ( x -> <S2SV_ModEnd> pred_mv ) <S2SV_ModStart> ) ; vp9_rd_cost_init ( & dummy_rdc ) ; x -> color_sensitivity [ 0 ] = 0 ; x -> color_sensitivity [ 1 ] = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; if ( seg_skip ) { partition_search_type = FIXED_PARTITION ; } } <S2SV_ModStart> switch ( <S2SV_ModEnd> partition_search_type ) <S2SV_ModStart> cpi , tile_info , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> , tp <S2SV_ModStart> mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , <S2SV_ModStart> , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; <S2SV_ModStart> SOURCE_VAR_BASED_PARTITION : <S2SV_ModEnd> set_source_var_based_partition ( <S2SV_ModStart> cpi , tile_info , x , mi <S2SV_ModEnd> , mi_row <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> , tp <S2SV_ModStart> mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , <S2SV_ModStart> , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; <S2SV_ModStart> break ; <S2SV_ModEnd> case FIXED_PARTITION <S2SV_ModStart> FIXED_PARTITION : if ( ! seg_skip ) <S2SV_ModStart> bsize = sf -> always_this_block_size <S2SV_ModEnd> ; set_fixed_partitioning <S2SV_ModStart> cpi , tile_info , mi <S2SV_ModEnd> , mi_row <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> , tp <S2SV_ModStart> mi_col , BLOCK_64X64 , <S2SV_ModEnd> 1 , <S2SV_ModStart> , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; <S2SV_ModStart> REFERENCE_PARTITION : set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_ModStart> cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && xd -> mi [ 0 ] -> mbmi . segment_id <S2SV_ModEnd> ) { <S2SV_ModStart> ) { if ( cm -> width <= 352 && cm -> height <= 288 ) x -> max_partition_size = BLOCK_32X32 ; else x -> max_partition_size = BLOCK_64X64 ; x -> min_partition_size = BLOCK_8X8 ; <S2SV_ModStart> cpi , td , tile_data <S2SV_ModEnd> , tp <S2SV_ModStart> mi_col , BLOCK_64X64 , & dummy_rdc <S2SV_ModEnd> , 1 <S2SV_ModStart> , INT64_MAX , td -> pc_root <S2SV_ModStart> else { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModEnd> nonrd_use_partition ( <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> , tp <S2SV_ModStart> , & dummy_rdc , td -> pc_root ) ; else nonrd_select_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , 1 , & dummy_rdc , td -> pc_root <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; break ;
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * <S2SV_ModStart> * const tile_info = & tile_data -> tile_info ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( <S2SV_ModEnd> xd -> <S2SV_ModStart> -> left_context ) ) ; memset ( xd -> left_seg_context <S2SV_ModStart> xd -> left_seg_context <S2SV_ModEnd> ) ) <S2SV_ModStart> mi_col = tile_info <S2SV_ModEnd> -> mi_col_start <S2SV_ModStart> mi_col < tile_info <S2SV_ModEnd> -> mi_col_end <S2SV_ModStart> ) { const struct segmentation * const seg = & cm -> seg ; <S2SV_ModStart> dummy_dist ; RD_COST dummy_rdc ; int i ; int seg_skip = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi = cm -> mi_grid_visible + idx_str <S2SV_ModEnd> ; if <S2SV_ModStart> i = 0 <S2SV_ModEnd> ; i <S2SV_ModStart> i < 64 <S2SV_ModEnd> ; ++ <S2SV_ModStart> i ) td -> leaf_tree [ i ] . pred_interp_filter = SWITCHABLE ; for ( i = 0 ; i < 64 ; ++ i ) { td -> pc_tree [ i ] . vertical [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . vertical [ 1 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 0 ] . pred_interp_filter = SWITCHABLE ; td -> pc_tree [ i ] . horizontal [ 1 ] . pred_interp_filter = SWITCHABLE ; } } vp9_zero ( x -> pred_mv ) ; td -> pc_root -> index = 0 ; if ( seg -> enabled ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; int segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; seg_skip = segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ; } x -> source_variance = UINT_MAX <S2SV_ModEnd> ; if <S2SV_ModStart> if ( <S2SV_ModEnd> sf -> <S2SV_ModStart> FIXED_PARTITION || seg_skip ) { const BLOCK_SIZE bsize = seg_skip ? BLOCK_64X64 : sf -> always_this_block_size ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( cpi -> partition_search_skippable_frame ) { BLOCK_SIZE bsize ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; bsize = get_rd_var_based_fixed_partition ( cpi , x , mi_row , mi_col ) ; set_fixed_partitioning ( cpi , tile_info , mi , mi_row , mi_col , bsize ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else if ( <S2SV_ModStart> == VAR_BASED_PARTITION && cm -> frame_type != KEY_FRAME ) { choose_partitioning ( cpi , tile_info , x , mi_row , mi_col ) ; rd_use_partition ( cpi , td , tile_data , mi , tp , mi_row , mi_col , BLOCK_64X64 , & dummy_rate , & dummy_dist , 1 , td -> pc_root ) ; } else { if ( <S2SV_ModEnd> sf -> <S2SV_ModStart> sf -> auto_min_max_partition_size <S2SV_ModEnd> ) { <S2SV_ModStart> cpi , tile_info , x , mi_row , mi_col , BLOCK_64X64 ) ; rd_auto_partition_range ( cpi , tile_info , xd , mi_row , mi_col , & x -> min_partition_size , & x -> max_partition_size ) ; } rd_pick_partition ( cpi , td , tile_data <S2SV_ModEnd> , tp <S2SV_ModStart> , & dummy_rdc <S2SV_ModEnd> , INT64_MAX <S2SV_ModStart> , INT64_MAX , td -> pc_root <S2SV_ModEnd> ) ;
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs <S2SV_ModStart> BLOCK_SIZE subsize = bsize <S2SV_ModStart> subsize = get_subsize ( bsize , pc_tree -> partitioning <S2SV_ModEnd> ) ; <S2SV_ModStart> subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ <S2SV_ModStart> PARTITION_NONE : <S2SV_ModEnd> encode_b ( <S2SV_ModStart> tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_VERT : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> -> mi_cols && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_HORZ : encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> -> mi_rows && bsize > BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_SPLIT : <S2SV_ModEnd> if ( <S2SV_ModStart> if ( bsize == BLOCK_8X8 ) { encode_b ( cpi , tile , td , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> encode_sb ( <S2SV_ModStart> cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) ; encode_sb ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb <S2SV_ModStart> cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb <S2SV_ModStart> cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] ) ; } <S2SV_ModEnd> break ; <S2SV_ModStart> assert ( 0 && <S2SV_ModStart> "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; break
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs <S2SV_ModStart> ) { <S2SV_ModEnd> const int <S2SV_ModStart> ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; <S2SV_ModStart> PARTITION_NONE : <S2SV_ModEnd> encode_b_rt ( <S2SV_ModStart> cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_VERT : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> -> mi_cols && bsize > BLOCK_8X8 <S2SV_ModStart> ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_HORZ : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> -> mi_rows && bsize > BLOCK_8X8 <S2SV_ModStart> ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; encode_sb_rt <S2SV_ModStart> cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb_rt <S2SV_ModStart> cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb_rt <S2SV_ModStart> cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> assert ( 0 && <S2SV_ModStart> "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; break
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> mbmi ; const int seg_skip = segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) <S2SV_ModEnd> ; const <S2SV_ModStart> x -> select_tx_size <S2SV_ModEnd> && mbmi <S2SV_ModStart> allow_skip_recode ; if ( ! x -> skip_recode && ! cpi -> sf . use_nonrd_pick_mode ) memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> if ( ! is_inter_block ( mbmi ) <S2SV_ModEnd> ) { <S2SV_ModStart> ) { int plane ; mbmi -> skip = 1 ; for ( plane = 0 ; plane < MAX_MB_PLANE ; ++ plane ) vp9_encode_intra_block_plane ( x , MAX ( bsize , BLOCK_8X8 ) , plane ) ; <S2SV_ModStart> if ( output_enabled ) sum_intra_stats ( td -> counts , mi ) ; vp9_tokenize_sb ( cpi , td , t , ! output_enabled , MAX ( bsize , BLOCK_8X8 ) ) ; <S2SV_ModEnd> } else <S2SV_ModStart> else { int ref ; const int is_compound = has_second_ref ( mbmi ) ; <S2SV_ModStart> 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; assert ( cfg != NULL ) ; <S2SV_ModStart> ; } if ( ! ( cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ) || seg_skip ) vp9_build_inter_predictors_sby <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; vp9_build_inter_predictors_sbuv ( xd , mi_row , mi_col , MAX ( bsize , BLOCK_8X8 ) ) <S2SV_ModEnd> ; vp9_encode_sb <S2SV_ModStart> ( cpi , td <S2SV_ModStart> ) ; <S2SV_ModEnd> } if <S2SV_ModStart> skip || seg_skip <S2SV_ModEnd> ) ) <S2SV_ModStart> ] , get_tx_size_context <S2SV_ModEnd> ( xd <S2SV_ModStart> , & td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> tx ) <S2SV_ModStart> ; } ++ td -> counts -> tx . tx_totals [ mbmi -> tx_size ] ; ++ td -> counts -> tx . tx_totals [ get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] ) ] ;
<S2SV_ModStart> bsize , PC_TREE * pc_tree <S2SV_ModEnd> ) { <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs <S2SV_ModStart> partition = pc_tree -> partitioning ; BLOCK_SIZE subsize = get_subsize ( bsize , partition ) <S2SV_ModEnd> ; assert <S2SV_ModStart> PARTITION_NONE : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd <S2SV_ModStart> ) = pc_tree -> none . mic ; * ( x -> mbmi_ext ) = pc_tree -> none . mbmi_ext <S2SV_ModEnd> ; duplicate_mode_info_in_sb <S2SV_ModStart> PARTITION_VERT : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd <S2SV_ModStart> ) = pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic ; <S2SV_ModStart> mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 0 ] . mbmi_ext ; <S2SV_ModStart> mi_col , subsize <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { set_mode_info_offsets ( cm , x , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic ; <S2SV_ModStart> mic ; * ( x -> mbmi_ext ) = pc_tree -> vertical [ 1 ] . mbmi_ext ; <S2SV_ModStart> hbs , subsize <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_HORZ : set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd <S2SV_ModStart> ) = pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic ; <S2SV_ModStart> mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 0 ] . mbmi_ext ; <S2SV_ModStart> mi_col , subsize <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { set_mode_info_offsets ( cm , x , xd , mi_row + hbs , mi_col ) ; * ( xd -> mi [ 0 ] ) = pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic ; <S2SV_ModStart> mic ; * ( x -> mbmi_ext ) = pc_tree -> horizontal [ 1 ] . mbmi_ext ; <S2SV_ModStart> mi_col , subsize <S2SV_ModEnd> ) ; <S2SV_ModStart> PARTITION_SPLIT : { <S2SV_ModEnd> fill_mode_info_sb ( <S2SV_ModStart> subsize , pc_tree -> split [ 0 ] ) ; fill_mode_info_sb ( cm , x , mi_row , mi_col + hbs , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; fill_mode_info_sb <S2SV_ModStart> , mi_row + hbs , mi_col , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; fill_mode_info_sb <S2SV_ModStart> , mi_col + hbs , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> break ; }
<S2SV_ModStart> v -> log2_count <S2SV_ModEnd> = c <S2SV_ModStart> c ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> variance_node node ; memset ( & node , 0 , sizeof ( node ) )
<S2SV_ModStart> ) return GOLDEN_FRAME <S2SV_ModEnd> ; else <S2SV_ModStart> else return LAST_FRAME <S2SV_ModEnd> ; }
<S2SV_ModStart> * cpi , MACROBLOCK * x <S2SV_ModStart> , & x -> plane [ 0 ] . src <S2SV_ModEnd> , mi_row
<S2SV_ModStart> get_sb_partition_size_range ( MACROBLOCKD * xd <S2SV_ModEnd> , MODE_INFO <S2SV_ModStart> * max_block_size , int bs_hist [ BLOCK_SIZES ] <S2SV_ModStart> ) { <S2SV_ModEnd> int sb_width_in_blocks <S2SV_ModStart> 0 ; bs_hist [ sb_type ] ++ ;
<S2SV_ModStart> cpi , const struct buf_2d * ref <S2SV_ModEnd> , int <S2SV_ModStart> ) { unsigned int sse , var ; uint8_t * last_y ; <S2SV_ModStart> YV12_BUFFER_CONFIG * last <S2SV_ModEnd> = get_ref_frame_buffer <S2SV_ModStart> ) ; assert ( last != NULL ) ; last_y = & last -> y_buffer [ <S2SV_ModEnd> mi_row * <S2SV_ModStart> * MI_SIZE * last <S2SV_ModEnd> -> y_stride <S2SV_ModStart> y_stride + <S2SV_ModEnd> mi_col * <S2SV_ModStart> * MI_SIZE ] <S2SV_ModEnd> ; var <S2SV_ModStart> vf ( ref -> <S2SV_ModEnd> buf , <S2SV_ModStart> buf , ref -> <S2SV_ModEnd> stride , <S2SV_ModStart> stride , last_y , last <S2SV_ModEnd> -> y_stride
<S2SV_ModStart> cpi -> td . <S2SV_ModStart> ) ; <S2SV_ModEnd> vp9_setup_src_planes ( <S2SV_ModStart> -> Source <S2SV_ModEnd> , 0 <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( xd
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( x
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA <S2SV_ModStart> bsize , RD_COST * rd_cost , <S2SV_ModEnd> int do_recon <S2SV_ModStart> int64_t best_rd , PC_TREE * pc_tree ) { const SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> VP9_COMMON * <S2SV_ModStart> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> ctx = & pc_tree -> none <S2SV_ModEnd> ; int <S2SV_ModStart> BLOCK_SIZE subsize = bsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int <S2SV_ModStart> tp_orig ; <S2SV_ModEnd> assert ( <S2SV_ModStart> ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; if ( sf -> <S2SV_ModEnd> auto_min_max_partition_size ) <S2SV_ModStart> bsize <= x -> <S2SV_ModEnd> max_partition_size && <S2SV_ModStart> bsize >= x -> <S2SV_ModEnd> min_partition_size ) <S2SV_ModStart> bsize <= x -> <S2SV_ModEnd> max_partition_size && <S2SV_ModStart> bsize > x -> <S2SV_ModEnd> min_partition_size ) <S2SV_ModStart> bsize <= x -> <S2SV_ModEnd> max_partition_size && <S2SV_ModStart> bsize > x -> <S2SV_ModEnd> min_partition_size ) <S2SV_ModStart> bsize > x -> min_partition_size ; } if ( sf -> <S2SV_ModEnd> use_square_partition_only ) <S2SV_ModStart> ; } ctx -> pred_pixel_ready = ! ( partition_vert_allowed || <S2SV_ModEnd> partition_horz_allowed || <S2SV_ModStart> partition_horz_allowed || do_split ) <S2SV_ModEnd> ; if <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> , & this_rdc , bsize , ctx ) ; ctx <S2SV_ModEnd> -> mic <S2SV_ModStart> mbmi ; ctx -> mbmi_ext = * x -> mbmi_ext ; ctx -> skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; ctx -> skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX <S2SV_ModStart> ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ) { <S2SV_ModStart> { int64_t dist_breakout_thr = sf -> partition_search_breakout_dist_thr <S2SV_ModEnd> ; int64_t <S2SV_ModStart> ; int64_t rate_breakout_thr = sf -> partition_search_breakout_rate_thr ; dist_breakout_thr <S2SV_ModEnd> >>= 8 <S2SV_ModStart> ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; best_rdc = this_rdc ; if ( bsize >= BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> ; if <S2SV_ModStart> lossless && this_rdc . rate < rate_breakout_thr && this_rdc . dist < dist_breakout_thr <S2SV_ModEnd> ) { <S2SV_ModStart> } } } store_pred_mv ( x , ctx ) ; if ( do_split <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> PARTITION_SPLIT ] ; sum_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , sum_rdc . rate , sum_rdc . dist ) <S2SV_ModStart> 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ <S2SV_ModStart> continue ; <S2SV_ModEnd> load_pred_mv ( <S2SV_ModStart> cpi , td , tile_data <S2SV_ModEnd> , tp <S2SV_ModStart> , & this_rdc , 0 , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } <S2SV_ModStart> else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } <S2SV_ModStart> if ( sf -> <S2SV_ModEnd> less_rectangular_check ) <S2SV_ModStart> ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row <S2SV_ModStart> ) { <S2SV_ModEnd> load_pred_mv ( <S2SV_ModStart> ) ; pc_tree -> horizontal [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> , & this_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; if ( sf -> adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 ; nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col <S2SV_ModStart> ) { <S2SV_ModEnd> load_pred_mv ( <S2SV_ModStart> ) ; pc_tree -> vertical [ 1 ] . pred_pixel_ready = 1 ; <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> , & this_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & sum_rdc ) <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , sum_rdc . rate , sum_rdc . dist ) ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } else { pred_pixel_ready_reset ( pc_tree , bsize ) ; } } * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> INT_MAX ) { vp9_rd_cost_reset ( rd_cost ) ; <S2SV_ModStart> return ; } <S2SV_ModStart> bsize , pc_tree ) ; if ( best_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX <S2SV_ModStart> ) ; encode_sb_rt <S2SV_ModEnd> ( cpi <S2SV_ModStart> ( cpi , td , tile_info , tp <S2SV_ModEnd> , mi_row <S2SV_ModStart> output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; <S2SV_ModStart> == BLOCK_64X64 && do_recon <S2SV_ModStart> assert ( best_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX
<S2SV_ModStart> cpi , TileDataEnc * tile_data , MACROBLOCK * const x , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModEnd> TileInfo * <S2SV_ModStart> * const tile_info = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD <S2SV_ModStart> e_mbd ; MB_MODE_INFO * mbmi ; <S2SV_ModStart> cpi , tile_info , x , mi_row , mi_col , bsize ) ; mbmi = & <S2SV_ModEnd> xd -> <S2SV_ModStart> -> mbmi ; mbmi -> sb_type = bsize ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ; if ( cm -> frame_type == KEY_FRAME ) hybrid_intra_mode_search ( cpi , x , rd_cost , bsize , ctx ) ; else if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rd_cost , bsize ) ; else if ( bsize >= BLOCK_8X8 ) <S2SV_ModEnd> vp9_pick_inter_mode ( <S2SV_ModStart> x , tile_data , mi_row , mi_col , rd_cost , bsize , ctx ) ; else vp9_pick_inter_mode_sub8x8 ( cpi , x , mi_row , mi_col , rd_cost , bsize , ctx ) ; duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; if ( rd_cost -> rate == INT_MAX ) vp9_rd_cost_reset ( rd_cost ) ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist <S2SV_ModEnd> ; }
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO <S2SV_ModStart> * * mi <S2SV_ModEnd> , TOKENEXTRA <S2SV_ModStart> output_enabled , RD_COST * dummy_cost , PC_TREE * pc_tree <S2SV_ModEnd> ) { <S2SV_ModStart> common ; TileInfo * tile_info = & tile_data -> tile_info ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs <S2SV_ModStart> subsize ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) ? mi <S2SV_ModEnd> [ 0 <S2SV_ModStart> ] ; if ( output_enabled && bsize != BLOCK_4X4 ) { int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; td -> counts -> partition [ ctx ] [ partition ] ++ ; } <S2SV_ModStart> PARTITION_NONE : pc_tree -> none . pred_pixel_ready = 1 ; <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> none ) ; pc_tree -> none . <S2SV_ModEnd> mic . <S2SV_ModStart> -> mbmi ; pc_tree -> none . mbmi_ext = * x -> mbmi_ext ; pc_tree -> none . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> none . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none ) <S2SV_ModStart> PARTITION_VERT : pc_tree -> vertical [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> vertical [ 0 ] ) ; pc_tree -> vertical [ 0 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> -> mbmi ; pc_tree -> vertical [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModStart> -> mi_cols && bsize > BLOCK_8X8 <S2SV_ModStart> ) { pc_tree -> vertical [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col + hbs , dummy_cost , subsize , & pc_tree -> vertical [ 1 ] ) ; pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi ; pc_tree -> vertical [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> vertical [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> vertical [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] ) ; <S2SV_ModEnd> } break <S2SV_ModStart> PARTITION_HORZ : pc_tree -> horizontal [ 0 ] . pred_pixel_ready = 1 <S2SV_ModEnd> ; nonrd_pick_sb_modes <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 0 ] ) ; pc_tree -> horizontal [ 0 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> -> mbmi ; pc_tree -> horizontal [ 0 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 0 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 0 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] ) <S2SV_ModStart> -> mi_rows && bsize > BLOCK_8X8 <S2SV_ModStart> ) { pc_tree -> horizontal [ 1 ] . pred_pixel_ready <S2SV_ModEnd> = 1 <S2SV_ModStart> cpi , tile_data , x , mi_row + hbs , mi_col , dummy_cost , subsize , & pc_tree -> horizontal [ 1 ] ) ; pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> mic . <S2SV_ModStart> mbmi = xd -> mi <S2SV_ModEnd> [ 0 <S2SV_ModStart> mbmi ; pc_tree -> horizontal [ 1 ] . mbmi_ext = * x -> mbmi_ext ; pc_tree -> horizontal [ 1 ] . skip_txfm [ 0 ] = x -> skip_txfm [ 0 ] ; pc_tree -> horizontal [ 1 ] . skip = x -> skip ; encode_b_rt ( cpi , td , tile_info , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] ) ; <S2SV_ModEnd> } break <S2SV_ModStart> ) ; if ( bsize == BLOCK_8X8 ) { nonrd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , dummy_cost , subsize , pc_tree -> leaf_split [ 0 ] ) ; encode_b_rt ( cpi , td , tile_info , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> leaf_split [ 0 ] ) ; } else { <S2SV_ModEnd> nonrd_use_partition ( <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> , tp <S2SV_ModStart> output_enabled , dummy_cost , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; nonrd_use_partition <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> + hbs <S2SV_ModStart> output_enabled , dummy_cost , pc_tree -> split [ 1 ] ) ; nonrd_use_partition ( cpi , td , tile_data , mi + hbs * mis , tp , mi_row + hbs , mi_col , subsize , output_enabled , dummy_cost , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; nonrd_use_partition <S2SV_ModStart> cpi , td , tile_data , mi <S2SV_ModEnd> + hbs <S2SV_ModStart> * mis + hbs <S2SV_ModStart> , mi_col + hbs <S2SV_ModStart> output_enabled , dummy_cost , pc_tree -> split [ 3 ] ) <S2SV_ModEnd> ; } <S2SV_ModStart> assert ( 0 && <S2SV_ModStart> ) ; break ; <S2SV_ModStart> if ( partition != PARTITION_SPLIT || <S2SV_ModStart> bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize <S2SV_ModEnd> , bsize <S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> tile , MACROBLOCKD * const xd , <S2SV_ModStart> common ; <S2SV_ModEnd> MODE_INFO * <S2SV_ModStart> * * mi <S2SV_ModEnd> = xd <S2SV_ModStart> left_available && mi <S2SV_ModEnd> [ - <S2SV_ModStart> up_available && mi <S2SV_ModEnd> [ - <S2SV_ModStart> ] ; const <S2SV_ModEnd> int row8x8_remaining <S2SV_ModStart> mi_row ; const <S2SV_ModStart> = BLOCK_64X64 ; int bs_hist [ BLOCK_SIZES ] = { 0 } <S2SV_ModStart> * * <S2SV_ModEnd> prev_mi = <S2SV_ModStart> get_sb_partition_size_range ( xd <S2SV_ModEnd> , prev_mi <S2SV_ModStart> & max_size , bs_hist <S2SV_ModStart> ) { MODE_INFO * * left_sb64_mi = & mi <S2SV_ModEnd> [ - <S2SV_ModStart> get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { MODE_INFO * * above_sb64_mi = & mi <S2SV_ModEnd> [ - <S2SV_ModStart> get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { min_size = BLOCK_4X4 ; } else { <S2SV_ModStart> MIN ( cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ; } <S2SV_ModEnd> if (
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , TOKENEXTRA <S2SV_ModStart> mi_row , int mi_col , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> bsize , RD_COST * rd_cost , <S2SV_ModEnd> int64_t best_rd <S2SV_ModStart> int64_t best_rd , PC_TREE * pc_tree <S2SV_ModStart> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> ctx = & pc_tree -> none <S2SV_ModEnd> ; int <S2SV_ModStart> subsize ; RD_COST this_rdc , sum_rdc , best_rdc <S2SV_ModEnd> ; int <S2SV_ModStart> subsampling_y ; BLOCK_SIZE min_size = x -> min_partition_size ; BLOCK_SIZE max_size = x -> max_partition_size ; # if CONFIG_FP_MB_STATS unsigned int src_diff_var = UINT_MAX ; int none_complexity = 0 ; # endif <S2SV_ModStart> tp_orig ; <S2SV_ModEnd> assert ( <S2SV_ModStart> bsize ] ) ; vp9_rd_cost_init ( & this_rdc ) ; vp9_rd_cost_init ( & sum_rdc ) ; vp9_rd_cost_reset ( & best_rdc ) ; best_rdc . rdcost = best_rd ; set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize <S2SV_ModStart> == BLOCK_16X16 && cpi -> oxcf . aq_mode ) <S2SV_ModEnd> x -> <S2SV_ModStart> ) ; if ( cpi -> sf . cb_partition_search && bsize == BLOCK_16X16 ) { int cb_partition_search_ctrl = ( ( pc_tree -> index == 0 || pc_tree -> index == 3 ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; if ( cb_partition_search_ctrl && bsize > min_size && bsize < max_size ) set_partition_range ( cm , xd , mi_row , mi_col , bsize , & min_size , & max_size <S2SV_ModEnd> ) ; <S2SV_ModStart> bsize <= max_size && <S2SV_ModEnd> bsize >= <S2SV_ModStart> bsize >= min_size <S2SV_ModEnd> ) ; <S2SV_ModStart> bsize <= max_size && <S2SV_ModEnd> bsize > <S2SV_ModStart> bsize > min_size <S2SV_ModEnd> ) || <S2SV_ModStart> bsize <= max_size && <S2SV_ModEnd> bsize > <S2SV_ModStart> bsize > min_size <S2SV_ModEnd> ) || <S2SV_ModStart> bsize > min_size <S2SV_ModEnd> ; } <S2SV_ModStart> save_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } # endif # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && bsize >= BLOCK_32X32 && do_split && partition_none_allowed && src_diff_var > 4 && cm -> base_qindex < qindex_split_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c ; MOTION_DIRECTION this_mv ; MOTION_DIRECTION right_mv ; MOTION_DIRECTION bottom_mv ; this_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index ] ) ; if ( c != mb_col_end - 1 ) { right_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + 1 ] ) ; none_complexity += get_motion_inconsistency ( this_mv , right_mv ) ; } if ( r != mb_row_end - 1 ) { bottom_mv = get_motion_direction_fp ( cpi -> twopass . this_frame_mb_stats [ mb_index + cm -> mb_cols ] ) ; none_complexity += get_motion_inconsistency ( this_mv , bottom_mv ) ; } } } if ( none_complexity > complexity_16x16_blocks_threshold [ bsize ] ) { partition_none_allowed <S2SV_ModEnd> = 0 <S2SV_ModStart> 0 ; } } # endif <S2SV_ModEnd> if ( <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , & this_rdc , bsize , <S2SV_ModEnd> ctx , <S2SV_ModStart> ctx , best_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> != INT_MAX <S2SV_ModStart> ) ; this_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , this_rdc . rate , this_rdc . dist ) ; } if ( this_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ) { <S2SV_ModStart> { int64_t dist_breakout_thr = cpi -> sf . partition_search_breakout_dist_thr ; int rate_breakout_thr = cpi -> sf . partition_search_breakout_rate_thr ; best_rdc = this_rdc <S2SV_ModEnd> ; if <S2SV_ModStart> BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; dist_breakout_thr <S2SV_ModEnd> >>= 8 <S2SV_ModStart> ) ; rate_breakout_thr *= num_pels_log2_lookup [ bsize ] ; if ( ! x -> e_mbd . lossless && ( ctx -> skippable && best_rdc . dist < dist_breakout_thr && best_rdc . rate < rate_breakout_thr ) ) { do_split = 0 ; do_rect = 0 ; } # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats && do_split != 0 && cm -> base_qindex > qindex_skip_threshold_lookup [ bsize ] ) { int mb_row = mi_row >> 1 ; int mb_col = mi_col >> 1 ; int mb_row_end = MIN ( mb_row + num_16x16_blocks_high_lookup [ bsize ] , cm -> mb_rows ) ; int mb_col_end = MIN ( mb_col + num_16x16_blocks_wide_lookup [ bsize ] , cm -> mb_cols ) ; int r , c ; int skip = 1 ; for ( r = mb_row ; r < mb_row_end ; r ++ ) { for ( c = mb_col ; c < mb_col_end ; c ++ ) { const int mb_index = r * cm -> mb_cols + c <S2SV_ModEnd> ; if <S2SV_ModStart> ( ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_MOTION_ZERO_MASK ) || ! ( cpi -> twopass . this_frame_mb_stats [ mb_index ] & FPMB_ERROR_SMALL_MASK ) ) { skip = 0 ; break ; } } if ( skip == 0 ) { break ; } } if ( skip ) { if ( src_diff_var == UINT_MAX ) { set_offsets ( cpi , tile_info , x , mi_row , mi_col , bsize ) ; src_diff_var = get_sby_perpixel_diff_variance ( cpi , & x -> plane [ 0 ] . src , mi_row , mi_col , bsize ) ; } if ( src_diff_var < 8 <S2SV_ModEnd> ) { <S2SV_ModStart> } } # endif } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( cpi -> sf . adaptive_motion_search ) store_pred_mv ( x , ctx ) ; if ( do_split ) { subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; if ( bsize == BLOCK_8X8 ) { i = 4 ; if ( cpi -> sf . adaptive_pred_interp_filter && partition_none_allowed ) pc_tree -> leaf_split [ 0 ] -> pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc , subsize , pc_tree -> leaf_split [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rate == INT_MAX ) sum_rdc . rdcost = INT64_MAX ; } else { <S2SV_ModEnd> for ( <S2SV_ModStart> 4 && sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> ; ++ <S2SV_ModStart> continue ; if ( cpi -> sf . adaptive_motion_search ) load_pred_mv ( x , ctx ) ; pc_tree -> split [ i ] -> index = i <S2SV_ModEnd> ; rd_pick_partition <S2SV_ModStart> cpi , td , tile_data <S2SV_ModEnd> , tp <S2SV_ModStart> , & this_rdc , best_rdc . rdcost - sum_rdc . rdcost , pc_tree -> split [ i ] ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX <S2SV_ModStart> INT64_MAX ; break ; <S2SV_ModStart> else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } } if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && i <S2SV_ModStart> ) ; sum_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModEnd> ; } <S2SV_ModStart> restore_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> partition_horz_allowed && ( do_rect || vp9_active_h_edge ( cpi , mi_row , mi_step ) ) <S2SV_ModEnd> ) { <S2SV_ModStart> PARTITION_HORZ ) <S2SV_ModEnd> ; if <S2SV_ModStart> partition_none_allowed ) pc_tree -> horizontal [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> horizontal [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_row <S2SV_ModStart> -> mi_rows && bsize > BLOCK_8X8 ) { PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; <S2SV_ModEnd> update_state ( <S2SV_ModStart> cpi , td , ctx , mi_row , mi_col <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , <S2SV_ModEnd> subsize , <S2SV_ModStart> subsize , ctx ) <S2SV_ModEnd> ; if <S2SV_ModStart> partition_none_allowed ) pc_tree -> horizontal [ 1 ] . <S2SV_ModEnd> pred_interp_filter = <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> , & this_rdc , subsize , & pc_tree -> horizontal [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX <S2SV_ModStart> else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_HORZ ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_HORZ ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } if ( partition_vert_allowed && ( do_rect || vp9_active_v_edge ( cpi , mi_col , mi_step ) ) ) { subsize <S2SV_ModEnd> = get_subsize <S2SV_ModStart> PARTITION_VERT ) <S2SV_ModEnd> ; if <S2SV_ModStart> partition_none_allowed ) pc_tree -> vertical [ 0 ] . pred_interp_filter = ctx -> mic . mbmi . interp_filter ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & sum_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & pc_tree -> vertical [ 0 ] , best_rdc . rdcost ) ; if ( sum_rdc . rdcost < best_rdc . rdcost <S2SV_ModEnd> && mi_col <S2SV_ModStart> -> mi_cols && bsize > BLOCK_8X8 <S2SV_ModStart> cpi , td , & pc_tree -> vertical [ 0 ] , mi_row , mi_col <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , <S2SV_ModEnd> subsize , <S2SV_ModStart> subsize , & pc_tree -> vertical [ 0 ] ) <S2SV_ModEnd> ; if <S2SV_ModStart> partition_none_allowed ) pc_tree -> vertical [ 1 ] . <S2SV_ModEnd> pred_interp_filter = <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> , & this_rdc , subsize <S2SV_ModEnd> , & <S2SV_ModStart> , & pc_tree -> vertical [ 1 ] , best_rdc . rdcost - sum_rdc . rdcost ) ; if ( this_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> ) { sum_rdc . rdcost <S2SV_ModEnd> = INT64_MAX <S2SV_ModStart> else { sum_rdc . rate += this_rdc . rate ; sum_rdc . dist += this_rdc . dist ; sum_rdc . rdcost += this_rdc . rdcost ; } } if ( sum_rdc . rdcost < best_rdc . rdcost ) { pl = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; sum_rdc . rate += cpi -> partition_cost [ pl ] [ PARTITION_VERT ] ; sum_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , sum_rdc . rate , sum_rdc . dist ) ; if ( sum_rdc . rdcost < best_rdc . rdcost ) { best_rdc = sum_rdc ; pc_tree -> partitioning = PARTITION_VERT ; } } restore_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; } ( void ) best_rd <S2SV_ModEnd> ; * <S2SV_ModStart> ; * rd_cost = best_rdc ; if ( best_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> INT_MAX && best_rdc . dist <S2SV_ModEnd> < INT64_MAX <S2SV_ModStart> INT64_MAX && pc_tree -> index != 3 <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; encode_sb ( cpi , td , tile_info , tp <S2SV_ModEnd> , mi_row <S2SV_ModStart> output_enabled , bsize , pc_tree <S2SV_ModEnd> ) ; <S2SV_ModStart> assert ( best_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> assert ( best_rdc . dist <S2SV_ModEnd> < INT64_MAX
<S2SV_ModStart> cpi , TileDataEnc * tile_data , MACROBLOCK * const x <S2SV_ModEnd> , int <S2SV_ModStart> mi_col , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE <S2SV_ModStart> common ; TileInfo * const tile_info <S2SV_ModEnd> = & <S2SV_ModStart> = & tile_data -> tile_info <S2SV_ModEnd> ; MACROBLOCKD <S2SV_ModStart> orig_rdmult ; vpx_clear_system_state ( ) <S2SV_ModEnd> ; x <S2SV_ModStart> 1 ; <S2SV_ModEnd> set_offsets ( <S2SV_ModStart> cpi , tile_info , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> 0 ; ctx -> skippable = 0 ; ctx -> pred_pixel_ready = 0 ; <S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> source_variance = vp9_high_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize , xd -> bd ) ; } else { x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; } # else x -> source_variance = vp9_get_sby_perpixel_variance ( cpi , & x -> plane [ 0 ] . src , bsize ) ; # endif orig_rdmult = x -> rdmult <S2SV_ModEnd> ; if <S2SV_ModStart> segment_id = get_segment_id <S2SV_ModEnd> ( cm <S2SV_ModStart> ; } <S2SV_ModEnd> x -> <S2SV_ModStart> -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> x -> <S2SV_ModStart> -> rdmult = set_segment_rdmult ( cpi , x , mbmi -> segment_id <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( cyclic_refresh_segment_id_boosted ( get_segment_id <S2SV_ModEnd> ( cm <S2SV_ModStart> ) ) ) <S2SV_ModStart> x , rd_cost , bsize , ctx , <S2SV_ModEnd> best_rd ) <S2SV_ModStart> BLOCK_8X8 ) { if ( segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) vp9_rd_pick_inter_mode_sb_seg_skip ( cpi , tile_data , x , rd_cost , bsize , ctx , best_rd ) ; else <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> mi_col , rd_cost <S2SV_ModEnd> , bsize <S2SV_ModStart> ) ; } else { <S2SV_ModEnd> vp9_rd_pick_inter_mode_sub8x8 ( <S2SV_ModStart> cpi , tile_data , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> mi_col , rd_cost <S2SV_ModEnd> , bsize <S2SV_ModStart> ; } } if ( ( rd_cost -> rate <S2SV_ModEnd> != INT_MAX <S2SV_ModStart> INT_MAX ) && <S2SV_ModEnd> ( aq_mode <S2SV_ModStart> == COMPLEXITY_AQ ) && ( bsize >= BLOCK_16X16 ) && ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) ) { vp9_caq_select_segment ( cpi , x , bsize , mi_row , mi_col , rd_cost -> rate ) ; } x -> rdmult = orig_rdmult ; if ( rd_cost -> rate == INT_MAX ) rd_cost -> rdcost = INT64_MAX ; ctx -> rate = rd_cost -> rate ; ctx -> dist = rd_cost -> dist ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> cpi , ThreadData * td , TileDataEnc * tile_data <S2SV_ModEnd> , MODE_INFO <S2SV_ModStart> int do_recon , PC_TREE * pc_tree <S2SV_ModStart> common ; TileInfo * const tile_info = & tile_data -> tile_info ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const <S2SV_ModStart> ] ; RD_COST last_part_rdc , none_rdc , chosen_rdc <S2SV_ModEnd> ; BLOCK_SIZE <S2SV_ModStart> 1 ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; <S2SV_ModStart> ) ; vp9_rd_cost_reset ( & last_part_rdc ) ; vp9_rd_cost_reset ( & none_rdc ) ; vp9_rd_cost_reset ( & chosen_rdc ) ; <S2SV_ModStart> ) ; pc_tree -> partitioning = partition ; <S2SV_ModEnd> save_context ( <S2SV_ModStart> save_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> == BLOCK_16X16 && cpi -> oxcf . aq_mode <S2SV_ModStart> cpi , tile_info , x <S2SV_ModEnd> , mi_row <S2SV_ModStart> ) ; <S2SV_ModEnd> } if <S2SV_ModStart> ) { pc_tree -> partitioning = PARTITION_NONE <S2SV_ModEnd> ; rd_pick_sb_modes <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , & none_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX <S2SV_ModStart> if ( none_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> ) { none_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; none_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , none_rdc . rate , none_rdc . dist <S2SV_ModEnd> ) ; <S2SV_ModStart> restore_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> bs_type ; pc_tree -> partitioning = partition <S2SV_ModEnd> ; } <S2SV_ModStart> cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , bsize , ctx <S2SV_ModEnd> , INT64_MAX <S2SV_ModStart> PARTITION_HORZ : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> horizontal [ 0 ] , <S2SV_ModEnd> INT64_MAX ) <S2SV_ModStart> if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX <S2SV_ModStart> ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> horizontal [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> ; update_state <S2SV_ModStart> cpi , td , ctx , mi_row , mi_col <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , <S2SV_ModEnd> subsize , <S2SV_ModStart> subsize , ctx ) <S2SV_ModEnd> ; rd_pick_sb_modes <S2SV_ModStart> cpi , tile_data , x , <S2SV_ModEnd> mi_row + <S2SV_ModStart> , & tmp_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> , INT64_MAX <S2SV_ModStart> if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break <S2SV_ModStart> ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> ; } <S2SV_ModStart> PARTITION_VERT : rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> , INT64_MAX <S2SV_ModStart> if ( last_part_rdc . rate <S2SV_ModEnd> != INT_MAX <S2SV_ModStart> ) { RD_COST tmp_rdc ; PICK_MODE_CONTEXT * ctx = & pc_tree -> vertical [ 0 ] ; vp9_rd_cost_init ( & tmp_rdc ) <S2SV_ModEnd> ; update_state <S2SV_ModStart> cpi , td , ctx , mi_row , mi_col <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , 0 ) ; encode_superblock ( cpi , td , tp , 0 , mi_row , mi_col , <S2SV_ModEnd> subsize , <S2SV_ModStart> subsize , ctx ) <S2SV_ModEnd> ; rd_pick_sb_modes <S2SV_ModStart> cpi , tile_data , x , <S2SV_ModEnd> mi_row , <S2SV_ModStart> , & tmp_rdc <S2SV_ModEnd> , subsize <S2SV_ModStart> subsize , & pc_tree -> vertical [ bsize > BLOCK_8X8 ] , <S2SV_ModEnd> INT64_MAX ) <S2SV_ModStart> if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break <S2SV_ModStart> ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist ; last_part_rdc . rdcost += tmp_rdc . rdcost <S2SV_ModEnd> ; } <S2SV_ModStart> PARTITION_SPLIT : if ( bsize == BLOCK_8X8 ) { rd_pick_sb_modes ( cpi , tile_data , x , mi_row , mi_col , & last_part_rdc , subsize , pc_tree -> leaf_split [ 0 ] , INT64_MAX ) ; break ; } last_part_rdc . rate = 0 ; last_part_rdc . dist = 0 ; last_part_rdc . rdcost <S2SV_ModEnd> = 0 <S2SV_ModStart> 0x01 ; RD_COST tmp_rdc <S2SV_ModEnd> ; if <S2SV_ModStart> continue ; vp9_rd_cost_init ( & tmp_rdc ) ; rd_use_partition ( cpi , td , tile_data , mi_8x8 + jj * bss * mis + ii * bss , tp , mi_row + y_idx , mi_col + x_idx <S2SV_ModEnd> , subsize <S2SV_ModStart> , subsize , & tmp_rdc . rate , & tmp_rdc . dist <S2SV_ModEnd> , i <S2SV_ModStart> != 3 , pc_tree -> split [ i ] ) ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & last_part_rdc ) <S2SV_ModEnd> ; break <S2SV_ModStart> ; } last_part_rdc . rate += tmp_rdc . rate ; last_part_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; break ; <S2SV_ModStart> if ( last_part_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> ) { last_part_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; last_part_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , last_part_rdc . rate , last_part_rdc . dist <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; chosen_rdc . rate = 0 ; chosen_rdc . dist <S2SV_ModEnd> = 0 <S2SV_ModStart> restore_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> bsize ) ; pc_tree -> partitioning = PARTITION_SPLIT <S2SV_ModStart> ) ; RD_COST tmp_rdc <S2SV_ModEnd> ; ENTROPY_CONTEXT <S2SV_ModStart> continue ; save_context ( x , mi_row , mi_col , a , l , sa , sl , bsize ) ; pc_tree -> split [ i ] -> partitioning = PARTITION_NONE ; rd_pick_sb_modes ( cpi , tile_data , x , mi_row + y_idx , mi_col + x_idx , & tmp_rdc , split_subsize , & pc_tree -> split [ i ] -> none , INT64_MAX ) ; restore_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> ) ; if ( tmp_rdc . rate <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> INT_MAX || tmp_rdc . dist <S2SV_ModEnd> == INT64_MAX <S2SV_ModStart> ) { vp9_rd_cost_reset ( & chosen_rdc ) <S2SV_ModEnd> ; break <S2SV_ModStart> ; } chosen_rdc . rate += tmp_rdc . rate ; chosen_rdc . dist += tmp_rdc . dist <S2SV_ModEnd> ; if <S2SV_ModStart> cpi , td , tile_info <S2SV_ModEnd> , tp <S2SV_ModStart> , split_subsize , pc_tree -> split [ i ] <S2SV_ModStart> ) ; chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> if ( chosen_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> ) { chosen_rdc . rate += cpi <S2SV_ModEnd> -> partition_cost <S2SV_ModStart> ] ; chosen_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , chosen_rdc . rate , chosen_rdc . dist ) ; } } if ( last_part_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> ) { <S2SV_ModStart> BLOCK_8X8 ) pc_tree -> partitioning = partition ; chosen_rdc = last_part_rdc ; } if ( none_rdc . rdcost < chosen_rdc . rdcost <S2SV_ModEnd> ) { <S2SV_ModStart> BLOCK_8X8 ) pc_tree -> partitioning = PARTITION_NONE ; chosen_rdc = none_rdc <S2SV_ModEnd> ; } <S2SV_ModStart> restore_context ( x <S2SV_ModEnd> , mi_row <S2SV_ModStart> assert ( chosen_rdc . rate <S2SV_ModEnd> < INT_MAX <S2SV_ModStart> INT_MAX && chosen_rdc . dist <S2SV_ModEnd> < INT64_MAX <S2SV_ModStart> ) ; encode_sb ( cpi , td , tile_info , tp , mi_row , mi_col , <S2SV_ModEnd> output_enabled , <S2SV_ModStart> output_enabled , bsize , pc_tree ) ; } * rate = chosen_rdc . rate <S2SV_ModEnd> ; * <S2SV_ModStart> dist = chosen_rdc . dist <S2SV_ModEnd> ; }
<S2SV_ModStart> restore_context ( MACROBLOCK * const x <S2SV_ModEnd> , int <S2SV_ModStart> ) { <S2SV_ModEnd> MACROBLOCKD * <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( xd <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( xd <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( xd
<S2SV_ModStart> save_context ( MACROBLOCK * const x <S2SV_ModEnd> , int <S2SV_ModStart> { const <S2SV_ModEnd> MACROBLOCKD * <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( a <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( l <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( sa <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( sl
<S2SV_ModStart> * cpi , MACROBLOCKD * const xd <S2SV_ModStart> if ( xd -> <S2SV_ModEnd> lossless ) <S2SV_ModStart> lossless ) <S2SV_ModEnd> return ONLY_4X4 <S2SV_ModStart> ONLY_4X4 ; <S2SV_ModEnd> if ( <S2SV_ModStart> common . frame_type == KEY_FRAME && cpi -> sf . use_nonrd_pick_mode ) return ALLOW_16X16 ; <S2SV_ModEnd> if ( <S2SV_ModStart> USE_LARGESTALL ) <S2SV_ModEnd> return ALLOW_32X32 <S2SV_ModStart> ALLOW_32X32 ; <S2SV_ModEnd> else if <S2SV_ModStart> == USE_FULL_RD || <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> sf . tx_size_search_method == USE_TX_8X8 ) return <S2SV_ModEnd> TX_MODE_SELECT ; <S2SV_ModStart> TX_MODE_SELECT ; else <S2SV_ModEnd> return cpi <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> cpi , MACROBLOCK <S2SV_ModEnd> * const <S2SV_ModStart> * const x , MACROBLOCKD * const xd <S2SV_ModEnd> , int <S2SV_ModStart> ) { set_mode_info_offsets <S2SV_ModEnd> ( & <S2SV_ModStart> -> common , x <S2SV_ModStart> bsize ; <S2SV_ModEnd> } }
<S2SV_ModStart> mi_stride ; const <S2SV_ModStart> mi_row ; const <S2SV_ModStart> else { set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , bsize , mi_8x8 ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> tile , MACROBLOCK * const x , <S2SV_ModStart> ) { <S2SV_ModEnd> VP9_COMMON * <S2SV_ModStart> ; const <S2SV_ModEnd> struct segmentation <S2SV_ModStart> ) ; set_mode_info_offsets ( cm , x <S2SV_ModEnd> , xd <S2SV_ModStart> ( xd -> plane <S2SV_ModStart> cpi -> rd . <S2SV_ModStart> cpi -> rd . <S2SV_ModStart> segment_id = get_segment_id <S2SV_ModEnd> ( cm <S2SV_ModStart> ; } xd -> tile = * tile ;
<S2SV_ModStart> tile , MACROBLOCK * const x , <S2SV_ModStart> common ; <S2SV_ModEnd> const int <S2SV_ModStart> mi_stride ; const <S2SV_ModStart> mi_row ; const <S2SV_ModStart> mi_col ; <S2SV_ModEnd> MODE_INFO * <S2SV_ModStart> + mi_col ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) <S2SV_ModStart> ) { int i , j ; int index ; diff d32 [ 4 ] ; const int offset = ( mi_row >> 1 ) * cm -> mb_cols + ( mi_col >> 1 ) ; int is_larger_better = 0 ; int use32x32 = 0 ; unsigned int thr <S2SV_ModEnd> = cpi <S2SV_ModStart> cpi -> source_var_thresh ; memset ( d32 , 0 , 4 * sizeof ( diff ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { diff * d16 [ 4 ] ; for ( j = 0 ; j < 4 ; j ++ ) { int b_mi_row = coord_lookup [ i * 4 + j ] . row ; int b_mi_col = coord_lookup [ i * 4 + j ] . col ; int boffset = b_mi_row / 2 * cm -> mb_cols + b_mi_col / 2 ; d16 [ j ] <S2SV_ModEnd> = cpi <S2SV_ModStart> cpi -> source_diff_var + offset + boffset ; index = b_mi_row * mis + b_mi_col ; mi_8x8 [ index ] = mi_upper_left + index ; mi_8x8 [ index ] -> mbmi . sb_type = BLOCK_16X16 ; } is_larger_better = ( d16 [ 0 ] -> var < thr ) && ( d16 [ 1 ] -> var < thr ) && ( d16 [ 2 ] -> var < thr ) && ( d16 [ 3 ] -> var < thr ) ; if ( is_larger_better ) { use32x32 += 1 <S2SV_ModEnd> ; for <S2SV_ModStart> for ( j = 0 ; j < 4 ; j <S2SV_ModEnd> ++ ) <S2SV_ModStart> ) { d32 [ i <S2SV_ModEnd> ] . <S2SV_ModStart> . sse += d16 [ j ] -> sse ; d32 [ i <S2SV_ModEnd> ] . <S2SV_ModStart> . sum += d16 [ j ] -> sum ; } d32 [ i ] . var = d32 [ i <S2SV_ModEnd> ] . <S2SV_ModStart> sse - <S2SV_ModEnd> ( ( <S2SV_ModStart> BLOCK_32X32 ; } } <S2SV_ModStart> if ( use32x32 == 4 ) { thr <<= 1 ; is_larger_better = ( d32 [ 0 ] . var < thr ) && ( d32 [ 1 ] . var < thr ) && ( d32 [ 2 ] . var < thr ) && ( d32 [ 3 ] . var < thr ) ; if ( is_larger_better ) { mi_8x8 [ 0 ] = mi_upper_left ; mi_8x8 [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; } } <S2SV_ModEnd> } else <S2SV_ModStart> else { int bh = num_8x8_blocks_high_lookup [ BLOCK_16X16 ] ; int bw = num_8x8_blocks_wide_lookup [ BLOCK_16X16 ] ; set_partial_b64x64_partition ( mi_upper_left , mis , bh , bw , row8x8_remaining , col8x8_remaining , BLOCK_16X16 , mi_8x8 ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> cpi , MACROBLOCK * const x , MACROBLOCKD * const xd , <S2SV_ModStart> data , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> mi_col , int64_t threshold , BLOCK_SIZE bsize_min , int force_split <S2SV_ModEnd> ) { <S2SV_ModStart> ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) <S2SV_ModEnd> ; assert <S2SV_ModStart> if ( force_split == 1 ) return 0 ; if ( bsize == bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( <S2SV_ModStart> cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } return 0 ; } else if ( bsize > bsize_min ) { if ( low_res || cm -> frame_type == KEY_FRAME ) get_variance ( & vt . part_variances -> none ) ; if ( cm -> frame_type == KEY_FRAME && ( bsize > BLOCK_32X32 || vt . part_variances -> none . variance > ( threshold << 4 ) ) ) { return 0 ; } if ( mi_col + block_width / 2 < cm -> mi_cols && <S2SV_ModEnd> mi_row + <S2SV_ModStart> part_variances -> none <S2SV_ModEnd> . variance <S2SV_ModStart> < threshold ) { set_block_size ( cpi , x , xd , mi_row , mi_col , bsize ) ; return 1 ; } if ( mi_row + block_height / 2 < cm -> mi_rows <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; get_variance ( & vt . part_variances -> vert [ 0 ] ) ; get_variance ( & vt . part_variances -> vert [ 1 ] ) ; if ( vt . part_variances -> vert [ 0 ] . variance < threshold && vt . part_variances -> vert [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> cpi , x , xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> cpi , x , xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> ; } } <S2SV_ModStart> -> mi_cols <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; get_variance ( & vt . part_variances -> horz [ 0 ] ) ; get_variance ( & vt . part_variances -> horz [ 1 ] ) ; if ( vt . part_variances -> horz [ 0 ] . variance < threshold && vt . part_variances -> horz [ 1 ] . variance < threshold && get_plane_block_size ( subsize , & xd -> plane [ 1 ] ) < BLOCK_INVALID ) { <S2SV_ModStart> cpi , x , xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> cpi , x , xd <S2SV_ModEnd> , mi_row <S2SV_ModStart> ; } } return 0 ; }
<S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( ctx
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ) { assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> a -> log2_count + 1 <S2SV_ModEnd> , r
<S2SV_ModStart> { const PREDICTION_MODE <S2SV_ModEnd> y_mode = <S2SV_ModStart> ; const PREDICTION_MODE <S2SV_ModEnd> uv_mode =
<S2SV_ModStart> i ; node -> part_variances = NULL ; <S2SV_ModStart> i ] . part_variances . none ; break ; } case BLOCK_4X4 : { v4x4 * vt = ( v4x4 * ) data ; node -> part_variances = & vt -> part_variances ; for ( i = 0 ; i < 4 ; i ++ ) node -> split [ i ] = & vt -> split [ i ] <S2SV_ModStart> ) ; break ;
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> common ; RD_COUNTS * const rdc = & td -> rd_counts ; <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> -> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h <S2SV_ModStart> mi ; * x -> mbmi_ext = ctx -> mbmi_ext ; <S2SV_ModStart> -> enabled <S2SV_ModEnd> ) { <S2SV_ModStart> segment_id = get_segment_id <S2SV_ModEnd> ( cm <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> bsize , ctx -> rate , ctx -> dist , x -> skip <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( <S2SV_ModEnd> is_inter_block ( <S2SV_ModStart> skip ; memcpy <S2SV_ModEnd> ( x <S2SV_ModStart> sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * <S2SV_ModStart> return ; <S2SV_ModEnd> # if <S2SV_ModStart> vp9_update_mv_count ( td <S2SV_ModEnd> ) ; <S2SV_ModStart> ; ++ td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> switchable_interp [ <S2SV_ModStart> } } rdc -> comp_pred_diff <S2SV_ModEnd> [ SINGLE_REFERENCE <S2SV_ModStart> single_pred_diff ; rdc -> comp_pred_diff <S2SV_ModEnd> [ COMPOUND_REFERENCE <S2SV_ModStart> comp_pred_diff ; rdc -> comp_pred_diff <S2SV_ModEnd> [ REFERENCE_MODE_SELECT <S2SV_ModStart> i ) rdc -> filter_diff <S2SV_ModEnd> [ i <S2SV_ModStart> ; } for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } }
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> e_mbd ; MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_ModStart> seg ; const int bw = num_8x8_blocks_wide_lookup [ mi -> mbmi . sb_type ] ; const int bh = num_8x8_blocks_high_lookup [ mi -> mbmi . sb_type ] ; const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ; const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ; <S2SV_ModStart> mic ; * ( x -> mbmi_ext ) = ctx -> mbmi_ext ; <S2SV_ModStart> if ( seg -> enabled && cpi -> oxcf . aq_mode ) { if <S2SV_ModStart> aq_mode == COMPLEXITY_AQ || cpi -> oxcf . aq_mode == VARIANCE_AQ ) { const uint8_t * const map = <S2SV_ModEnd> seg -> <S2SV_ModStart> seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; mbmi -> segment_id = get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; } else <S2SV_ModEnd> { vp9_cyclic_refresh_update_segment <S2SV_ModStart> cpi , mbmi , <S2SV_ModEnd> mi_row , <S2SV_ModStart> bsize , ctx -> rate , ctx -> dist , x -> skip ) ; } <S2SV_ModEnd> vp9_init_plane_quantizers ( <S2SV_ModStart> vp9_update_mv_count ( td <S2SV_ModEnd> ) ; <S2SV_ModStart> ; ++ td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> switchable_interp [ <S2SV_ModStart> ; } if ( mbmi -> sb_type < BLOCK_8X8 ) { mbmi -> mv [ 0 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 0 ] . as_int ; mbmi -> mv [ 1 ] . as_int = mi -> bmi [ 3 ] . as_mv [ 1 ] . as_int ; } } if ( cm -> use_prev_frame_mvs ) { MV_REF * const frame_mvs = cm -> cur_frame -> mvs + mi_row * cm -> mi_cols + mi_col ; int w , h ; for ( h = 0 ; h < y_mis ; ++ h ) { MV_REF * const frame_mv = frame_mvs + h * cm -> mi_cols ; for ( w = 0 ; w < x_mis ; ++ w ) { MV_REF * const mv = frame_mv + w ; mv -> ref_frame [ 0 ] = mi -> mbmi . ref_frame [ 0 ] ; mv -> ref_frame [ 1 ] = mi -> mbmi . ref_frame [ 1 ] ; mv -> mv [ 0 ] . as_int = mi -> mbmi . mv [ 0 ] . as_int ; mv -> mv [ 1 ] . as_int = mi -> mbmi . mv [ 1 ] . as_int ; } } <S2SV_ModStart> skip ; x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;
<S2SV_ModStart> update_stats ( <S2SV_ModEnd> VP9_COMMON * <S2SV_ModStart> VP9_COMMON * cm , ThreadData * td ) { const MACROBLOCK * x <S2SV_ModEnd> = & <S2SV_ModStart> = & td <S2SV_ModEnd> -> mb <S2SV_ModStart> mbmi ; const MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext ; const BLOCK_SIZE bsize = mbmi -> sb_type ; <S2SV_ModStart> ) { FRAME_COUNTS * const counts = td -> counts ; const int inter_block = is_inter_block ( mbmi ) ; <S2SV_ModStart> seg_ref_active = segfeature_active <S2SV_ModEnd> ( & <S2SV_ModStart> ) { <S2SV_ModEnd> counts -> <S2SV_ModStart> } } if ( inter_block && ! segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) { const int mode_ctx = mbmi_ext -> mode_context [ mbmi -> ref_frame [ 0 ] ] ; if ( bsize >= BLOCK_8X8 ) { const PREDICTION_MODE mode = mbmi -> mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( mode ) ] ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int j = idy * 2 + idx ; const PREDICTION_MODE b_mode = mi -> bmi [ j ] . as_mode ; ++ counts -> inter_mode [ mode_ctx ] [ INTER_OFFSET ( b_mode ) ] ; } } } }
<S2SV_ModStart> ) { cpi <S2SV_ModEnd> -> allow_comp_inter_inter <S2SV_ModStart> else { cpi <S2SV_ModEnd> -> allow_comp_inter_inter <S2SV_ModStart> int i ; RD_OPT * const rd_opt = & cpi -> rd ; FRAME_COUNTS * counts = cpi -> td . counts ; RD_COUNTS * const rdc = & cpi -> td . rd_counts <S2SV_ModStart> ) ; <S2SV_ModEnd> int64_t * <S2SV_ModStart> int64_t * const mode_thrs = rd_opt -> prediction_type_threshes <S2SV_ModEnd> [ frame_type <S2SV_ModStart> ] ; <S2SV_ModEnd> int64_t * <S2SV_ModStart> int64_t * const filter_thrs = rd_opt -> filter_threshes <S2SV_ModEnd> [ frame_type <S2SV_ModStart> ] ; const int is_alt_ref = <S2SV_ModEnd> frame_type == <S2SV_ModStart> == ALTREF_FRAME ; if ( is_alt_ref <S2SV_ModStart> || ! cpi <S2SV_ModEnd> -> allow_comp_inter_inter <S2SV_ModStart> if ( mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE <S2SV_ModStart> ] > mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE <S2SV_ModStart> ] && mode_thrs <S2SV_ModEnd> [ COMPOUND_REFERENCE <S2SV_ModStart> ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT <S2SV_ModStart> if ( mode_thrs <S2SV_ModEnd> [ SINGLE_REFERENCE <S2SV_ModStart> ] > mode_thrs <S2SV_ModEnd> [ REFERENCE_MODE_SELECT <S2SV_ModStart> SWITCHABLE ) <S2SV_ModEnd> cm -> <S2SV_ModStart> interp_filter = get_interp_filter ( filter_thrs , is_alt_ref ) ; <S2SV_ModEnd> encode_frame_internal ( <S2SV_ModStart> i ) mode_thrs [ i ] = ( mode_thrs [ i ] + rdc -> comp_pred_diff <S2SV_ModEnd> [ i <S2SV_ModStart> MBs ) / 2 ; <S2SV_ModEnd> for ( <S2SV_ModStart> SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_thrs [ i ] = ( filter_thrs [ i ] + rdc -> filter_diff <S2SV_ModEnd> [ i <S2SV_ModStart> -> MBs <S2SV_ModEnd> ) / <S2SV_ModStart> 2 ; <S2SV_ModEnd> if ( <S2SV_ModStart> single_count_zero += counts -> <S2SV_ModEnd> comp_inter [ <S2SV_ModStart> comp_count_zero += counts -> <S2SV_ModEnd> comp_inter [ <S2SV_ModStart> vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) <S2SV_ModStart> vp9_zero ( counts -> <S2SV_ModEnd> comp_inter ) <S2SV_ModStart> count4x4 += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count4x4 += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count4x4 += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count8x8_lp += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count8x8_lp += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count8x8_8x8p += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count16x16_16x16p += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count16x16_lp += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> count32x32 += counts -> <S2SV_ModEnd> tx . <S2SV_ModStart> ALLOW_8X8 ; reset_skip_tx_size <S2SV_ModEnd> ( cm <S2SV_ModStart> ONLY_4X4 ; reset_skip_tx_size <S2SV_ModEnd> ( cm <S2SV_ModStart> ALLOW_16X16 ; reset_skip_tx_size <S2SV_ModEnd> ( cm <S2SV_ModStart> SINGLE_REFERENCE ; <S2SV_ModEnd> encode_frame_internal (
<S2SV_ModStart> buffers [ 3 <S2SV_ModEnd> ] = <S2SV_ModStart> -> v_buffer <S2SV_ModEnd> } ; <S2SV_ModStart> strides [ 3 <S2SV_ModEnd> ] = <S2SV_ModStart> -> uv_stride <S2SV_ModEnd> } ;
<S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> skip_recode ) { if ( x -> quant_fp ) { if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } else { vp9_xform_quant_fp ( x , plane , block , plane_bsize , tx_size ) ; } } else { if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { int txfm_blk_index = ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ; if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_NONE ) { <S2SV_ModStart> ) ; } else if ( x -> skip_txfm [ txfm_blk_index ] == SKIP_TXFM_AC_ONLY ) { vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; } else { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; } } } <S2SV_ModStart> ) { const int ctx = combine_entropy_contexts ( * a , * l ) ; * a = * l = <S2SV_ModStart> optimize_b ( x , plane , block , tx_size , ctx ) > 0 <S2SV_ModEnd> ; } <S2SV_ModStart> return ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> TX_32X32 : vp9_highbd_idct32x32_add <S2SV_ModEnd> ( dqcoeff <S2SV_ModStart> stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; <S2SV_ModStart> TX_16X16 : vp9_highbd_idct16x16_add <S2SV_ModEnd> ( dqcoeff <S2SV_ModStart> stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; <S2SV_ModStart> TX_8X8 : vp9_highbd_idct8x8_add <S2SV_ModEnd> ( dqcoeff <S2SV_ModStart> stride , p -> eobs [ block ] , xd -> bd <S2SV_ModEnd> ) ; <S2SV_ModStart> TX_4X4 : x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , <S2SV_ModStart> xd -> bd <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_16X16 : vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_8X8 : vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; case TX_4X4 : x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; break ; default : assert ( 0 && "Invalid<S2SV_blank>transform<S2SV_blank>size" ) ; break ; }
<S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> 0 ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { x -> highbd_itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] , xd -> bd ) ; return ; } # endif x <S2SV_ModEnd> -> itxm_add <S2SV_ModStart> ) ; }
<S2SV_ModStart> src , tran_low_t <S2SV_ModEnd> * dst <S2SV_ModStart> rd_transform ) vpx_fdct32x32_rd <S2SV_ModEnd> ( src <S2SV_ModStart> ; else vpx_fdct32x32 <S2SV_ModEnd> ( src
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> optimize_b ( <S2SV_ModStart> optimize_b ( MACROBLOCK * mb , <S2SV_ModStart> block , <S2SV_ModEnd> TX_SIZE tx_size <S2SV_ModStart> tx_size , int ctx <S2SV_ModEnd> ) { <S2SV_ModStart> macroblock_plane * const <S2SV_ModStart> macroblockd_plane * const <S2SV_ModStart> ] ; uint8_t token_cache [ 1024 ] ; const tran_low_t * const <S2SV_ModEnd> coeff = <S2SV_ModStart> ) ; tran_low_t * const <S2SV_ModEnd> qcoeff = <S2SV_ModStart> ) ; tran_low_t * const <S2SV_ModEnd> dqcoeff = <S2SV_ModStart> ) ; const <S2SV_ModStart> block ] ; const <S2SV_ModEnd> PLANE_TYPE type <S2SV_ModStart> -> plane_type <S2SV_ModEnd> ; const <S2SV_ModStart> ) ; const int16_t * dequant_ptr = pd -> dequant ; const uint8_t * const band_translate = get_band_translate ( tx_size ) ; const scan_order * const so = get_scan ( xd , tx_size , type , block ) <S2SV_ModEnd> ; const <S2SV_ModStart> int16_t * const scan = so -> scan ; const int16_t * const nb = so -> neighbors ; int next = eob , sz = 0 ; int64_t rdmult = mb -> rdmult * plane_rd_mult [ type ] , rddiv = mb -> rddiv ; int64_t rd_cost0 , rd_cost1 ; int rate0 , rate1 , error0 , error1 ; int16_t t0 , t1 ; EXTRABIT e0 ; int best , band , pt , i , final_eob ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table <S2SV_ModEnd> ( xd <S2SV_ModStart> ( xd -> bd ) ; # else <S2SV_ModEnd> const int16_t <S2SV_ModStart> int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModEnd> assert ( <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( ! ref <S2SV_ModEnd> ) rdmult <S2SV_ModStart> 4 ; <S2SV_ModEnd> tokens [ <S2SV_ModStart> 0 ; <S2SV_ModEnd> tokens [ <S2SV_ModStart> eob ] [ 1 ] = <S2SV_ModEnd> tokens [ <S2SV_ModStart> eob ] [ 0 ] <S2SV_ModEnd> ; for <S2SV_ModStart> vp9_pt_energy_class [ vp9_get_token ( <S2SV_ModEnd> qcoeff [ <S2SV_ModStart> ] ] ) <S2SV_ModEnd> ] ; <S2SV_ModStart> -- > 0 <S2SV_ModEnd> ; ) <S2SV_ModStart> dx ; const int <S2SV_ModStart> ] ; int <S2SV_ModStart> rate ; vp9_get_token_extra ( x , & t0 , & e0 ) <S2SV_ModEnd> ; if <S2SV_ModStart> base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { dx >>= xd -> bd - 8 ; } # endif <S2SV_ModStart> ZERO_TOKEN ; e0 = 0 ; <S2SV_ModStart> else { vp9_get_token_extra ( x , & t0 , & e0 ) ; <S2SV_ModEnd> t1 = <S2SV_ModStart> t1 = t0 <S2SV_ModEnd> ; } <S2SV_ModStart> base_bits = vp9_get_cost ( t0 , e0 , cat6_high_cost <S2SV_ModEnd> ) ; <S2SV_ModStart> ( shortcut ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH <S2SV_ModStart> -= ( ( <S2SV_ModStart> 0 ] >> ( xd -> bd - 8 ) ) <S2SV_ModStart> sz ; } else { dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; } # else dx -= ( dequant_ptr [ rc != 0 ] + sz ) ^ sz ; # endif <S2SV_ModStart> ] ; <S2SV_ModEnd> rate0 = <S2SV_ModStart> ] [ ctx <S2SV_ModEnd> ] [ <S2SV_ModStart> ] [ ctx <S2SV_ModEnd> ] [ <S2SV_ModStart> final_eob = <S2SV_ModEnd> - 1 <S2SV_ModStart> 1 ; memset <S2SV_ModEnd> ( qcoeff <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( dqcoeff <S2SV_ModStart> ) { const int <S2SV_ModStart> qc ; const int rc = scan [ i ] ; <S2SV_ModStart> ; } <S2SV_ModEnd> qcoeff [ <S2SV_ModStart> final_eob ; return final_eob <S2SV_ModEnd> ; }
<S2SV_ModStart> vp9_encode_block_intra ( <S2SV_ModEnd> int plane <S2SV_ModStart> tx_size , void * arg <S2SV_ModEnd> ) { <S2SV_ModStart> struct encode_b_args * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; tran_low_t * coeff = BLOCK_OFFSET ( p -> coeff , block ) ; tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; tran_low_t * dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; const scan_order * scan_order ; TX_TYPE tx_type = DCT_DCT ; PREDICTION_MODE mode ; const int bwl = b_width_log2_lookup [ plane_bsize ] ; const int diff_stride = 4 * ( 1 << bwl ) ; uint8_t * src , * dst ; int16_t * src_diff ; uint16_t * eob = & p -> eobs [ block ] ; const int src_stride = p -> src . stride ; const int dst_stride = pd -> dst . stride ; int i , j ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * ( j * dst_stride + i ) ] ; src = & p -> src . buf [ 4 * ( j * src_stride + i ) ] ; src_diff = & p -> src_diff [ 4 * ( j * diff_stride + i ) ] ; if ( tx_size == TX_4X4 ) { tx_type = get_tx_type_4x4 ( pd -> plane_type , xd , block ) ; scan_order = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; mode = plane == 0 ? get_y_mode ( xd -> mi [ 0 ] , block ) : mbmi -> uv_mode ; } else { mode = plane == 0 ? mbmi -> mode : mbmi -> uv_mode ; if ( tx_size == TX_32X32 ) { scan_order = & vp9_default_scan_orders [ TX_32X32 ] ; } else { tx_type = get_tx_type ( pd -> plane_type , xd ) ; scan_order = & vp9_scan_orders [ tx_size ] [ tx_type ] ; } } vp9_predict_intra_block ( xd , bwl , tx_size , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , i , j , plane ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; highbd_fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_idct32x32_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; else vp9_highbd_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_highbd_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { vp9_highbd_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_highbd_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride , xd -> bd ) ; if ( tx_type != DCT_DCT ) vp9_highbd_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) { x -> highbd_itxm_add ( dqcoeff , dst , dst_stride , * eob , xd -> bd ) ; } else { vp9_highbd_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type , xd -> bd ) ; } } break ; default : assert ( 0 ) ; return ; } if ( * eob ) * ( args -> skip ) = 0 ; return ; } # endif switch ( tx_size ) { case TX_32X32 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 32 , 32 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_idct32x32_add ( dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_16X16 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 16 , 16 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht16x16 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht16x16_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_8X8 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 8 , 8 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; vp9_fht8x8 ( src_diff , coeff , diff_stride , tx_type ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) vp9_iht8x8_add ( tx_type , dqcoeff , dst , dst_stride , * eob ) ; break ; case TX_4X4 : if ( ! x -> skip_recode ) { vpx_subtract_block ( 4 , 4 , src_diff , diff_stride , src , src_stride , dst , dst_stride ) ; if ( tx_type != DCT_DCT ) vp9_fht4x4 ( src_diff , coeff , diff_stride , tx_type ) ; else x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; } if ( ! x -> skip_encode && * eob ) { if ( tx_type == DCT_DCT ) x -> itxm_add ( dqcoeff , dst , dst_stride , * eob ) ; else vp9_iht4x4_16_add ( dqcoeff , dst , dst_stride , tx_type ) ; } break ; default : assert ( 0 ) ; break ; } if ( * eob ) * ( args -> skip ) = 0 <S2SV_ModEnd> ; }
<S2SV_ModStart> plane , vp9_encode_block_intra <S2SV_ModEnd> , &
<S2SV_ModStart> plane ; mbmi -> skip = 1 ; if ( x -> skip ) return ; <S2SV_ModStart> ( mbmi , pd
<S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( x -> e_mbd . cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( bh , bw , p -> src_diff , bw , p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride , x -> e_mbd . bd ) ; return ; } # endif vpx_subtract_block <S2SV_ModEnd> ( bh
<S2SV_ModStart> ] ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> ) ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> ) ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> TX_32X32 : highbd_fdct32x32 <S2SV_ModEnd> ( x <S2SV_ModStart> ) ; vpx_highbd_quantize_b_32x32 <S2SV_ModEnd> ( coeff <S2SV_ModStart> qcoeff , dqcoeff , <S2SV_ModEnd> pd -> <S2SV_ModStart> dequant , eob , <S2SV_ModEnd> scan_order -> <S2SV_ModStart> TX_16X16 : vpx_highbd_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff <S2SV_ModStart> -> dequant <S2SV_ModEnd> , eob <S2SV_ModStart> TX_8X8 : vpx_highbd_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff <S2SV_ModStart> -> dequant <S2SV_ModEnd> , eob <S2SV_ModStart> ) ; vpx_highbd_quantize_b <S2SV_ModEnd> ( coeff <S2SV_ModStart> dequant , <S2SV_ModEnd> eob , <S2SV_ModStart> 0 ) ; } return ; } # endif switch ( tx_size ) { case TX_32X32 : fdct32x32 ( x -> use_lp32x32fdct , src_diff , coeff , diff_stride ) ; vpx_quantize_b_32x32 ( coeff , 1024 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_16X16 : vpx_fdct16x16 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 256 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_8X8 : vpx_fdct8x8 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 64 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; case TX_4X4 : x -> fwd_txm4x4 ( src_diff , coeff , diff_stride ) ; vpx_quantize_b ( coeff , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , qcoeff , dqcoeff , pd -> dequant , eob , scan_order -> scan , scan_order -> iscan ) ; break ; default : assert ( 0 ) ; break
<S2SV_ModStart> encode_mv_component ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> i ) vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> usehp ) vpx_write <S2SV_ModEnd> ( w
<S2SV_ModStart> mbmi , const MB_MODE_INFO_EXT * mbmi_ext , <S2SV_ModStart> = & mbmi_ext <S2SV_ModEnd> -> ref_mvs
<S2SV_ModStart> update_mv ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ] , vpx_prob <S2SV_ModEnd> * cur_p <S2SV_ModStart> cur_p , vpx_prob <S2SV_ModEnd> upd_p ) <S2SV_ModStart> { const vpx_prob <S2SV_ModEnd> new_p = <S2SV_ModStart> 256 ; vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> new_p ; vpx_write_literal <S2SV_ModEnd> ( w
<S2SV_ModStart> cpi , vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> if ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> -> sf . mv
<S2SV_ModStart> vp9_entropy_mv_init ( void
<S2SV_ModStart> vp9_update_mv_count ( ThreadData * td ) { <S2SV_ModEnd> const MACROBLOCKD <S2SV_ModStart> * xd = & td -> mb . e_mbd ; <S2SV_ModEnd> const MODE_INFO <S2SV_ModStart> -> mbmi ; const MB_MODE_INFO_EXT * mbmi_ext = td -> mb . mbmi_ext <S2SV_ModStart> mbmi , mbmi_ext , <S2SV_ModStart> , & td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> mv ) <S2SV_ModStart> mbmi , mbmi_ext , <S2SV_ModStart> , & td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> mv )
<S2SV_ModStart> usehp , vpx_writer * w , nmv_context_counts * const counts <S2SV_ModEnd> ) { <S2SV_ModStart> -> fc -> <S2SV_ModEnd> nmvc ; <S2SV_ModStart> nmvc ; <S2SV_ModEnd> write_mv_update (
<S2SV_ModStart> ( const vpx_tree_index <S2SV_ModEnd> * tree <S2SV_ModStart> tree , vpx_prob <S2SV_ModEnd> probs [ <S2SV_ModStart> n , vpx_writer <S2SV_ModEnd> * w
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( dst_ptr1 <S2SV_ModStart> ) ; memcpy ( dst_ptr1 + extend_left , src_ptr1 , w ) ; memset <S2SV_ModEnd> ( dst_ptr2 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dst_ptr1 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dst_ptr2
<S2SV_ModStart> const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> MAX ( src -> y_height + 16 , <S2SV_ModStart> src -> y_height <S2SV_ModEnd> , 6 <S2SV_ModStart> 6 ) ) <S2SV_ModStart> src -> y_crop_height <S2SV_ModEnd> ; const <S2SV_ModStart> # if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> # endif <S2SV_ModStart> src -> y_crop_width , src -> y_crop_height <S2SV_ModEnd> , et_y <S2SV_ModStart> src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv <S2SV_ModStart> src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv
<S2SV_ModStart> accumulate_frame_motion_stats ( const <S2SV_ModStart> FIRSTPASS_STATS * stats <S2SV_ModEnd> , double <S2SV_ModStart> double * mv_in_out <S2SV_ModEnd> , double <S2SV_ModStart> ) { const double pct = stats <S2SV_ModEnd> -> pcnt_motion <S2SV_ModStart> ; * mv_in_out = stats <S2SV_ModEnd> -> mv_in_out_count <S2SV_ModStart> mv_in_out_count * pct <S2SV_ModEnd> ; * <S2SV_ModStart> mv_in_out_accumulator += * mv_in_out <S2SV_ModEnd> ; * <S2SV_ModStart> fabs ( * mv_in_out <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( pct <S2SV_ModEnd> > 0.05 <S2SV_ModStart> const double mvr_ratio <S2SV_ModEnd> = fabs <S2SV_ModStart> fabs ( stats <S2SV_ModEnd> -> mvr_abs <S2SV_ModStart> fabs ( stats <S2SV_ModEnd> -> MVr <S2SV_ModStart> const double mvc_ratio <S2SV_ModEnd> = fabs <S2SV_ModStart> fabs ( stats <S2SV_ModEnd> -> mvc_abs <S2SV_ModStart> fabs ( stats <S2SV_ModEnd> -> MVc <S2SV_ModStart> mv_ratio_accumulator += pct * ( mvr_ratio < stats -> mvr_abs ? mvr_ratio : stats <S2SV_ModEnd> -> mvr_abs <S2SV_ModStart> mvr_abs ) <S2SV_ModEnd> ; * <S2SV_ModStart> mv_ratio_accumulator += pct * ( mvc_ratio < stats -> mvc_abs ? mvc_ratio : stats <S2SV_ModEnd> -> mvc_abs <S2SV_ModStart> mvc_abs ) <S2SV_ModEnd> ; }
<S2SV_ModStart> section -> weight += frame -> weight ; section -> <S2SV_ModStart> section -> <S2SV_ModEnd> pcnt_inter += <S2SV_ModStart> -> pcnt_neutral ; section -> intra_skip_pct += frame -> intra_skip_pct ; section -> inactive_zone_rows += frame -> inactive_zone_rows ; section -> inactive_zone_cols += frame -> inactive_zone_cols
<S2SV_ModStart> ) { TWO_PASS <S2SV_ModEnd> * const <S2SV_ModStart> ) { const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; <S2SV_ModStart> if ( this_frame == NULL <S2SV_ModEnd> ) break <S2SV_ModStart> accumulate_frame_motion_stats ( <S2SV_ModEnd> this_frame , <S2SV_ModStart> get_prediction_decay_rate ( cpi , <S2SV_ModEnd> this_frame ) <S2SV_ModStart> boost_score += decay_accumulator * <S2SV_ModEnd> calc_frame_boost ( <S2SV_ModStart> cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { const FIRSTPASS_STATS * this_frame = read_frame_stats ( twopass , i + offset ) ; <S2SV_ModStart> if ( this_frame == NULL <S2SV_ModEnd> ) break <S2SV_ModStart> accumulate_frame_motion_stats ( <S2SV_ModEnd> this_frame , <S2SV_ModStart> get_prediction_decay_rate ( cpi , <S2SV_ModEnd> this_frame ) <S2SV_ModStart> boost_score += decay_accumulator * <S2SV_ModEnd> calc_frame_boost ( <S2SV_ModStart> cpi , this_frame , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; <S2SV_ModStart> * 20 ) ; arf_boost = MAX ( arf_boost , MIN_ARF_GF_BOOST
<S2SV_ModStart> int q , vpx_bit_depth_t bit_depth <S2SV_ModStart> ( q , bit_depth <S2SV_ModStart> ) * 0.01 <S2SV_ModEnd> + pt_low
<S2SV_ModStart> cpi , const <S2SV_ModStart> double this_frame_mv_in_out , double max_boost <S2SV_ModStart> frame_boost ; const double lq = vp9_convert_qindex_to_q ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> rc . avg_frame_qindex [ INTER_FRAME ] , cpi -> common . bit_depth ) ; const double boost_q_correction = MIN ( ( 0.5 + ( lq * 0.015 ) ) , 1.5 ) ; int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; num_mbs = ( int ) MAX ( 1 , num_mbs * calculate_active_area ( cpi , this_frame ) ) ; <S2SV_ModEnd> frame_boost = <S2SV_ModStart> = ( BASELINE_ERR_PER_MB * num_mbs ) <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK <S2SV_ModStart> coded_error ) ; <S2SV_ModEnd> frame_boost = <S2SV_ModStart> frame_boost = frame_boost * BOOST_FACTOR * boost_q_correction <S2SV_ModEnd> ; if <S2SV_ModStart> frame_boost , max_boost * boost_q_correction <S2SV_ModEnd> ) ;
<S2SV_ModStart> , const TWO_PASS * twopass , const VP9EncoderConfig * oxcf , const <S2SV_ModStart> { const FIRSTPASS_STATS <S2SV_ModEnd> * const <S2SV_ModStart> * const <S2SV_ModEnd> stats = <S2SV_ModStart> total_stats ; const double av_weight <S2SV_ModEnd> = stats <S2SV_ModStart> stats -> weight <S2SV_ModEnd> / stats <S2SV_ModStart> count ; const double av_err = ( stats -> coded_error * av_weight ) / stats -> count ; double <S2SV_ModStart> this_frame -> coded_error * this_frame -> weight <S2SV_ModEnd> / DOUBLE_DIVIDE_CHECK <S2SV_ModStart> ) , oxcf -> <S2SV_ModEnd> two_pass_vbrbias / <S2SV_ModStart> / 100.0 ) ; modified_error *= pow ( calculate_active_area ( cpi , this_frame ) , ACT_AREA_CORRECTION
<S2SV_ModStart> ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_ModStart> rc ; VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> oxcf ; TWO_PASS <S2SV_ModEnd> * const <S2SV_ModStart> FIRSTPASS_STATS next_frame <S2SV_ModEnd> ; const <S2SV_ModStart> FIRSTPASS_STATS * const start_pos = twopass -> stats_in <S2SV_ModEnd> ; int <S2SV_ModStart> 0.0 ; # if GROUP_ADAPTIVE_MAXQ double gf_group_raw_error = 0.0 ; # endif double gf_group_skip_pct = 0.0 ; double gf_group_inactive_zone_rows = 0.0 ; <S2SV_ModStart> mv_ratio_accumulator_thresh ; unsigned int allow_alt_ref = is_altref_enabled ( cpi ) ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; int active_max_gf_interval ; int active_min_gf_interval ; int64_t gf_group_bits ; double gf_group_error_left ; int gf_arf_bits ; <S2SV_ModStart> const int is_key_frame = frame_is_intra_only ( cm ) ; const int arf_active_or_kf = is_key_frame || rc -> source_alt_ref_active ; if ( is_key_frame == 0 ) { vp9_zero ( twopass -> gf_group ) ; } vpx_clear_system_state ( ) ; vp9_zero ( next_frame ) ; mod_frame_err = calculate_modified_err ( cpi , twopass <S2SV_ModEnd> , oxcf <S2SV_ModStart> , oxcf , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( arf_active_or_kf ) { <S2SV_ModEnd> gf_group_err -= <S2SV_ModStart> gf_first_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error -= this_frame -> coded_error ; # endif gf_group_skip_pct -= this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows -= this_frame -> inactive_zone_rows ; } <S2SV_ModStart> mv_ratio_accumulator_thresh = ( cpi -> initial_height + cpi -> initial_width ) / 4.0 ; { int int_max_q = ( int ) ( vp9_convert_qindex_to_q ( twopass -> active_worst_quality , <S2SV_ModEnd> cpi -> <S2SV_ModStart> common . bit_depth ) ) ; int int_lbq = ( int ) ( vp9_convert_qindex_to_q ( rc -> last_boosted_qindex , <S2SV_ModEnd> cpi -> <S2SV_ModStart> common . bit_depth ) ) ; active_min_gf_interval = rc -> min_gf_interval + MIN ( 2 , int_max_q / 200 ) ; if ( active_min_gf_interval > rc -> max_gf_interval ) active_min_gf_interval = rc -> max_gf_interval ; if ( cpi -> multi_arf_allowed ) { <S2SV_ModEnd> active_max_gf_interval = <S2SV_ModStart> active_max_gf_interval = rc -> max_gf_interval ; } else { active_max_gf_interval = <S2SV_ModStart> 12 + MIN ( 4 , ( int_lbq / 6 ) ) ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval <S2SV_ModEnd> ; if <S2SV_ModStart> max_gf_interval ; if ( active_max_gf_interval < active_min_gf_interval ) active_max_gf_interval = active_min_gf_interval ; } } <S2SV_ModStart> cpi , twopass , oxcf , <S2SV_ModStart> mod_frame_err ; # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; <S2SV_ModStart> get_prediction_decay_rate ( cpi <S2SV_ModEnd> , & <S2SV_ModStart> loop_decay_rate ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> detect_transition_to_still ( cpi <S2SV_ModEnd> , i <S2SV_ModStart> boost_score += <S2SV_ModEnd> decay_accumulator * <S2SV_ModStart> , this_frame_mv_in_out , GF_MAX_BOOST <S2SV_ModEnd> ) ; <S2SV_ModStart> i >= ( active_max_gf_interval + arf_active_or_kf ) && <S2SV_ModEnd> zero_motion_accumulator < <S2SV_ModStart> 0.995 ) <S2SV_ModEnd> || ( <S2SV_ModStart> ( i >= active_min_gf_interval + arf_active_or_kf <S2SV_ModEnd> ) && <S2SV_ModStart> ) < BOOST_BREAKOUT <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ; rc -> constrained_gf_group = ( i >= <S2SV_ModEnd> rc -> <S2SV_ModStart> -> frames_to_key ) ? 1 : 0 ; if ( allow_alt_ref && <S2SV_ModEnd> ( i <S2SV_ModStart> i < cpi -> oxcf . lag_in_frames ) && ( i >= rc -> min_gf_interval ) ) { rc -> gfu_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; rc -> source_alt_ref_pending = 1 ; cpi -> multi_arf_enabled = ( cpi -> multi_arf_allowed && ( rc -> baseline_gf_interval >= 6 ) && ( zero_motion_accumulator < 0.995 ) ) ? 1 : 0 ; } else { rc -> gfu_boost = MAX ( ( int ) boost_score , MIN_ARF_GF_BOOST ) ; rc -> source_alt_ref_pending = 0 ; } rc -> baseline_gf_interval = i - ( is_key_frame || rc -> source_alt_ref_pending ) ; if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_gf_interval = ( rc -> baseline_gf_interval + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_gf_interval - rc -> baseline_gf_interval ; ++ j ) { <S2SV_ModEnd> if ( <S2SV_ModStart> break ; <S2SV_ModEnd> gf_group_err += <S2SV_ModStart> gf_group_err += calculate_modified_err ( cpi , twopass , oxcf , this_frame ) ; <S2SV_ModEnd> # if <S2SV_ModStart> # if GROUP_ADAPTIVE_MAXQ gf_group_raw_error += this_frame -> coded_error ; <S2SV_ModEnd> # endif <S2SV_ModStart> # endif gf_group_skip_pct += this_frame -> intra_skip_pct ; gf_group_inactive_zone_rows += this_frame -> inactive_zone_rows ; } <S2SV_ModEnd> rc -> <S2SV_ModStart> baseline_gf_interval = new_gf_interval ; } rc -> frames_till_gf_update_due = <S2SV_ModEnd> rc -> <S2SV_ModStart> -> baseline_gf_interval ; reset_fpf_position ( twopass , start_pos ) ; gf_group_bits = calculate_total_gf_group_bits ( cpi , gf_group_err ) ; # if GROUP_ADAPTIVE_MAXQ if ( ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> oxcf . rc_mode != VPX_Q <S2SV_ModEnd> ) && <S2SV_ModStart> ) && ( rc -> baseline_gf_interval > 1 ) ) { const int vbr_group_bits_per_frame = ( int ) ( gf_group_bits / rc -> baseline_gf_interval ) ; const double group_av_err = gf_group_raw_error / rc -> baseline_gf_interval ; const double group_av_skip_pct = gf_group_skip_pct / rc -> baseline_gf_interval ; const double group_av_inactive_zone = ( ( gf_group_inactive_zone_rows * 2 ) / ( rc -> baseline_gf_interval * ( double ) cm -> mb_rows ) ) ; int tmp_q ; double rc_factor = 1.0 ; if ( rc -> rate_error_estimate > 0 ) { rc_factor = MAX ( RC_FACTOR_MIN , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } else { rc_factor = MIN ( RC_FACTOR_MAX , ( double ) ( 100 - rc -> rate_error_estimate ) / 100.0 ) ; } tmp_q = get_twopass_worst_quality ( cpi , group_av_err , ( group_av_skip_pct + group_av_inactive_zone ) , vbr_group_bits_per_frame , twopass -> kfgroup_inter_fraction * rc_factor ) ; twopass -> active_worst_quality = MAX ( tmp_q , twopass -> active_worst_quality >> 1 <S2SV_ModEnd> ) ; <S2SV_ModStart> # endif gf_arf_bits = calculate_boost_bits ( rc -> baseline_gf_interval , rc -> gfu_boost , gf_group_bits ) ; twopass -> kf_group_error_left -= ( int64_t ) gf_group_err ; if ( rc -> source_alt_ref_pending ) { gf_group_error_left = gf_group_err - mod_frame_err ; <S2SV_ModStart> } else if ( is_key_frame == 0 ) { gf_group_error_left = gf_group_err - gf_first_frame_err ; } else { gf_group_error_left = gf_group_err ; } allocate_gf_group_bits ( cpi , gf_group_bits , gf_group_error_left , gf_arf_bits ) ; reset_fpf_position ( twopass , start_pos ) ; if <S2SV_ModEnd> ( cpi <S2SV_ModStart> KEY_FRAME ) { twopass -> section_intra_rating = calculate_section_intra_ratio ( start_pos , twopass -> stats_in_end , rc -> baseline_gf_interval ) ; } if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED <S2SV_ModEnd> ; }
<S2SV_ModStart> ( const TWO_PASS <S2SV_ModEnd> * twopass <S2SV_ModStart> ) { const FIRSTPASS_STATS * const next_frame = <S2SV_ModEnd> read_frame_stats ( <S2SV_ModStart> twopass , <S2SV_ModEnd> offset ) <S2SV_ModStart> offset ) ; return next_frame != NULL && next_frame -> <S2SV_ModEnd> pcnt_second_ref > <S2SV_ModStart> > next_frame -> <S2SV_ModEnd> pcnt_inter && <S2SV_ModStart> && next_frame -> <S2SV_ModEnd> pcnt_second_ref >= <S2SV_ModStart> >= 0.5 <S2SV_ModEnd> ; }
<S2SV_ModStart> detect_transition_to_still ( VP9_COMP * cpi <S2SV_ModEnd> , int <S2SV_ModStart> ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc <S2SV_ModEnd> ; if <S2SV_ModStart> frame_interval > rc -> min_gf_interval <S2SV_ModEnd> && loop_decay_rate <S2SV_ModStart> j ; <S2SV_ModEnd> for ( <S2SV_ModStart> ) { const FIRSTPASS_STATS * stats = & twopass -> stats_in [ j ] ; <S2SV_ModStart> if ( stats >= twopass -> stats_in_end <S2SV_ModEnd> ) break <S2SV_ModStart> if ( stats -> <S2SV_ModEnd> pcnt_inter - <S2SV_ModStart> pcnt_inter - stats -> <S2SV_ModEnd> pcnt_motion < <S2SV_ModStart> ; } return <S2SV_ModEnd> j == <S2SV_ModStart> == still_interval <S2SV_ModEnd> ; } <S2SV_ModStart> } return 0 <S2SV_ModEnd> ; }
<S2SV_ModStart> rc ; TWO_PASS <S2SV_ModEnd> * const <S2SV_ModStart> -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group ; const VP9EncoderConfig * const oxcf = & cpi -> oxcf <S2SV_ModStart> FIRSTPASS_STATS * const <S2SV_ModStart> last_frame ; int kf_bits = 0 ; int loop_decay_counter = 0 ; <S2SV_ModStart> = 1.0 ; double av_decay_accumulator = 0.0 <S2SV_ModStart> KEY_FRAME ; vp9_zero ( * gf_group ) ; <S2SV_ModStart> 0 ; cpi -> multi_arf_last_grp_enabled = 0 ; <S2SV_ModStart> ( cpi , twopass , oxcf <S2SV_ModStart> -> stats_in_end && rc -> frames_to_key < cpi -> oxcf . key_freq <S2SV_ModStart> cpi , twopass , oxcf , <S2SV_ModStart> auto_key && twopass -> stats_in < twopass -> stats_in_end <S2SV_ModEnd> ) { <S2SV_ModStart> this_frame , twopass -> stats_in <S2SV_ModEnd> ) ) <S2SV_ModStart> get_prediction_decay_rate ( cpi , twopass -> stats_in <S2SV_ModEnd> ) ; <S2SV_ModStart> detect_transition_to_still ( cpi <S2SV_ModEnd> , i <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> - i <S2SV_ModStart> 2 * cpi -> oxcf . key_freq <S2SV_ModEnd> ) break <S2SV_ModStart> frames_to_key > cpi -> oxcf . key_freq <S2SV_ModEnd> ) { <S2SV_ModStart> kf_group_err = 0.0 <S2SV_ModEnd> ; for <S2SV_ModStart> cpi , twopass , oxcf , <S2SV_ModStart> -> stats_in_end || rc -> frames_to_key >= cpi -> oxcf . key_freq <S2SV_ModStart> if ( is_two_pass_svc ( cpi ) && cpi -> svc . number_temporal_layers > 1 ) { int count = ( 1 << ( cpi -> svc . number_temporal_layers - 1 ) ) - 1 ; int new_frame_to_key = ( rc -> frames_to_key + count ) & ( ~ count ) ; int j ; for ( j = 0 ; j < new_frame_to_key - rc -> frames_to_key ; ++ j ) { if ( EOF == input_stats ( twopass , this_frame ) ) break ; <S2SV_ModEnd> kf_group_err += <S2SV_ModStart> cpi , twopass , oxcf , this_frame ) ; } rc -> frames_to_key = new_frame_to_key ; } if ( twopass -> stats_in >= twopass -> stats_in_end ) { kf_group_err += calculate_modified_err ( cpi , twopass , oxcf , <S2SV_ModStart> ; } twopass -> kf_group_bits = MAX ( 0 , twopass -> kf_group_bits ) ; <S2SV_ModStart> i < ( rc -> frames_to_key - 1 ) <S2SV_ModEnd> ; ++ <S2SV_ModStart> break ; zero_motion_accumulator = MIN ( zero_motion_accumulator , get_zero_motion_factor ( cpi , & next_frame ) ) ; if ( <S2SV_ModEnd> ( i <S2SV_ModStart> i <= <S2SV_ModEnd> rc -> <S2SV_ModStart> -> max_gf_interval ) || ( ( i <= ( rc -> max_gf_interval * 4 ) ) && ( decay_accumulator > 0.5 ) ) ) { const double frame_boost = calc_frame_boost ( cpi , this_frame , 0 , KF_MAX_BOOST ) <S2SV_ModEnd> ; if <S2SV_ModStart> get_prediction_decay_rate ( cpi , <S2SV_ModEnd> & next_frame <S2SV_ModStart> ) ; av_decay_accumulator += decay_accumulator ; ++ loop_decay_counter ; <S2SV_ModStart> decay_accumulator * frame_boost ) ; } } av_decay_accumulator /= ( double ) loop_decay_counter <S2SV_ModEnd> ; reset_fpf_position <S2SV_ModStart> ) ; twopass -> kf_zeromotion_pct = ( int ) ( zero_motion_accumulator * 100.0 <S2SV_ModEnd> ) ; <S2SV_ModStart> section_intra_rating = calculate_section_intra_ratio ( start_position , twopass -> stats_in_end , rc -> frames_to_key ) ; rc -> kf_boost = <S2SV_ModStart> ) ( av_decay_accumulator * boost_score ) ; rc -> <S2SV_ModEnd> kf_boost = <S2SV_ModStart> kf_boost = MAX ( rc -> kf_boost , <S2SV_ModEnd> ( rc <S2SV_ModStart> ) ) ; rc -> <S2SV_ModStart> kf_boost = MAX ( rc -> kf_boost , <S2SV_ModEnd> MIN_KF_BOOST ) <S2SV_ModStart> MIN_KF_BOOST ) ; kf_bits = calculate_boost_bits <S2SV_ModEnd> ( ( <S2SV_ModStart> 1 ) , rc -> kf_boost , twopass -> kf_group_bits ) ; if ( twopass -> kf_group_bits ) { twopass -> kfgroup_inter_fraction = ( double ) ( twopass -> kf_group_bits - kf_bits ) / ( double ) twopass -> kf_group_bits <S2SV_ModEnd> ; } <S2SV_ModStart> else { twopass -> kfgroup_inter_fraction = 1.0 <S2SV_ModEnd> ; } <S2SV_ModStart> kf_group_bits -= <S2SV_ModEnd> kf_bits ; <S2SV_ModStart> kf_bits ; gf_group -> bit_allocation [ 0 ] = kf_bits ; gf_group -> update_type [ 0 ] = KF_UPDATE ; gf_group -> rf_level [ 0 ] = KF_STD ; <S2SV_ModEnd> twopass -> <S2SV_ModStart> kf_group_err ; if ( oxcf -> resize_mode == RESIZE_DYNAMIC ) { cpi -> rc . next_frame_size_selector = UNSCALED ; }
<S2SV_ModStart> , n <S2SV_ModEnd> ; const <S2SV_ModStart> ] ; const <S2SV_ModStart> new_mv_mode_penalty = NEW_MV_MODE_PENALTY ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param <S2SV_ModEnd> ; const <S2SV_ModStart> const int sr = get_search_range ( cpi ) <S2SV_ModEnd> ; step_param <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { v_fn_ptr . vf = highbd_get_block_variance_fn ( bsize , xd -> bd ) ; } # endif <S2SV_ModStart> , & cpi -> ss_cfg , & <S2SV_ModStart> & v_fn_ptr <S2SV_ModEnd> , ref_mv <S2SV_ModStart> tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; } <S2SV_ModStart> ( x , & cpi -> ss_cfg <S2SV_ModStart> v_fn_ptr , <S2SV_ModEnd> ref_mv ) <S2SV_ModStart> tmp_err ; * best_mv = tmp_mv <S2SV_ModEnd> ; }
<S2SV_ModStart> , const VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> * (
<S2SV_ModStart> <S2SV_null> static vpx_variance_fn_t <S2SV_ModEnd> get_block_variance_fn ( <S2SV_ModStart> : return vpx_mse8x8 <S2SV_ModEnd> ; case <S2SV_ModStart> : return vpx_mse16x8 <S2SV_ModEnd> ; case <S2SV_ModStart> : return vpx_mse8x16 <S2SV_ModEnd> ; default <S2SV_ModStart> : return vpx_mse16x16 <S2SV_ModEnd> ; }
<S2SV_ModStart> ( const VP9_COMP * cpi <S2SV_ModEnd> , const <S2SV_ModStart> const double sr_decay_rate = get_sr_decay_rate ( cpi , next_frame ) <S2SV_ModEnd> ; const <S2SV_ModStart> const double zero_motion_factor = ( 0.95 * pow ( ( next_frame -> pcnt_inter - next_frame -> pcnt_motion ) , ZM_POWER_FACTOR ) ) ; return MAX ( zero_motion_factor , ( sr_decay_rate + ( <S2SV_ModEnd> ( 1.0 <S2SV_ModStart> 1.0 - sr_decay_rate ) * zero_motion_factor ) ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> input_stats ( TWO_PASS <S2SV_ModEnd> * p
<S2SV_ModStart> fpfile , "%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf" "%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.4lf" "%12.4lf<S2SV_blank>%12.4lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.0lf<S2SV_blank>%12.4lf\\n" <S2SV_ModEnd> , stats <S2SV_ModStart> stats -> weight , stats -> <S2SV_ModStart> stats -> <S2SV_ModEnd> pcnt_inter , <S2SV_ModStart> -> pcnt_neutral , stats -> intra_skip_pct , stats -> inactive_zone_rows , stats -> inactive_zone_cols
<S2SV_ModStart> <S2SV_null> static const FIRSTPASS_STATS * <S2SV_ModEnd> read_frame_stats ( <S2SV_ModStart> ( const TWO_PASS <S2SV_ModEnd> * p <S2SV_ModStart> * p <S2SV_ModEnd> , int <S2SV_ModStart> ) { if ( <S2SV_ModEnd> ( offset <S2SV_ModStart> >= 0 && p -> stats_in + offset <S2SV_ModEnd> >= p <S2SV_ModStart> stats_in_end ) || <S2SV_ModEnd> ( offset <S2SV_ModStart> < 0 && p -> stats_in + offset <S2SV_ModEnd> < p <S2SV_ModStart> stats_in_start ) ) { return NULL <S2SV_ModEnd> ; } <S2SV_ModStart> ; } return & p -> stats_in <S2SV_ModEnd> [ offset <S2SV_ModStart> ] ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> reset_fpf_position ( TWO_PASS <S2SV_ModEnd> * p
<S2SV_ModStart> section -> weight -= frame -> weight ; section -> <S2SV_ModStart> section -> <S2SV_ModEnd> pcnt_inter -= <S2SV_ModStart> -> pcnt_neutral ; section -> intra_skip_pct -= frame -> intra_skip_pct ; section -> inactive_zone_rows -= frame -> inactive_zone_rows ; section -> inactive_zone_cols -= frame -> inactive_zone_cols
<S2SV_ModStart> test_candidate_kf ( TWO_PASS <S2SV_ModEnd> * twopass <S2SV_ModStart> 0 ; double pcnt_intra = 1.0 - this_frame -> pcnt_inter ; double modified_pcnt_inter = this_frame -> pcnt_inter - this_frame -> pcnt_neutral ; <S2SV_ModStart> pcnt_second_ref < SECOND_REF_USEAGE_THRESH <S2SV_ModEnd> ) && <S2SV_ModStart> pcnt_second_ref < SECOND_REF_USEAGE_THRESH ) && ( ( this_frame -> pcnt_inter < VERY_LOW_INTER_THRESH ) || ( ( pcnt_intra > MIN_INTRA_LEVEL ) && ( pcnt_intra > ( INTRA_VS_INTER_THRESH * modified_pcnt_inter ) <S2SV_ModEnd> ) && <S2SV_ModStart> ) < KF_II_ERR_THRESHOLD <S2SV_ModEnd> ) && <S2SV_ModStart> ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || <S2SV_ModStart> ) > ERR_CHANGE_THRESHOLD <S2SV_ModEnd> ) || <S2SV_ModStart> ) > II_IMPROVEMENT_THRESHOLD <S2SV_ModEnd> ) ) <S2SV_ModStart> = ( BOOST_FACTOR <S2SV_ModEnd> * local_next_frame <S2SV_ModStart> next_iiratio > KF_II_MAX ) next_iiratio = KF_II_MAX <S2SV_ModEnd> ; if
<S2SV_ModStart> if ( is_two_pass_svc ( cpi ) <S2SV_ModEnd> ) {
<S2SV_ModStart> * cpi , const struct lookahead_entry * source <S2SV_ModStart> cpi -> td . <S2SV_ModStart> = & cpi -> td . pc_root -> none <S2SV_ModEnd> ; int <S2SV_ModStart> recon_uvoffset ; <S2SV_ModEnd> int64_t intra_error <S2SV_ModStart> 0 ; const <S2SV_ModStart> intrapenalty = INTRA_MODE_PENALTY ; double neutral_count <S2SV_ModEnd> ; int <S2SV_ModStart> ; int intra_skip_count = 0 ; int image_data_start_row = INVALID_ROW <S2SV_ModEnd> ; int <S2SV_ModStart> 0 ; MV lastmv = { 0 , 0 } ; TWO_PASS <S2SV_ModEnd> * twopass <S2SV_ModStart> } ; int recon_y_stride , recon_uv_stride , uv_mb_height ; YV12_BUFFER_CONFIG * const lst_yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; YV12_BUFFER_CONFIG * gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; YV12_BUFFER_CONFIG * const new_yv12 = get_frame_new_buffer ( cm ) ; <S2SV_ModStart> lst_yv12 ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & <S2SV_ModEnd> cpi -> <S2SV_ModStart> svc . layer_context [ cpi -> svc . spatial_layer_id ] : NULL ; double intra_factor ; double brightness_factor ; BufferPool * const pool = cm -> buffer_pool ; assert ( new_yv12 <S2SV_ModEnd> != NULL <S2SV_ModStart> NULL ) ; assert ( ( lc != NULL ) || frame_is_intra_only ( cm ) || ( lst_yv12 != NULL ) ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { vp9_zero_array ( cpi -> twopass . frame_mb_stats_buf , cm -> initial_mbs ) ; } # endif vpx_clear_system_state ( ) ; intra_factor = 0.0 ; brightness_factor = 0.0 ; neutral_count = 0.0 ; set_first_pass_params ( cpi ) ; vp9_set_quantizer ( cm , find_fp_qindex ( cm -> bit_depth ) ) ; if ( lc != NULL ) { twopass = & lc -> twopass ; cpi -> lst_fb_idx = cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags = VP9_LAST_FLAG ; if ( cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id < REF_FRAMES ) { cpi -> gld_fb_idx = cpi -> svc . number_spatial_layers + cpi -> svc . spatial_layer_id ; cpi -> ref_frame_flags |= VP9_GOLD_FLAG ; cpi -> refresh_golden_frame = ( lc -> current_video_frame_in_layer == 0 ) ; } else { cpi -> refresh_golden_frame = 0 ; } if ( lc -> current_video_frame_in_layer == 0 ) cpi -> ref_frame_flags = 0 ; vp9_scale_references ( cpi ) ; if ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) <S2SV_ModStart> first_ref_buf = vp9_get_scaled_ref_frame ( cpi , LAST_FRAME ) ; if ( first_ref_buf == NULL ) first_ref_buf = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; } if ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) { gld_yv12 = vp9_get_scaled_ref_frame ( cpi , GOLDEN_FRAME ) ; if ( gld_yv12 == NULL ) { gld_yv12 = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } } else { gld_yv12 = NULL ; } set_ref_ptrs ( cm , xd , ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ? LAST_FRAME : NONE , ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ? GOLDEN_FRAME : NONE ) ; cpi -> Source = vp9_scale_if_required ( cm , cpi -> un_scaled_source , & cpi -> scaled_source ) ; } vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; vp9_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_dst_planes ( xd -> plane , new_yv12 , 0 , 0 ) ; if ( ! frame_is_intra_only ( cm ) ) { vp9_setup_pre_planes ( xd , 0 , first_ref_buf , 0 , 0 , NULL ) ; } xd -> mi = cm -> mi_grid_visible ; xd <S2SV_ModEnd> -> mi <S2SV_ModStart> -> mi [ 0 ] = cm <S2SV_ModEnd> -> mi <S2SV_ModStart> -> mi <S2SV_ModEnd> ; vp9_frame_init_quantizer <S2SV_ModStart> ) ; recon_y_stride = new_yv12 -> y_stride ; recon_uv_stride = new_yv12 -> uv_stride ; uv_mb_height = 16 >> ( new_yv12 -> y_height > new_yv12 -> uv_height ) ; <S2SV_ModStart> ) { MV best_ref_mv = { 0 , 0 } <S2SV_ModEnd> ; xd <S2SV_ModStart> ) ; <S2SV_ModEnd> const BLOCK_SIZE <S2SV_ModStart> ) ; double log_intra ; int level_sample ; # if CONFIG_FP_MB_STATS const int mb_index = mb_row * cm -> mb_cols + mb_col ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) <S2SV_ModStart> ) ; x -> skip_encode = 0 ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . tx_size = use_dc_pred ? ( bsize >= BLOCK_16X16 ? TX_16X16 : TX_8X8 ) : TX_4X4 ; vp9_encode_intra_block_plane ( x , bsize , 0 ) ; this_error = vpx_get_mb_ss ( x -> plane [ 0 ] . src_diff ) ; if ( this_error < UL_INTRA_THRESH ) { ++ intra_skip_count ; } else if ( ( mb_col > 0 ) && ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = mb_row ; } # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { switch ( cm -> bit_depth ) { case VPX_BITS_8 : break ; case VPX_BITS_10 : this_error >>= 4 ; break ; case VPX_BITS_12 : this_error >>= 8 ; break ; default : assert ( 0 && "cm->bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>" "VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return ; } } # endif vpx_clear_system_state ( ) ; log_intra = log ( this_error + 1.0 ) ; if ( log_intra < 10.0 ) intra_factor += 1.0 + ( ( 10.0 - log_intra ) * 0.05 ) ; else intra_factor += 1.0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) level_sample = CONVERT_TO_SHORTPTR ( x -> plane [ 0 ] . src . buf ) [ 0 ] ; else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # else level_sample = x -> plane [ 0 ] . src . buf [ 0 ] ; # endif if ( ( level_sample < DARK_THRESH ) && ( log_intra < 9.0 ) ) brightness_factor += 1.0 + ( 0.01 * ( DARK_THRESH - level_sample ) ) ; else brightness_factor += 1.0 ; <S2SV_ModEnd> this_error += <S2SV_ModStart> this_error ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; } # endif <S2SV_ModStart> if ( ( lc == NULL && <S2SV_ModStart> 0 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 0 ) ) <S2SV_ModStart> , motion_error , raw_motion_error ; MV mv = { 0 , 0 } <S2SV_ModEnd> , tmp_mv <S2SV_ModStart> , tmp_mv = { 0 , 0 } ; struct buf_2d unscaled_last_source_buf_2d <S2SV_ModStart> recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif unscaled_last_source_buf_2d . buf = cpi -> unscaled_last_source -> y_buffer + recon_yoffset ; unscaled_last_source_buf_2d . stride = cpi -> unscaled_last_source -> y_stride ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { raw_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d , xd -> bd ) ; } else { raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; } # else raw_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & unscaled_last_source_buf_2d ) ; # endif if ( raw_motion_error > 25 || lc != NULL ) { first_pass_motion_search ( cpi , x , & best_ref_mv , & mv , & motion_error ) ; if ( ! is_zero_mv ( & best_ref_mv ) ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_mv , & tmp_mv , & tmp_err ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ; mv <S2SV_ModEnd> = tmp_mv <S2SV_ModStart> = tmp_mv ; } } if ( ( ( lc == NULL && <S2SV_ModEnd> cm -> <S2SV_ModStart> > 1 ) || ( lc != NULL && lc -> current_video_frame_in_layer > 1 ) ) <S2SV_ModStart> recon_yoffset ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> gf_motion_error = highbd_get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] , xd -> bd ) ; } else { gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; } # else gf_motion_error = get_prediction_error ( bsize , & x -> plane [ 0 ] . src , & xd -> plane [ 0 ] . pre [ 0 ] ) ; # endif <S2SV_ModEnd> first_pass_motion_search ( <S2SV_ModStart> & tmp_mv <S2SV_ModEnd> , & <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ; } } else { sr_coded_error += motion_error ; } <S2SV_ModStart> best_ref_mv . row = 0 ; best_ref_mv . col = 0 ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif <S2SV_ModEnd> if ( <S2SV_ModStart> ) { vpx_clear_system_state ( ) ; <S2SV_ModStart> ) && ( <S2SV_ModStart> this_error < ( <S2SV_ModStart> intrapenalty ) ) ) { neutral_count += 1.0 ; } else if ( ( this_error > NCOUNT_INTRA_THRESH ) && ( this_error < ( NCOUNT_INTRA_FACTOR * motion_error ) ) ) { neutral_count += ( double ) motion_error / DOUBLE_DIVIDE_CHECK ( ( double ) this_error ) ; } mv <S2SV_ModEnd> . row <S2SV_ModStart> mv . <S2SV_ModEnd> col *= <S2SV_ModStart> 0 ] . as_mv <S2SV_ModStart> mv . <S2SV_ModEnd> row ; <S2SV_ModStart> mv . <S2SV_ModEnd> row ) <S2SV_ModStart> mv . <S2SV_ModEnd> col ; <S2SV_ModStart> mv . <S2SV_ModEnd> col ) <S2SV_ModStart> mv . <S2SV_ModEnd> row * <S2SV_ModStart> * mv <S2SV_ModEnd> . row <S2SV_ModStart> mv . <S2SV_ModEnd> col * <S2SV_ModStart> * mv <S2SV_ModEnd> . col <S2SV_ModStart> ; best_ref_mv <S2SV_ModEnd> = mv <S2SV_ModStart> = mv ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] = 0 ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_DCINTRA_MASK ; cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_ZERO_MASK ; if ( this_error > FPMB_ERROR_LARGE_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_LARGE_MASK ; } else if ( this_error < FPMB_ERROR_SMALL_TH ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_ERROR_SMALL_MASK ; } } # endif if ( ! is_zero_mv ( & mv ) <S2SV_ModEnd> ) { <S2SV_ModStart> mvcount ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] &= ~ FPMB_MOTION_ZERO_MASK ; <S2SV_ModStart> mv . as_mv . col > 0 && mv . as_mv . col >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_RIGHT_MASK ; } else if ( mv . as_mv . row < 0 && abs ( mv . as_mv . row ) >= abs ( mv . as_mv . col ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_UP_MASK ; } else if ( mv . as_mv . col < 0 && abs ( mv . as_mv . col ) >= abs ( mv . as_mv . row ) ) { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_LEFT_MASK ; } else { cpi -> twopass . frame_mb_stats_buf [ mb_index ] |= FPMB_MOTION_DOWN_MASK ; } } # endif if ( ! is_equal_mv ( & mv , & lastmv ) <S2SV_ModEnd> ) ++ <S2SV_ModStart> new_mv_count ; lastmv <S2SV_ModEnd> = mv <S2SV_ModStart> = mv <S2SV_ModEnd> ; if <S2SV_ModStart> mv . <S2SV_ModEnd> row > <S2SV_ModStart> ( mv <S2SV_ModEnd> . row <S2SV_ModStart> mv . <S2SV_ModEnd> row > <S2SV_ModStart> ( mv <S2SV_ModEnd> . row <S2SV_ModStart> mv . <S2SV_ModEnd> col > <S2SV_ModStart> ( mv <S2SV_ModEnd> . col <S2SV_ModStart> mv . <S2SV_ModEnd> col > <S2SV_ModStart> ( mv <S2SV_ModEnd> . col <S2SV_ModStart> mb_cols ; vpx_clear_system_state ( ) ; } if ( ( image_data_start_row > cm -> mb_rows / 2 ) || ( image_data_start_row == INVALID_ROW ) ) { image_data_start_row = cm -> mb_rows / 2 ; } if ( image_data_start_row > 0 ) { intra_skip_count = MAX ( 0 , intra_skip_count - ( image_data_start_row * cm -> mb_cols * 2 ) ) ; } <S2SV_ModEnd> { FIRSTPASS_STATS <S2SV_ModStart> fps ; const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; const double min_err = 200 * sqrt ( num_mbs ) ; intra_factor = intra_factor / ( double ) num_mbs ; brightness_factor = brightness_factor / ( double ) num_mbs ; <S2SV_ModStart> fps . weight = intra_factor * brightness_factor ; fps . <S2SV_ModStart> . spatial_layer_id ; fps . coded_error = ( double ) ( coded_error >> 8 ) + min_err ; fps . sr_coded_error = ( double ) ( sr_coded_error >> 8 ) + min_err <S2SV_ModStart> 8 ) + min_err <S2SV_ModEnd> ; fps <S2SV_ModStart> intercount / num_mbs <S2SV_ModEnd> ; fps <S2SV_ModStart> second_ref_count / num_mbs <S2SV_ModEnd> ; fps <S2SV_ModStart> neutral_count / num_mbs ; fps . intra_skip_pct = ( double ) intra_skip_count / num_mbs ; fps . inactive_zone_rows = ( double ) image_data_start_row ; fps . inactive_zone_cols = ( double ) 0 <S2SV_ModEnd> ; if <S2SV_ModStart> sum_mvrs - ( ( double ) sum_mvr * sum_mvr <S2SV_ModEnd> / mvcount <S2SV_ModStart> sum_mvcs - ( ( double ) sum_mvc * sum_mvc <S2SV_ModEnd> / mvcount <S2SV_ModStart> mvcount / num_mbs <S2SV_ModEnd> ; } <S2SV_ModStart> ) ( <S2SV_ModEnd> source -> <S2SV_ModStart> ts_end - <S2SV_ModEnd> source -> <S2SV_ModStart> ) ; # if CONFIG_FP_MB_STATS if ( cpi -> use_fp_mb_stats ) { output_fpmb_stats ( twopass -> frame_mb_stats_buf , cm , cpi -> output_pkt_list ) ; } # endif <S2SV_ModStart> ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } vpx_extend_frame_borders ( new_yv12 ) ; if ( lc != NULL <S2SV_ModEnd> ) { <S2SV_ModStart> else { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> lst_fb_idx ] , cm -> new_fb_idx ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> 0 && cpi -> gld_fb_idx != INVALID_IDX && lc == <S2SV_ModEnd> NULL ) <S2SV_ModStart> ) { ref_cnt_fb ( pool -> frame_bufs , & cm -> ref_frame_map [ cpi -> gld_fb_idx ] , cm -> ref_frame_map [ cpi -> lst_fb_idx ] <S2SV_ModEnd> ) ; <S2SV_ModStart> current_video_frame ; if ( cpi -> use_svc ) vp9_inc_frame_in_layer ( cpi ) ;
<S2SV_ModStart> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> const int is_two_pass_svc <S2SV_ModEnd> = ( <S2SV_ModStart> 1 ) || <S2SV_ModEnd> ( svc <S2SV_ModStart> -> number_temporal_layers > <S2SV_ModEnd> 1 ) <S2SV_ModStart> ) ; TWO_PASS * const twopass = is_two_pass_svc ? <S2SV_ModEnd> & svc <S2SV_ModStart> . twopass : & cpi -> twopass ; double frame_rate ; FIRSTPASS_STATS * stats ; <S2SV_ModEnd> zero_stats ( <S2SV_ModStart> return ; stats = & <S2SV_ModStart> -> total_stats ; * stats <S2SV_ModStart> total_left_stats = * stats <S2SV_ModEnd> ; frame_rate <S2SV_ModStart> 10000000.0 * stats -> <S2SV_ModEnd> count / <S2SV_ModStart> count / stats -> <S2SV_ModEnd> duration ; <S2SV_ModStart> if ( is_two_pass_svc <S2SV_ModEnd> ) { <S2SV_ModStart> ) ( stats -> <S2SV_ModEnd> duration * <S2SV_ModStart> ) ( stats -> <S2SV_ModEnd> duration * <S2SV_ModStart> ; } <S2SV_ModEnd> twopass -> <S2SV_ModStart> ; { const double avg_error = stats -> coded_error / DOUBLE_DIVIDE_CHECK ( stats -> count ) ; const FIRSTPASS_STATS * s = twopass -> stats_in ; double modified_error_total <S2SV_ModEnd> = 0.0 <S2SV_ModStart> 0.0 ; twopass -> modified_error_min = ( avg_error * oxcf -> two_pass_vbrmin_section ) / 100 ; twopass -> modified_error_max = ( avg_error * oxcf -> two_pass_vbrmax_section ) / 100 <S2SV_ModEnd> ; while <S2SV_ModStart> while ( s < twopass -> stats_in_end ) { <S2SV_ModEnd> modified_error_total += <S2SV_ModStart> cpi , twopass , oxcf , s ) ; ++ s <S2SV_ModEnd> ; } <S2SV_ModStart> modified_error_left = <S2SV_ModEnd> modified_error_total ; <S2SV_ModStart> modified_error_total ; } cpi -> rc . vbr_bits_off_target = 0 ; cpi -> rc . vbr_bits_off_target_fast = 0 ; cpi -> rc . rate_error_estimate = 0 ; twopass -> kf_zeromotion_pct = 100 ; twopass -> last_kfgroup_zeromotion_pct = 100 ; if ( oxcf -> resize_mode != RESIZE_NONE ) { vp9_init_subsampling ( cpi <S2SV_ModEnd> ) ;
<S2SV_ModStart> rc ; TWO_PASS <S2SV_ModEnd> * const <S2SV_ModStart> -> twopass ; GF_GROUP * const gf_group = & twopass -> gf_group <S2SV_ModStart> this_frame ; int target_rate ; LAYER_CONTEXT * const lc = is_two_pass_svc ( cpi ) ? & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] : 0 ; if ( lc != NULL ) { frames_left = ( int ) ( twopass -> total_stats . count - lc -> current_video_frame_in_layer ) ; } else { frames_left = ( int ) ( twopass -> total_stats . count - cm -> current_video_frame ) ; } if ( ! twopass -> stats_in ) return ; if ( gf_group -> update_type [ gf_group -> index ] == ARF_UPDATE ) { int target_rate ; configure_buffer_updates ( cpi ) ; target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; cm -> frame_type = INTER_FRAME ; if ( lc != NULL ) { if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } } if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } return ; } vpx_clear_system_state ( ) ; if ( cpi -> oxcf . rc_mode == VPX_Q ) { twopass -> active_worst_quality = cpi -> oxcf . cq_level ; } else if ( cm -> current_video_frame == 0 || ( lc != NULL && lc -> current_video_frame_in_layer == 0 ) ) { const int section_target_bandwidth = ( int ) ( twopass -> bits_left / frames_left ) ; const double section_length = twopass -> total_left_stats . count ; const double section_error = twopass -> total_left_stats . coded_error / section_length ; const double section_intra_skip = twopass -> total_left_stats . intra_skip_pct / section_length ; const double section_inactive_zone = ( twopass -> total_left_stats . inactive_zone_rows * 2 ) / ( ( double ) cm -> mb_rows * section_length ) ; const int tmp_q = get_twopass_worst_quality ( cpi , section_error , section_intra_skip + section_inactive_zone , section_target_bandwidth , DEFAULT_GRP_WEIGHT ) ; twopass -> active_worst_quality = tmp_q ; twopass -> baseline_active_worst_quality = tmp_q ; rc -> ni_av_qi = tmp_q ; rc -> last_q [ INTER_FRAME ] = tmp_q ; rc -> avg_q = vp9_convert_qindex_to_q ( tmp_q , cm -> bit_depth ) ; rc -> avg_frame_qindex [ INTER_FRAME ] = tmp_q ; rc -> last_q [ KEY_FRAME ] = ( tmp_q + cpi -> oxcf . best_allowed_q ) / 2 ; rc -> avg_frame_qindex [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; } vp9_zero ( this_frame ) ; if ( EOF == input_stats ( twopass , & this_frame ) ) return ; if ( this_frame . intra_skip_pct >= FC_ANIMATION_THRESH ) twopass -> fr_content_type = FC_GRAPHICS_ANIMATION ; else twopass -> fr_content_type = FC_NORMAL ; if ( rc -> frames_to_key == 0 || ( cpi -> frame_flags & FRAMEFLAGS_KEY ) ) { <S2SV_ModStart> this_frame_copy ; this_frame_copy = this_frame ; find_next_key_frame ( cpi , & this_frame ) ; this_frame = this_frame_copy ; } else { cm -> frame_type = INTER_FRAME ; } if ( lc != NULL ) { if ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; lc -> frames_from_key_frame = 0 ; cpi -> svc . encode_intra_empty_frame = 1 ; } } else { cm -> frame_type = INTER_FRAME ; lc -> is_key_frame = <S2SV_ModEnd> cpi -> <S2SV_ModStart> layer_context [ 0 ] . is_key_frame ; if ( lc -> is_key_frame ) { cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; lc -> frames_from_key_frame = 0 ; } } } if ( rc -> frames_till_gf_update_due == 0 ) { define_gf_group ( cpi , & this_frame ) ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( lc != NULL ) cpi -> refresh_golden_frame = 1 ; # if ARF_STATS_OUTPUT { FILE * fpfile ; fpfile = fopen ( "arf.stt" , "a" ) ; ++ arf_count ; fprintf ( fpfile , "%10d<S2SV_blank>%10ld<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10ld\\n" , <S2SV_ModEnd> cm -> <S2SV_ModStart> -> current_video_frame , <S2SV_ModEnd> rc -> <S2SV_ModStart> -> frames_till_gf_update_due , rc -> kf_boost , arf_count , rc -> gfu_boost ) ; fclose ( fpfile ) ; } <S2SV_ModEnd> # endif <S2SV_ModStart> # endif } configure_buffer_updates ( cpi ) ; if ( cpi -> sf . allow_partition_search_skip && cpi -> oxcf . pass == 2 && <S2SV_ModEnd> ( ! <S2SV_ModStart> ( ! cpi -> use_svc || is_two_pass_svc ( cpi ) ) ) { cpi -> partition_search_skippable_frame = is_skippable_frame ( cpi ) ; } target_rate = gf_group -> bit_allocation [ gf_group -> index ] ; if ( cpi -> common . frame_type == KEY_FRAME ) target_rate = vp9_rc_clamp_iframe_target_size ( cpi , target_rate ) <S2SV_ModEnd> ; else <S2SV_ModStart> ; else target_rate = vp9_rc_clamp_pframe_target_size ( cpi , target_rate ) ; rc -> base_frame_target = target_rate ; { const int num_mbs = ( cpi -> oxcf . resize_mode != RESIZE_NONE ) ? cpi -> initial_mbs : cpi -> common . MBs ; twopass -> mb_av_energy = log ( ( ( this_frame . intra_error * 256.0 ) / num_mbs ) + 1.0 ) ; } <S2SV_ModEnd> subtract_stats (
<S2SV_ModStart> ) { TWO_PASS * const twopass = & cpi -> twopass ; RATE_CONTROL * const rc = & cpi -> rc ; const int <S2SV_ModEnd> bits_used = <S2SV_ModStart> bits_used = rc -> base_frame_target ; rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ; twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ; if ( rc -> total_actual_bits ) { rc -> rate_error_estimate = ( int ) ( ( rc -> vbr_bits_off_target * 100 ) / rc -> total_actual_bits ) ; rc -> rate_error_estimate = clamp ( rc -> rate_error_estimate , - 100 , 100 ) ; } else { rc -> rate_error_estimate = 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) { twopass -> <S2SV_ModEnd> kf_group_bits -= <S2SV_ModStart> bits_used ; twopass -> last_kfgroup_zeromotion_pct = twopass -> kf_zeromotion_pct ; } twopass -> kf_group_bits <S2SV_ModEnd> = MAX <S2SV_ModStart> MAX ( twopass -> kf_group_bits <S2SV_ModEnd> , 0 <S2SV_ModStart> ) ; ++ twopass -> gf_group . index ; if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) && ! cpi -> rc . is_src_frame_alt_ref ) { const int maxq_adj_limit = rc -> worst_quality - twopass -> active_worst_quality ; const int minq_adj_limit = ( cpi -> oxcf . rc_mode == VPX_CQ ? MINQ_ADJ_LIMIT_CQ : MINQ_ADJ_LIMIT ) ; if ( rc -> rate_error_estimate > cpi -> oxcf . under_shoot_pct ) { -- twopass -> extend_maxq ; if ( rc -> rolling_target_bits >= rc -> rolling_actual_bits ) ++ twopass -> extend_minq ; } else if ( rc -> rate_error_estimate < - cpi -> oxcf . over_shoot_pct ) { -- twopass -> extend_minq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) ++ twopass -> extend_maxq ; } else { if ( rc -> projected_frame_size > ( 2 * rc -> base_frame_target ) && rc -> projected_frame_size > ( 2 * rc -> avg_frame_bandwidth ) ) ++ twopass -> extend_maxq ; if ( rc -> rolling_target_bits < rc -> rolling_actual_bits ) -- twopass -> extend_minq ; else if ( rc -> rolling_target_bits > rc -> rolling_actual_bits ) -- twopass -> extend_maxq ; } twopass -> extend_minq = clamp ( twopass -> extend_minq <S2SV_ModEnd> , 0 <S2SV_ModStart> , 0 , minq_adj_limit ) ; twopass -> extend_maxq = clamp ( twopass -> extend_maxq , 0 , maxq_adj_limit ) ; if ( ! frame_is_kf_gf_arf ( cpi ) && ! cpi -> rc . is_src_frame_alt_ref ) { int fast_extra_thresh = rc -> base_frame_target / HIGH_UNDERSHOOT_RATIO ; if ( rc -> projected_frame_size < fast_extra_thresh ) { rc -> vbr_bits_off_target_fast += fast_extra_thresh - rc -> projected_frame_size ; rc -> vbr_bits_off_target_fast = MIN ( rc -> vbr_bits_off_target_fast , ( 4 * rc -> avg_frame_bandwidth ) ) ; if ( rc -> avg_frame_bandwidth ) { twopass -> extend_minq_fast = ( int ) ( rc -> vbr_bits_off_target_fast * 8 / rc -> avg_frame_bandwidth ) ; } twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else if ( rc -> vbr_bits_off_target_fast ) { twopass -> extend_minq_fast = MIN ( twopass -> extend_minq_fast , minq_adj_limit - twopass -> extend_minq ) ; } else { twopass -> extend_minq_fast = 0 ; } } } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> -> frame = 0.0 ; section -> weight <S2SV_ModStart> -> sr_coded_error <S2SV_ModEnd> = 0.0 <S2SV_ModStart> -> pcnt_neutral = 0.0 ; section -> intra_skip_pct = 0.0 ; section -> inactive_zone_rows = 0.0 ; section -> inactive_zone_cols
<S2SV_ModStart> ++ ) vpx_free_frame_buffer <S2SV_ModEnd> ( &
<S2SV_ModStart> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> ) { const int legacy_byte_alignment = 0 ; <S2SV_ModStart> if ( vpx_alloc_frame_buffer <S2SV_ModEnd> ( & <S2SV_ModStart> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , legacy_byte_alignment <S2SV_ModEnd> ) )
<S2SV_ModStart> ts_end , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif <S2SV_ModStart> # endif int width = src -> y_crop_width ; int height = src -> y_crop_height ; int uv_width = src -> uv_crop_width ; int uv_height = src -> uv_crop_height ; int subsampling_x = src -> subsampling_x ; int subsampling_y = src -> subsampling_y ; int larger_dimensions , new_dimensions ; <S2SV_ModStart> ) ; new_dimensions = width != buf -> img . y_crop_width || height != buf -> img . y_crop_height || uv_width != buf -> img . uv_crop_width || uv_height != buf -> img . uv_crop_height ; larger_dimensions = width > buf -> img . y_width || height > buf -> img . y_height || uv_width > buf -> img . uv_width || uv_height > buf -> img . uv_height ; assert ( ! larger_dimensions || new_dimensions ) ; <S2SV_ModStart> if ( ! new_dimensions && <S2SV_ModStart> else { # endif if ( larger_dimensions ) { YV12_BUFFER_CONFIG new_img ; memset ( & new_img , 0 , sizeof ( new_img ) ) ; if ( vpx_alloc_frame_buffer ( & new_img , width , height , subsampling_x , subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , 0 ) ) return 1 ; vpx_free_frame_buffer ( & buf -> img ) ; buf -> img = new_img ; } else if ( new_dimensions ) { buf -> img . y_crop_width = src -> y_crop_width ; buf -> img . y_crop_height = src -> y_crop_height ; buf -> img . uv_crop_width = src -> uv_crop_width ; buf -> img . uv_crop_height = src -> uv_crop_height ; buf -> img . subsampling_x = src -> subsampling_x ; buf -> img . subsampling_y = src -> subsampling_y ; } <S2SV_ModStart> ) ; # if USE_PARTIAL_COPY } <S2SV_ModEnd> # endif
<S2SV_ModStart> cpi -> td . <S2SV_ModStart> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; const <S2SV_ModStart> ; int cost_list [ 5 ] ; int <S2SV_ModStart> step_param = mv_sf -> reduce_first_step_size <S2SV_ModEnd> ; step_param <S2SV_ModStart> step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 <S2SV_ModStart> - 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> 0 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> 0 , mv_sf -> <S2SV_ModEnd> subpel_iters_per_step , <S2SV_ModStart> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> & sse , NULL , 0 , 0 <S2SV_ModStart> ; return vpx_sad16x16 <S2SV_ModEnd> ( x <S2SV_ModStart> . stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> , const MV * ref_mv , <S2SV_ModStart> int_mv * <S2SV_ModEnd> dst_mv , <S2SV_ModStart> cpi -> td . <S2SV_ModStart> tmp_err ; MV tmp_mv ; err = vpx_sad16x16 <S2SV_ModEnd> ( x <S2SV_ModStart> . stride <S2SV_ModEnd> ) ; <S2SV_ModStart> cpi , ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { err = tmp_err ; dst_mv <S2SV_ModEnd> -> as_mv <S2SV_ModStart> -> as_mv = tmp_mv ; } if ( ref_mv -> row != 0 || ref_mv -> col != 0 ) { unsigned int tmp_err ; MV zero_ref_mv = { 0 , 0 } , tmp_mv ; tmp_err = do_16x16_motion_iteration ( cpi , & zero_ref_mv , & tmp_mv , mb_row , mb_col ) ; if ( tmp_err < err ) { dst_mv -> as_mv = tmp_mv <S2SV_ModEnd> ; err
<S2SV_ModStart> cpi -> td . <S2SV_ModStart> err = vpx_sad16x16 <S2SV_ModEnd> ( x <S2SV_ModStart> . stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> cpi , PREDICTION_MODE <S2SV_ModEnd> * pbest_mode <S2SV_ModStart> cpi -> td . <S2SV_ModStart> e_mbd ; PREDICTION_MODE <S2SV_ModEnd> best_mode = <S2SV_ModStart> xd , <S2SV_ModEnd> 2 , <S2SV_ModStart> err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride <S2SV_ModEnd> ) ;
<S2SV_ModStart> cpi -> td . <S2SV_ModStart> 0 ; MV gld_top_mv = { 0 , 0 } <S2SV_ModEnd> ; MODE_INFO <S2SV_ModStart> MODE_INFO mi_local ; vp9_zero ( mi_local ) <S2SV_ModEnd> ; x <S2SV_ModStart> ) { MV gld_left_mv = gld_top_mv <S2SV_ModEnd> ; int <S2SV_ModStart> = gld_y_offset <S2SV_ModEnd> ; x <S2SV_ModStart> ) ; gld_left_mv <S2SV_ModEnd> = mb_stats <S2SV_ModStart> ref [ GOLDEN_FRAME <S2SV_ModEnd> ] . <S2SV_ModStart> mv . as_mv ; if ( mb_col == 0 ) { gld_top_mv = gld_left_mv <S2SV_ModEnd> ; }
<S2SV_ModStart> golden_ref , const MV <S2SV_ModEnd> * prev_golden_ref_mv <S2SV_ModStart> cpi -> td .
<S2SV_ModStart> , GOLDEN_FRAME ) ; assert ( golden_ref != NULL <S2SV_ModStart> ] ; memset <S2SV_ModEnd> ( frame_stats <S2SV_ModStart> ; } vpx_clear_system_state <S2SV_ModEnd> ( )
<S2SV_ModStart> get_max_filter_level ( const <S2SV_ModStart> * cpi ) { if ( cpi -> oxcf . pass == 2 <S2SV_ModStart> ; } else { return MAX_LOOP_FILTER ; } }
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> search_filter_level ( <S2SV_ModStart> ) { const <S2SV_ModStart> common ; const <S2SV_ModStart> ; int <S2SV_ModEnd> filt_direction = <S2SV_ModStart> = 0 ; int64_t best_err ; int filt_best <S2SV_ModStart> 4 ; int64_t <S2SV_ModEnd> ss_err [ <S2SV_ModStart> ] ; memset <S2SV_ModEnd> ( ss_err <S2SV_ModStart> ) ; int64_t <S2SV_ModEnd> bias = <S2SV_ModStart> ; if ( ( cpi -> oxcf . pass == 2 ) && <S2SV_ModStart> 20 ) ) bias = ( <S2SV_ModEnd> bias * <S2SV_ModStart> . section_intra_rating ) <S2SV_ModStart> ) { ss_err [ filt_low ] <S2SV_ModEnd> = try_filter_frame <S2SV_ModStart> ) ; } if ( ( ss_err [ filt_low ] <S2SV_ModEnd> - bias <S2SV_ModStart> if ( ss_err [ filt_low ] < best_err ) best_err = ss_err [ filt_low ] <S2SV_ModEnd> ; filt_best <S2SV_ModStart> ) { ss_err [ filt_high ] <S2SV_ModEnd> = try_filter_frame <S2SV_ModStart> ) ; } if ( ss_err [ filt_high ] <S2SV_ModEnd> < ( <S2SV_ModStart> best_err = ss_err [ filt_high ] <S2SV_ModEnd> ; filt_best <S2SV_ModStart> } } return <S2SV_ModEnd> filt_best ;
<S2SV_ModStart> <S2SV_null> static int64_t <S2SV_ModEnd> try_filter_frame ( <S2SV_ModStart> common ; int64_t <S2SV_ModEnd> filt_err ; <S2SV_ModStart> filt_err ; if ( cpi -> num_workers > 1 ) vp9_loop_filter_frame_mt ( cm -> frame_to_show , cm , cpi -> td . mb . e_mbd . plane , filt_level , 1 , partial_frame , cpi -> workers , cpi -> num_workers , & cpi -> lf_row_sync ) ; else <S2SV_ModStart> vp9_loop_filter_frame ( cm -> frame_to_show , <S2SV_ModStart> cpi -> td . <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) { filt_err = vp9_highbd_get_y_sse ( sd , cm -> frame_to_show ) ; } else { <S2SV_ModStart> ) ; } # else filt_err = vp9_get_y_sse ( sd , cm -> frame_to_show ) ; # endif
<S2SV_ModStart> method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) { lf -> filter_level = 0 ; } else if ( method >= <S2SV_ModStart> , 0 , cm -> bit_depth ) ; # if CONFIG_VP9_HIGHBITDEPTH int filt_guess ; switch ( cm -> bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> filt_guess = <S2SV_ModStart> ) ; break ; case VPX_BITS_10 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 4060632 , 20 ) ; break ; case VPX_BITS_12 : filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 16242526 , 22 ) ; break ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>" "or<S2SV_blank>VPX_BITS_12" ) ; return ; } # else int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; # endif <S2SV_ModStart> else { lf -> filter_level =
<S2SV_ModStart> * out_dist_sum , unsigned int * var_y , unsigned int * sse_y <S2SV_ModStart> ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> 6 ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> 6 ; const uint32_t dc_quant = pd -> dequant [ 0 ] ; const uint32_t ac_quant = pd -> dequant [ 1 ] ; unsigned <S2SV_ModStart> ) ; int skip_dc = 0 ; * var_y = var ; * sse_y = sse ; if ( cpi -> common . tx_mode == TX_MODE_SELECT ) { if ( sse > ( var << 2 ) ) xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; else xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; else if ( xd -> mi [ 0 ] -> mbmi . tx_size > TX_16X16 ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_16X16 ; } else { xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; } { const BLOCK_SIZE unit_size = txsize_to_bsize [ xd -> mi [ 0 ] -> mbmi . tx_size ] ; const unsigned int num_blk_log2 = ( b_width_log2_lookup [ bsize ] - b_width_log2_lookup [ unit_size ] ) + ( b_height_log2_lookup [ bsize ] - b_height_log2_lookup [ unit_size ] ) ; const unsigned int sse_tx = sse >> num_blk_log2 ; const unsigned int var_tx = var >> num_blk_log2 ; x -> skip_txfm [ 0 ] = SKIP_TXFM_NONE ; if ( var_tx < ac_thr || var == 0 ) { x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_ONLY ; if ( sse_tx - var_tx < dc_thr || sse == var ) x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } else { if ( sse_tx - var_tx < dc_thr || sse == var ) skip_dc = 1 ; } } if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC ) { * out_rate_sum = 0 ; * out_dist_sum = sse << 4 ; return ; } if ( ! skip_dc ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; # endif } if ( ! skip_dc ) { * out_rate_sum = rate >> 1 <S2SV_ModEnd> ; * <S2SV_ModStart> ; } else { * out_rate_sum = 0 ; * out_dist_sum = ( sse - var ) << 4 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; # endif * out_rate_sum += rate ; * out_dist_sum += dist << 4 ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> void <S2SV_ModEnd> vp9_pick_inter_mode ( <S2SV_ModStart> x , TileDataEnc * tile_data , int mi_row , int mi_col , RD_COST * rd_cost , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) { VP9_COMMON * const cm = & cpi -> common ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModEnd> TileInfo * <S2SV_ModStart> * const tile_info = & tile_data -> tile_info ; <S2SV_ModEnd> MACROBLOCKD * <S2SV_ModStart> MACROBLOCKD * const <S2SV_ModStart> MB_MODE_INFO * const <S2SV_ModStart> -> mbmi <S2SV_ModEnd> ; struct <S2SV_ModStart> ] ; PREDICTION_MODE <S2SV_ModEnd> best_mode = <S2SV_ModStart> = LAST_FRAME ; MV_REFERENCE_FRAME usable_ref_frame ; TX_SIZE best_tx_size = TX_SIZES <S2SV_ModStart> } ; RD_COST this_rdc , best_rdc ; uint8_t skip_txfm = SKIP_TXFM_NONE , best_mode_skip_txfm = SKIP_TXFM_NONE ; unsigned int var_y = UINT_MAX ; unsigned int sse_y = UINT_MAX ; const int reduction_fac = ( bsize <= BLOCK_16X16 ) ? ( ( bsize <= BLOCK_8X8 ) ? 4 : 2 ) : 0 ; const <S2SV_ModEnd> int intra_cost_penalty <S2SV_ModStart> intra_cost_penalty = vp9_get_intra_cost_penalty ( <S2SV_ModEnd> cm -> <S2SV_ModStart> -> y_dc_delta_q , cm -> bit_depth ) >> reduction_fac <S2SV_ModEnd> ; const <S2SV_ModStart> 0 ) <S2SV_ModEnd> ; const <S2SV_ModStart> cpi -> rd . threshes [ mbmi -> <S2SV_ModEnd> segment_id ] <S2SV_ModStart> rd_thresh_freq_fact = tile_data -> thresh_freq_fact <S2SV_ModEnd> [ bsize <S2SV_ModStart> bsize ] <S2SV_ModEnd> ; INTERP_FILTER <S2SV_ModStart> INTERP_FILTER filter_ref ; const int bsl = mi_width_log2_lookup [ bsize ] ; const int pred_filter_search = cm -> <S2SV_ModEnd> interp_filter == <S2SV_ModStart> SWITCHABLE ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int const_motion [ MAX_REF_FRAMES ] = { 0 } ; const int bh = num_4x4_blocks_high_lookup [ bsize ] << 2 ; const int bw = num_4x4_blocks_wide_lookup [ bsize ] << 2 ; PRED_BUFFER tmp [ 4 ] ; DECLARE_ALIGNED ( 16 , uint8_t , pred_buf [ 3 * 64 * 64 ] ) ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , pred_buf_16 [ 3 * 64 * 64 ] ) ; # endif struct buf_2d orig_dst = pd -> dst ; PRED_BUFFER * best_pred = NULL ; PRED_BUFFER * this_mode_pred = NULL ; const int pixels_in_block = bh * bw ; int reuse_inter_pred = cpi -> sf . reuse_inter_pred_sby && ctx -> pred_pixel_ready ; int ref_frame_skip_mask = 0 ; int idx ; int best_pred_sad = INT_MAX ; int best_early_term = 0 ; int ref_frame_cost [ MAX_REF_FRAMES ] ; init_ref_frame_cost ( cm , xd , ref_frame_cost ) ; if ( reuse_inter_pred ) { int i ; for ( i = 0 ; i < 3 ; i ++ ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) tmp [ i ] . data = CONVERT_TO_BYTEPTR ( & pred_buf_16 [ pixels_in_block * i ] ) ; else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # else tmp [ i ] . data = & pred_buf [ pixels_in_block * i ] ; # endif tmp [ i ] . stride = bw ; tmp [ i ] . in_use = 0 ; } tmp [ 3 ] . data = pd -> dst . buf ; tmp [ 3 ] . stride = pd -> dst . stride ; tmp [ 3 ] . in_use = 0 ; } x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; x <S2SV_ModEnd> -> skip <S2SV_ModStart> 0 ; <S2SV_ModEnd> if ( <S2SV_ModStart> interp_filter ; else filter_ref = cm -> interp_filter ; vp9_rd_cost_reset ( & best_rdc ) ; vp9_rd_cost_reset ( rd_cost ) ; mbmi -> sb_type = bsize ; mbmi -> ref_frame [ 0 ] = NONE ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ) ; # if CONFIG_VP9_TEMPORAL_DENOISING vp9_denoiser_reset_frame_stats ( ctx ) ; # endif if ( cpi -> rc . frames_since_golden == 0 && ! cpi -> use_svc ) { usable_ref_frame = LAST_FRAME ; } else { usable_ref_frame = GOLDEN_FRAME ; } <S2SV_ModStart> ref_frame <= usable_ref_frame <S2SV_ModEnd> ; ++ <S2SV_ModStart> ) { const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , ref_frame ) ; x -> pred_mv_sad [ ref_frame ] = INT_MAX ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; if ( ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) && ( yv12 != NULL ) ) { int_mv * const candidates = x -> mbmi_ext -> ref_mvs [ ref_frame ] ; const struct scale_factors * const sf = & cm -> frame_refs [ ref_frame - 1 ] . sf ; vp9_setup_pred_block ( xd , yv12_mb [ ref_frame ] , yv12 , mi_row , mi_col , sf , sf ) ; if ( cm -> use_prev_frame_mvs ) vp9_find_mv_refs ( cm , xd , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col , NULL , NULL , x -> mbmi_ext -> mode_context ) ; else const_motion [ ref_frame ] = mv_refs_rt ( cm , x , xd , tile_info , xd -> mi [ 0 ] , ref_frame , candidates , mi_row , mi_col ) ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , candidates , & frame_mv [ NEARESTMV ] [ ref_frame ] , & frame_mv [ NEARMV ] [ ref_frame ] ) ; <S2SV_ModStart> ( ! vp9_is_scaled ( sf ) && bsize >= BLOCK_8X8 ) vp9_mv_pred ( cpi , x , yv12_mb [ ref_frame ] [ 0 ] . buf , yv12 -> y_stride , ref_frame , bsize ) ; } else { ref_frame_skip_mask |= ( 1 << ref_frame ) ; } } for ( idx = 0 ; idx < RT_INTER_MODES ; ++ idx ) { int rate_mv = 0 ; int mode_rd_thresh ; int mode_index ; int i ; int64_t this_sse ; int is_skippable ; int this_early_term = 0 ; PREDICTION_MODE this_mode = ref_mode_set [ idx ] . pred_mode ; if ( cpi -> use_svc ) this_mode = ref_mode_set_svc [ idx ] . pred_mode ; if ( ! ( cpi -> sf . inter_mode_mask [ bsize ] & ( 1 << this_mode ) ) ) continue ; ref_frame = ref_mode_set [ idx ] . ref_frame ; if ( cpi -> use_svc ) ref_frame = ref_mode_set_svc [ idx ] . ref_frame ; if ( ! <S2SV_ModStart> continue ; if ( const_motion [ ref_frame ] && this_mode == NEARMV ) continue ; i = <S2SV_ModEnd> ( ref_frame <S2SV_ModStart> LAST_FRAME ) ? GOLDEN_FRAME : LAST_FRAME ; if ( ( cpi -> ref_frame_flags & flag_list [ i ] ) && sf -> reference_masking ) if ( x -> pred_mv_sad [ ref_frame ] > ( x -> pred_mv_sad [ i ] << 1 ) ) ref_frame_skip_mask |= <S2SV_ModEnd> ( 1 <S2SV_ModStart> 1 << ref_frame ) ; if ( ref_frame_skip_mask & ( 1 << ref_frame ) ) continue ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; mbmi -> ref_frame [ 0 ] = ref_frame ; set_ref_ptrs ( cm , xd , ref_frame , NONE ) ; mode_index = mode_idx [ ref_frame ] [ <S2SV_ModStart> this_mode ) ] ; mode_rd_thresh = best_mode_skip_txfm ? <S2SV_ModEnd> rd_threshes [ <S2SV_ModStart> rd_threshes [ mode_index ] << 1 : rd_threshes [ mode_index ] ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , <S2SV_ModEnd> rd_thresh_freq_fact [ <S2SV_ModStart> rd_thresh_freq_fact [ mode_index ] ) <S2SV_ModEnd> ) continue <S2SV_ModStart> ) { if ( ref_frame > LAST_FRAME && ! cpi -> use_svc ) { int tmp_sad ; int dis , cost_list [ 5 ] ; if ( bsize < BLOCK_16X16 ) continue ; tmp_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize , mi_row , mi_col ) ; if ( tmp_sad > x -> pred_mv_sad [ LAST_FRAME ] ) continue ; if ( tmp_sad + ( num_pels_log2_lookup [ bsize ] << 4 ) > best_pred_sad ) continue ; frame_mv [ NEWMV ] [ ref_frame ] . as_int = mbmi -> mv [ 0 ] . as_int ; rate_mv = vp9_mv_bit_cost ( & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . row >>= 3 ; frame_mv [ NEWMV ] [ ref_frame ] . as_mv . col >>= 3 ; cpi -> find_fractional_mv_step ( x , & frame_mv [ NEWMV ] [ ref_frame ] . as_mv , & x -> mbmi_ext -> ref_mvs [ ref_frame ] [ 0 ] . as_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr <S2SV_ModEnd> [ bsize <S2SV_ModStart> bsize ] , cpi -> sf . mv . subpel_force_stop , cpi -> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis , & x -> pred_sse [ ref_frame ] , NULL , 0 , 0 ) ; } else if ( ! combined_motion_search ( cpi , x , bsize , mi_row , mi_col , & frame_mv [ NEWMV ] [ ref_frame ] , & rate_mv , best_rdc . rdcost ) ) { <S2SV_ModEnd> continue ; <S2SV_ModStart> continue ; } } if ( this_mode == NEWMV && ref_frame == LAST_FRAME && frame_mv [ NEWMV ] [ LAST_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ LAST_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ LAST_FRAME ] = best_pred_sad ; } if ( cpi -> use_svc ) { if ( this_mode == NEWMV && ref_frame == GOLDEN_FRAME && <S2SV_ModEnd> frame_mv [ <S2SV_ModStart> ] [ GOLDEN_FRAME ] . as_int != INVALID_MV ) { const int pre_stride = xd -> plane [ 0 ] . pre [ 0 ] . stride ; const uint8_t * const pre_buf = xd -> plane [ 0 ] . pre [ 0 ] . buf + <S2SV_ModEnd> ( frame_mv <S2SV_ModStart> ] [ GOLDEN_FRAME ] . as_mv . row >> 3 ) * pre_stride + ( frame_mv [ NEWMV ] [ GOLDEN_FRAME ] . as_mv . col >> 3 ) ; best_pred_sad = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , pre_buf , pre_stride ) ; x -> pred_mv_sad [ GOLDEN_FRAME ] = best_pred_sad ; } <S2SV_ModEnd> } if <S2SV_ModStart> != NEARESTMV && <S2SV_ModEnd> frame_mv [ <S2SV_ModStart> as_int ; if ( reuse_inter_pred ) { if ( ! this_mode_pred ) { this_mode_pred = & tmp [ 3 ] ; } else { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = bw ; } } <S2SV_ModStart> ) && pred_filter_search && ( ref_frame == LAST_FRAME || ( ref_frame == GOLDEN_FRAME && cpi -> use_svc ) ) && ( <S2SV_ModStart> . row | mbmi -> mv [ 0 ] . as_mv . col ) <S2SV_ModStart> != 0 ) ) { <S2SV_ModEnd> int pf_rate <S2SV_ModStart> ] ; unsigned int pf_var [ 3 ] ; unsigned int pf_sse [ 3 ] ; TX_SIZE pf_tx_size [ 3 ] ; int64_t best_cost = INT64_MAX ; INTERP_FILTER best_filter = SWITCHABLE , filter ; PRED_BUFFER * current_pred = this_mode_pred ; for ( filter = EIGHTTAP ; filter <= EIGHTTAP_SMOOTH ; ++ filter ) { int64_t cost ; <S2SV_ModStart> interp_filter = filter <S2SV_ModEnd> ; vp9_build_inter_predictors_sby <S2SV_ModStart> pf_rate [ filter ] , <S2SV_ModEnd> & pf_dist <S2SV_ModStart> pf_dist [ filter ] , & pf_var [ filter ] , & pf_sse [ filter ] ) ; pf_rate [ filter ] += vp9_get_switchable_rate ( cpi , xd ) ; cost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , <S2SV_ModEnd> pf_rate [ <S2SV_ModStart> pf_rate [ filter ] , <S2SV_ModEnd> pf_dist [ <S2SV_ModStart> pf_dist [ filter ] ) ; pf_tx_size [ filter ] = <S2SV_ModEnd> mbmi -> <S2SV_ModStart> mbmi -> tx_size ; if ( cost < best_cost ) { best_filter = filter ; best_cost = cost ; skip_txfm = x -> skip_txfm [ 0 ] ; if ( reuse_inter_pred ) { if ( this_mode_pred != current_pred ) { free_pred_buffer ( this_mode_pred ) ; this_mode_pred = current_pred ; } if ( filter < EIGHTTAP_SHARP ) { current_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; pd -> dst . buf = current_pred -> data ; pd -> dst . stride = bw ; } } } } if ( reuse_inter_pred && this_mode_pred != current_pred ) free_pred_buffer ( current_pred ) ; mbmi -> <S2SV_ModStart> interp_filter = best_filter ; mbmi -> tx_size = pf_tx_size [ best_filter ] ; this_rdc . rate = <S2SV_ModEnd> pf_rate [ <S2SV_ModStart> pf_rate [ best_filter ] ; this_rdc . dist = <S2SV_ModEnd> pf_dist [ <S2SV_ModStart> pf_dist [ best_filter ] ; var_y = pf_var [ best_filter ] ; sse_y = pf_sse [ best_filter ] ; x -> skip_txfm [ 0 ] = skip_txfm ; if ( reuse_inter_pred ) { pd -> dst . buf = this_mode_pred -> data ; pd -> dst . stride = this_mode_pred -> stride ; } <S2SV_ModEnd> } else <S2SV_ModStart> ) ; if ( bsize > BLOCK_32X32 && ! cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) && cm -> base_qindex ) { model_rd_for_sb_y_large ( cpi , bsize , x , xd , & this_rdc . rate , & this_rdc . dist , & var_y , & sse_y , mi_row , mi_col , & this_early_term ) ; } else { <S2SV_ModStart> , & this_rdc . <S2SV_ModStart> , & this_rdc . dist , & var_y , & sse_y ) ; } } if ( ! this_early_term ) { this_sse = ( int64_t ) sse_y ; block_yrd ( cpi , x , & this_rdc . rate , & this_rdc . dist , & is_skippable , & this_sse , 0 , bsize , MIN ( mbmi -> tx_size , TX_16X16 ) ) ; x -> skip_txfm [ 0 ] = is_skippable ; if ( is_skippable ) { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } else { if ( RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , this_sse ) ) { this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { this_rdc . rate = vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; this_rdc . dist = this_sse ; x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } } if ( cm -> interp_filter == SWITCHABLE ) { if ( ( mbmi -> mv [ 0 ] . as_mv . row | mbmi -> mv [ 0 ] . as_mv . col ) & 0x07 ) this_rdc . rate += vp9_get_switchable_rate ( cpi , xd ) ; } } else { this_rdc . rate += cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( cpi , xd ) : 0 ; this_rdc . rate += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; } if ( x -> color_sensitivity [ 0 ] || x -> color_sensitivity [ 1 ] ) { int uv_rate = 0 ; int64_t uv_dist = 0 ; if ( x -> color_sensitivity [ 0 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 1 ) ; if ( x -> color_sensitivity [ 1 ] ) vp9_build_inter_predictors_sbp ( xd , mi_row , mi_col , bsize , 2 ) ; model_rd_for_sb_uv ( cpi , bsize , x , xd , & uv_rate , & uv_dist , & var_y , & sse_y ) ; this_rdc . rate += uv_rate ; this_rdc . dist += uv_dist ; } this_rdc . <S2SV_ModEnd> rate += <S2SV_ModStart> rate_mv ; this_rdc . <S2SV_ModStart> rate += cpi <S2SV_ModEnd> -> inter_mode_cost <S2SV_ModStart> inter_mode_cost [ x -> mbmi_ext -> mode_context [ ref_frame ] ] [ INTER_OFFSET ( this_mode ) ] ; this_rdc . rate += ref_frame_cost [ ref_frame ] ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; if ( cpi -> allow_encode_breakout ) { encode_breakout_test ( cpi , x , bsize , mi_row , mi_col , ref_frame , this_mode , var_y , sse_y , yv12_mb , & this_rdc . rate , & this_rdc . dist ) ; if ( x -> skip ) { this_rdc . rate += rate_mv ; this_rdc . rdcost = RDCOST ( x -> rdmult , x -> rddiv , this_rdc . rate , this_rdc . dist ) ; } } # if CONFIG_VP9_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 ) vp9_denoiser_update_frame_stats ( mbmi , sse_y , this_mode , ctx ) ; # else ( void ) ctx ; # endif if ( this_rdc . rdcost < best_rdc . rdcost || x -> skip ) { best_rdc = this_rdc <S2SV_ModEnd> ; best_mode <S2SV_ModStart> interp_filter ; best_tx_size = mbmi -> tx_size ; <S2SV_ModStart> ref_frame ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; best_early_term = this_early_term ; if ( reuse_inter_pred ) { free_pred_buffer ( best_pred ) ; best_pred = this_mode_pred ; } } else { if ( reuse_inter_pred ) free_pred_buffer ( this_mode_pred ) ; } if ( x -> skip ) break ; if ( best_early_term && idx > 0 ) { x -> skip = 1 ; break ; <S2SV_ModEnd> } } <S2SV_ModStart> mbmi -> tx_size = best_tx_size ; mbmi -> <S2SV_ModStart> as_int ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( best_rdc . rdcost == INT64_MAX || ( ! x -> skip && best_rdc . rdcost <S2SV_ModEnd> > inter_mode_thresh <S2SV_ModStart> > inter_mode_thresh && bsize <= cpi -> sf . max_intra_bsize ) ) { struct estimate_block_intra_args args = { cpi , x , DC_PRED , 0 , 0 } ; const TX_SIZE intra_tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; int i ; TX_SIZE best_intra_tx_size = TX_SIZES ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data == orig_dst . buf ) { this_mode_pred = & tmp [ get_pred_buffer ( tmp , 3 ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , this_mode_pred -> data , this_mode_pred -> stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif best_pred = this_mode_pred ; } } pd -> dst = orig_dst ; <S2SV_ModEnd> for ( <S2SV_ModStart> for ( i = 0 ; i < 4 ; ++ i ) { const PREDICTION_MODE <S2SV_ModStart> this_mode = intra_mode_list [ i ] ; THR_MODES mode_index = mode_idx [ INTRA_FRAME ] [ mode_offset ( this_mode ) ] ; int mode_rd_thresh = rd_threshes [ mode_index ] ; if ( ! ( ( 1 << <S2SV_ModEnd> this_mode ) <S2SV_ModStart> this_mode ) & cpi -> sf . intra_y_mode_bsize_mask [ bsize ] ) ) continue ; if ( rd_less_than_thresh ( best_rdc . rdcost , mode_rd_thresh , rd_thresh_freq_fact [ mode_index ] ) ) continue ; mbmi -> mode = this_mode ; mbmi -> ref_frame [ 0 ] = INTRA_FRAME ; args . mode = this_mode ; args . rate = 0 ; args . dist = 0 ; mbmi -> tx_size = intra_tx_size ; vp9_foreach_transformed_block_in_plane <S2SV_ModEnd> ( xd <S2SV_ModStart> xd , bsize , 0 , estimate_block_intra , & args ) ; this_rdc . rate = args . rate ; this_rdc . dist = args . dist ; this_rdc . <S2SV_ModEnd> rate += <S2SV_ModStart> rate += cpi <S2SV_ModEnd> -> mbmode_cost <S2SV_ModStart> ] ; this_rdc . rate += ref_frame_cost [ INTRA_FRAME ] ; this_rdc . <S2SV_ModStart> intra_cost_penalty ; this_rdc . rdcost <S2SV_ModEnd> = RDCOST <S2SV_ModStart> rddiv , this_rdc . <S2SV_ModStart> rate , this_rdc . <S2SV_ModStart> if ( this_rdc . rdcost < best_rdc . rdcost ) { best_rdc = this_rdc ; best_mode = this_mode ; best_intra_tx_size = mbmi -> tx_size ; best_ref_frame = INTRA_FRAME ; mbmi -> uv_mode = this_mode ; mbmi -> mv [ 0 ] . as_int = INVALID_MV ; best_mode_skip_txfm = x -> skip_txfm [ 0 ] ; } } if ( best_ref_frame != INTRA_FRAME ) { mbmi -> tx_size = best_tx_size ; } else { mbmi -> tx_size = best_intra_tx_size ; } } pd -> dst = orig_dst ; mbmi -> mode = best_mode ; mbmi -> ref_frame [ 0 ] = best_ref_frame ; x -> skip_txfm [ 0 ] = best_mode_skip_txfm ; if ( reuse_inter_pred && best_pred != NULL ) { if ( best_pred -> data != orig_dst . buf && is_inter_mode ( mbmi -> mode ) ) { # if CONFIG_VP9_HIGHBITDEPTH if ( cm -> use_highbitdepth ) vpx_highbd_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh , xd -> bd ) ; else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # else vpx_convolve_copy ( best_pred -> data , best_pred -> stride , pd -> dst . buf , pd -> dst . stride , NULL , 0 , NULL , 0 , bw , bh ) ; # endif } } if ( cpi -> sf . adaptive_rd_thresh ) { THR_MODES best_mode_idx = mode_idx [ best_ref_frame ] [ mode_offset ( mbmi -> mode ) ] ; if ( best_ref_frame == INTRA_FRAME ) { int intra_modes = sizeof ( intra_mode_list ) / sizeof ( PREDICTION_MODE ) ; int i ; for ( i = 0 ; i < intra_modes ; i ++ ) { update_thresh_freq_fact ( cpi , tile_data , bsize , INTRA_FRAME , best_mode_idx , intra_mode_list [ i ] ) ; } } else { for ( ref_frame = LAST_FRAME ; ref_frame <= GOLDEN_FRAME ; ++ ref_frame ) { PREDICTION_MODE this_mode ; if ( best_ref_frame != ref_frame ) continue ; for ( this_mode = NEARESTMV ; this_mode <= NEWMV ; ++ this_mode ) { update_thresh_freq_fact ( cpi , tile_data , bsize , ref_frame , best_mode_idx , this_mode ) ; } } } } * rd_cost = best_rdc <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { <S2SV_ModEnd> vp9_init_plane_quantizers ( <S2SV_ModStart> cpi -> td .
<S2SV_ModStart> ) ; int <S2SV_ModEnd> i ; <S2SV_ModStart> ] . quant_fp = quants -> y_quant_fp [ qindex ] ; x -> plane [ 0 ] . round_fp = quants -> y_round_fp [ qindex ] ; x -> plane [ 0 ] . <S2SV_ModStart> ] ; xd -> plane [ 0 ] . dequant = cpi <S2SV_ModEnd> -> y_dequant <S2SV_ModStart> qindex ] ; x -> plane [ 0 ] . quant_thred [ 0 ] = x -> plane [ 0 ] . zbin [ 0 ] * x -> plane [ 0 ] . zbin [ 0 ] ; x -> plane [ 0 ] . quant_thred [ 1 ] = x -> plane [ 0 ] . zbin [ 1 ] * x -> plane [ 0 ] . zbin [ 1 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] . quant_fp = quants -> uv_quant_fp [ qindex ] ; x -> plane [ i ] . round_fp = quants -> uv_round_fp [ qindex ] ; x -> plane [ i ] . <S2SV_ModStart> ] ; xd -> plane [ i ] . dequant = cpi <S2SV_ModEnd> -> uv_dequant <S2SV_ModStart> qindex ] ; x -> plane [ i ] . quant_thred [ 0 ] = x -> plane [ i ] . zbin [ 0 ] * x -> plane [ i ] . zbin [ 0 ] ; x -> plane [ i ] . quant_thred [ 1 ] = x -> plane [ i ] . zbin [ 1 ] * x -> plane [ i ] . zbin [ 1 <S2SV_ModEnd> ] ; <S2SV_ModStart> ; } <S2SV_ModEnd> x -> <S2SV_ModStart> skip_block = segfeature_active <S2SV_ModEnd> ( & <S2SV_ModStart> , x , x
<S2SV_ModStart> qzbin_factor = get_qzbin_factor ( q , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { int qrounding_factor_fp = i == 0 ? 48 : 42 ; if ( q == 0 ) qrounding_factor_fp = 64 ; <S2SV_ModStart> -> y_dc_delta_q , cm -> bit_depth <S2SV_ModStart> , 0 , cm -> bit_depth <S2SV_ModStart> quants -> y_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> y_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant <S2SV_ModStart> 7 ; quants -> y_zbin [ q ] [ i ] = ROUND_POWER_OF_TWO ( qzbin_factor * quant , 7 ) ; quants -> y_round [ q ] [ i ] = ( qrounding_factor * quant ) >> 7 ; cpi <S2SV_ModEnd> -> y_dequant <S2SV_ModStart> -> uv_dc_delta_q , cm -> bit_depth <S2SV_ModStart> -> uv_ac_delta_q , cm -> bit_depth <S2SV_ModStart> quants -> uv_quant_fp [ q ] [ i ] = ( 1 << 16 ) / quant ; quants -> uv_round_fp [ q ] [ i ] = ( qrounding_factor_fp <S2SV_ModEnd> * quant <S2SV_ModStart> 7 ; quants -> uv_zbin <S2SV_ModEnd> [ q <S2SV_ModStart> quants -> uv_round <S2SV_ModEnd> [ q <S2SV_ModStart> 7 ; cpi -> uv_dequant [ q ] [ i ] = quant ; <S2SV_ModEnd> } for <S2SV_ModStart> quants -> y_quant_fp [ q ] [ i ] = quants -> y_quant_fp [ q ] [ 1 ] ; quants -> y_round_fp [ q ] [ i ] = quants -> y_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> ] ; cpi <S2SV_ModEnd> -> y_dequant <S2SV_ModStart> ] = cpi <S2SV_ModEnd> -> y_dequant <S2SV_ModStart> quants -> uv_quant_fp [ q ] [ i ] = quants -> uv_quant_fp [ q ] [ 1 ] ; quants -> uv_round_fp [ q ] [ i ] = quants -> uv_round_fp [ q ] [ 1 ] ; quants -> <S2SV_ModStart> ] ; cpi <S2SV_ModEnd> -> uv_dequant <S2SV_ModStart> ] = cpi <S2SV_ModEnd> -> uv_dequant <S2SV_ModStart> ] ; <S2SV_ModEnd> } }
<S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_quantize_b <S2SV_ModEnd> ( BLOCK_OFFSET <S2SV_ModStart> dequant , & p -> eobs [ block ] , scan , iscan ) ; return ; } # endif vpx_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant <S2SV_ModEnd> , &
<S2SV_ModStart> ; const RATE_CONTROL * rc <S2SV_ModEnd> = & <S2SV_ModStart> cpi -> <S2SV_ModEnd> rc ; <S2SV_ModStart> critical_level = rc <S2SV_ModEnd> -> optimal_buffer_level <S2SV_ModStart> optimal_buffer_level >> 3 <S2SV_ModEnd> ; int64_t <S2SV_ModStart> int active_worst_quality ; int ambient_qp ; unsigned int num_frames_weight_key = 5 * cpi -> svc . number_temporal_layers <S2SV_ModStart> worst_quality ; ambient_qp = <S2SV_ModEnd> ( cm <S2SV_ModStart> -> current_video_frame < num_frames_weight_key ) ? <S2SV_ModEnd> MIN ( <S2SV_ModStart> MIN ( <S2SV_ModEnd> rc -> <S2SV_ModStart> INTER_FRAME ] <S2SV_ModEnd> , rc <S2SV_ModStart> KEY_FRAME ] ) : <S2SV_ModEnd> rc -> <S2SV_ModStart> INTER_FRAME ] ; active_worst_quality = MIN ( rc -> worst_quality , ambient_qp * 5 / 4 ) ; if ( <S2SV_ModEnd> rc -> <S2SV_ModStart> -> buffer_level > rc -> optimal_buffer_level ) { int max_adjustment_down = active_worst_quality / 3 ; if ( max_adjustment_down ) { buff_lvl_step = ( ( rc -> maximum_buffer_size - rc -> optimal_buffer_level ) / max_adjustment_down ) ; if ( buff_lvl_step ) adjustment = ( int ) ( ( rc -> buffer_level - rc -> optimal_buffer_level ) / buff_lvl_step ) ; active_worst_quality -= adjustment ; } } else if ( rc -> buffer_level > critical_level ) { if ( critical_level ) { buff_lvl_step = ( rc -> optimal_buffer_level - critical_level ) ; if ( buff_lvl_step ) { adjustment = ( int ) ( ( rc -> worst_quality - ambient_qp ) * ( rc -> optimal_buffer_level - rc -> buffer_level ) / buff_lvl_step ) ; } active_worst_quality = ambient_qp <S2SV_ModEnd> + adjustment
<S2SV_ModStart> -> rc ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const SVC * const svc = & cpi -> svc <S2SV_ModStart> ( ( rc -> <S2SV_ModEnd> starting_buffer_level / <S2SV_ModStart> ) ( rc -> starting_buffer_level / 2 ) ; } else { int kf_boost = 32 ; double framerate = cpi -> framerate ; if ( svc -> number_temporal_layers > 1 && oxcf -> rc_mode == VPX_CBR ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , svc -> number_temporal_layers ) ; const LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; framerate = lc -> framerate ; } <S2SV_ModEnd> kf_boost = <S2SV_ModStart> MAX ( kf_boost , ( int ) ( 2 * framerate <S2SV_ModEnd> - 16 <S2SV_ModStart> frames_since_key < framerate <S2SV_ModEnd> / 2 <S2SV_ModStart> / ( framerate <S2SV_ModEnd> / 2 <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> ) >>
<S2SV_ModStart> rc ; const <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> * kf_ratio
<S2SV_ModStart> { const VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> diff = rc <S2SV_ModEnd> -> optimal_buffer_level <S2SV_ModStart> 1 + rc <S2SV_ModEnd> -> optimal_buffer_level <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> >> 4 <S2SV_ModStart> int target ; if ( oxcf -> gf_cbr_boost_pct ) { const int af_ratio_pct = oxcf -> gf_cbr_boost_pct + 100 ; target = cpi -> refresh_golden_frame ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio_pct ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * 100 ) / ( rc -> baseline_gf_interval * 100 + af_ratio_pct - 100 ) ; } else { target = rc -> avg_frame_bandwidth ; } if ( is_one_pass_cbr_svc ( cpi ) ) { int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , svc -> temporal_layer_id , <S2SV_ModEnd> svc -> <S2SV_ModStart> -> number_temporal_layers ) <S2SV_ModEnd> ; const <S2SV_ModStart> layer_context [ layer <S2SV_ModEnd> ] ; <S2SV_ModStart> ; } if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; }
<S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> * rc <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> ; #
<S2SV_ModStart> double x1 , vpx_bit_depth_t bit_depth <S2SV_ModStart> ++ ) { <S2SV_ModStart> ( i , bit_depth <S2SV_ModStart> i ; }
<S2SV_ModStart> ) { const RATE_CONTROL * const rc = & cpi -> rc ; double rcf ; <S2SV_ModStart> ) { rcf = rc -> rate_correction_factors [ KF_STD ] ; } else if ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rcf = rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> ; } <S2SV_ModStart> && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && <S2SV_ModStart> && ! <S2SV_ModEnd> cpi -> <S2SV_ModStart> use_svc && ( <S2SV_ModStart> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ) rcf = rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> ; else <S2SV_ModStart> ; else rcf = rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> ; } <S2SV_ModStart> ; } rcf *= rcf_mult [ rc -> frame_size_selector ] ; return fclamp ( rcf , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ;
<S2SV_ModStart> q ; int * rtc_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , rtc_minq ) ; <S2SV_ModStart> ( qindex , cm -> bit_depth <S2SV_ModStart> 0.75 ) , cm -> bit_depth <S2SV_ModStart> active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> <S2SV_ModStart> ] , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> ( active_best_quality , cm -> bit_depth <S2SV_ModStart> * q_adj_factor , cm -> bit_depth <S2SV_ModStart> active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> active_best_quality = rtc_minq <S2SV_ModEnd> [ rc <S2SV_ModStart> active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality <S2SV_ModStart> active_best_quality = rtc_minq <S2SV_ModEnd> [ rc <S2SV_ModStart> active_best_quality = rtc_minq <S2SV_ModEnd> [ active_worst_quality <S2SV_ModStart> -> this_key_frame_forced && <S2SV_ModEnd> ! ( <S2SV_ModStart> ) ) { int qdelta = 0 ; vpx_clear_system_state ( ) ; qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; * top_index = <S2SV_ModEnd> active_worst_quality + <S2SV_ModStart> active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; }
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> oxcf ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ( qindex , cm -> bit_depth <S2SV_ModStart> * 0.75 , cm -> bit_depth <S2SV_ModStart> } else <S2SV_ModEnd> { double <S2SV_ModStart> active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> <S2SV_ModStart> ] , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> ( active_best_quality , cm -> bit_depth <S2SV_ModStart> * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else <S2SV_ModStart> oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { <S2SV_ModStart> q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = <S2SV_ModStart> oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { <S2SV_ModStart> active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } <S2SV_ModStart> oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && <S2SV_ModStart> active_best_quality < cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> ; } <S2SV_ModStart> if LIMIT_QRANGE_FOR_ALTREF_AND_KEY { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> -> this_key_frame_forced && <S2SV_ModEnd> ! ( <S2SV_ModStart> ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = <S2SV_ModEnd> active_worst_quality + <S2SV_ModStart> active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } <S2SV_ModStart> oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { <S2SV_ModStart> } } <S2SV_ModEnd> assert (
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> oxcf ; const GF_GROUP * gf_group = & cpi -> twopass . gf_group ; const int cq_level = get_active_cq_level ( rc , oxcf ) <S2SV_ModEnd> ; int <S2SV_ModStart> ; int active_best_quality <S2SV_ModEnd> ; int <S2SV_ModStart> ; int active_worst_quality = cpi -> twopass . active_worst_quality ; int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) <S2SV_ModEnd> ; if <S2SV_ModStart> cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ) { double last_boosted_q ; int delta_qindex ; <S2SV_ModStart> int qindex ; if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { qindex = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> <S2SV_ModStart> -> last_boosted_qindex ) ; active_best_quality = qindex ; <S2SV_ModEnd> last_boosted_q = <S2SV_ModStart> ( qindex , cm -> bit_depth ) ; <S2SV_ModEnd> delta_qindex = <S2SV_ModStart> last_boosted_q * 1.25 , cm -> bit_depth ) ; active_worst_quality = MIN <S2SV_ModEnd> ( qindex <S2SV_ModStart> delta_qindex , active_worst_quality ) ; } else { qindex = rc -> last_boosted_qindex ; last_boosted_q = vp9_convert_qindex_to_q ( qindex , cm -> bit_depth ) ; delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , last_boosted_q * 0.75 , cm -> bit_depth ) ; active_best_quality = MAX ( qindex + delta_qindex , <S2SV_ModStart> ) ; } <S2SV_ModStart> active_best_quality = get_kf_active_quality ( rc , active_worst_quality , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> ( active_best_quality , cm -> bit_depth <S2SV_ModStart> * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else <S2SV_ModStart> oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { <S2SV_ModStart> q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = <S2SV_ModStart> oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { <S2SV_ModStart> active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; if ( gf_group -> rf_level [ gf_group -> index ] == GF_ARF_LOW ) active_best_quality = ( active_best_quality + cq_level + <S2SV_ModEnd> 1 ) <S2SV_ModStart> 1 ) / 2 ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } <S2SV_ModStart> oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && <S2SV_ModStart> active_best_quality < cq_level ) ) { active_best_quality = cq_level ; } } } if ( ( cpi -> oxcf . rc_mode != VPX_Q ) && ( cpi -> twopass . gf_zeromotion_pct < VLOW_MOTION_THRESHOLD ) ) { if ( frame_is_intra_only ( cm ) || ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ) { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) ; active_worst_quality += ( cpi -> twopass . extend_maxq / 2 ) ; } else { active_best_quality -= ( cpi -> twopass . extend_minq + cpi -> twopass . extend_minq_fast ) / 2 ; active_worst_quality += cpi -> twopass . extend_maxq ; } } <S2SV_ModEnd> # if <S2SV_ModStart> if LIMIT_QRANGE_FOR_ALTREF_AND_KEY vpx_clear_system_state ( ) ; if ( ! ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) ) || ! rc -> this_key_frame_forced || ( cpi -> twopass . last_kfgroup_zeromotion_pct < STATIC_MOTION_THRESH ) ) { int qdelta = vp9_frame_type_qdelta ( cpi , gf_group -> rf_level [ gf_group -> index ] , active_worst_quality ) ; active_worst_quality = MAX ( active_worst_quality + qdelta , active_best_quality ) ; } # endif if ( rc -> frame_size_selector != UNSCALED <S2SV_ModEnd> && ! <S2SV_ModStart> && ! frame_is_kf_gf_arf ( cpi ) ) { int qdelta = vp9_compute_qdelta_by_rate ( rc , cm -> frame_type , active_best_quality , 2.0 , cm -> bit_depth ) ; active_best_quality = MAX ( active_best_quality + qdelta , rc -> best_quality ) ; } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; if ( oxcf -> rc_mode == VPX_Q ) { q = active_best_quality ; } else if ( ( frame_is_intra_only ( cm ) || vp9_is_upper_layer_key_frame ( cpi ) ) && <S2SV_ModStart> ) { if ( cpi -> twopass . last_kfgroup_zeromotion_pct >= STATIC_MOTION_THRESH ) { q = MIN ( rc -> last_kf_qindex , <S2SV_ModEnd> rc -> <S2SV_ModStart> -> last_boosted_qindex ) ; } else { q = rc -> last_boosted_qindex ; } <S2SV_ModEnd> } else <S2SV_ModStart> q > active_worst_quality <S2SV_ModEnd> ) { <S2SV_ModStart> max_frame_bandwidth ) active_worst_quality = q ; else q = active_worst_quality ; } } clamp ( q , active_best_quality , active_worst_quality ) ; <S2SV_ModStart> top_index = active_worst_quality <S2SV_ModEnd> ; * <S2SV_ModStart> bottom_index = active_best_quality ; <S2SV_ModEnd> assert (
<S2SV_ModStart> ) { RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> ) { rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( <S2SV_ModStart> cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> = factor <S2SV_ModStart> && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && <S2SV_ModStart> && ! <S2SV_ModEnd> cpi -> <S2SV_ModStart> use_svc && ( <S2SV_ModStart> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ) rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> = factor <S2SV_ModStart> ; else rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> = factor
<S2SV_ModStart> 0 ; <S2SV_ModEnd> rc ->
<S2SV_ModStart> -> common <S2SV_ModEnd> ; RATE_CONTROL <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> - encoded_frame_size <S2SV_ModStart> bits_off_target , rc <S2SV_ModEnd> -> maximum_buffer_size <S2SV_ModStart> if ( is_one_pass_cbr_svc ( cpi ) <S2SV_ModEnd> ) {
<S2SV_ModStart> source_alt_ref_pending ) { <S2SV_ModStart> 0 ; }
<S2SV_ModStart> { int i <S2SV_ModEnd> = 0 <S2SV_ModStart> for ( i <S2SV_ModEnd> = current_temporal_layer <S2SV_ModStart> 1 ; i <S2SV_ModEnd> < svc <S2SV_ModStart> ; ++ i <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; <S2SV_ModStart> layer_context [ layer <S2SV_ModEnd> ] ; <S2SV_ModStart> bits_off_target , lrc <S2SV_ModEnd> -> maximum_buffer_size
<S2SV_ModStart> double qtarget , vpx_bit_depth_t bit_depth <S2SV_ModStart> ( i , bit_depth <S2SV_ModStart> ( i , bit_depth
<S2SV_ModStart> double rate_target_ratio , vpx_bit_depth_t bit_depth <S2SV_ModStart> , 1.0 , bit_depth <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> , 1.0 , bit_depth <S2SV_ModStart> target_bits_per_mb ) { target_index = i ; <S2SV_ModStart> break ; }
<S2SV_ModStart> int qindex , vpx_bit_depth_t bit_depth <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModStart> , 0 , bit_depth <S2SV_ModStart> 4.0 ; case VPX_BITS_10 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 16.0 ; case VPX_BITS_12 : return vp9_ac_quant ( qindex , 0 , bit_depth ) / 64.0 ; default : assert ( 0 && "bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12" ) ; return - 1.0 ; } # else return vp9_ac_quant ( qindex , 0 , bit_depth ) / 4.0 ; # endif
<S2SV_ModStart> double correction_factor , vpx_bit_depth_t bit_depth <S2SV_ModStart> ( qindex , bit_depth <S2SV_ModStart> KEY_FRAME ? 2700000 : 1800000 ; assert ( correction_factor <= MAX_BPB_FACTOR && correction_factor >= MIN_BPB_FACTOR ) <S2SV_ModEnd> ; enumerator <S2SV_ModStart> ) ( <S2SV_ModEnd> enumerator * <S2SV_ModStart> q ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf
<S2SV_ModStart> ; const VP9EncoderConfig * oxcf = & cpi -> oxcf ; const <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> >> 5 <S2SV_ModStart> max_frame_bandwidth ; if ( oxcf -> rc_max_inter_bitrate_pct ) { const int max_rate = rc -> avg_frame_bandwidth * oxcf -> rc_max_inter_bitrate_pct / 100 ; target = MIN ( target , max_rate ) ; }
<S2SV_ModStart> , int frame_target <S2SV_ModEnd> , int <S2SV_ModStart> oxcf . rc_mode == VPX_Q <S2SV_ModEnd> ) { <S2SV_ModStart> else { const int tolerance <S2SV_ModEnd> = ( <S2SV_ModStart> recode_tolerance * frame_target <S2SV_ModEnd> ) / <S2SV_ModStart> ; * <S2SV_ModEnd> frame_under_shoot_limit = <S2SV_ModStart> frame_under_shoot_limit = MAX ( frame_target - tolerance - 200 , 0 ) <S2SV_ModEnd> ; * <S2SV_ModStart> * frame_over_shoot_limit = MIN ( frame_target + tolerance + 200 , <S2SV_ModEnd> cpi -> <S2SV_ModStart> max_frame_bandwidth ) <S2SV_ModEnd> ; } <S2SV_ModStart> } } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { const VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> drop_frames_water_mark * rc <S2SV_ModEnd> -> optimal_buffer_level
<S2SV_ModStart> || ( cpi <S2SV_ModEnd> -> frame_flags <S2SV_ModStart> auto_key && 0 <S2SV_ModEnd> ) ) <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc <S2SV_ModStart> = 0 <S2SV_ModEnd> ; } <S2SV_ModStart> INTER_FRAME ; } if ( rc -> frames_till_gf_update_due == 0 ) { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_set_golden_update ( cpi ) ; else rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 ; rc -> frames_till_gf_update_due = rc -> baseline_gf_interval ; if ( rc -> frames_till_gf_update_due > rc -> frames_to_key ) rc -> frames_till_gf_update_due = rc -> frames_to_key ; cpi -> refresh_golden_frame = 1 ; rc -> gfu_boost = DEFAULT_GF_BOOST ; } if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; if ( cm -> frame_type == KEY_FRAME ) <S2SV_ModStart> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; else target = <S2SV_ModStart> ) ; <S2SV_ModEnd> vp9_rc_set_frame_target ( <S2SV_ModStart> ) ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC ) cpi -> resize_pending = vp9_resize_one_pass_cbr ( cpi ) ; else cpi -> resize_pending = 0 <S2SV_ModEnd> ; }
<S2SV_ModStart> || ( cpi <S2SV_ModEnd> -> frame_flags <S2SV_ModStart> auto_key && 0 <S2SV_ModEnd> ) ) <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> ; rc <S2SV_ModStart> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval ) / 2 <S2SV_ModEnd> ; rc <S2SV_ModStart> frames_to_key ) { rc -> frames_till_gf_update_due = rc -> frames_to_key ; rc -> constrained_gf_group = 1 ; } else { rc -> constrained_gf_group = 0 ; } <S2SV_ModEnd> cpi ->
<S2SV_ModStart> rc -> avg_frame_bandwidth ; const int layer = LAYER_IDS_TO_IDX ( cpi -> svc . spatial_layer_id , cpi -> svc . temporal_layer_id , cpi -> svc . number_temporal_layers ) <S2SV_ModEnd> ; if <S2SV_ModStart> || ( cpi <S2SV_ModEnd> -> frame_flags <S2SV_ModStart> cpi -> oxcf . key_freq <S2SV_ModEnd> == 0 <S2SV_ModStart> if ( is_two_pass_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { cpi -> svc . layer_context [ layer ] . is_key_frame = 1 ; reset_temporal_layer_to_zero ( cpi ) ; cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG & ~ VP9_GOLD_FLAG & ~ VP9_ALT_FLAG ) ; target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } } else { cm -> frame_type = INTER_FRAME ; if ( is_two_pass_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id <S2SV_ModEnd> == 0 <S2SV_ModStart> == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; if ( lc -> is_key_frame ) cpi -> ref_frame_flags &= ( ~ VP9_LAST_FLAG ) ; } cpi -> ref_frame_flags &= ( ~ VP9_ALT_FLAG ) ; } else if ( is_one_pass_cbr_svc ( cpi ) ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; if ( cpi -> svc . spatial_layer_id == 0 ) { lc -> is_key_frame = 0 ; } else { lc -> is_key_frame = cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ; } target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; } } if ( <S2SV_ModEnd> cpi -> <S2SV_ModStart> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) vp9_cyclic_refresh_update_parameters ( cpi ) ; <S2SV_ModEnd> vp9_rc_set_frame_target (
<S2SV_ModStart> ( const VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> ) { int i ; <S2SV_ModStart> oxcf -> rc_mode == VPX_CBR <S2SV_ModEnd> ) { <S2SV_ModStart> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = <S2SV_ModStart> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = <S2SV_ModStart> 2 ; } rc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; rc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; rc -> buffer_level = rc -> starting_buffer_level ; rc -> bits_off_target = rc -> starting_buffer_level ; rc -> rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q , oxcf -> bit_depth ) ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { rc -> rate_correction_factors [ i ] = 1.0 ; } rc -> min_gf_interval = oxcf -> min_gf_interval ; rc -> max_gf_interval = oxcf -> max_gf_interval ; if ( rc -> min_gf_interval == 0 ) rc -> min_gf_interval = vp9_rc_get_default_min_gf_interval ( oxcf -> width , oxcf -> height , oxcf -> init_framerate ) ; if ( rc -> max_gf_interval == 0 ) rc -> max_gf_interval = vp9_rc_get_default_max_gf_interval ( oxcf -> init_framerate , rc -> min_gf_interval ) ; rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval <S2SV_ModEnd> ) / <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vp9_rc_init_minq_luts ( void <S2SV_ModStart> ) { init_minq_luts ( kf_low_motion_minq_8 , kf_high_motion_minq_8 , arfgf_low_motion_minq_8 , arfgf_high_motion_minq_8 , inter_minq_8 , rtc_minq_8 , VPX_BITS_8 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH init_minq_luts ( kf_low_motion_minq_10 , kf_high_motion_minq_10 , arfgf_low_motion_minq_10 , arfgf_high_motion_minq_10 , inter_minq_10 , rtc_minq_10 , VPX_BITS_10 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; init_minq_luts ( kf_low_motion_minq_12 , kf_high_motion_minq_12 , arfgf_low_motion_minq_12 , arfgf_high_motion_minq_12 , inter_minq_12 , rtc_minq_12 , VPX_BITS_12 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; # endif <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> cpi -> oxcf . <S2SV_ModStart> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) q <S2SV_ModStart> if ( <S2SV_ModEnd> cpi ->
<S2SV_ModStart> ) { const <S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> rc ; const int qindex = cm -> base_qindex ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { vp9_cyclic_refresh_postencode ( cpi ) ; } <S2SV_ModEnd> rc -> <S2SV_ModStart> vp9_rc_update_rate_correction_factors ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> ] = qindex <S2SV_ModEnd> ; rc <S2SV_ModStart> ] + qindex <S2SV_ModEnd> , 2 <S2SV_ModStart> ) ; if ( cpi -> use_svc ) { int i = 0 ; SVC * svc = & cpi -> svc ; for ( i = 0 ; i < svc -> number_temporal_layers ; ++ i ) { const int layer = LAYER_IDS_TO_IDX ( svc -> spatial_layer_id , i , svc -> number_temporal_layers ) ; LAYER_CONTEXT * lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * lrc = & lc -> rc ; lrc -> last_q [ KEY_FRAME ] = rc -> last_q [ KEY_FRAME ] ; lrc -> avg_frame_qindex [ KEY_FRAME ] = rc -> avg_frame_qindex [ KEY_FRAME ] ; } } <S2SV_ModStart> } else { if ( rc -> is_src_frame_alt_ref || ! <S2SV_ModEnd> ( cpi <S2SV_ModStart> refresh_alt_ref_frame ) || <S2SV_ModEnd> ( cpi <S2SV_ModStart> oxcf -> rc_mode == VPX_CBR <S2SV_ModEnd> ) ) <S2SV_ModStart> last_q [ INTER_FRAME ] = qindex <S2SV_ModEnd> ; rc <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME ] = <S2SV_ModEnd> ROUND_POWER_OF_TWO ( <S2SV_ModStart> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] + <S2SV_ModStart> ] + qindex <S2SV_ModEnd> , 2 <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModEnd> ) ; <S2SV_ModStart> tot_q / <S2SV_ModEnd> rc -> <S2SV_ModStart> ni_tot_qi += qindex <S2SV_ModEnd> ; rc <S2SV_ModStart> ; } } if ( ( qindex <S2SV_ModEnd> < rc <S2SV_ModStart> ) || <S2SV_ModEnd> ( cm <S2SV_ModStart> ) || ( ! rc -> constrained_gf_group && ( <S2SV_ModStart> last_boosted_qindex = qindex ; } if ( cm -> frame_type == KEY_FRAME ) rc -> last_kf_qindex = qindex ; <S2SV_ModEnd> update_buffer_level ( <S2SV_ModStart> total_target_bits += <S2SV_ModEnd> cm -> <S2SV_ModStart> rc -> avg_frame_bandwidth <S2SV_ModEnd> : 0 <S2SV_ModStart> : 0 <S2SV_ModEnd> ; rc <S2SV_ModStart> if ( ! cpi -> use_svc ) { if ( is_altref_enabled ( cpi ) <S2SV_ModEnd> && cpi <S2SV_ModStart> ) ; } <S2SV_ModStart> ; } if ( oxcf -> pass != 0 ) { cpi -> resize_pending = rc -> next_frame_size_selector != rc -> frame_size_selector ; rc -> frame_size_selector = rc -> next_frame_size_selector ; }
<S2SV_ModStart> cpi -> <S2SV_ModEnd> rc . <S2SV_ModStart> -- ; cpi -> rc . rc_2_frame = 0 ; cpi -> rc . rc_1_frame = 0 ;
<S2SV_ModStart> , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = <S2SV_ModStart> , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
<S2SV_ModStart> target ; if ( cpi -> oxcf . resize_mode == RESIZE_DYNAMIC && rc -> frame_size_selector != UNSCALED ) rc -> this_frame_target = ( int ) ( rc -> this_frame_target * rate_thresh_mult [ rc -> frame_size_selector ] ) ;
<S2SV_ModStart> * cpi <S2SV_ModEnd> ) { <S2SV_ModStart> 0 ; if ( cpi -> rc . is_src_frame_alt_ref ) return ; vpx_clear_system_state ( ) ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cpi -> common . seg . enabled ) { projected_size_based_on_q = vp9_cyclic_refresh_estimate_bits_at_q ( cpi , rate_correction_factor ) ; } else { projected_size_based_on_q = vp9_estimate_bits_at_q ( cpi -> common . <S2SV_ModEnd> frame_type , <S2SV_ModStart> , rate_correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> projected_size_based_on_q > FRAME_OVERHEAD_BITS ) correction_factor = ( int ) ( ( 100 * ( int64_t ) cpi -> rc . projected_frame_size ) / projected_size_based_on_q ) ; adjustment_limit = 0.25 + 0.5 * MIN ( 1 , fabs ( log10 ( 0.01 * correction_factor ) ) ) ; cpi -> rc . q_2_frame = cpi -> rc . q_1_frame ; cpi -> rc . q_1_frame = cm -> base_qindex ; cpi -> rc . rc_2_frame = cpi -> rc . rc_1_frame ; if ( correction_factor > 110 ) cpi -> rc . rc_1_frame = - 1 ; else if ( correction_factor < 90 ) cpi -> rc . rc_1_frame = 1 ; else cpi -> rc . rc_1_frame = 0 ; <S2SV_ModEnd> if (
<S2SV_ModStart> rd ; int rate ; int64_t dist ; int64_t sse ; if ( args -> exit_early <S2SV_ModEnd> ) return <S2SV_ModStart> ) ) { struct encode_b_args arg = { x , NULL , & mbmi -> skip } ; <S2SV_ModStart> vp9_encode_block_intra ( <S2SV_ModEnd> plane , <S2SV_ModStart> , & arg ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( max_txsize_lookup [ plane_bsize ] == tx_size ) { if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_NONE ) { <S2SV_ModEnd> vp9_xform_quant ( <S2SV_ModStart> dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } else if ( x -> skip_txfm [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] == SKIP_TXFM_AC_ONLY ) { tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ plane ] . coeff , block ) ; tran_low_t * const dqcoeff = BLOCK_OFFSET ( xd -> plane [ plane ] . dqcoeff , block ) ; vp9_xform_quant_dc ( x , plane , block , plane_bsize , tx_size ) ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; if ( x -> plane [ plane ] . eobs [ block ] ) { const int64_t orig_sse = ( int64_t ) coeff [ 0 ] * coeff [ 0 ] ; const int64_t resd_sse = coeff [ 0 ] - dqcoeff [ 0 ] ; int64_t dc_correct = orig_sse - resd_sse * resd_sse ; # if CONFIG_VP9_HIGHBITDEPTH dc_correct >>= ( ( xd -> bd - 8 ) * 2 ) ; # endif if ( tx_size != TX_32X32 ) dc_correct >>= 2 ; dist = MAX ( 0 , sse - dc_correct ) ; } } else { x -> plane [ plane ] . eobs [ block ] = 0 ; sse = x -> bsse [ ( plane << 2 ) + ( block >> ( tx_size << 1 ) ) ] << 4 ; dist = sse ; } } else { vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; dist_block ( x , plane , block , tx_size , & dist , & sse ) ; } rd = RDCOST ( x -> rdmult , x -> rddiv , 0 , dist ) ; if ( args -> this_rd + rd > args -> best_rd ) { args -> exit_early = 1 ; return ; } rate = <S2SV_ModEnd> rate_block ( <S2SV_ModStart> rddiv , <S2SV_ModEnd> rate , <S2SV_ModStart> rate , <S2SV_ModEnd> dist ) <S2SV_ModStart> 0 , <S2SV_ModEnd> sse ) <S2SV_ModStart> this_rate += <S2SV_ModEnd> rate ; <S2SV_ModStart> this_dist += <S2SV_ModEnd> dist ; <S2SV_ModStart> this_sse += <S2SV_ModEnd> sse ; <S2SV_ModStart> args -> exit_early <S2SV_ModEnd> = 1 <S2SV_ModStart> ; } args -> skippable &= ! x -> plane [ plane ] . eobs [ block ] ;
<S2SV_ModStart> ] , int this_mode , const MV_REFERENCE_FRAME ref_frames [ 2 ] ) { if ( ( this_mode == NEARMV || this_mode == NEARESTMV || this_mode == <S2SV_ModEnd> ZEROMV ) <S2SV_ModStart> ZEROMV ) && frame_mv [ this_mode ] [ ref_frames [ 0 ] ] . as_int == 0 && ( ref_frames [ 1 ] <S2SV_ModEnd> == NONE <S2SV_ModStart> ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . <S2SV_ModStart> mode_context [ ref_frames [ 0 ] <S2SV_ModEnd> ] ; <S2SV_ModStart> if ( ref_frames [ 1 ] <S2SV_ModEnd> == NONE <S2SV_ModStart> ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . <S2SV_ModStart> ] [ ref_frames [ 0 ] <S2SV_ModEnd> ] . <S2SV_ModStart> ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARESTMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] . <S2SV_ModStart> ] [ ref_frames [ 0 ] ] . as_int == 0 && frame_mv [ NEARMV ] [ ref_frames [ 1 ] <S2SV_ModEnd> ] .
<S2SV_ModStart> cpi , MACROBLOCK * const x , <S2SV_ModStart> skip_uv , PREDICTION_MODE <S2SV_ModEnd> * mode_uv <S2SV_ModStart> ) { <S2SV_ModEnd> if (
<S2SV_ModStart> conditional_skipintra ( PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> mode , PREDICTION_MODE <S2SV_ModEnd> best_intra_mode )
<S2SV_ModStart> <S2SV_null> static <S2SV_ModEnd> int cost_coeffs <S2SV_ModStart> ; const tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> cost ; # if CONFIG_VP9_HIGHBITDEPTH const int16_t * cat6_high_cost = vp9_get_high_cost_table ( xd -> bd ) ; # else const int16_t * cat6_high_cost = vp9_get_high_cost_table ( 8 ) ; # endif <S2SV_ModStart> ( mbmi , pd <S2SV_ModStart> ] ; int16_t prev_t ; EXTRABIT e ; vp9_get_token_extra ( v , & prev_t , & e ) <S2SV_ModEnd> ; cost <S2SV_ModStart> ] + vp9_get_cost ( prev_t , e , cat6_high_cost ) <S2SV_ModEnd> ; token_cache <S2SV_ModStart> ] ; int16_t <S2SV_ModEnd> t ; <S2SV_ModStart> ] ; vp9_get_token_extra ( v , & t , & e ) <S2SV_ModEnd> ; if <S2SV_ModStart> ] + vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> ; } <S2SV_ModStart> ] + vp9_get_cost ( t , e , cat6_high_cost ) <S2SV_ModEnd> ; token_cache
<S2SV_ModStart> cpi , PREDICTION_MODE <S2SV_ModEnd> mode , <S2SV_ModStart> int mode_context <S2SV_ModEnd> ) { <S2SV_ModStart> ; return cpi <S2SV_ModEnd> -> inter_mode_cost <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> dist_block ( MACROBLOCK * x , <S2SV_ModStart> tx_size , int64_t * out_dist , int64_t * out_sse <S2SV_ModEnd> ) { <S2SV_ModStart> << 1 <S2SV_ModEnd> ; MACROBLOCKD <S2SV_ModStart> 2 ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> ) ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH const int bd = ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd : 8 ; * out_dist = vp9_highbd_block_error <S2SV_ModEnd> ( coeff <S2SV_ModStart> & this_sse , bd ) >> shift ; # else * out_dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ; # endif * out_sse <S2SV_ModEnd> = this_sse <S2SV_ModStart> ) >> # if CONFIG_VP9_HIGHBITDEPTH <S2SV_ModStart> + 2 + ( bd - 8 ) * 2 ) ; # else ( shift + 2 ) ; # endif * out_dist <S2SV_ModEnd> += ( <S2SV_ModStart> ) ; * out_sse <S2SV_ModEnd> += p
<S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> kernel = vp9_filter_kernels [ <S2SV_ModEnd> mi -> <S2SV_ModStart> . interp_filter ] <S2SV_ModEnd> ; for <S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> ( pre <S2SV_ModStart> height , ref , <S2SV_ModEnd> kernel , <S2SV_ModStart> 2 ) , xd -> bd <S2SV_ModStart> ; } else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , <S2SV_ModEnd> height , <S2SV_ModStart> height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , <S2SV_ModStart> width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> stride , dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> k = <S2SV_ModStart> rd2 ; tran_low_t <S2SV_ModEnd> * coeff <S2SV_ModStart> fwd_txm4x4 ( vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> ) ; } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif
<S2SV_ModStart> estimate_ref_frame_costs ( const VP9_COMMON * cm , const MACROBLOCKD * xd , <S2SV_ModEnd> int segment_id <S2SV_ModStart> ref_costs_comp , vpx_prob <S2SV_ModEnd> * comp_mode_p <S2SV_ModStart> ) { int seg_ref_active = segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ; if ( seg_ref_active ) { memset <S2SV_ModEnd> ( ref_costs_single <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( ref_costs_comp <S2SV_ModStart> else { vpx_prob <S2SV_ModEnd> intra_inter_p = <S2SV_ModStart> ) ; vpx_prob <S2SV_ModEnd> comp_inter_p = <S2SV_ModStart> ) { vpx_prob <S2SV_ModEnd> ref_single_p1 = <S2SV_ModStart> ) ; vpx_prob <S2SV_ModEnd> ref_single_p2 = <S2SV_ModStart> ) { vpx_prob <S2SV_ModEnd> ref_comp_p =
<S2SV_ModStart> x , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> bsize , int * rate2 , int64_t * distortion <S2SV_ModEnd> , int <S2SV_ModStart> int * skippable <S2SV_ModEnd> , int <S2SV_ModStart> int * rate_y , <S2SV_ModEnd> int * <S2SV_ModStart> int * rate_uv <S2SV_ModEnd> , int <S2SV_ModStart> int * disable_skip <S2SV_ModEnd> , int_mv <S2SV_ModStart> int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) <S2SV_ModStart> int64_t ref_best_rd , int64_t * mask_filter , int64_t filter_cache [ ] <S2SV_ModStart> -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> const int <S2SV_ModEnd> this_mode = <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> 16 , uint16_t , tmp_buf16 [ MAX_MB_PLANE * 64 * 64 ] ) ; uint8_t * tmp_buf ; # else DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf [ <S2SV_ModEnd> MAX_MB_PLANE * <S2SV_ModStart> * 64 ] ) ; # endif <S2SV_ModEnd> int pred_exists <S2SV_ModStart> rd , tmp_rd , <S2SV_ModStart> 0 ; INTERP_FILTER best_filter = SWITCHABLE ; uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = { 0 } ; int64_t bsse [ MAX_MB_PLANE << 2 ] = { 0 } ; int bsl = mi_width_log2_lookup [ bsize ] ; int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int skip_txfm_sb = 0 ; int64_t skip_sse_sb = INT64_MAX ; int64_t distortion_y = 0 , distortion_uv = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ; } else { tmp_buf = ( uint8_t * ) tmp_buf16 ; } # endif if ( pred_filter_search ) { INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ; if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ; if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ; } <S2SV_ModStart> INT64_MAX ; if ( cpi -> sf . adaptive_mode_search ) { if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ; } <S2SV_ModStart> , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> x , <S2SV_ModEnd> bsize , <S2SV_ModStart> INT64_MAX ; frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) { * rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ; } else { <S2SV_ModStart> rate_mv ; } <S2SV_ModEnd> } } <S2SV_ModStart> i < is_comp_pred + 1 <S2SV_ModEnd> ; ++ <S2SV_ModStart> ; } if ( discount_newmv_test ( cpi , this_mode , frame_mv [ refs [ 0 ] ] , mode_mv , refs [ 0 ] ) ) { * rate2 += MIN ( cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) , cost_mv_ref ( cpi , NEARESTMV , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ) ; } else { <S2SV_ModStart> this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ; } if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && <S2SV_ModStart> mbmi -> mode != NEARESTMV ) return INT64_MAX <S2SV_ModEnd> ; pred_exists <S2SV_ModStart> ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> i ) filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ) { <S2SV_ModEnd> best_filter = <S2SV_ModStart> } else if ( best_filter == SWITCHABLE ) <S2SV_ModStart> rs_rd ; int tmp_skip_sb = 0 ; int64_t tmp_skip_sse = INT64_MAX ; <S2SV_ModStart> vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> rs_rd ; * mask_filter <S2SV_ModEnd> = MAX <S2SV_ModStart> MAX ( * mask_filter <S2SV_ModEnd> , rd <S2SV_ModStart> 0 ; if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) { rate_sum = INT_MAX ; dist_sum = INT64_MAX ; continue ; } <S2SV_ModStart> & dist_sum , & tmp_skip_sb , & tmp_skip_sse <S2SV_ModStart> ) ; filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> rs_rd ; * mask_filter <S2SV_ModEnd> = MAX <S2SV_ModStart> MAX ( * mask_filter <S2SV_ModEnd> , rd <S2SV_ModStart> rd ; <S2SV_ModEnd> best_filter = <S2SV_ModStart> 1 ; tmp_rd = best_rd ; skip_txfm_sb = tmp_skip_sb ; skip_sse_sb = tmp_skip_sse ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; <S2SV_ModStart> interp_filter : <S2SV_ModEnd> best_filter ; <S2SV_ModStart> vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) : <S2SV_ModStart> } } rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; <S2SV_ModStart> else { int tmp_rate ; int64_t tmp_dist ; <S2SV_ModStart> ) ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; } if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ; if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> rate2 += rs ; memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( x -> bsse , bsse , sizeof ( bsse ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ( ! skip_txfm_sb ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; vp9_subtract_plane ( x , bsize , 0 ) ; super_block_yrd ( cpi , x , rate_y , & distortion_y , & skippable_y , psse , bsize , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( ! super_block_uvrd ( cpi , x , rate_uv , & distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv <S2SV_ModEnd> ; * <S2SV_ModStart> * distortion += distortion_uv ; * skippable = skippable_y && skippable_uv ; } else { <S2SV_ModEnd> x -> <S2SV_ModStart> 1 ; * disable_skip <S2SV_ModEnd> = 1 <S2SV_ModStart> ; * <S2SV_ModEnd> distortion = <S2SV_ModStart> distortion = skip_sse_sb ; <S2SV_ModEnd> } if <S2SV_ModStart> ( ! is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable <S2SV_ModEnd> ; restore_dst_buf <S2SV_ModStart> ; return 0 <S2SV_ModEnd> ; }
<S2SV_ModStart> { const VP9_COMMON * const cm = & cpi -> common ; const <S2SV_ModStart> ref ; <S2SV_ModEnd> const InterpKernel <S2SV_ModStart> kernel = vp9_filter_kernels [ <S2SV_ModEnd> mbmi -> <S2SV_ModStart> -> interp_filter ] ; struct scale_factors sf <S2SV_ModEnd> ; struct <S2SV_ModStart> ] ; <S2SV_ModEnd> int last_besterr <S2SV_ModStart> } ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , second_pred_alloc_16 [ 64 * 64 ] ) ; uint8_t * second_pred ; # else DECLARE_ALIGNED ( 16 , uint8_t , second_pred [ 64 * 64 ] ) ; # endif <S2SV_ModStart> ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> ; } # if CONFIG_VP9_HIGHBITDEPTH vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height , cm -> use_highbitdepth ) ; # else vp9_setup_scale_factors_for_frame ( & sf , cm -> width , cm -> height , cm -> width , cm -> height ) ; # endif <S2SV_ModStart> sadperbit16 ; MV <S2SV_ModEnd> tmp_mv ; <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { second_pred = CONVERT_TO_BYTEPTR ( second_pred_alloc_16 ) ; vp9_highbd_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE , xd -> bd ) ; } else { second_pred = ( uint8_t * ) second_pred_alloc_16 ; <S2SV_ModStart> , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; } # else vp9_build_inter_predictor ( ref_yv12 [ ! id ] . buf , ref_yv12 [ ! id ] . stride , second_pred , pw , & frame_mv [ refs [ ! id ] ] . as_mv , & sf , pw , ph , 0 , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE , mi_row * MI_SIZE ) ; # endif if ( id ) <S2SV_ModStart> xd -> <S2SV_ModEnd> plane [ <S2SV_ModStart> ; tmp_mv <S2SV_ModEnd> = frame_mv <S2SV_ModStart> ] . as_mv <S2SV_ModEnd> ; tmp_mv <S2SV_ModStart> ; tmp_mv <S2SV_ModEnd> . col <S2SV_ModStart> tmp_mv . <S2SV_ModEnd> row >>= <S2SV_ModStart> & tmp_mv , sadpb , search_range , & cpi -> fn_ptr [ bsize ] , & ref_mv [ id ] <S2SV_ModStart> as_mv , second_pred <S2SV_ModEnd> ) ; <S2SV_ModStart> & tmp_mv <S2SV_ModEnd> , & <S2SV_ModStart> cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x <S2SV_ModStart> & tmp_mv , & ref_mv [ id ] <S2SV_ModStart> as_mv , <S2SV_ModEnd> cpi -> <S2SV_ModStart> sf . mv . <S2SV_ModStart> subpel_iters_per_step , NULL , <S2SV_ModStart> ] = ref_yv12 [ 0 ] <S2SV_ModEnd> ; if <S2SV_ModStart> ] . as_mv <S2SV_ModEnd> = tmp_mv <S2SV_ModStart> = tmp_mv <S2SV_ModEnd> ; last_besterr <S2SV_ModStart> , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8
<S2SV_ModStart> * out_dist_sum , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> sse ; unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 ; <S2SV_ModStart> ) ; const TX_SIZE max_tx_size = max_txsize_lookup <S2SV_ModEnd> [ bs <S2SV_ModStart> bs ] ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = <S2SV_ModEnd> p -> <S2SV_ModStart> . buf + ( idy * <S2SV_ModEnd> p -> <S2SV_ModStart> . stride << lh ) + ( idx << lw ) ; uint8_t * dst = <S2SV_ModEnd> pd -> <S2SV_ModStart> . buf + ( idy * <S2SV_ModEnd> pd -> <S2SV_ModStart> . stride << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride <S2SV_ModStart> ) ; x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; <S2SV_ModStart> if ( ! x -> select_tx_size ) { if ( var < ac_thr || var <S2SV_ModEnd> == 0 <S2SV_ModStart> 0 ) { <S2SV_ModStart> x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> <S2SV_ModStart> ref ] += <S2SV_ModEnd> sse ; <S2SV_ModStart> sse ; } } total_sse += sum_sse ; <S2SV_ModStart> cpi -> sf . simple_model_rd_from_var <S2SV_ModEnd> ) { <S2SV_ModStart> rate ; const <S2SV_ModEnd> int64_t square_error <S2SV_ModStart> square_error = sum_sse <S2SV_ModEnd> ; int <S2SV_ModStart> ] >> dequant_shift <S2SV_ModEnd> ) ; <S2SV_ModStart> else { <S2SV_ModEnd> vp9_model_rd_from_var_lapndz ( <S2SV_ModStart> vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 <S2SV_ModEnd> ] >> <S2SV_ModStart> ] >> dequant_shift , <S2SV_ModEnd> & rate <S2SV_ModStart> } * skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; *
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> rate_block ( <S2SV_ModStart> ) ; return <S2SV_ModEnd> cost_coeffs (
<S2SV_ModStart> , int row , int col , PREDICTION_MODE <S2SV_ModEnd> * best_mode <S2SV_ModStart> ) { PREDICTION_MODE <S2SV_ModEnd> mode ; <S2SV_ModStart> buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; <S2SV_ModStart> buf [ row * 4 * src_stride + col * 4 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH uint16_t best_dst16 [ 8 * 8 ] ; # endif memcpy <S2SV_ModEnd> ( ta <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( tl <S2SV_ModStart> TX_4X4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( tempa <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( templ <S2SV_ModStart> block = ( row + idy ) <S2SV_ModEnd> * 2 <S2SV_ModStart> 2 + ( col + idx ) <S2SV_ModEnd> ; const <S2SV_ModStart> src_diff = vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 <S2SV_ModStart> ) ; tran_low_t <S2SV_ModEnd> * const <S2SV_ModStart> xd , <S2SV_ModEnd> 1 , <S2SV_ModStart> dst_stride , col + <S2SV_ModStart> idx , row + idy , 0 ) ; vpx_highbd_subtract_block <S2SV_ModEnd> ( 4 <S2SV_ModStart> , dst_stride , xd -> bd <S2SV_ModStart> ] ; vp9_highbd_fwht4x4 <S2SV_ModEnd> ( src_diff <S2SV_ModStart> ) goto next_highbd ; vp9_highbd_iwht4x4_add <S2SV_ModEnd> ( BLOCK_OFFSET <S2SV_ModStart> block ] , xd -> bd <S2SV_ModStart> ] ; if ( tx_type == DCT_DCT ) vpx_highbd_fdct4x4 ( src_diff , coeff , 8 ) ; else vp9_highbd_fht4x4 <S2SV_ModEnd> ( src_diff <S2SV_ModStart> distortion += vp9_highbd_block_error ( <S2SV_ModEnd> coeff , <S2SV_ModStart> & unused , xd -> bd <S2SV_ModStart> ) goto next_highbd ; vp9_highbd_iht4x4_add <S2SV_ModEnd> ( tx_type <S2SV_ModStart> block ] , xd -> bd <S2SV_ModStart> mode ; memcpy <S2SV_ModEnd> ( a <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( l <S2SV_ModStart> idy ) { memcpy ( best_dst16 <S2SV_ModEnd> + idy <S2SV_ModStart> 8 , CONVERT_TO_SHORTPTR ( <S2SV_ModStart> * dst_stride ) <S2SV_ModStart> * 4 * sizeof ( uint16_t ) <S2SV_ModStart> ; } } next_highbd <S2SV_ModEnd> : { <S2SV_ModStart> idy ) { memcpy ( CONVERT_TO_SHORTPTR <S2SV_ModEnd> ( dst_init <S2SV_ModStart> * dst_stride ) , best_dst16 <S2SV_ModEnd> + idy <S2SV_ModStart> * 4 * sizeof ( uint16_t ) ) ; } <S2SV_ModEnd> return best_rd <S2SV_ModStart> ; } # endif for ( mode = DC_PRED ; mode <= TM_PRED ; ++ mode ) { int64_t this_rd ; int ratey = 0 ; int64_t distortion = 0 ; int rate = bmode_costs [ mode ] ; if ( ! ( cpi -> sf . intra_y_mode_mask [ TX_4X4 ] & ( 1 << mode ) ) ) continue ; if ( cpi -> sf . mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( mode , * best_mode ) ) continue ; } memcpy ( tempa , ta , sizeof ( ta ) ) ; memcpy ( templ , tl , sizeof ( tl ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high ; ++ idy ) { for ( idx = 0 ; idx < num_4x4_blocks_wide ; ++ idx ) { const int block = ( row + idy ) * 2 + ( col + idx ) ; const uint8_t * const src = & src_init [ idx * 4 + idy * 4 * src_stride ] ; uint8_t * const dst = & dst_init [ idx * 4 + idy * 4 * dst_stride ] ; int16_t * const src_diff = vp9_raster_block_offset_int16 ( BLOCK_8X8 , block , p -> src_diff ) ; tran_low_t * const coeff = BLOCK_OFFSET ( x -> plane [ 0 ] . coeff , block ) ; xd -> mi [ 0 ] -> bmi [ block ] . as_mode = mode ; vp9_predict_intra_block ( xd , 1 , TX_4X4 , mode , x -> skip_encode ? src : dst , x -> skip_encode ? src_stride : dst_stride , dst , dst_stride , col + idx , row + idy , 0 ) ; vpx_subtract_block ( 4 , 4 , src_diff , 8 , src , src_stride , dst , dst_stride ) ; if ( xd -> lossless ) { const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; vp9_fwht4x4 ( src_diff , coeff , 8 ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iwht4x4_add ( BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } else { int64_t unused ; const TX_TYPE tx_type = get_tx_type_4x4 ( PLANE_TYPE_Y , xd , block ) ; const scan_order * so = & vp9_scan_orders [ TX_4X4 ] [ tx_type ] ; vp9_fht4x4 ( src_diff , coeff , 8 , tx_type ) ; vp9_regular_quantize_b_4x4 ( x , 0 , block , so -> scan , so -> iscan ) ; ratey += cost_coeffs ( x , 0 , block , tempa + idx , templ + idy , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; distortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , block ) , 16 , & unused ) >> 2 ; if ( RDCOST ( x -> rdmult , x -> rddiv , ratey , distortion ) >= best_rd ) goto next ; vp9_iht4x4_add ( tx_type , BLOCK_OFFSET ( pd -> dqcoeff , block ) , dst , dst_stride , p -> eobs [ block ] ) ; } } } rate += ratey ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; memcpy ( a , tempa , sizeof ( tempa ) ) ; memcpy ( l , templ , sizeof ( templ ) ) ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( best_dst + idy * 8 , dst_init + idy * dst_stride , num_4x4_blocks_wide * 4 ) ; } next : { } } if ( best_rd >= rd_thresh || x -> skip_encode ) return best_rd ; for ( idy = 0 ; idy < num_4x4_blocks_high * 4 ; ++ idy ) memcpy ( dst_init + idy * dst_stride , best_dst + idy * 8 , num_4x4_blocks_wide * 4 ) ; return best_rd ; }
<S2SV_ModStart> e_mbd ; PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = <S2SV_ModStart> , this_sse ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) <S2SV_ModStart> mode ; if ( ! <S2SV_ModStart> best_rd ) <S2SV_ModEnd> ) continue <S2SV_ModStart> this_rate_tokenonly + cpi <S2SV_ModEnd> -> intra_uv_mode_cost <S2SV_ModStart> x -> select_tx_size ) swap_block_ptr ( x , ctx , 2 , 0 , 1 , MAX_MB_PLANE ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> , int64_t <S2SV_ModEnd> best_rd ) <S2SV_ModStart> ) { PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = <S2SV_ModStart> ; int <S2SV_ModEnd> * bmode_costs <S2SV_ModStart> * bmode_costs ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi ; const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = cpi <S2SV_ModEnd> -> y_mode_costs <S2SV_ModStart> ] ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { if ( cpi -> sf . use_nonrd_pick_mode ) { if ( conditional_skipintra ( mode , mode_selected ) ) continue ; if ( * skippable ) break ; <S2SV_ModStart> mode ; super_block_yrd <S2SV_ModEnd> ( cpi <S2SV_ModStart> , bsize <S2SV_ModEnd> , best_rd <S2SV_ModStart> ; } <S2SV_ModEnd> } mic
<S2SV_ModStart> xd -> above_mi <S2SV_ModEnd> ; const <S2SV_ModStart> xd -> left_mi <S2SV_ModEnd> ; const <S2SV_ModStart> bmode_costs = cpi <S2SV_ModEnd> -> mbmode_cost <S2SV_ModStart> mbmode_cost ; memcpy <S2SV_ModEnd> ( t_above <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( t_left <S2SV_ModStart> ) { PREDICTION_MODE <S2SV_ModEnd> best_mode = <S2SV_ModStart> { const PREDICTION_MODE <S2SV_ModEnd> A = <S2SV_ModStart> ; const PREDICTION_MODE <S2SV_ModEnd> L = <S2SV_ModStart> bmode_costs = cpi -> y_mode_costs [ A ] [ L ] ; } this_rd = rd_pick_intra4x4block ( cpi , mb , idy , idx <S2SV_ModEnd> , &
<S2SV_ModStart> DC_PRED ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; <S2SV_ModStart> rate_tokenonly + cpi <S2SV_ModEnd> -> intra_uv_mode_cost
<S2SV_ModStart> x , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> e_mbd ; const <S2SV_ModStart> { 0 , 0 <S2SV_ModStart> ; int <S2SV_ModEnd> step_param ; <S2SV_ModStart> ref_mv = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> -> mv_row_max ; int cost_list [ 5 ] <S2SV_ModStart> ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> ] = x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> ref ] <S2SV_ModEnd> ; if <S2SV_ModStart> sf . mv . <S2SV_ModStart> auto_mv_step_size && cm -> <S2SV_ModEnd> show_frame ) <S2SV_ModStart> vp9_init_search_range ( <S2SV_ModEnd> x -> <S2SV_ModStart> mv_step_param ) / 2 <S2SV_ModEnd> ; } <S2SV_ModStart> < BLOCK_64X64 <S2SV_ModEnd> ) { <S2SV_ModStart> * ( b_width_log2_lookup [ BLOCK_64X64 ] <S2SV_ModEnd> - MIN <S2SV_ModStart> MIN ( b_height_log2_lookup [ bsize ] , b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ) ) <S2SV_ModStart> bsize ] <S2SV_ModEnd> ; int <S2SV_ModStart> 2 ; if ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ) { int i ; <S2SV_ModStart> ALTREF_FRAME && cm -> <S2SV_ModEnd> show_frame ; <S2SV_ModStart> ] . row = 0 ; x -> pred_mv [ ref ] . col <S2SV_ModEnd> = 0 <S2SV_ModStart> MAX_MB_PLANE ; ++ i <S2SV_ModEnd> ) xd <S2SV_ModStart> return ; } <S2SV_ModStart> 3 ; bestsme = vp9_full_pixel_search ( cpi , x , bsize , & mvp_full , step_param , sadpb , cond_cost_list ( cpi , cost_list ) , & ref_mv , & tmp_mv -> as_mv , INT_MAX , <S2SV_ModEnd> 1 ) <S2SV_ModStart> 1 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max <S2SV_ModEnd> ; if <S2SV_ModStart> INT_MAX ) { int dis ; cpi -> find_fractional_mv_step <S2SV_ModEnd> ( x <S2SV_ModStart> ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , <S2SV_ModStart> ] , <S2SV_ModEnd> cpi -> <S2SV_ModStart> sf . mv . subpel_force_stop , <S2SV_ModEnd> cpi -> <S2SV_ModStart> sf . mv . subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , x -> nmvjointcost , x -> mvcost , & dis <S2SV_ModEnd> , & <S2SV_ModStart> ref ] , NULL , 0 , 0 <S2SV_ModStart> . adaptive_motion_search <S2SV_ModEnd> ) x <S2SV_ModStart> ref ] <S2SV_ModEnd> = tmp_mv <S2SV_ModStart> tmp_mv -> as_mv <S2SV_ModEnd> ; if
<S2SV_ModStart> mode_index , <S2SV_ModEnd> int64_t comp_pred_diff <S2SV_ModStart> , int64_t <S2SV_ModEnd> best_filter_diff [ <S2SV_ModStart> SWITCHABLE_FILTER_CONTEXTS ] , int skippable <S2SV_ModStart> ctx -> skippable = skippable ; ctx -> <S2SV_ModStart> ctx -> mbmi_ext = * x -> mbmi_ext <S2SV_ModEnd> ; ctx <S2SV_ModStart> ] ; memcpy <S2SV_ModEnd> ( ctx
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> super_block_uvrd ( <S2SV_ModStart> mbmi ; const TX_SIZE uv_tx_size <S2SV_ModEnd> = get_uv_tx_size <S2SV_ModStart> ( mbmi , & xd -> plane [ 1 ] <S2SV_ModStart> 0 ; int is_cost_valid = 1 ; <S2SV_ModStart> 0 ) is_cost_valid = 0 <S2SV_ModEnd> ; if <S2SV_ModStart> mbmi ) && is_cost_valid <S2SV_ModStart> bsize , uv_tx_size <S2SV_ModEnd> , cpi <S2SV_ModStart> INT_MAX ) { is_cost_valid = 0 ; break ; } <S2SV_ModEnd> * rate <S2SV_ModStart> ; } if ( ! is_cost_valid ) { * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } return is_cost_valid <S2SV_ModEnd> ; }
<S2SV_ModStart> , int m , int n , int min_plane , int <S2SV_ModStart> ) { int i ; for ( i = min_plane ; i < max_plane ; ++ i ) { <S2SV_ModStart> p = & <S2SV_ModStart> -> plane [ i ] <S2SV_ModStart> pd = & <S2SV_ModStart> . plane [ i ] ; p -> <S2SV_ModEnd> coeff = <S2SV_ModStart> ] [ m ] ; p -> <S2SV_ModEnd> qcoeff = <S2SV_ModStart> ] [ m <S2SV_ModEnd> ] ; <S2SV_ModStart> ; pd -> <S2SV_ModEnd> dqcoeff = <S2SV_ModStart> ] [ m ] ; p -> <S2SV_ModEnd> eobs = <S2SV_ModStart> ] [ m ] ; ctx -> coeff_pbuf [ i ] [ m ] = ctx -> coeff_pbuf [ i ] [ n ] ; ctx -> qcoeff_pbuf [ i ] [ m ] = ctx -> qcoeff_pbuf [ i ] [ n ] ; ctx -> dqcoeff_pbuf [ i ] [ m ] = ctx -> dqcoeff_pbuf [ i ] [ n ] ; ctx -> eobs_pbuf [ i ] [ m ] = ctx -> eobs_pbuf [ i ] [ n ] ; ctx -> coeff_pbuf [ i ] [ n ] = p -> <S2SV_ModEnd> coeff ; <S2SV_ModStart> ] [ n ] = p -> <S2SV_ModEnd> qcoeff ; <S2SV_ModStart> ] [ n <S2SV_ModEnd> ] = <S2SV_ModStart> = pd -> <S2SV_ModEnd> dqcoeff ; <S2SV_ModStart> ] [ n ] = p -> <S2SV_ModEnd> eobs ;
<S2SV_ModStart> rdcost_block_args args ; vp9_zero ( args ) <S2SV_ModEnd> ; args <S2SV_ModStart> = use_fast_coef_casting ; args . skippable = 1 <S2SV_ModStart> args . exit_early <S2SV_ModEnd> ) { <S2SV_ModStart> skippable = args . skippable <S2SV_ModEnd> ; }
<S2SV_ModStart> ( const tran_low_t <S2SV_ModEnd> * coeff <S2SV_ModStart> , const tran_low_t <S2SV_ModEnd> * dqcoeff
<S2SV_ModStart> <S2SV_null> <S2SV_null> void <S2SV_ModEnd> vp9_rd_pick_inter_mode_sb ( <S2SV_ModStart> cpi , TileDataEnc * tile_data , <S2SV_ModStart> x , <S2SV_ModEnd> int mi_row <S2SV_ModStart> mi_col , RD_COST * rd_cost , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> common ; TileInfo * const tile_info = & tile_data -> tile_info ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModStart> -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> seg ; PREDICTION_MODE <S2SV_ModEnd> this_mode ; <S2SV_ModStart> , i , k <S2SV_ModStart> } } ; INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] <S2SV_ModStart> ; int64_t <S2SV_ModEnd> best_pred_diff [ <S2SV_ModStart> MB_MODE_INFO best_mbmode <S2SV_ModEnd> ; int <S2SV_ModStart> ; int best_mode_skippable = 0 ; int midx <S2SV_ModEnd> , best_mode_index <S2SV_ModStart> best_mode_index = - 1 <S2SV_ModEnd> ; unsigned <S2SV_ModStart> ] ; vpx_prob <S2SV_ModEnd> comp_mode_p ; <S2SV_ModStart> INT64_MAX ; unsigned int best_pred_sse = UINT_MAX ; PREDICTION_MODE <S2SV_ModEnd> best_intra_mode = <S2SV_ModStart> = DC_PRED <S2SV_ModEnd> ; int <S2SV_ModStart> ] ; PREDICTION_MODE <S2SV_ModEnd> mode_uv [ <S2SV_ModStart> ] ; const <S2SV_ModEnd> int intra_cost_penalty <S2SV_ModStart> intra_cost_penalty = vp9_get_intra_cost_penalty ( <S2SV_ModEnd> cm -> <S2SV_ModStart> -> y_dc_delta_q , cm -> bit_depth ) <S2SV_ModEnd> ; int <S2SV_ModStart> 0 ; uint8_t ref_frame_skip_mask [ 2 ] = { 0 } ; uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = { 0 } <S2SV_ModEnd> ; int <S2SV_ModStart> mode_skip_start = sf -> <S2SV_ModEnd> mode_skip_start + <S2SV_ModStart> rd_threshes = rd_opt -> threshes <S2SV_ModEnd> [ segment_id <S2SV_ModStart> rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ; int64_t mode_threshold [ MAX_MODES ] ; int * mode_map = tile_data -> mode_map <S2SV_ModEnd> [ bsize <S2SV_ModStart> mode_search_skip_flags = sf -> <S2SV_ModEnd> mode_search_skip_flags ; <S2SV_ModStart> mode_search_skip_flags ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; vp9_zero ( best_mbmode ) ; x -> skip_encode = sf -> <S2SV_ModEnd> skip_encode_frame && <S2SV_ModStart> QIDX_SKIP_THRESH ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX ; <S2SV_ModStart> estimate_ref_frame_costs ( cm , xd <S2SV_ModEnd> , segment_id <S2SV_ModStart> i < <S2SV_ModEnd> SWITCHABLE_FILTER_CONTEXTS ; <S2SV_ModStart> INT_MAX ; for ( i = 0 ; i < MB_MODE_COUNT ; ++ i ) { for ( k = 0 ; k < MAX_REF_FRAMES ; ++ k ) { single_inter_filter [ i ] [ k ] = SWITCHABLE ; single_skippable [ i ] [ k ] = 0 ; } } rd_cost -> rate <S2SV_ModEnd> = INT_MAX <S2SV_ModStart> ) { assert ( get_ref_frame_buffer <S2SV_ModEnd> ( cpi <S2SV_ModStart> cpi , ref_frame ) != NULL ) ; setup_buffer_inter ( cpi , x , <S2SV_ModEnd> ref_frame , <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; } <S2SV_ModStart> if ( sf -> <S2SV_ModEnd> reference_masking ) <S2SV_ModStart> { mode_skip_mask [ ref_frame ] |= INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> ; break <S2SV_ModStart> if ( segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> ) && get_segdata <S2SV_ModEnd> ( seg <S2SV_ModStart> ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } <S2SV_ModEnd> } if <S2SV_ModStart> ( ! segfeature_active <S2SV_ModEnd> ( seg <S2SV_ModStart> ) { ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> ; if <S2SV_ModStart> ) mode_skip_mask [ ALTREF_FRAME ] <S2SV_ModStart> 1 << NEARMV <S2SV_ModEnd> ) ; <S2SV_ModStart> ) mode_skip_mask [ ALTREF_FRAME ] <S2SV_ModStart> 1 << NEARESTMV ) ; } } if ( cpi -> rc . is_src_frame_alt_ref ) { if ( sf -> alt_ref_search_fp ) { mode_skip_mask [ ALTREF_FRAME ] = 0 ; ref_frame_skip_mask [ 0 ] = ~ ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; } } if ( sf -> alt_ref_search_fp ) if ( ! cm -> show_frame && x -> pred_mv_sad [ GOLDEN_FRAME ] < INT_MAX ) if ( x -> pred_mv_sad [ ALTREF_FRAME ] > ( x -> pred_mv_sad [ GOLDEN_FRAME ] << 1 ) ) mode_skip_mask [ ALTREF_FRAME ] |= INTER_ALL ; if ( sf -> adaptive_mode_search ) { if ( <S2SV_ModEnd> cm -> <S2SV_ModStart> cm -> show_frame && ! cpi -> rc . is_src_frame_alt_ref && cpi -> rc . frames_since_golden >= 3 ) if ( x -> pred_mv_sad [ GOLDEN_FRAME ] > ( x -> pred_mv_sad [ LAST_FRAME ] << 1 ) ) mode_skip_mask [ GOLDEN_FRAME ] |= INTER_ALL <S2SV_ModEnd> ; } <S2SV_ModStart> bsize > sf -> <S2SV_ModEnd> max_intra_bsize ) <S2SV_ModStart> ) { ref_frame_skip_mask [ 0 ] |= ( 1 << INTRA_FRAME ) ; ref_frame_skip_mask [ 1 ] |= ( 1 << INTRA_FRAME ) ; } mode_skip_mask [ INTRA_FRAME ] |= ~ ( sf -> intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ) ; for ( i = 0 ; i <= LAST_NEW_MV_INDEX ; ++ i ) mode_threshold [ i ] = 0 ; for ( i = LAST_NEW_MV_INDEX + 1 ; i < MAX_MODES ; ++ i ) mode_threshold [ i ] = ( ( int64_t ) rd_threshes [ i ] * rd_thresh_freq_fact [ i ] ) >> 5 ; midx = sf -> schedule_mode_search ? mode_skip_start : 0 ; while ( midx > 4 ) { uint8_t end_pos = 0 ; for ( i = 5 ; i < midx ; ++ i ) { if ( mode_threshold [ mode_map [ i - 1 ] ] > mode_threshold [ mode_map [ i ] ] ) { uint8_t tmp = mode_map [ i ] ; mode_map [ i ] = mode_map [ i - 1 ] ; mode_map [ i - 1 ] = tmp ; end_pos = i ; } } midx = end_pos ; } for ( midx = 0 ; midx < MAX_MODES ; ++ midx <S2SV_ModEnd> ) { <S2SV_ModStart> int mode_index = mode_map [ midx ] ; <S2SV_ModEnd> int mode_excluded <S2SV_ModStart> 0 ; <S2SV_ModEnd> int this_skip2 <S2SV_ModStart> 0 ; this_mode = vp9_mode_order [ mode_index ] . mode ; ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; if ( midx <S2SV_ModEnd> == mode_skip_start <S2SV_ModStart> == mode_skip_start && best_mode_index >= 0 <S2SV_ModStart> switch ( best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> LAST_FRAME : ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= LAST_FRAME_MODE_MASK <S2SV_ModStart> |= LAST_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModStart> GOLDEN_FRAME : ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= GOLDEN_FRAME_MODE_MASK <S2SV_ModStart> |= GOLDEN_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModStart> ALTREF_FRAME : ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= ALT_REF_MODE_MASK <S2SV_ModStart> ) ; break ; } } if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) continue ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( mode_skip_mask [ ref_frame ] <S2SV_ModStart> 1 << this_mode ) ) continue ; if ( best_mode_skippable && sf -> schedule_mode_search ) mode_threshold [ mode_index ] <<= 1 <S2SV_ModEnd> ; if <S2SV_ModStart> best_rd < mode_threshold <S2SV_ModEnd> [ mode_index <S2SV_ModStart> mode_index ] ) continue ; if ( sf -> motion_field_mode_search ) { const int mi_width = MIN ( num_8x8_blocks_wide_lookup [ bsize ] , tile_info -> mi_col_end - mi_col ) ; const int mi_height = MIN ( num_8x8_blocks_high_lookup [ bsize ] , tile_info -> mi_row_end - mi_row ) ; const int bsl = mi_width_log2_lookup [ bsize ] ; int cb_partition_search_ctrl = ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; MB_MODE_INFO * ref_mbmi ; int const_motion = 1 ; int skip_ref_frame = ! cb_partition_search_ctrl ; MV_REFERENCE_FRAME rf = NONE ; int_mv ref_mv ; ref_mv . as_int = INVALID_MV ; if ( ( mi_row - 1 ) >= tile_info -> mi_row_start ) { ref_mv = xd -> mi [ - xd -> mi_stride ] -> mbmi . mv [ 0 ] ; rf = xd -> mi [ - xd -> mi_stride ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_width ; ++ i ) { ref_mbmi = & xd -> mi [ - xd -> mi_stride + i ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( ( mi_col - 1 ) >= tile_info -> mi_col_start ) { if ( ref_mv . as_int == INVALID_MV ) ref_mv = xd -> mi [ - 1 ] -> mbmi . mv [ 0 ] ; if ( rf == NONE ) rf = xd -> mi [ - 1 ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_height ; ++ i ) { ref_mbmi = & xd -> mi [ i * xd -> mi_stride - 1 ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( skip_ref_frame && this_mode != NEARESTMV && this_mode != NEWMV ) if ( rf > INTRA_FRAME ) if ( ref_frame != rf ) continue ; if ( const_motion ) if ( this_mode == NEARMV || this_mode == ZEROMV <S2SV_ModEnd> ) continue <S2SV_ModStart> continue ; } <S2SV_ModEnd> comp_pred = <S2SV_ModStart> if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( <S2SV_ModStart> ) && best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> == INTRA_FRAME <S2SV_ModEnd> ) continue <S2SV_ModStart> if ( sf -> adaptive_mode_search ) if ( ( x -> source_variance << num_pels_log2_lookup [ bsize ] ) > best_pred_sse <S2SV_ModEnd> ) continue <S2SV_ModStart> if ( best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> else { const MV_REFERENCE_FRAME ref_frames [ 2 ] = { ref_frame , second_ref_frame } ; <S2SV_ModEnd> if ( <S2SV_ModStart> cpi , mbmi_ext -> mode_context , frame_mv , this_mode , ref_frames ) ) continue ; } <S2SV_ModStart> mbmi -> mode = this_mode ; <S2SV_ModEnd> mbmi -> <S2SV_ModStart> mbmi -> <S2SV_ModEnd> uv_mode = <S2SV_ModStart> uv_mode = DC_PRED <S2SV_ModEnd> ; mbmi <S2SV_ModStart> interp_filter ; mbmi -> mv [ 0 ] . as_int = mbmi -> mv [ 1 ] . as_int = 0 ; <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> uv_tx ; struct macroblockd_plane * const pd = & xd -> plane [ 1 ] ; memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; super_block_yrd <S2SV_ModEnd> ( cpi <S2SV_ModStart> , bsize <S2SV_ModEnd> , best_rd <S2SV_ModStart> , bsize , pd -> subsampling_x , pd -> subsampling_y <S2SV_ModStart> ( cpi , x <S2SV_ModStart> rate_y + cpi <S2SV_ModEnd> -> mbmode_cost <S2SV_ModStart> x , bsize <S2SV_ModEnd> , & <S2SV_ModStart> , & <S2SV_ModEnd> rate_uv , <S2SV_ModStart> rate_uv , <S2SV_ModEnd> & disable_skip <S2SV_ModStart> disable_skip , <S2SV_ModEnd> frame_mv , <S2SV_ModStart> , single_newmv , single_inter_filter , single_skippable <S2SV_ModStart> , best_rd , & mask_filter , filter_cache <S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; <S2SV_ModEnd> rate2 += <S2SV_ModStart> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; <S2SV_ModEnd> } else <S2SV_ModStart> if ( <S2SV_ModEnd> ref_frame != <S2SV_ModStart> ) ; <S2SV_ModEnd> this_skip2 = <S2SV_ModStart> } else <S2SV_ModEnd> { rate2 <S2SV_ModStart> ; } rd_variance_adjustment ( cpi , x , bsize , & this_rd , ref_frame , x -> source_variance ) ; <S2SV_ModStart> } } <S2SV_ModEnd> if ( <S2SV_ModStart> this_rd ) <S2SV_ModEnd> ; } <S2SV_ModStart> ; } else { best_pred_sse = x -> pred_sse [ ref_frame ] ; } rd_cost -> rate <S2SV_ModEnd> = rate2 <S2SV_ModStart> rate2 ; rd_cost -> dist <S2SV_ModEnd> = distortion2 <S2SV_ModStart> = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModStart> this_skip2 ; best_mode_skippable = skippable ; <S2SV_ModStart> x -> select_tx_size <S2SV_ModEnd> ) swap_block_ptr <S2SV_ModStart> ctx , 1 , 0 , 0 , <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( ctx <S2SV_ModStart> sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * <S2SV_ModStart> ) { <S2SV_ModEnd> int qstep <S2SV_ModStart> 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> ] ) <S2SV_ModEnd> best_pred_rd [ <S2SV_ModStart> single_rd ; <S2SV_ModEnd> } else <S2SV_ModStart> ] ) <S2SV_ModEnd> best_pred_rd [ <S2SV_ModStart> single_rd ; <S2SV_ModEnd> } if <S2SV_ModStart> ref = filter_cache <S2SV_ModEnd> [ cm <S2SV_ModStart> if ( filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> adj_rd = mask_filter <S2SV_ModEnd> - ref <S2SV_ModStart> adj_rd = filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> ; } <S2SV_ModEnd> } } <S2SV_ModStart> if ( best_mbmode . mode == NEWMV ) { const MV_REFERENCE_FRAME refs [ 2 ] = { best_mbmode . ref_frame [ 0 ] , best_mbmode . ref_frame [ 1 ] } ; int comp_pred_mode = refs [ 1 ] > INTRA_FRAME ; if ( frame_mv [ NEARESTMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARESTMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARESTMV ; else if ( frame_mv [ NEARMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARMV ; else if ( best_mbmode . mv [ 0 ] . as_int == 0 && ( ( comp_pred_mode && best_mbmode . mv [ 1 ] . as_int == 0 ) || ! comp_pred_mode ) ) best_mbmode . mode = ZEROMV ; } if ( best_mode_index < 0 || <S2SV_ModStart> best_rd_so_far ) { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate ) <S2SV_ModStart> if ( best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> ( mbmi , & xd -> plane [ 1 ] <S2SV_ModStart> if ( ! <S2SV_ModStart> cpi -> rc . is_src_frame_alt_ref ) vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , <S2SV_ModEnd> best_mode_index ) <S2SV_ModStart> best_mode_index ) ; <S2SV_ModEnd> * mbmi <S2SV_ModStart> ) ; } else { vp9_zero ( best_filter_diff ) ; } x -> skip |= best_mode_skippable ; if ( ! x -> skip && ! x -> select_tx_size ) { int has_high_freq_coeff = 0 ; int plane ; int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ? MAX_MB_PLANE : 1 ; <S2SV_ModStart> for ( plane = 0 ; plane < max_plane ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } for ( plane = max_plane ; plane < MAX_MB_PLANE ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } best_mode_skippable |= ! has_high_freq_coeff ; } assert ( best_mode_index >= 0 ) ; store_coding_context ( x , ctx , best_mode_index , best_pred_diff , best_filter_diff , best_mode_skippable ) <S2SV_ModEnd> ; }
<S2SV_ModStart> <S2SV_null> <S2SV_null> void <S2SV_ModEnd> vp9_rd_pick_inter_mode_sub8x8 ( <S2SV_ModStart> cpi , TileDataEnc * tile_data , <S2SV_ModStart> x , <S2SV_ModEnd> int mi_row <S2SV_ModStart> mi_col , RD_COST * rd_cost <S2SV_ModEnd> , BLOCK_SIZE <S2SV_ModStart> VP9_COMMON * const <S2SV_ModStart> -> common ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf <S2SV_ModStart> MACROBLOCKD * const <S2SV_ModStart> MB_MODE_INFO * const <S2SV_ModStart> segmentation * const <S2SV_ModStart> ; int64_t <S2SV_ModEnd> best_pred_diff [ <S2SV_ModStart> MB_MODE_INFO best_mbmode <S2SV_ModEnd> ; int <S2SV_ModStart> ; int ref_index , best_ref_index <S2SV_ModEnd> = 0 <S2SV_ModStart> ] ; vpx_prob comp_mode_p <S2SV_ModEnd> ; INTERP_FILTER <S2SV_ModStart> int rate_uv_intra <S2SV_ModEnd> , rate_uv_tokenonly <S2SV_ModStart> , rate_uv_tokenonly <S2SV_ModEnd> ; int64_t <S2SV_ModStart> int64_t dist_uv <S2SV_ModEnd> ; int <S2SV_ModStart> int skip_uv ; PREDICTION_MODE mode_uv = DC_PRED ; const <S2SV_ModEnd> int intra_cost_penalty <S2SV_ModStart> intra_cost_penalty = vp9_get_intra_cost_penalty ( <S2SV_ModEnd> cm -> <S2SV_ModStart> -> y_dc_delta_q , cm -> bit_depth <S2SV_ModStart> ; int ref_frame_skip_mask [ 2 ] = { 0 } ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] <S2SV_ModEnd> ; int <S2SV_ModStart> ; int internal_active_edge = vp9_active_edge_sb ( cpi , mi_row , mi_col ) && vp9_internal_image_edge ( cpi ) <S2SV_ModEnd> ; x <S2SV_ModStart> skip_encode = sf -> <S2SV_ModEnd> skip_encode_frame && <S2SV_ModStart> QIDX_SKIP_THRESH ; memset <S2SV_ModEnd> ( x <S2SV_ModStart> 4 ) ; vp9_zero ( best_mbmode ) ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX <S2SV_ModStart> estimate_ref_frame_costs ( cm , xd <S2SV_ModEnd> , segment_id <S2SV_ModStart> i < SWITCHABLE_FILTER_CONTEXTS <S2SV_ModEnd> ; i <S2SV_ModStart> ++ ) best_filter_rd <S2SV_ModEnd> [ i <S2SV_ModStart> INT64_MAX ; rate_uv_intra <S2SV_ModEnd> = INT_MAX <S2SV_ModStart> INT_MAX ; rd_cost -> rate <S2SV_ModEnd> = INT_MAX <S2SV_ModStart> ) { setup_buffer_inter <S2SV_ModEnd> ( cpi <S2SV_ModStart> x , <S2SV_ModEnd> ref_frame , <S2SV_ModStart> ; } else { ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= ( <S2SV_ModStart> ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; <S2SV_ModEnd> } for <S2SV_ModStart> for ( ref_index = 0 ; ref_index <S2SV_ModEnd> < MAX_REFS <S2SV_ModStart> ; ++ ref_index <S2SV_ModEnd> ) { <S2SV_ModStart> 0 ; <S2SV_ModEnd> int i <S2SV_ModStart> 0 ; <S2SV_ModEnd> ref_frame = <S2SV_ModStart> vp9_ref_order [ ref_index <S2SV_ModEnd> ] . <S2SV_ModStart> vp9_ref_order [ ref_index <S2SV_ModEnd> ] . <S2SV_ModStart> if ( ref_index <S2SV_ModEnd> > 2 <S2SV_ModStart> 2 && sf -> <S2SV_ModEnd> mode_skip_start < <S2SV_ModStart> if ( ref_index <S2SV_ModEnd> == 3 <S2SV_ModStart> switch ( best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> INTRA_FRAME : <S2SV_ModEnd> break ; <S2SV_ModStart> LAST_FRAME : ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; break <S2SV_ModStart> GOLDEN_FRAME : ref_frame_skip_mask [ 0 ] |= ( 1 << LAST_FRAME ) | ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; break <S2SV_ModStart> ALTREF_FRAME : ref_frame_skip_mask [ 0 ] |= ( 1 << GOLDEN_FRAME ) | ( 1 << LAST_FRAME ) <S2SV_ModEnd> ; break <S2SV_ModStart> ) ; break ; } } } if ( ( ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> & ( <S2SV_ModStart> 1 << ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) <S2SV_ModEnd> ) ) <S2SV_ModStart> continue ; if ( ! internal_active_edge && rd_less_than_thresh <S2SV_ModEnd> ( best_rd <S2SV_ModStart> ( best_rd , rd_opt -> threshes <S2SV_ModEnd> [ segment_id <S2SV_ModStart> ] [ ref_index ] , tile_data -> thresh_freq_fact <S2SV_ModEnd> [ bsize <S2SV_ModStart> ] [ ref_index ] ) <S2SV_ModEnd> ) continue <S2SV_ModStart> continue ; comp_pred = <S2SV_ModEnd> second_ref_frame > <S2SV_ModStart> > INTRA_FRAME ; if ( comp_pred ) { if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( ( sf -> mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA <S2SV_ModStart> ) && best_mbmode . <S2SV_ModEnd> ref_frame [ <S2SV_ModStart> 0 ] <S2SV_ModEnd> == INTRA_FRAME <S2SV_ModStart> == INTRA_FRAME ) continue ; } if ( ref_frame > INTRA_FRAME && vp9_is_scaled ( & cm -> frame_refs [ ref_frame - 1 ] . sf ) ) <S2SV_ModEnd> continue ; <S2SV_ModStart> continue ; if ( <S2SV_ModEnd> second_ref_frame > <S2SV_ModStart> > INTRA_FRAME <S2SV_ModEnd> && vp9_is_scaled <S2SV_ModStart> continue ; if ( comp_pred ) mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; else if ( ref_frame != INTRA_FRAME ) mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { continue ; } else if ( ! segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) continue ; } mbmi -> tx_size = TX_4X4 ; mbmi -> uv_mode = DC_PRED ; mbmi -> ref_frame [ 0 ] = ref_frame ; mbmi -> ref_frame [ 1 ] = second_ref_frame <S2SV_ModEnd> ; mbmi <S2SV_ModStart> interp_filter ; x -> skip = 0 ; set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> rate ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( rate_uv_intra <S2SV_ModEnd> == INT_MAX <S2SV_ModStart> cpi , x , <S2SV_ModStart> & rate_uv_intra <S2SV_ModEnd> , & <S2SV_ModStart> & rate_uv_tokenonly <S2SV_ModEnd> , & <S2SV_ModStart> & dist_uv <S2SV_ModEnd> , & <S2SV_ModStart> & skip_uv <S2SV_ModEnd> , & <S2SV_ModStart> & mode_uv <S2SV_ModEnd> ) ; <S2SV_ModStart> += rate_uv_intra <S2SV_ModEnd> ; rate_uv <S2SV_ModStart> = rate_uv_tokenonly <S2SV_ModEnd> ; distortion2 <S2SV_ModStart> += dist_uv <S2SV_ModEnd> ; distortion_uv <S2SV_ModStart> = dist_uv <S2SV_ModEnd> ; mbmi <S2SV_ModStart> = mode_uv <S2SV_ModEnd> ; } <S2SV_ModStart> ? & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> ) ? rd_opt -> threshes <S2SV_ModEnd> [ segment_id <S2SV_ModStart> ] : rd_opt -> threshes <S2SV_ModEnd> [ segment_id <S2SV_ModStart> ) ? rd_opt -> threshes <S2SV_ModEnd> [ segment_id <S2SV_ModStart> this_rd_thresh ; <S2SV_ModEnd> for ( <S2SV_ModStart> i ) filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> source_variance < sf -> <S2SV_ModEnd> disable_filter_search_var_thresh ) <S2SV_ModStart> if ( sf -> <S2SV_ModEnd> adaptive_pred_interp_filter == <S2SV_ModStart> if ( sf -> <S2SV_ModEnd> adaptive_pred_interp_filter == <S2SV_ModStart> rs_rd ; MB_MODE_INFO_EXT * mbmi_ext = x -> mbmi_ext ; <S2SV_ModStart> tmp_rd = rd_pick_best_sub8x8_mode <S2SV_ModEnd> ( cpi <S2SV_ModStart> x , & mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; filter_cache <S2SV_ModEnd> [ switchable_filter_index <S2SV_ModStart> tmp_rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS <S2SV_ModStart> rs_rd ; mask_filter <S2SV_ModEnd> = MAX <S2SV_ModStart> MAX ( mask_filter <S2SV_ModEnd> , tmp_rd <S2SV_ModStart> 0 && sf -> <S2SV_ModEnd> use_rd_breakout && <S2SV_ModStart> tmp_rd = rd_pick_best_sub8x8_mode <S2SV_ModEnd> ( cpi <S2SV_ModStart> x , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs <S2SV_ModStart> vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; if ( ! <S2SV_ModStart> tmp_best_rdu ) <S2SV_ModEnd> ) continue <S2SV_ModStart> uv_sse ; <S2SV_ModEnd> } } <S2SV_ModStart> ) { if ( <S2SV_ModEnd> ref_frame != <S2SV_ModStart> } else <S2SV_ModEnd> { rate2 <S2SV_ModStart> distortion2 ) <S2SV_ModEnd> ; } <S2SV_ModStart> MAX_MB_PLANE ; best_ref_index = ref_index <S2SV_ModEnd> ; if <S2SV_ModStart> ; } rd_cost -> rate <S2SV_ModEnd> = rate2 <S2SV_ModStart> rate2 ; rd_cost -> dist <S2SV_ModEnd> = distortion2 <S2SV_ModStart> = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModStart> x -> select_tx_size <S2SV_ModEnd> ) swap_block_ptr <S2SV_ModStart> ctx , 1 , 0 , 0 , <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( ctx <S2SV_ModStart> zcoeff_blk [ TX_4X4 <S2SV_ModEnd> ] , <S2SV_ModStart> sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * <S2SV_ModStart> ( ( sf -> <S2SV_ModEnd> mode_search_skip_flags & <S2SV_ModStart> && ( ref_index <S2SV_ModEnd> > MIN_EARLY_TERM_INDEX <S2SV_ModStart> ) { <S2SV_ModEnd> int qstep <S2SV_ModStart> 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> if ( ! comp_pred <S2SV_ModEnd> && single_rd <S2SV_ModStart> ] ) <S2SV_ModEnd> best_pred_rd [ <S2SV_ModStart> single_rd ; <S2SV_ModEnd> else if <S2SV_ModStart> if ( comp_pred <S2SV_ModEnd> && single_rd <S2SV_ModStart> ] ) <S2SV_ModEnd> best_pred_rd [ <S2SV_ModStart> single_rd ; <S2SV_ModEnd> if ( <S2SV_ModStart> ref = filter_cache <S2SV_ModEnd> [ cm <S2SV_ModStart> if ( filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> adj_rd = mask_filter <S2SV_ModEnd> - ref <S2SV_ModStart> adj_rd = filter_cache <S2SV_ModEnd> [ i <S2SV_ModStart> adj_rd ) <S2SV_ModEnd> ; } <S2SV_ModStart> best_rd_so_far ) { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate ) <S2SV_ModStart> if ( best_mbmode <S2SV_ModEnd> . ref_frame <S2SV_ModStart> ) { <S2SV_ModEnd> * mbmi <S2SV_ModStart> best_mbmode ; <S2SV_ModEnd> rd_pick_intra_sbuv_mode ( <S2SV_ModStart> & rate_uv_intra <S2SV_ModEnd> , & <S2SV_ModStart> & rate_uv_tokenonly <S2SV_ModEnd> , & <S2SV_ModStart> & dist_uv <S2SV_ModEnd> , & <S2SV_ModStart> & skip_uv <S2SV_ModEnd> , BLOCK_8X8 <S2SV_ModStart> BLOCK_8X8 , TX_4X4 <S2SV_ModEnd> ) ; <S2SV_ModStart> == INT64_MAX ) { rd_cost -> rate <S2SV_ModEnd> = INT_MAX <S2SV_ModStart> INT_MAX ; rd_cost -> dist <S2SV_ModEnd> = INT64_MAX <S2SV_ModStart> INT64_MAX ; rd_cost -> rdcost = INT64_MAX ; return <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_ref_index ) ; <S2SV_ModEnd> * mbmi <S2SV_ModStart> i ) memcpy <S2SV_ModEnd> ( & <S2SV_ModStart> ; } <S2SV_ModEnd> store_coding_context ( <S2SV_ModStart> ctx , best_ref_index <S2SV_ModEnd> , best_pred_diff <S2SV_ModStart> best_pred_diff , best_filter_diff , 0 ) <S2SV_ModEnd> ; }
<S2SV_ModStart> x , RD_COST * rd_cost , <S2SV_ModEnd> BLOCK_SIZE bsize <S2SV_ModStart> e_mbd ; struct macroblockd_plane * const pd = xd -> plane ; <S2SV_ModStart> = 0 <S2SV_ModEnd> ; TX_SIZE <S2SV_ModStart> INTRA_FRAME ; xd -> mi [ 0 ] -> mbmi . ref_frame [ 1 ] = NONE ; <S2SV_ModStart> bsize , <S2SV_ModEnd> best_rd ) <S2SV_ModStart> ) { rd_cost -> rate <S2SV_ModEnd> = INT_MAX <S2SV_ModStart> return ; } } else { y_skip = 0 ; if ( rd_pick_intra_sub_8x8_y_mode ( cpi , x , & rate_y , & rate_y_tokenonly , & dist_y , best_rd ) >= best_rd ) { rd_cost -> rate = INT_MAX ; return ; } <S2SV_ModStart> , bsize , pd [ 1 ] . subsampling_x , pd [ 1 ] . subsampling_y <S2SV_ModStart> uv_skip , MAX ( BLOCK_8X8 , bsize ) , <S2SV_ModEnd> max_uv_tx_size ) <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) { rd_cost -> rate <S2SV_ModEnd> = rate_y <S2SV_ModStart> ) ; rd_cost -> dist <S2SV_ModEnd> = dist_y <S2SV_ModStart> dist_uv ; } else { rd_cost -> rate = rate_y + rate_uv + vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; rd_cost -> dist = dist_y + dist_uv ; } <S2SV_ModEnd> ctx -> <S2SV_ModStart> ctx -> mic = * xd -> mi [ 0 ] ; <S2SV_ModEnd> ctx -> <S2SV_ModStart> ctx -> mbmi_ext = * x -> mbmi_ext ; rd_cost -> rdcost = RDCOST ( x -> rdmult , x -> rddiv , rd_cost -> rate , rd_cost -> dist ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ) return filteredinterp_filters1000 <S2SV_ModEnd> ; else <S2SV_ModStart> ) return filteredinterp_filters875 <S2SV_ModEnd> ; else <S2SV_ModStart> ) return filteredinterp_filters750 <S2SV_ModEnd> ; else <S2SV_ModStart> ) return filteredinterp_filters625 <S2SV_ModEnd> ; else <S2SV_ModStart> else return filteredinterp_filters500 <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { <S2SV_ModEnd> const int16_t
<S2SV_ModStart> ) { <S2SV_ModEnd> const int16_t
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> sizeof ( output [ 0 ] <S2SV_ModEnd> ) *
<S2SV_ModStart> ) ; assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ;
<S2SV_ModStart> segcounts , vpx_prob <S2SV_ModEnd> * segment_tree_probs
<S2SV_ModStart> segcounts , vpx_prob <S2SV_ModEnd> * probs
<S2SV_ModStart> count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> const TileInfo <S2SV_ModStart> TileInfo * <S2SV_ModEnd> tile , <S2SV_ModStart> * * mi <S2SV_ModEnd> , int <S2SV_ModStart> ) { <S2SV_ModEnd> int segment_id <S2SV_ModStart> mi = mi <S2SV_ModEnd> ; segment_id <S2SV_ModStart> bsize = xd -> mi <S2SV_ModEnd> [ 0 <S2SV_ModStart> pred_segment_id = get_segment_id <S2SV_ModEnd> ( cm
<S2SV_ModStart> count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_ModEnd> const TileInfo <S2SV_ModStart> TileInfo * tile , <S2SV_ModEnd> MODE_INFO * <S2SV_ModStart> * * mi <S2SV_ModEnd> , int <S2SV_ModStart> ) { <S2SV_ModEnd> const int <S2SV_ModStart> num_8x8_blocks_wide_lookup [ mi <S2SV_ModEnd> [ 0 <S2SV_ModStart> num_8x8_blocks_high_lookup [ mi <S2SV_ModEnd> [ 0 <S2SV_ModStart> count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts <S2SV_ModStart> count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts <S2SV_ModStart> count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs <S2SV_ModStart> count_segs ( cm , xd , tile , mi <S2SV_ModEnd> , no_pred_segcounts <S2SV_ModStart> count_segs ( cm , xd , tile , mi <S2SV_ModEnd> + hbs <S2SV_ModStart> count_segs_sb ( cm , xd <S2SV_ModEnd> , tile <S2SV_ModStart> , & mi <S2SV_ModEnd> [ mi_dr
<S2SV_ModStart> vp9_choose_segmap_coding_method ( <S2SV_ModEnd> VP9_COMMON * <S2SV_ModStart> VP9_COMMON * cm , MACROBLOCKD * xd ) { <S2SV_ModEnd> struct segmentation <S2SV_ModStart> } ; vpx_prob <S2SV_ModEnd> no_pred_tree [ <S2SV_ModStart> ] ; vpx_prob <S2SV_ModEnd> t_pred_tree [ <S2SV_ModStart> ] ; vpx_prob <S2SV_ModEnd> t_nopred_prob [ <S2SV_ModStart> ] ; memset <S2SV_ModEnd> ( seg <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( seg <S2SV_ModStart> tile ; MODE_INFO * * mi_ptr ; <S2SV_ModStart> 8 * cm -> mi_stride ) { MODE_INFO * * <S2SV_ModEnd> mi = <S2SV_ModStart> count_segs_sb ( cm , xd <S2SV_ModEnd> , & <S2SV_ModStart> 1 ; memcpy <S2SV_ModEnd> ( seg <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( seg <S2SV_ModStart> 0 ; memcpy <S2SV_ModEnd> ( seg
<S2SV_ModStart> 0 ; seg -> update_map = 0 ; seg -> update_data = 0 ;
<S2SV_ModStart> 0 ; memset <S2SV_ModEnd> ( seg
<S2SV_ModStart> abs_delta ; memcpy <S2SV_ModEnd> ( seg
<S2SV_ModStart> ) { const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart> = 1 <S2SV_ModEnd> ; sf <S2SV_ModStart> ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> ) ; } <S2SV_ModStart> sf -> <S2SV_ModEnd> use_rd_breakout = <S2SV_ModStart> sf -> mv . <S2SV_ModStart> sf -> mv . <S2SV_ModStart> = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> tx_size_search_method = frame_is_boosted <S2SV_ModEnd> ( cpi <S2SV_ModStart> USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> ( cm <S2SV_ModStart> cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | <S2SV_ModStart> sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) { sf -> use_square_partition_only = ! frame_is_intra_only <S2SV_ModEnd> ( cm <S2SV_ModStart> ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 <S2SV_ModStart> sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> ; sf <S2SV_ModStart> 4 ; if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; <S2SV_ModStart> sf -> <S2SV_ModEnd> use_lp32x32fdct = <S2SV_ModStart> = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart> sf -> <S2SV_ModEnd> optimize_coefficients = <S2SV_ModStart> sf -> mv . <S2SV_ModStart> ] = INTRA_DC <S2SV_ModEnd> ; sf <S2SV_ModStart> ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> set_rt_speed_feature ( VP9_COMP * cpi <S2SV_ModEnd> , SPEED_FEATURES <S2SV_ModStart> int speed , vp9e_tune_content content ) { VP9_COMMON * const cm = & cpi -> common ; const int is_keyframe = cm -> frame_type == KEY_FRAME ; const int frames_since_key = is_keyframe ? 0 : cpi -> rc . frames_since_key ; <S2SV_ModEnd> sf -> <S2SV_ModStart> sf -> <S2SV_ModEnd> use_fast_coef_costing = <S2SV_ModStart> ( speed >= <S2SV_ModEnd> 1 ) <S2SV_ModStart> USE_LARGESTALL ; <S2SV_ModEnd> sf -> <S2SV_ModStart> sf -> mv . <S2SV_ModStart> = INTRA_DC_H_V <S2SV_ModEnd> ; } <S2SV_ModStart> sf -> mode_search_skip_flags = <S2SV_ModEnd> ( cm <S2SV_ModStart> ( cm -> frame_type == KEY_FRAME <S2SV_ModEnd> ) ? <S2SV_ModStart> ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | <S2SV_ModStart> sf -> <S2SV_ModEnd> adaptive_pred_interp_filter = <S2SV_ModStart> sf -> <S2SV_ModEnd> reference_masking = <S2SV_ModStart> reference_masking = ( cpi -> oxcf . resize_mode != RESIZE_DYNAMIC && cpi -> svc . number_spatial_layers == 1 ) ? 1 : 0 <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> lf_motion_threshold = LOW_MOTION_THRESHOLD <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> <S2SV_ModEnd> use_lp32x32fdct = <S2SV_ModStart> intra_y_mode_mask [ TX_16X16 <S2SV_ModEnd> ] = <S2SV_ModStart> = INTRA_DC_H_V <S2SV_ModEnd> ; } <S2SV_ModStart> sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate = <S2SV_ModStart> sf -> mv . <S2SV_ModStart> sf -> <S2SV_ModEnd> adaptive_rd_thresh = <S2SV_ModStart> = LPF_PICK_FROM_Q <S2SV_ModEnd> ; } <S2SV_ModStart> == ( frames_since_key <S2SV_ModEnd> + 1 <S2SV_ModStart> sf -> mv . <S2SV_ModStart> ] = INTRA_DC <S2SV_ModEnd> ; } <S2SV_ModStart> ] = INTRA_DC <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> mv . <S2SV_ModEnd> search_method = <S2SV_ModStart> sf -> inter_mode_mask <S2SV_ModEnd> [ BLOCK_32X32 <S2SV_ModStart> ] = INTER_NEAREST_NEAR_NEW ; sf -> inter_mode_mask <S2SV_ModEnd> [ BLOCK_32X64 <S2SV_ModStart> ] = INTER_NEAREST ; sf -> inter_mode_mask <S2SV_ModEnd> [ BLOCK_64X32 <S2SV_ModStart> ] = INTER_NEAREST ; sf -> inter_mode_mask <S2SV_ModEnd> [ BLOCK_64X64 <S2SV_ModStart> ] = INTER_NEAREST <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> use_quant_fp = ! is_keyframe ; sf -> auto_min_max_partition_size = is_keyframe ? RELAXED_NEIGHBORING_MIN_MAX : STRICT_NEIGHBORING_MIN_MAX ; sf -> default_max_partition_size <S2SV_ModEnd> = BLOCK_32X32 <S2SV_ModStart> sf -> default_min_partition_size <S2SV_ModEnd> = BLOCK_8X8 <S2SV_ModStart> sf -> force_frame_boost = is_keyframe || ( frames_since_key % <S2SV_ModEnd> ( sf <S2SV_ModStart> max_delta_qindex = is_keyframe <S2SV_ModEnd> ? 20 <S2SV_ModStart> sf -> <S2SV_ModEnd> allow_skip_recode = <S2SV_ModStart> 0 ; sf -> inter_mode_mask [ BLOCK_32X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_32X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X32 ] = INTER_NEAREST_NEW_ZERO ; sf -> inter_mode_mask [ BLOCK_64X64 ] = INTER_NEAREST_NEW_ZERO ; sf -> adaptive_rd_thresh = 2 ; sf -> reuse_inter_pred_sby = 1 ; sf -> partition_search_breakout_rate_thr = 200 ; sf -> coeff_prob_appx_step = 4 ; sf -> use_fast_coef_updates = is_keyframe ? TWO_LOOP : ONE_LOOP_REDUCED ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH ; sf -> tx_size_search_method = is_keyframe ? USE_LARGESTALL : USE_TX_8X8 ; sf -> simple_model_rd_from_var = 1 ; if ( ! is_keyframe ) { int i ; if ( content == VP9E_CONTENT_SCREEN ) { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_TM_H_V ; } else { for ( i = 0 ; i < BLOCK_SIZES ; ++ i ) if ( i >= BLOCK_16X16 ) sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC ; else sf -> intra_y_mode_bsize_mask [ i ] = INTRA_DC_H_V ; } } <S2SV_ModStart> partition_search_type = VAR_BASED_PARTITION <S2SV_ModEnd> ; sf <S2SV_ModStart> sf -> mv . <S2SV_ModStart> search_method = NSTEP ; sf -> mv . reduce_first_step_size = 1 ; sf -> skip_encode_sb = 0 <S2SV_ModEnd> ; } <S2SV_ModStart> ) { sf -> adaptive_rd_thresh = 3 ; sf -> mv . search_method = FAST_DIAMOND ; sf -> mv . fullpel_search_step_param = 10 ; if ( cpi -> svc . number_temporal_layers > 2 && cpi -> svc . temporal_layer_id == 0 ) { sf -> mv . search_method = NSTEP ; sf -> mv . fullpel_search_step_param = 6 ; } } if ( speed >= 8 ) { sf -> adaptive_rd_thresh = 4 ; sf -> mv . subpel_force_stop = 2 ; sf -> lpf_pick = LPF_PICK_MINIMAL_LPF <S2SV_ModEnd> ; }
<S2SV_ModStart> encode_term_subexp ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) { vpx_write_literal <S2SV_ModEnd> ( w <S2SV_ModStart> ) { vpx_write_literal <S2SV_ModEnd> ( w <S2SV_ModStart> ) { vpx_write_literal <S2SV_ModEnd> ( w
<S2SV_ModStart> encode_uniform ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) { vpx_write_literal <S2SV_ModEnd> ( w <S2SV_ModStart> else { vpx_write_literal <S2SV_ModEnd> ( w <S2SV_ModStart> ) ; vpx_write_literal <S2SV_ModEnd> ( w
<S2SV_ModStart> prob_diff_update_cost ( vpx_prob <S2SV_ModEnd> newp , <S2SV_ModStart> newp , vpx_prob <S2SV_ModEnd> oldp )
<S2SV_ModStart> vp9_cond_prob_diff_update ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> w , vpx_prob <S2SV_ModEnd> * oldp <S2SV_ModStart> { const vpx_prob <S2SV_ModEnd> upd = <S2SV_ModStart> DIFF_UPDATE_PROB ; vpx_prob <S2SV_ModEnd> newp = <S2SV_ModStart> ) { vpx_write <S2SV_ModEnd> ( w <S2SV_ModStart> else { vpx_write <S2SV_ModEnd> ( w
<S2SV_ModStart> ct , vpx_prob <S2SV_ModEnd> oldp , <S2SV_ModStart> oldp , vpx_prob <S2SV_ModEnd> * bestp <S2SV_ModStart> bestp , vpx_prob <S2SV_ModEnd> upd ) <S2SV_ModStart> 0 ; vpx_prob <S2SV_ModEnd> newp ,
<S2SV_ModStart> , const vpx_prob * oldp , vpx_prob <S2SV_ModEnd> * bestp <S2SV_ModStart> bestp , vpx_prob upd , int stepsize ) { int <S2SV_ModEnd> i , <S2SV_ModStart> newp ; vpx_prob <S2SV_ModEnd> bestnewp , <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( newplist <S2SV_ModStart> sizeof ( vpx_prob <S2SV_ModEnd> ) * <S2SV_ModStart> ] ; if ( * bestp > oldp [ PIVOT_NODE ] ) { <S2SV_ModStart> step = - stepsize ; for ( newp = <S2SV_ModEnd> * bestp <S2SV_ModStart> * bestp ; newp > <S2SV_ModEnd> oldp [ <S2SV_ModStart> } } } else { step = stepsize ; for ( newp = <S2SV_ModStart> * bestp ; newp < oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } } * bestp = bestnewp <S2SV_ModEnd> ; return
<S2SV_ModStart> vp9_write_prob_diff_update ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> w , vpx_prob <S2SV_ModEnd> newp , <S2SV_ModStart> newp , vpx_prob <S2SV_ModEnd> oldp )
<S2SV_ModStart> write_bit_gte ( vpx_writer <S2SV_ModEnd> * w <S2SV_ModStart> ) { vpx_write_literal <S2SV_ModEnd> ( w
<S2SV_ModStart> get_layer_context ( VP9_COMP * const cpi <S2SV_ModEnd> ) { <S2SV_ModStart> ) { if ( is_one_pass_cbr_svc ( cpi ) ) return & cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers + cpi -> svc . temporal_layer_id ] ; else return ( cpi -> svc . <S2SV_ModEnd> number_temporal_layers > <S2SV_ModStart> > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) <S2SV_ModStart> ? & cpi -> svc . <S2SV_ModEnd> layer_context [ <S2SV_ModStart> layer_context [ cpi -> svc . <S2SV_ModEnd> temporal_layer_id ] <S2SV_ModStart> : & cpi -> svc . <S2SV_ModEnd> layer_context [ <S2SV_ModStart> layer_context [ cpi -> svc . <S2SV_ModEnd> spatial_layer_id ]
<S2SV_ModStart> vp9_inc_frame_in_layer ( VP9_COMP * const cpi <S2SV_ModEnd> ) { <S2SV_ModStart> lc = & cpi -> svc . <S2SV_ModEnd> layer_context [ <S2SV_ModStart> layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers <S2SV_ModEnd> ] ; <S2SV_ModStart> current_video_frame_in_layer ; ++ lc -> frames_from_key_frame ;
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> ; int sl , tl ; int alt_ref_idx = svc -> number_spatial_layers ; svc -> spatial_layer_id = 0 ; svc -> temporal_layer_id = 0 ; if ( cpi -> oxcf . error_resilient_mode == 0 && cpi -> oxcf . pass == 2 ) { if ( vpx_realloc_frame_buffer ( & cpi -> svc . empty_frame . img , SMALL_FRAME_WIDTH , SMALL_FRAME_HEIGHT , cpi -> common . subsampling_x , cpi -> common . subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cpi -> common . use_highbitdepth , # endif VP9_ENC_BORDER_IN_PIXELS , cpi -> common . byte_alignment , NULL , NULL , NULL ) ) vpx_internal_error ( & cpi -> common . error , VPX_CODEC_MEM_ERROR , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>empty<S2SV_blank>frame<S2SV_blank>for<S2SV_blank>multiple<S2SV_blank>frame<S2SV_blank>" "contexts" ) ; memset ( cpi -> svc . empty_frame . img . buffer_alloc , 0x80 , cpi -> svc . empty_frame . img . buffer_alloc_sz ) ; } for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { int layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; RATE_CONTROL * const lrc = & lc -> rc <S2SV_ModEnd> ; int <S2SV_ModStart> ; int i ; lc -> current_video_frame_in_layer = 0 ; lc -> layer_size = 0 ; lc -> frames_from_key_frame = 0 ; lc -> last_frame_type = FRAME_TYPES ; lrc -> ni_av_qi = oxcf -> worst_allowed_q ; lrc -> total_actual_bits = 0 ; lrc -> total_target_vs_actual = 0 ; lrc -> ni_tot_qi = 0 ; lrc -> tot_q = 0.0 ; lrc -> avg_q = 0.0 ; lrc -> ni_frames = 0 ; lrc -> decimation_count = 0 ; lrc -> decimation_factor = 0 ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { lrc -> rate_correction_factors [ i ] = 1.0 ; } if ( cpi -> oxcf . rc_mode == VPX_CBR ) { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ INTER_FRAME ] = oxcf -> worst_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = oxcf -> worst_allowed_q ; } else { lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; lrc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; lrc -> last_q [ INTER_FRAME ] = oxcf -> best_allowed_q ; lrc -> avg_frame_qindex [ KEY_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; lrc -> avg_frame_qindex [ INTER_FRAME ] = ( oxcf -> worst_allowed_q + oxcf -> best_allowed_q ) / 2 ; if ( oxcf -> ss_enable_auto_arf [ sl ] ) lc -> alt_ref_idx = alt_ref_idx ++ ; else lc -> alt_ref_idx = INVALID_IDX ; lc -> gold_ref_idx = INVALID_IDX ; } lrc -> buffer_level = oxcf -> starting_buffer_level_ms * lc -> target_bandwidth / 1000 ; lrc -> bits_off_target = lrc -> buffer_level ; } } if ( ! <S2SV_ModEnd> ( svc <S2SV_ModStart> > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) && alt_ref_idx < REF_FRAMES ) <S2SV_ModEnd> svc -> <S2SV_ModStart> layer_context [ 0 ] . gold_ref_idx = alt_ref_idx ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) { TWO_PASS <S2SV_ModEnd> * const
<S2SV_ModStart> get_layer_context ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> cpi -> alt_ref_source <S2SV_ModEnd> = lc <S2SV_ModStart> lc -> alt_ref_source <S2SV_ModEnd> ; if
<S2SV_ModStart> { const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> get_layer_context ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> lc -> alt_ref_source <S2SV_ModEnd> = cpi <S2SV_ModStart> cpi -> alt_ref_source <S2SV_ModEnd> ; }
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> ; int sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { <S2SV_ModEnd> int layer_end <S2SV_ModStart> int layer_end <S2SV_ModEnd> ; if <S2SV_ModStart> > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModStart> -> rc ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) <S2SV_ModStart> > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) { <S2SV_ModStart> framerate = cpi <S2SV_ModEnd> -> framerate <S2SV_ModStart> framerate = cpi <S2SV_ModEnd> -> framerate <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( <S2SV_ModStart> } } }
<S2SV_ModStart> { const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> get_layer_context ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf <S2SV_ModStart> ) ; vp9_rc_set_gf_interval_range ( cpi , lrc ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ; const VP9EncoderConfig <S2SV_ModEnd> * const <S2SV_ModStart> get_layer_context ( cpi <S2SV_ModEnd> ) ; <S2SV_ModStart> const int st_idx = svc -> spatial_layer_id * svc -> number_temporal_layers + <S2SV_ModEnd> svc -> <S2SV_ModStart> temporal_layer_id ; const int tl = svc -> temporal_layer_id ; lc -> framerate = cpi <S2SV_ModEnd> -> framerate <S2SV_ModStart> ts_rate_decimator [ tl <S2SV_ModEnd> ] ; <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( <S2SV_ModStart> if ( tl <S2SV_ModEnd> == 0 <S2SV_ModStart> lrc -> avg_frame_bandwidth <S2SV_ModEnd> ; } <S2SV_ModStart> prev_layer_framerate = cpi <S2SV_ModEnd> -> framerate <S2SV_ModStart> ts_rate_decimator [ tl <S2SV_ModEnd> - 1 <S2SV_ModStart> oxcf -> layer_target_bitrate [ st_idx <S2SV_ModEnd> - 1 <S2SV_ModStart> 1 ] <S2SV_ModEnd> ; lc
<S2SV_ModStart> MACROBLOCK * const x = & cpi -> td . <S2SV_ModEnd> mb ; <S2SV_ModStart> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; <S2SV_ModStart> = INT_MAX ; int distortion ; unsigned int sse ; int cost_list [ 5 ] <S2SV_ModStart> stride ; <S2SV_ModEnd> step_param = <S2SV_ModStart> step_param = mv_sf -> reduce_first_step_size ; <S2SV_ModEnd> step_param = <S2SV_ModStart> step_param = MIN ( step_param , MAX_MVSEARCH_STEPS <S2SV_ModEnd> - 2 <S2SV_ModStart> 2 ) <S2SV_ModEnd> ; vp9_hex_search <S2SV_ModStart> 1 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> ) ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , NULL , NULL , & distortion , & sse , <S2SV_ModEnd> NULL , <S2SV_ModStart> NULL , 0 , 0 ) ; <S2SV_ModEnd> x ->
<S2SV_ModStart> cpi , YV12_BUFFER_CONFIG * * frames , <S2SV_ModStart> mb_cols = ( frames [ alt_ref_index ] -> y_crop_width + 15 ) >> 4 <S2SV_ModEnd> ; int <S2SV_ModStart> mb_rows = ( frames [ alt_ref_index ] -> y_crop_height + 15 ) >> 4 <S2SV_ModEnd> ; int <S2SV_ModStart> 0 ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , accumulator [ <S2SV_ModEnd> 16 * <S2SV_ModStart> * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> , count [ <S2SV_ModEnd> 16 * <S2SV_ModStart> * 3 ] <S2SV_ModStart> cpi -> td . <S2SV_ModStart> f = <S2SV_ModEnd> frames [ <S2SV_ModStart> dst2 ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint16_t , predictor16 [ 16 * 16 * 3 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 <S2SV_ModStart> uint8_t , predictor8 [ 16 * 16 * 3 ] ) ; uint8_t * predictor ; # else DECLARE_ALIGNED ( 16 , uint8_t , predictor [ <S2SV_ModEnd> 16 * <S2SV_ModStart> * 3 ] ) ; # endif <S2SV_ModEnd> const int <S2SV_ModStart> subsampling_y ; const int mb_uv_width = 16 >> mbd -> plane [ 1 ] . subsampling_x ; <S2SV_ModStart> i ; # if CONFIG_VP9_HIGHBITDEPTH if <S2SV_ModEnd> ( mbd <S2SV_ModStart> mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { predictor = CONVERT_TO_BYTEPTR ( predictor16 ) ; } else { predictor = predictor8 ; } # endif <S2SV_ModEnd> for ( <S2SV_ModStart> ) { <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> td . <S2SV_ModStart> cpi -> td . <S2SV_ModStart> ( ( <S2SV_ModEnd> mb_rows - <S2SV_ModStart> ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> stride ; memset <S2SV_ModEnd> ( accumulator <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( count <S2SV_ModStart> ) ; <S2SV_ModEnd> cpi -> <S2SV_ModStart> cpi -> td . <S2SV_ModStart> cpi -> td . <S2SV_ModStart> ( ( <S2SV_ModEnd> mb_cols - <S2SV_ModStart> ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> ) { const int thresh_low = 10000 ; const int thresh_high = 20000 ; <S2SV_ModStart> if ( <S2SV_ModEnd> frames [ <S2SV_ModStart> err = <S2SV_ModEnd> temporal_filter_find_matching_mb_c ( <S2SV_ModStart> cpi , <S2SV_ModEnd> frames [ <S2SV_ModStart> mb_y_offset , <S2SV_ModEnd> frames [ <S2SV_ModStart> mb_y_offset , <S2SV_ModEnd> frames [ <S2SV_ModStart> ) ; <S2SV_ModEnd> filter_weight = <S2SV_ModStart> err < thresh_low <S2SV_ModEnd> ? 2 <S2SV_ModStart> err < thresh_high <S2SV_ModEnd> ? 1 <S2SV_ModStart> mbd , frames [ frame ] -> y_buffer + mb_y_offset , frames [ frame ] -> u_buffer + mb_uv_offset , frames [ frame ] -> v_buffer + mb_uv_offset , frames [ frame ] -> y_stride , mb_uv_width , mb_uv_height , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . row , mbd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv . col , predictor , scale , mb_col * 16 , mb_row * 16 ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { int adj_strength = strength + 2 * ( mbd -> bd - 8 ) ; vp9_highbd_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , adj_strength , filter_weight , accumulator , count ) ; vp9_highbd_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_highbd_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , adj_strength , filter_weight , accumulator + 512 , count + 512 ) ; } else { vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; } # else vp9_temporal_filter_apply ( f -> y_buffer + mb_y_offset , f -> y_stride , predictor , 16 , 16 , strength , filter_weight , accumulator , count ) ; vp9_temporal_filter_apply ( f -> u_buffer + mb_uv_offset , f -> uv_stride , predictor + 256 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 256 , count + 256 ) ; vp9_temporal_filter_apply ( f -> v_buffer + mb_uv_offset , f -> uv_stride , predictor + 512 , mb_uv_width , mb_uv_height , strength , filter_weight , accumulator + 512 , count + 512 ) ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( mbd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { uint16_t * dst1_16 ; uint16_t * dst2_16 ; dst1 = <S2SV_ModStart> cpi -> alt_ref_buffer . y_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) <S2SV_ModEnd> ; stride <S2SV_ModStart> pval *= <S2SV_ModEnd> fixed_divide [ <S2SV_ModStart> 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval <S2SV_ModStart> v_buffer ; dst1_16 = CONVERT_TO_SHORTPTR ( dst1 ) ; dst2_16 = CONVERT_TO_SHORTPTR ( dst2 ) ; <S2SV_ModStart> j < mb_uv_width <S2SV_ModEnd> ; j <S2SV_ModStart> pval *= <S2SV_ModEnd> fixed_divide [ <S2SV_ModStart> 19 ; dst1_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval <S2SV_ModStart> pval *= <S2SV_ModEnd> fixed_divide [ <S2SV_ModStart> 19 ; dst2_16 [ byte ] = ( uint16_t <S2SV_ModEnd> ) pval <S2SV_ModStart> stride - mb_uv_width ; } } else { dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < <S2SV_ModStart> mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } } # else dst1 = cpi -> alt_ref_buffer . y_buffer ; stride = cpi -> alt_ref_buffer . y_stride ; byte = mb_y_offset ; for ( i = 0 , k = 0 ; i < 16 ; i ++ ) { for ( j = 0 ; j < 16 ; j ++ , k ++ ) { unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - 16 ; } dst1 = cpi -> alt_ref_buffer . u_buffer ; dst2 = cpi -> alt_ref_buffer . v_buffer ; stride = cpi -> alt_ref_buffer . uv_stride ; byte = mb_uv_offset ; for ( i = 0 , k = 256 ; i < mb_uv_height ; i ++ ) { for ( j = 0 ; j < mb_uv_width ; j ++ , k ++ ) { int m = k + 256 ; unsigned int pval = accumulator [ k ] + ( count [ k ] >> 1 ) ; pval *= fixed_divide [ count [ k ] ] ; pval >>= 19 ; dst1 [ byte ] = ( uint8_t ) pval ; pval = accumulator [ m ] + ( count [ m ] >> 1 ) ; pval *= fixed_divide [ count [ m ] ] ; pval >>= 19 ; dst2 [ byte ] = ( uint8_t ) pval ; byte ++ ; } byte += stride - mb_uv_width ; } # endif <S2SV_ModEnd> mb_y_offset += <S2SV_ModStart> += 16 ; mb_uv_offset += mb_uv_width ; } mb_y_offset += 16 * ( f -> y_stride - mb_cols ) <S2SV_ModStart> += mb_uv_height * <S2SV_ModEnd> f -> <S2SV_ModStart> uv_stride - mb_uv_width * mb_cols <S2SV_ModEnd> ; }
<S2SV_ModStart> , int uv_block_width , int uv_block_height <S2SV_ModEnd> , int <S2SV_ModStart> kernel = vp9_filter_kernels [ <S2SV_ModEnd> xd -> <S2SV_ModStart> . interp_filter ] <S2SV_ModEnd> ; enum <S2SV_ModStart> if ( uv_block_width <S2SV_ModEnd> == 8 <S2SV_ModStart> ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv <S2SV_ModStart> ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv
<S2SV_ModStart> unsigned int block_width , unsigned int block_height <S2SV_ModEnd> , int <S2SV_ModStart> 0 ; const int rounding = strength > 0 ? 1 << ( strength - 1 ) : 0 ; <S2SV_ModStart> i < block_height <S2SV_ModEnd> ; i <S2SV_ModStart> j < block_width <S2SV_ModEnd> ; j <S2SV_ModStart> modifier += rounding <S2SV_ModEnd> ; modifier <S2SV_ModStart> stride - block_width <S2SV_ModEnd> ; }
<S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * context_tree <S2SV_ModStart> context_tree , int32_t <S2SV_ModEnd> extra ,
<S2SV_ModStart> , const vpx_prob <S2SV_ModEnd> * context_tree
<S2SV_ModStart> ; return segfeature_active <S2SV_ModEnd> ( seg
<S2SV_ModStart> argv ; ( void ) plane ; ( void ) plane_bsize ; ( void ) tx_size ; <S2SV_ModStart> args -> <S2SV_ModEnd> eobs [
<S2SV_ModStart> arg ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> xd = & x -> e_mbd <S2SV_ModEnd> ; struct <S2SV_ModStart> = & x -> <S2SV_ModEnd> plane [
<S2SV_ModStart> cpi ; ThreadData * const td = args -> td ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> MACROBLOCKD * const <S2SV_ModStart> xd = & x -> e_mbd <S2SV_ModEnd> ; TOKENEXTRA <S2SV_ModStart> = & x -> <S2SV_ModEnd> plane [ <S2SV_ModStart> ; const tran_low_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const <S2SV_ModStart> int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = td -> rd_counts . coef_counts [ tx_size ] [ type ] [ ref ] ; vpx_prob <S2SV_ModEnd> ( * <S2SV_ModStart> . fc -> <S2SV_ModEnd> coef_probs [ <S2SV_ModStart> ] = td -> counts -> <S2SV_ModEnd> eob_branch [ <S2SV_ModStart> ) ; int16_t token ; EXTRABIT extra ; <S2SV_ModStart> ; } vp9_get_token_extra ( v , & token , & extra ) ; <S2SV_ModStart> ] , <S2SV_ModEnd> extra , <S2SV_ModStart> uint8_t ) <S2SV_ModEnd> token , <S2SV_ModStart> vp9_pt_energy_class [ <S2SV_ModEnd> token ]
<S2SV_ModStart> { x -> plane [ plane ] . eobs
<S2SV_ModStart> cpi , ThreadData * td , <S2SV_ModStart> common ; MACROBLOCK * const x = & td -> mb ; <S2SV_ModStart> = & x -> <S2SV_ModEnd> e_mbd ; <S2SV_ModStart> -> mbmi <S2SV_ModEnd> ; const <S2SV_ModStart> = ! segfeature_active <S2SV_ModEnd> ( & <S2SV_ModStart> cpi , td <S2SV_ModEnd> , t <S2SV_ModStart> dry_run ) td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> skip [ <S2SV_ModStart> ) ; <S2SV_ModEnd> return ; <S2SV_ModStart> ) { td <S2SV_ModEnd> -> counts <S2SV_ModStart> -> counts -> <S2SV_ModEnd> skip [ <S2SV_ModStart> ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> i , vpx_tree <S2SV_ModEnd> tree ,
<S2SV_ModStart> , const vpx_tree_index <S2SV_ModEnd> * tree <S2SV_ModStart> { const vpx_tree_index <S2SV_ModEnd> j =
<S2SV_ModStart> , const vpx_tree_index <S2SV_ModEnd> * tree
<S2SV_ModStart> vp9_tree_probs_from_distribution ( vpx_tree <S2SV_ModEnd> tree ,
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t ) <S2SV_ModStart> const __m128i k__cospi_p08_m24 <S2SV_ModEnd> = pair_set_epi16 <S2SV_ModStart> pair_set_epi16 ( cospi_8_64 , <S2SV_ModStart> - cospi_24_64 <S2SV_ModEnd> ) ; <S2SV_ModStart> ] , <S2SV_ModEnd> k__cospi_p24_p08 ) <S2SV_ModStart> v [ 3 ] = _mm_madd_epi16 ( u [ 3 <S2SV_ModEnd> ] , <S2SV_ModStart> ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p08_m24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p08_m24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_ModStart> ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; s [ 3 ] = <S2SV_ModStart> s [ 4 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 <S2SV_ModEnd> ] = <S2SV_ModStart> = _mm_add_epi16 <S2SV_ModEnd> ( p
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> _mm_set1_epi16 ( ( int16_t )
<S2SV_ModStart> res , <S2SV_ModEnd> const int <S2SV_ModStart> const int bit ) { <S2SV_ModEnd> __m128i sign0 <S2SV_ModStart> if ( bit == 2 <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const __m128i const_rounding = _mm_set1_epi16 ( 1 ) ; res [ 0 ] = _mm_add_epi16 ( res [ 0 ] , const_rounding ) ; res [ 1 ] = _mm_add_epi16 ( res [ 1 ] , const_rounding ) ; res [ 2 ] = _mm_add_epi16 ( res [ 2 ] , const_rounding ) ; res [ 3 ] = _mm_add_epi16 ( res [ 3 ] , const_rounding ) ; res [ 4 ] = _mm_add_epi16 ( res [ 4 ] , const_rounding ) ; res [ 5 ] = _mm_add_epi16 ( res [ 5 ] , const_rounding ) ; res [ 6 ] = _mm_add_epi16 ( res [ 6 ] , const_rounding ) ; res [ 7 ] = _mm_add_epi16 ( res [ 7 ] , const_rounding <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; if ( bit == 1 ) { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 1 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 1 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 1 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 1 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 1 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 1 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 1 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 1 ) ; } else { res [ 0 ] = _mm_srai_epi16 ( res [ 0 ] , 2 ) ; res [ 1 ] = _mm_srai_epi16 ( res [ 1 ] , 2 ) ; res [ 2 ] = _mm_srai_epi16 ( res [ 2 ] , 2 ) ; res [ 3 ] = _mm_srai_epi16 ( res [ 3 ] , 2 ) ; res [ 4 ] = _mm_srai_epi16 ( res [ 4 ] , 2 ) ; res [ 5 ] = _mm_srai_epi16 ( res [ 5 ] , 2 ) ; res [ 6 ] = _mm_srai_epi16 ( res [ 6 ] , 2 ) ; res [ 7 ] = _mm_srai_epi16 ( res [ 7 ] , 2 ) ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> DCT_DCT : vpx_fdct16x16_sse2 <S2SV_ModEnd> ( input
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> DCT_DCT : vpx_fdct4x4_sse2 <S2SV_ModEnd> ( input
<S2SV_ModStart> input , tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> DCT_DCT : vpx_fdct8x8_sse2 <S2SV_ModEnd> ( input
<S2SV_ModStart> write_buffer_16x16 ( tran_low_t <S2SV_ModEnd> * output
<S2SV_ModStart> write_buffer_4x4 ( tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) ; store_output ( & out01 , <S2SV_ModEnd> ( output <S2SV_ModStart> 8 ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & out23 , <S2SV_ModEnd> ( output <S2SV_ModStart> 8 ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> write_buffer_8x8 ( tran_low_t <S2SV_ModEnd> * output <S2SV_ModStart> ) { store_output ( & res [ 0 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 1 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 2 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 3 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 4 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 5 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 6 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; store_output ( & res [ 7 ] , <S2SV_ModEnd> ( output <S2SV_ModStart> stride ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> vp9_ref_frame_t * const <S2SV_ModStart> * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> <S2SV_ModStart> -> cpi -> common <S2SV_ModStart> -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> active_map , ( int ) <S2SV_ModStart> rows , ( int )
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> * ) <S2SV_ModEnd> ; if <S2SV_ModStart> void ) <S2SV_ModEnd> args ;
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ) { ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> cfg -> <S2SV_ModEnd> g_pass ==
<S2SV_ModStart> * ctx <S2SV_ModEnd> , va_list
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> cpi ; vpx_svc_extra_cfg_t <S2SV_ModEnd> * const <S2SV_ModStart> args , vpx_svc_extra_cfg_t <S2SV_ModEnd> * ) <S2SV_ModStart> ) ; int sl , tl ; for ( sl = 0 ; sl < <S2SV_ModEnd> cpi -> <S2SV_ModStart> svc . number_spatial_layers ; ++ sl ) { for ( tl = 0 ; tl < <S2SV_ModEnd> cpi -> <S2SV_ModStart> svc . number_temporal_layers ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cpi -> svc . number_temporal_layers ) ; LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ layer ] ; lc -> max_q <S2SV_ModEnd> = params <S2SV_ModStart> params -> max_quantizers [ sl ] ; lc -> min_q <S2SV_ModEnd> = params <S2SV_ModStart> params -> min_quantizers [ sl ] ; lc -> scaling_factor_num <S2SV_ModEnd> = params <S2SV_ModStart> params -> scaling_factor_num [ sl ] ; lc -> scaling_factor_den <S2SV_ModEnd> = params <S2SV_ModStart> params -> scaling_factor_den [ sl ] ; } } <S2SV_ModEnd> return VPX_CODEC_OK
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif vpx_free ( ctx -> buffer_pool ) ; vpx_free <S2SV_ModEnd> ( ctx
<S2SV_ModStart> VPX_CODEC_OK ; VP9_COMP * const cpi = ctx -> cpi ; const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ; size_t data_sz ; <S2SV_ModStart> ( img != NULL ) { <S2SV_ModEnd> res = <S2SV_ModStart> ) ; if ( res == VPX_CODEC_OK && cpi != NULL ) { data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ; if ( data_sz < 4096 ) data_sz = 4096 ; if ( ctx -> cx_data == NULL || ctx -> cx_data_sz < data_sz ) { ctx -> cx_data_sz = data_sz ; free ( ctx -> cx_data ) ; ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ; if ( ctx -> cx_data == NULL ) { return VPX_CODEC_MEM_ERROR ; } } } } <S2SV_ModStart> ; } vp9_apply_encoding_flags ( cpi , flags ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> VPX_CODEC_OK && <S2SV_ModEnd> cpi != <S2SV_ModStart> int lib_flags = 0 <S2SV_ModStart> int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ; int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) <S2SV_ModEnd> ; size_t <S2SV_ModStart> VPX_CODEC_USE_PSNR ) cpi <S2SV_ModEnd> -> b_calculate_psnr <S2SV_ModStart> = 1 <S2SV_ModEnd> ; if <S2SV_ModStart> vp9_receive_raw_frame ( cpi , flags | ctx -> next_frame_flags <S2SV_ModEnd> , & <S2SV_ModStart> ) { <S2SV_ModEnd> res = <S2SV_ModStart> ; } ctx -> next_frame_flags = 0 ; <S2SV_ModStart> -> cx_data_sz <S2SV_ModEnd> ; if <S2SV_ModStart> vp9_get_compressed_data ( <S2SV_ModEnd> cpi , <S2SV_ModStart> ) { <S2SV_ModEnd> vpx_codec_cx_pkt_t pkt <S2SV_ModStart> pkt ; # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id * cpi -> svc . number_temporal_layers ] . layer_size += size ; # endif if ( ! <S2SV_ModEnd> cpi -> <S2SV_ModStart> . show_frame || ( cpi -> use_svc && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) <S2SV_ModEnd> ) { <S2SV_ModStart> size ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) { pkt . kind = VPX_CODEC_CX_FRAME_PKT ; pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ; pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , <S2SV_ModEnd> dst_end_time_stamp - <S2SV_ModStart> pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ; pkt . data . frame . buf = ctx -> pending_cx_data ; pkt . data . frame . sz = size ; ctx -> pending_cx_data = NULL ; ctx -> pending_cx_data_sz = 0 ; ctx -> pending_frame_count = 0 ; ctx -> pending_frame_magnitude = 0 ; ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; } continue ; } pkt . <S2SV_ModStart> pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) <S2SV_ModEnd> ; pkt <S2SV_ModStart> long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp <S2SV_ModEnd> ) ; <S2SV_ModStart> flags = get_frame_pkt_flags ( cpi , lib_flags ) <S2SV_ModEnd> ; if <S2SV_ModStart> size ; if ( ! ctx -> output_cx_pkt_cb . output_cx_pkt ) <S2SV_ModStart> 1 ; if ( ctx -> output_cx_pkt_cb . output_cx_pkt ) ctx -> output_cx_pkt_cb . output_cx_pkt ( & pkt , ctx -> output_cx_pkt_cb . user_priv ) ; else <S2SV_ModStart> size ; # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC if ( cpi -> use_svc && ! ctx -> output_cx_pkt_cb . output_cx_pkt ) { vpx_codec_cx_pkt_t pkt_sizes , pkt_psnr ; int sl ; vp9_zero ( pkt_sizes ) ; vp9_zero ( pkt_psnr ) ; pkt_sizes . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ; pkt_psnr . kind = VPX_CODEC_SPATIAL_SVC_LAYER_PSNR ; for ( sl = 0 ; sl < cpi -> svc . number_spatial_layers ; ++ sl ) { LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ sl * cpi -> svc . number_temporal_layers ] ; pkt_sizes . data . layer_sizes [ sl ] = lc -> layer_size ; pkt_psnr . data . layer_psnr [ sl ] = lc -> psnr_pkt ; lc -> layer_size = 0 ; } vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_sizes ) ; vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt_psnr ) ; } # endif # endif if ( is_one_pass_cbr_svc ( cpi ) && ( cpi -> svc . spatial_layer_id == cpi -> svc . number_spatial_layers - 1 ) ) { break ; }
<S2SV_ModStart> vp9_ppflags_t flags ; vp9_zero ( flags ) <S2SV_ModEnd> ; if
<S2SV_ModStart> ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res <S2SV_ModEnd> ; }
<S2SV_ModStart> res ; int force_key = 0 ; if ( cfg -> g_w != ctx -> cfg . g_w || cfg -> g_h != ctx -> cfg . g_h ) { if ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS <S2SV_ModEnd> ) ERROR <S2SV_ModStart> ) ; if ( ! valid_ref_frame_size ( ctx -> cfg . g_w , ctx -> cfg . g_h , cfg -> g_w , cfg -> g_h ) || ( ctx -> cpi -> initial_width && ( int ) cfg -> g_w > ctx -> cpi -> initial_width ) || ( ctx -> cpi -> initial_height && ( int ) cfg -> g_h > ctx -> cpi -> initial_height ) ) force_key = 1 ; } <S2SV_ModStart> ) ; force_key |= ctx -> cpi -> common . profile != ctx -> oxcf . profile ; <S2SV_ModStart> ; } if ( force_key ) ctx -> next_frame_flags |= VPX_EFLAG_FORCE_KF ;
<S2SV_ModStart> { MODE new_mode = BEST ; switch ( ctx -> cfg . g_pass ) { case VPX_RC_ONE_PASS : <S2SV_ModEnd> if ( <S2SV_ModStart> ( deadline > 0 <S2SV_ModStart> ) { const vpx_codec_enc_cfg_t * const cfg = & ctx -> cfg ; <S2SV_ModStart> uint64_t ) cfg -> <S2SV_ModEnd> g_timebase . <S2SV_ModStart> uint64_t ) cfg -> <S2SV_ModEnd> g_timebase . <S2SV_ModStart> den ; new_mode <S2SV_ModEnd> = ( <S2SV_ModStart> ) ? GOOD : REALTIME ; } else { new_mode = BEST <S2SV_ModEnd> ; } <S2SV_ModStart> ; } break ; case VPX_RC_FIRST_PASS : break ; case VPX_RC_LAST_PASS : new_mode = deadline > 0 ? GOOD : BEST ; break ; } <S2SV_ModEnd> if ( <S2SV_ModStart> mode != new_mode <S2SV_ModEnd> ) { <S2SV_ModStart> mode = new_mode <S2SV_ModEnd> ; vp9_change_config
<S2SV_ModStart> set_encoder_config ( VP9EncoderConfig <S2SV_ModEnd> * oxcf <S2SV_ModStart> ) { const int is_vbr = cfg -> rc_end_usage == VPX_VBR ; int sl , tl ; <S2SV_ModStart> oxcf -> max_threads = ( int ) cfg -> g_threads ; oxcf -> <S2SV_ModStart> bit_depth = cfg -> g_bit_depth ; oxcf -> input_bit_depth = cfg -> g_input_bit_depth ; oxcf -> init_framerate <S2SV_ModEnd> = ( <S2SV_ModStart> oxcf -> init_framerate <S2SV_ModEnd> > 180 <S2SV_ModStart> oxcf -> init_framerate <S2SV_ModEnd> = 30 <S2SV_ModStart> = 30 ; oxcf -> mode = GOOD <S2SV_ModStart> oxcf -> pass = 0 <S2SV_ModEnd> ; break <S2SV_ModStart> oxcf -> pass = 1 <S2SV_ModEnd> ; break <S2SV_ModStart> oxcf -> pass = 2 <S2SV_ModEnd> ; break <S2SV_ModStart> oxcf -> rc_mode = <S2SV_ModEnd> cfg -> <S2SV_ModStart> -> rc_end_usage <S2SV_ModEnd> ; oxcf <S2SV_ModStart> target_bandwidth = 1000 * <S2SV_ModStart> oxcf -> rc_max_inter_bitrate_pct = extra_cfg -> rc_max_inter_bitrate_pct ; oxcf -> gf_cbr_boost_pct = extra_cfg -> gf_cbr_boost_pct ; oxcf -> <S2SV_ModStart> best_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> cfg -> <S2SV_ModStart> -> rc_min_quantizer ) <S2SV_ModEnd> ; oxcf <S2SV_ModStart> worst_allowed_q = extra_cfg -> lossless ? 0 : vp9_quantizer_to_qindex ( <S2SV_ModEnd> cfg -> <S2SV_ModStart> -> rc_max_quantizer ) <S2SV_ModEnd> ; oxcf <S2SV_ModStart> cq_level = vp9_quantizer_to_qindex ( <S2SV_ModEnd> extra_cfg -> <S2SV_ModStart> -> cq_level ) <S2SV_ModEnd> ; oxcf <S2SV_ModStart> oxcf -> scaled_frame_width = cfg -> rc_scaled_width ; oxcf -> scaled_frame_height = cfg -> rc_scaled_height ; if ( cfg -> rc_resize_allowed == 1 ) { oxcf -> resize_mode = ( oxcf -> scaled_frame_width == 0 || oxcf -> scaled_frame_height == 0 ) ? RESIZE_DYNAMIC : RESIZE_FIXED ; } else { oxcf -> resize_mode = RESIZE_NONE ; } oxcf -> maximum_buffer_size_ms = is_vbr ? 240000 : <S2SV_ModEnd> cfg -> <S2SV_ModStart> oxcf -> starting_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> cfg -> <S2SV_ModStart> oxcf -> optimal_buffer_level_ms = is_vbr ? 60000 : <S2SV_ModEnd> cfg -> <S2SV_ModStart> oxcf -> speed = abs ( extra_cfg -> cpu_used ) <S2SV_ModEnd> ; oxcf <S2SV_ModStart> oxcf -> enable_auto_arf <S2SV_ModEnd> = extra_cfg <S2SV_ModStart> rc_twopass_stats_in ; # if CONFIG_FP_MB_STATS oxcf -> firstpass_mb_stats_in = cfg -> rc_firstpass_mb_stats_in ; # endif oxcf -> color_space = extra_cfg -> color_space <S2SV_ModEnd> ; oxcf <S2SV_ModStart> oxcf -> min_gf_interval = extra_cfg -> min_gf_interval ; oxcf -> max_gf_interval = extra_cfg -> max_gf_interval <S2SV_ModEnd> ; oxcf <S2SV_ModStart> oxcf -> content = extra_cfg -> content ; oxcf -> <S2SV_ModStart> oxcf -> <S2SV_ModEnd> error_resilient_mode = <S2SV_ModStart> ss_number_layers ; oxcf -> ts_number_layers = cfg -> ts_number_layers ; oxcf -> temporal_layering_mode = ( enum vp9e_temporal_layering_mode ) cfg -> temporal_layering_mode ; for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ sl ] = cfg -> ss_enable_auto_alt_ref [ sl ] ; # endif for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { oxcf -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] = 1000 * cfg -> layer_target_bitrate [ sl * oxcf -> ts_number_layers + tl ] ; } } if <S2SV_ModEnd> ( oxcf <S2SV_ModStart> -> ss_number_layers == 1 && oxcf -> pass != 0 ) { oxcf -> ss_target_bitrate [ 0 ] = ( int ) oxcf -> target_bandwidth ; # if CONFIG_SPATIAL_SVC oxcf -> ss_enable_auto_arf [ 0 ] = extra_cfg -> enable_auto_alt_ref ; # endif } if ( oxcf -> ts_number_layers <S2SV_ModStart> ) { for ( tl = 0 ; tl < VPX_TS_MAX_LAYERS ; ++ tl ) { oxcf -> ts_rate_decimator [ tl ] = cfg -> ts_rate_decimator [ tl ] ? cfg -> ts_rate_decimator [ tl ] : 1 ; } <S2SV_ModEnd> } else <S2SV_ModStart> oxcf -> <S2SV_ModEnd> ts_number_layers == <S2SV_ModStart> oxcf -> <S2SV_ModEnd> ts_rate_decimator [
<S2SV_ModStart> rc_undershoot_pct , 100 <S2SV_ModEnd> ) ; <S2SV_ModStart> rc_overshoot_pct , 100 <S2SV_ModEnd> ) ; <S2SV_ModStart> RANGE_CHECK ( extra_cfg , min_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; RANGE_CHECK ( extra_cfg , max_gf_interval , 0 , ( MAX_LAG_BUFFERS - 1 ) ) ; if ( extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , 2 , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( extra_cfg -> min_gf_interval > 0 && extra_cfg -> max_gf_interval > 0 ) { RANGE_CHECK ( extra_cfg , max_gf_interval , extra_cfg -> min_gf_interval , ( MAX_LAG_BUFFERS - 1 ) ) ; } if ( cfg -> rc_resize_allowed == 1 ) { RANGE_CHECK ( cfg , rc_scaled_width , 0 , cfg -> g_w ) ; RANGE_CHECK ( cfg , rc_scaled_height , 0 , cfg -> g_h ) ; } RANGE_CHECK ( <S2SV_ModStart> cfg -> ss_number_layers * cfg -> <S2SV_ModStart> ts_number_layers > VPX_MAX_LAYERS ) ERROR ( "ss_number_layers<S2SV_blank>*<S2SV_blank>ts_number_layers<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range" ) ; if ( cfg -> ts_number_layers > <S2SV_ModStart> unsigned int sl , tl <S2SV_ModEnd> ; for <S2SV_ModStart> for ( sl = 1 ; sl <S2SV_ModEnd> < cfg <S2SV_ModStart> cfg -> ss_number_layers ; ++ sl ) { for ( tl = 1 ; tl < cfg -> <S2SV_ModStart> ; ++ tl ) { const int layer = LAYER_IDS_TO_IDX ( sl , tl , cfg -> ts_number_layers ) ; if ( cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> ] < <S2SV_ModStart> ] < cfg -> layer_target_bitrate [ layer <S2SV_ModEnd> - 1 <S2SV_ModStart> ) ; } } <S2SV_ModStart> for ( tl <S2SV_ModEnd> = cfg <S2SV_ModStart> 2 ; tl <S2SV_ModEnd> > 0 <S2SV_ModStart> ; -- tl <S2SV_ModEnd> ) if <S2SV_ModStart> ts_rate_decimator [ tl <S2SV_ModEnd> - 1 <S2SV_ModStart> ts_rate_decimator [ tl ] ) ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; } # if CONFIG_SPATIAL_SVC if ( ( cfg -> ss_number_layers > 1 || cfg -> ts_number_layers > 1 ) && cfg -> g_pass == VPX_RC_LAST_PASS ) { unsigned int i , alt_ref_sum = 0 ; for ( i = 0 ; i < cfg -> ss_number_layers ; ++ i ) { if ( cfg -> ss_enable_auto_alt_ref [ <S2SV_ModStart> ] ) ++ alt_ref_sum ; } if ( alt_ref_sum > REF_FRAMES - cfg -> ss_number_layers ) ERROR ( "Not<S2SV_blank>enough<S2SV_blank>ref<S2SV_blank>buffers<S2SV_blank>for<S2SV_blank>svc<S2SV_blank>alt<S2SV_blank>ref<S2SV_blank>frames" ) ; if ( cfg -> ss_number_layers * cfg -> ts_number_layers > 3 && cfg -> g_error_resilient == 0 ) ERROR ( "Multiple<S2SV_blank>frame<S2SV_blank>context<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>more<S2SV_blank>than<S2SV_blank>3<S2SV_blank>layers" ) ; } # endif <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; RANGE_CHECK <S2SV_ModEnd> ( extra_cfg <S2SV_ModStart> , enable_auto_alt_ref , 0 , 2 <S2SV_ModStart> , - 8 , 8 <S2SV_ModEnd> ) ; <S2SV_ModStart> extra_cfg , <S2SV_ModEnd> cq_level , <S2SV_ModStart> , 63 ) ; RANGE_CHECK ( cfg , g_bit_depth , VPX_BITS_8 , VPX_BITS_12 ) ; RANGE_CHECK ( cfg , g_input_bit_depth , 8 , 12 ) ; RANGE_CHECK ( extra_cfg , content , VP9E_CONTENT_DEFAULT , VP9E_CONTENT_INVALID - 1 <S2SV_ModStart> ) { const <S2SV_ModStart> ) ; const <S2SV_ModStart> -> ss_number_layers > 1 || cfg -> ts_number_layers <S2SV_ModStart> || ( unsigned <S2SV_ModStart> } } # if ! CONFIG_VP9_HIGHBITDEPTH if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 ) { ERROR ( "Profile<S2SV_blank>><S2SV_blank>1<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build<S2SV_blank>configuration" ) ; } # endif <S2SV_ModStart> PROFILE_1 && cfg -> g_bit_depth > VPX_BITS_8 ) { ERROR ( "Codec<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> -> g_profile <= <S2SV_ModEnd> ( unsigned <S2SV_ModStart> PROFILE_1 && cfg -> g_input_bit_depth > 8 ) { ERROR ( "Source<S2SV_blank>high<S2SV_blank>bit-depth<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank><<S2SV_blank>2" ) ; } if ( cfg -> g_profile > ( unsigned int ) PROFILE_1 && cfg -> g_bit_depth == VPX_BITS_8 ) { ERROR ( "Codec<S2SV_blank>bit-depth<S2SV_blank>8<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile<S2SV_blank>><S2SV_blank>1" ) ; } RANGE_CHECK ( extra_cfg , color_space , VPX_CS_UNKNOWN , VPX_CS_SRGB <S2SV_ModEnd> ) ;
<S2SV_ModStart> : case VPX_IMG_FMT_I42016 : break ; case <S2SV_ModStart> VPX_IMG_FMT_I444 : case VPX_IMG_FMT_I440 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 ) { ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile." ) ; } break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44416 : case VPX_IMG_FMT_I44016 : if ( ctx -> cfg . g_profile != ( unsigned int ) PROFILE_1 && ctx -> cfg . g_profile != ( unsigned int ) PROFILE_3 ) { ERROR ( "Invalid<S2SV_blank>image<S2SV_blank>format.<S2SV_blank>16-bit<S2SV_blank>I422,<S2SV_blank>I444,<S2SV_blank>I440<S2SV_blank>images<S2SV_blank>are<S2SV_blank>" "not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>profile." ) ; } <S2SV_ModStart> "supported." ) ; break
<S2SV_ModStart> j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( "Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\n" ) ; # endif <S2SV_ModStart> index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> vp9_copy_reference_dec ( frame_worker_data <S2SV_ModEnd> -> pbi
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ctx -> frame_workers <S2SV_ModEnd> ) { <S2SV_ModStart> ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> = & frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> display_height ; return VPX_CODEC_OK ; <S2SV_ModStart> ; } } <S2SV_ModEnd> return VPX_CODEC_INVALID_PARAM <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ctx -> frame_workers ) { VPxWorker * const worker <S2SV_ModEnd> = ctx <S2SV_ModStart> = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; RefCntBuffer * const frame_bufs = frame_worker_data -> pbi -> common . buffer_pool -> frame_bufs ; if ( frame_worker_data <S2SV_ModStart> . frame_to_show == NULL ) <S2SV_ModEnd> return VPX_CODEC_ERROR <S2SV_ModStart> return VPX_CODEC_ERROR ; if ( ctx -> last_show_frame >= 0 ) * corrupted = frame_bufs [ ctx -> last_show_frame ] . buf . corrupted <S2SV_ModStart> { return VPX_CODEC_ERROR <S2SV_ModEnd> ; } <S2SV_ModStart> } } return VPX_CODEC_INVALID_PARAM ; }
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModEnd> * update_info <S2SV_ModStart> update_info = frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> -> refresh_frame_flags <S2SV_ModEnd> ; return <S2SV_ModStart> { return VPX_CODEC_ERROR <S2SV_ModEnd> ; } <S2SV_ModStart> } } return VPX_CODEC_INVALID_PARAM ; }
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } if ( <S2SV_ModStart> fb ; VPxWorker * const worker = <S2SV_ModEnd> ctx -> <S2SV_ModStart> ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; fb = get_ref_frame ( & frame_worker_data -> pbi -> common <S2SV_ModEnd> , data <S2SV_ModStart> -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ) { ( void ) ctx ; ( void ) args ; <S2SV_ModEnd> return VPX_CODEC_INCAPABLE <S2SV_ModStart> VPX_CODEC_INCAPABLE ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> # else ( void ) ctx ; ( void ) args ;
<S2SV_ModStart> ctx , <S2SV_ModEnd> va_list args <S2SV_ModStart> ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , "Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> ( & frame_worker_data <S2SV_ModEnd> -> pbi
<S2SV_ModStart> ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ( void ) deadline <S2SV_ModEnd> ; if <S2SV_ModStart> ) { int is_intra_only = 0 ; <S2SV_ModStart> res = decoder_peek_si_internal <S2SV_ModEnd> ( * <S2SV_ModStart> -> si , & is_intra_only , ctx -> decrypt_cb , ctx -> decrypt_state <S2SV_ModStart> res ; if ( ! ctx -> si . is_kf && ! is_intra_only ) return VPX_CODEC_ERROR ; <S2SV_ModStart> ctx -> frame_parallel_decode <S2SV_ModEnd> ) { <S2SV_ModStart> ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data -> data = * data ; frame_worker_data -> data_size = data_sz ; frame_worker_data -> user_priv = user_priv ; frame_worker_data -> received_frame = 1 ; frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> -> pbi -> decrypt_cb = ctx -> decrypt_cb ; frame_worker_data -> pbi -> decrypt_state = ctx -> decrypt_state ; worker -> had_error = 0 ; winterface -> execute ( worker ) ; * data = frame_worker_data -> data_end ; if ( worker -> had_error ) return update_error_state ( ctx , & frame_worker_data -> pbi -> common . error ) ; check_resync ( ctx , frame_worker_data -> pbi ) ; } else { VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_submit_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) vp9_frameworker_copy_context ( & ctx -> frame_workers [ ctx -> next_submit_worker_id ] , & ctx -> frame_workers [ ctx -> last_submit_worker_id ] ) ; frame_worker_data -> pbi -> ready_for_new_data = 0 ; if ( frame_worker_data -> scratch_buffer_size < data_sz ) { frame_worker_data -> scratch_buffer = ( uint8_t * ) vpx_realloc ( frame_worker_data -> scratch_buffer , data_sz ) ; if ( frame_worker_data -> scratch_buffer <S2SV_ModStart> NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>reallocate<S2SV_blank>scratch<S2SV_blank>buffer" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> scratch_buffer_size = data_sz ; } frame_worker_data -> data_size = data_sz ; memcpy ( frame_worker_data -> scratch_buffer , * data , data_sz ) ; frame_worker_data -> frame_decoded = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame <S2SV_ModEnd> = 1 <S2SV_ModStart> 1 ; frame_worker_data -> data = frame_worker_data -> scratch_buffer ; frame_worker_data -> user_priv = user_priv ; if ( ctx -> next_submit_worker_id != ctx -> last_submit_worker_id ) ctx -> last_submit_worker_id = ( ctx -> last_submit_worker_id + 1 ) % ctx -> num_frame_workers ; ctx -> next_submit_worker_id = ( ctx -> next_submit_worker_id + 1 ) % ctx -> num_frame_workers ; -- ctx -> available_threads ; worker -> had_error = 0 ; winterface -> launch ( worker ) ; } <S2SV_ModEnd> return VPX_CODEC_OK
<S2SV_ModStart> uint8_t * const <S2SV_ModStart> vpx_codec_err_t res <S2SV_ModEnd> ; uint32_t <S2SV_ModStart> ; uint32_t frame_sizes <S2SV_ModEnd> [ 8 <S2SV_ModStart> ; int frame_count <S2SV_ModEnd> ; if <S2SV_ModStart> == NULL && <S2SV_ModEnd> data_sz == <S2SV_ModStart> 0 ) { ctx -> flushed = 1 ; return VPX_CODEC_OK ; } ctx -> flushed = 0 ; if ( ctx -> frame_workers == NULL ) { const vpx_codec_err_t res = init_decoder ( ctx ) ; if ( res != VPX_CODEC_OK ) return res ; } res = vp9_parse_superframe_index <S2SV_ModEnd> ( data <S2SV_ModStart> data_sz , frame_sizes <S2SV_ModEnd> , & <S2SV_ModStart> , & frame_count , ctx -> decrypt_cb , ctx -> decrypt_state ) ; if ( res != VPX_CODEC_OK ) return res ; if ( ctx -> frame_parallel_decode ) { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; return VPX_CODEC_CORRUPT_FRAME ; } if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { if ( ctx -> available_threads == 0 ) { if ( ctx -> num_cache_frames < FRAME_CACHE_SIZE ) { wait_worker_and_cache_frame ( ctx ) ; } else { set_error_detail ( ctx , "Frame<S2SV_blank>output<S2SV_blank>cache<S2SV_blank>is<S2SV_blank>full." ) ; return VPX_CODEC_ERROR ; } } res = decode_one ( ctx , & data , data_sz , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; } } else { if ( frame_count > 0 ) { int i ; for ( i = 0 ; i < frame_count ; ++ i ) { const uint8_t * data_start_copy = data_start ; const uint32_t frame_size = frame_sizes [ i ] ; vpx_codec_err_t res ; if ( data_start < data || frame_size > ( uint32_t ) ( data_end - data_start ) ) { set_error_detail ( ctx , "Invalid<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>in<S2SV_blank>index" ) ; return VPX_CODEC_CORRUPT_FRAME ; } res = decode_one ( ctx , & data_start_copy , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; data_start += frame_size ; } } else { while ( data_start < data_end ) { const uint32_t frame_size = ( uint32_t ) ( data_end - data_start ) ; const vpx_codec_err_t res = decode_one ( ctx , & data_start , frame_size , user_priv , deadline ) ; if ( res != VPX_CODEC_OK ) return res ; while ( data_start < data_end <S2SV_ModEnd> ) { <S2SV_ModStart> marker = read_marker ( ctx -> decrypt_cb , ctx -> decrypt_state , data_start ) ; if <S2SV_ModEnd> ( marker <S2SV_ModStart> ( marker ) <S2SV_ModEnd> break ; <S2SV_ModStart> break ; ++ data_start ; } } } } <S2SV_ModEnd> return res
<S2SV_ModStart> ctx -> frame_workers != NULL ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_worker_interface ( ) -> end ( worker ) ; vp9_remove_common ( & frame_worker_data -> pbi -> common ) ; # if CONFIG_VP9_POSTPROC vp9_free_postproc_buffers ( & frame_worker_data -> pbi -> common ) ; # endif <S2SV_ModEnd> vp9_decoder_remove ( <S2SV_ModStart> vp9_decoder_remove ( frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> ) ; vpx_free ( frame_worker_data -> scratch_buffer ) ; # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & frame_worker_data -> stats_mutex ) ; pthread_cond_destroy ( & frame_worker_data -> stats_cond ) ; # endif vpx_free ( frame_worker_data ) ; } # if CONFIG_MULTITHREAD pthread_mutex_destroy ( & ctx -> buffer_pool -> pool_mutex ) ; # endif } if ( ctx -> buffer_pool ) { vp9_free_ref_frame_buffers ( ctx -> buffer_pool ) ; vp9_free_internal_frame_buffers ( & ctx -> buffer_pool -> int_frame_buffers ) ; } vpx_free ( ctx -> frame_workers ) ; vpx_free ( ctx -> buffer_pool ) ; <S2SV_ModEnd> vpx_free (
<S2SV_ModStart> ctx -> frame_parallel_decode && ctx -> available_threads > 0 && ! ctx -> flushed ) { return NULL ; } if ( ctx -> num_cache_frames > 0 ) { release_last_output_frame ( ctx ) ; ctx -> last_show_frame = ctx -> frame_cache [ ctx -> frame_cache_read ] . fb_idx ; if ( ctx -> need_resync ) return NULL ; img = & ctx -> frame_cache [ ctx -> frame_cache_read ] . img ; ctx -> frame_cache_read = ( ctx -> frame_cache_read + 1 ) % FRAME_CACHE_SIZE ; -- ctx -> num_cache_frames ; return img ; } if <S2SV_ModEnd> ( * <S2SV_ModStart> * iter == NULL && ctx -> frame_workers != NULL ) { do { YV12_BUFFER_CONFIG sd ; vp9_ppflags_t flags = { 0 , 0 , 0 } ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; VPxWorker * const worker = & ctx -> frame_workers [ ctx -> next_output_worker_id ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; ctx -> next_output_worker_id = ( ctx -> next_output_worker_id + 1 ) % ctx -> num_frame_workers ; if ( ctx -> base . init_flags & VPX_CODEC_USE_POSTPROC ) set_ppflags ( ctx , & flags ) ; if ( winterface -> sync ( worker ) ) { if ( frame_worker_data -> received_frame == 1 ) { ++ ctx -> available_threads ; frame_worker_data -> received_frame = 0 ; check_resync ( ctx , frame_worker_data -> pbi ) ; } if ( vp9_get_raw_frame ( frame_worker_data -> pbi , & sd , & flags ) == 0 ) { VP9_COMMON * const cm = & frame_worker_data -> pbi -> common ; RefCntBuffer * const frame_bufs = cm -> buffer_pool -> frame_bufs ; release_last_output_frame ( ctx ) ; ctx -> last_show_frame = frame_worker_data -> pbi -> common . new_fb_idx ; if ( ctx -> need_resync ) return NULL ; yuvconfig2image ( & ctx -> img , & sd , frame_worker_data -> user_priv ) ; ctx -> img . fb_priv = frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer . priv ; img = & ctx -> img ; return img ; } } else { frame_worker_data -> received_frame = 0 ; ++ ctx -> available_threads ; ctx -> need_resync = 1 ; if ( ctx -> flushed != 1 ) return NULL ; } } while ( ctx -> next_output_worker_id != ctx -> next_submit_worker_id ) ; } return NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { ( void ) data ; <S2SV_ModStart> vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 <S2SV_ModEnd> , sizeof <S2SV_ModStart> ( * priv <S2SV_ModEnd> ) ) <S2SV_ModStart> if ( priv <S2SV_ModEnd> == NULL <S2SV_ModStart> return VPX_CODEC_MEM_ERROR <S2SV_ModEnd> ; ctx <S2SV_ModStart> * ) priv <S2SV_ModEnd> ; ctx <S2SV_ModStart> init_flags ; priv -> si . sz = sizeof ( priv -> si ) ; priv -> flushed = 0 ; priv -> frame_parallel_decode = ( ctx -> config . dec && ( ctx -> config . dec -> threads > 1 ) && ( ctx -> init_flags & VPX_CODEC_USE_FRAME_THREADING ) ) ? 1 : 0 ; <S2SV_ModStart> ) { priv <S2SV_ModEnd> -> cfg <S2SV_ModStart> = & priv <S2SV_ModEnd> -> cfg
<S2SV_ModStart> ) { return decoder_peek_si_internal <S2SV_ModEnd> ( data <S2SV_ModStart> ( data , <S2SV_ModEnd> data_sz , <S2SV_ModStart> data_sz , si <S2SV_ModEnd> , NULL <S2SV_ModStart> , NULL , NULL ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ctx -> frame_workers <S2SV_ModEnd> == NULL
<S2SV_ModStart> ) { int i ; for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> = & frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> common ; BufferPool * const pool = cm -> buffer_pool ; <S2SV_ModStart> new_fb_idx = INVALID_IDX ; cm -> byte_alignment = ctx -> byte_alignment ; cm -> skip_loop_filter = ctx -> skip_loop_filter <S2SV_ModEnd> ; if <S2SV_ModStart> ) { pool <S2SV_ModEnd> -> get_fb_cb <S2SV_ModStart> get_ext_fb_cb ; pool <S2SV_ModEnd> -> release_fb_cb <S2SV_ModStart> release_ext_fb_cb ; pool <S2SV_ModEnd> -> cb_priv <S2SV_ModStart> else { pool <S2SV_ModEnd> -> get_fb_cb <S2SV_ModStart> vp9_get_frame_buffer ; pool <S2SV_ModEnd> -> release_fb_cb <S2SV_ModStart> ( & pool <S2SV_ModEnd> -> int_frame_buffers <S2SV_ModStart> ) ; pool <S2SV_ModEnd> -> cb_priv <S2SV_ModStart> = & pool <S2SV_ModEnd> -> int_frame_buffers <S2SV_ModStart> } } }
<S2SV_ModStart> <S2SV_null> static vpx_codec_err_t <S2SV_ModEnd> init_decoder ( <S2SV_ModStart> ) { int i ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; ctx -> last_show_frame = - 1 ; ctx -> next_submit_worker_id = 0 ; ctx -> last_submit_worker_id = 0 ; ctx -> next_output_worker_id = 0 ; ctx -> frame_cache_read = 0 ; ctx -> frame_cache_write = 0 ; ctx -> num_cache_frames = 0 ; ctx -> need_resync = 1 ; ctx -> num_frame_workers = ( ctx -> frame_parallel_decode == 1 ) ? <S2SV_ModEnd> ctx -> <S2SV_ModStart> . threads : 1 ; if ( ctx -> num_frame_workers > MAX_DECODE_THREADS ) ctx -> num_frame_workers = MAX_DECODE_THREADS ; ctx -> available_threads = ctx -> num_frame_workers ; ctx -> flushed = 0 ; ctx -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( ctx -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & ctx -> buffer_pool -> pool_mutex , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>buffer<S2SV_blank>pool<S2SV_blank>mutex" ) ; return VPX_CODEC_MEM_ERROR ; } # endif ctx -> frame_workers = ( VPxWorker * ) vpx_malloc ( ctx -> num_frame_workers * sizeof ( * ctx -> frame_workers ) ) ; if ( ctx -> frame_workers == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_workers" ) ; return VPX_CODEC_MEM_ERROR ; } for ( i = 0 ; i < ctx -> num_frame_workers ; ++ i ) { VPxWorker * const worker = & ctx -> frame_workers [ i ] ; FrameWorkerData * frame_worker_data = NULL ; winterface -> init ( worker ) ; worker -> data1 = vpx_memalign ( 32 , sizeof ( FrameWorkerData ) ) ; if ( worker -> data1 == NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> vp9_decoder_create ( ctx -> buffer_pool ) ; if ( frame_worker_data <S2SV_ModEnd> -> pbi <S2SV_ModStart> NULL ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data" ) ; return VPX_CODEC_MEM_ERROR ; } frame_worker_data -> pbi -> frame_worker_owner = worker ; frame_worker_data -> worker_id = i ; frame_worker_data -> scratch_buffer = NULL ; frame_worker_data -> scratch_buffer_size = 0 ; frame_worker_data -> frame_context_ready = 0 ; frame_worker_data -> received_frame = 0 ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & frame_worker_data -> stats_mutex , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>mutex" ) ; return VPX_CODEC_MEM_ERROR ; } if ( pthread_cond_init ( & frame_worker_data -> stats_cond , NULL ) ) { set_error_detail ( ctx , "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>frame_worker_data<S2SV_blank>cond" ) ; return VPX_CODEC_MEM_ERROR ; } # endif frame_worker_data -> pbi -> max_threads = ( ctx -> frame_parallel_decode == 0 ) ? ctx -> cfg . threads : 0 ; frame_worker_data -> pbi -> inv_tile_order = ctx -> invert_tile_order ; frame_worker_data -> pbi -> frame_parallel_decode = ctx -> frame_parallel_decode ; frame_worker_data -> pbi -> common . frame_parallel_decode = ctx -> frame_parallel_decode ; worker -> hook = ( VPxWorkerHook ) frame_worker_hook ; if ( ! winterface -> reset ( worker ) ) { set_error_detail ( ctx , "Frame<S2SV_blank>Worker<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed" ) ; return VPX_CODEC_MEM_ERROR ; } } <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; return VPX_CODEC_OK ;
<S2SV_ModStart> post_proc_flag = <S2SV_ModEnd> ctx -> <S2SV_ModStart> noise_level ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> error_code ) set_error_detail ( ctx , <S2SV_ModEnd> error -> <S2SV_ModStart> : NULL )
<S2SV_ModStart> static const SvcInternal_t <S2SV_ModEnd> * get_const_svc_internal <S2SV_ModStart> ( const SvcInternal_t <S2SV_ModEnd> * )
<S2SV_ModStart> <S2SV_null> static SvcInternal_t <S2SV_ModEnd> * get_svc_internal <S2SV_ModStart> ) { SvcInternal_t <S2SV_ModEnd> * const <S2SV_ModStart> = ( SvcInternal_t <S2SV_ModEnd> * ) <S2SV_ModStart> return ( SvcInternal_t <S2SV_ModEnd> * )
<S2SV_ModStart> input_ptr ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; vpx_codec_err_t res = VPX_CODEC_OK ; int i , alt_ref_enabled = 0 <S2SV_ModEnd> ; if <S2SV_ModStart> strcmp ( "spatial-layers" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( "temporal-layers" , option_name ) == 0 ) { svc_ctx -> temporal_layers = atoi ( option_value ) ; } else if ( strcmp ( "scale-factors" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , SCALE_FACTOR , option_value , si -> svc_params . scaling_factor_num , si -> svc_params . scaling_factor_den <S2SV_ModEnd> ) ; <S2SV_ModStart> strcmp ( "max-quantizers" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . max_quantizers , NULL <S2SV_ModEnd> ) ; <S2SV_ModStart> strcmp ( "min-quantizers" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , QUANTIZER , option_value , si -> svc_params . min_quantizers , NULL <S2SV_ModEnd> ) ; <S2SV_ModStart> break ; } else if ( strcmp ( "auto-alt-refs" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , AUTO_ALT_REF , option_value , si -> enable_auto_alt_ref , NULL <S2SV_ModEnd> ) ; <S2SV_ModStart> break ; } else if ( strcmp ( "bitrates" , option_name ) == 0 ) { res = parse_layer_options_from_string ( svc_ctx , BITRATE , option_value , si -> bitrates , NULL ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( "multi-frame-contexts" , option_name ) == 0 ) { si -> use_multiple_frame_contexts = atoi ( option_value ) <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { if ( si -> svc_params . max_quantizers [ i ] > MAX_QUANTIZER || si -> svc_params . max_quantizers [ i ] < 0 || si -> svc_params . min_quantizers [ i ] > si -> svc_params . max_quantizers [ i ] || si -> svc_params . min_quantizers [ i ] < 0 ) res = VPX_CODEC_INVALID_PARAM ; } if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) alt_ref_enabled += si -> enable_auto_alt_ref [ i ] ; if ( alt_ref_enabled > REF_FRAMES - svc_ctx -> spatial_layers ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "svc:<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>ref:<S2SV_blank>Maxinum<S2SV_blank>%d(REF_FRAMES<S2SV_blank>-<S2SV_blank>layers)<S2SV_blank>layers<S2SV_blank>could" "enabled<S2SV_blank>auto<S2SV_blank>alt<S2SV_blank>reference<S2SV_blank>frame,<S2SV_blank>but<S2SV_blank>%<S2SV_blank>layers<S2SV_blank>are<S2SV_blank>enabled\\n" , REF_FRAMES - svc_ctx -> spatial_layers , alt_ref_enabled ) ; res = VPX_CODEC_INVALID_PARAM ; }
<S2SV_ModStart> svc_ctx , SVC_LOG_LEVEL <S2SV_ModEnd> level , <S2SV_ModStart> ap ; SvcInternal_t <S2SV_ModEnd> * const
<S2SV_ModStart> ) { SvcInternal_t <S2SV_ModEnd> * const <S2SV_ModStart> = ( SvcInternal_t <S2SV_ModEnd> * )
<S2SV_ModStart> int number_of_frames <S2SV_ModEnd> ; int <S2SV_ModStart> y_scale ; SvcInternal_t <S2SV_ModEnd> * const <S2SV_ModStart> ) ; number_of_frames = si -> psnr_pkt_received <S2SV_ModEnd> ; if <S2SV_ModStart> if ( number_of_frames <S2SV_ModEnd> <= 0 <S2SV_ModStart> ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> i < svc_ctx -> spatial_layers <S2SV_ModEnd> ; ++ <S2SV_ModStart> ) { <S2SV_ModEnd> svc_log ( <S2SV_ModStart> si -> psnr_pkt_received <S2SV_ModEnd> = 0
<S2SV_ModStart> cx_pkt ; SvcInternal_t <S2SV_ModEnd> * const <S2SV_ModStart> ; } svc_log_reset ( svc_ctx ) ; res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration <S2SV_ModEnd> , 0 <S2SV_ModStart> 0 , <S2SV_ModEnd> deadline ) <S2SV_ModStart> ) { # if VPX_ENCODER_ABI_VERSION > ( 5 + VPX_CODEC_ABI_VERSION ) # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_PSNR <S2SV_ModEnd> : { <S2SV_ModStart> : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) { int j ; svc_log ( svc_ctx , SVC_LOG_DEBUG , "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>PSNR(Total/Y/U/V):<S2SV_blank>" "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . psnr [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . psnr [ 3 ] ) ; svc_log ( svc_ctx , SVC_LOG_DEBUG , "SVC<S2SV_blank>frame:<S2SV_blank>%d,<S2SV_blank>layer:<S2SV_blank>%d,<S2SV_blank>SSE(Total/Y/U/V):<S2SV_blank>" "%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank><S2SV_blank>%2.3f<S2SV_blank>\\n" , si -> psnr_pkt_received , i , cx_pkt -> data . layer_psnr [ i ] . sse [ 0 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 1 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 2 ] , cx_pkt -> data . layer_psnr [ i ] . sse [ 3 ] ) ; for ( j = 0 ; j < COMPONENTS ; ++ j ) { si -> psnr_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . psnr [ j ] ; si -> sse_sum [ i ] [ j ] += cx_pkt -> data . layer_psnr [ i ] . sse [ j ] ; } } ++ si -> psnr_pkt_received ; break ; } case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : { int i ; for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) <S2SV_ModEnd> si -> <S2SV_ModStart> bytes_sum [ i <S2SV_ModEnd> ] += <S2SV_ModStart> ] += cx_pkt -> data . layer_sizes [ i ] ; break ; } # endif # endif default : { break ; } } } <S2SV_ModEnd> return VPX_CODEC_OK <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> { const SvcInternal_t <S2SV_ModEnd> * const
<S2SV_ModStart> ) { <S2SV_ModEnd> vpx_codec_err_t res <S2SV_ModStart> res ; int i ; SvcInternal_t <S2SV_ModEnd> * const <S2SV_ModStart> ; } if ( svc_ctx -> temporal_layering_mode == 3 ) { svc_ctx -> temporal_layers = 3 ; } else if ( svc_ctx -> temporal_layering_mode == 2 ) { svc_ctx -> temporal_layers = 2 ; } for ( i = 0 ; i < VPX_SS_MAX_LAYERS ; ++ i ) { si -> svc_params . max_quantizers [ i ] = MAX_QUANTIZER ; si -> svc_params . min_quantizers [ i ] = 0 ; si -> svc_params . scaling_factor_num [ i ] = DEFAULT_SCALE_FACTORS_NUM [ i ] ; si -> svc_params . scaling_factor_den [ i ] = DEFAULT_SCALE_FACTORS_DEN [ i ] ; } <S2SV_ModStart> res = parse_options ( svc_ctx , si -> options <S2SV_ModEnd> ) ; <S2SV_ModStart> res ; if ( svc_ctx -> spatial_layers < 1 ) svc_ctx -> spatial_layers = 1 ; if ( svc_ctx -> spatial_layers > VPX_SS_MAX_LAYERS ) svc_ctx -> spatial_layers = VPX_SS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers < 1 ) svc_ctx -> temporal_layers = 1 ; if ( svc_ctx -> temporal_layers > VPX_TS_MAX_LAYERS ) svc_ctx -> temporal_layers = VPX_TS_MAX_LAYERS ; if ( svc_ctx -> temporal_layers * svc_ctx -> spatial_layers > VPX_MAX_LAYERS ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "spatial<S2SV_blank>layers<S2SV_blank>*<S2SV_blank>temporal<S2SV_blank>layers<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>number<S2SV_blank>of<S2SV_blank>" "allowed<S2SV_blank>layers<S2SV_blank>of<S2SV_blank>%d\\n" , svc_ctx -> spatial_layers * svc_ctx -> temporal_layers , ( int ) VPX_MAX_LAYERS ) ; return VPX_CODEC_INVALID_PARAM ; } assign_layer_bitrates ( svc_ctx , enc_cfg ) ; # if CONFIG_SPATIAL_SVC for ( i = 0 ; i < svc_ctx -> spatial_layers ; ++ i ) enc_cfg -> ss_enable_auto_alt_ref [ i ] = si -> enable_auto_alt_ref [ i ] ; # endif if ( svc_ctx -> temporal_layers > 1 ) { int i ; for ( i = 0 ; i < svc_ctx -> temporal_layers ; ++ i ) { enc_cfg -> ts_target_bitrate [ i ] = enc_cfg -> rc_target_bitrate / svc_ctx -> temporal_layers ; enc_cfg -> ts_rate_decimator [ i ] = 1 << ( svc_ctx -> temporal_layers - 1 - i ) ; } } if ( svc_ctx -> threads ) enc_cfg -> g_threads = svc_ctx -> threads ; enc_cfg -> ss_number_layers = svc_ctx -> spatial_layers ; enc_cfg -> ts_number_layers = svc_ctx -> temporal_layers ; if ( enc_cfg -> rc_end_usage == VPX_CBR ) { enc_cfg -> rc_resize_allowed = 0 ; enc_cfg -> rc_min_quantizer = 2 ; enc_cfg -> rc_max_quantizer = 63 ; enc_cfg -> rc_undershoot_pct = 50 ; enc_cfg -> rc_overshoot_pct = 50 ; enc_cfg -> rc_buf_initial_sz = 20 ; enc_cfg -> rc_buf_optimal_sz = 600 ; enc_cfg -> rc_buf_sz = 1000 ; } if ( enc_cfg -> g_error_resilient == 0 && si -> use_multiple_frame_contexts == 0 ) enc_cfg -> g_error_resilient = 1 ; <S2SV_ModStart> res = vpx_codec_enc_init ( codec_ctx , iface , enc_cfg , VPX_CODEC_USE_PSNR <S2SV_ModEnd> ) ; <S2SV_ModStart> VPX_CODEC_OK ) { svc_log ( svc_ctx , SVC_LOG_ERROR , "svc_enc_init<S2SV_blank>error\\n" ) ; <S2SV_ModEnd> return res <S2SV_ModStart> res ; } vpx_codec_control <S2SV_ModEnd> ( codec_ctx <S2SV_ModStart> codec_ctx , VP9E_SET_SVC , 1 ) ; <S2SV_ModEnd> vpx_codec_control ( <S2SV_ModStart> codec_ctx , VP9E_SET_SVC_PARAMETERS , & si -> svc_params <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { SvcInternal_t <S2SV_ModEnd> * si <S2SV_ModStart> = ( SvcInternal_t <S2SV_ModEnd> * ) <S2SV_ModStart> ( si <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { SvcInternal_t <S2SV_ModEnd> * const
<S2SV_ModStart> fn ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> -> priv <S2SV_ModEnd> , ap
<S2SV_ModStart> else { <S2SV_ModEnd> ctx -> <S2SV_ModStart> destroy ( ( vpx_codec_alg_priv_t * ) <S2SV_ModStart> -> priv <S2SV_ModEnd> ) ;
<S2SV_ModStart> iface , const <S2SV_ModStart> flags & <S2SV_ModEnd> VPX_CODEC_USE_POSTPROC ) <S2SV_ModStart> res = <S2SV_ModEnd> ctx -> <S2SV_ModStart> ; } <S2SV_ModEnd> } return
<S2SV_ModStart> data_sz ) || ( data && ! data_sz ) <S2SV_ModStart> decode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , data
<S2SV_ModStart> get_frame ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter
<S2SV_ModStart> get_si ( get_alg_priv ( ctx ) <S2SV_ModEnd> , si
<S2SV_ModStart> set_fb_fn ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cb_get
<S2SV_ModStart> * map ; int i <S2SV_ModStart> for ( i = 0 ; i < iface -> enc . cfg_map_count ; ++ i ) { <S2SV_ModStart> . cfg_maps + i ; <S2SV_ModEnd> if (
<S2SV_ModStart> cfg_set ( get_alg_priv ( ctx ) <S2SV_ModEnd> , cfg
<S2SV_ModStart> flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) <S2SV_ModStart> if ( <S2SV_ModEnd> res )
<S2SV_ModStart> iface , const <S2SV_ModStart> flags & <S2SV_ModEnd> VPX_CODEC_USE_PSNR ) <S2SV_ModStart> ; } <S2SV_ModEnd> } return
<S2SV_ModStart> encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img <S2SV_ModStart> encode ( get_alg_priv ( ctx ) <S2SV_ModEnd> , img
<S2SV_ModStart> get_cx_data ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter
<S2SV_ModStart> get_glob_hdrs ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> get_preview ( get_alg_priv ( ctx ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> bps ; unsigned int stride_in_bytes ; <S2SV_ModStart> break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; <S2SV_ModStart> VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : <S2SV_ModStart> : case VPX_IMG_FMT_I440 : case <S2SV_ModStart> case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 <S2SV_ModStart> ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_ModStart> ) { const uint64_t alloc_size = <S2SV_ModEnd> ( fmt <S2SV_ModStart> ) ? ( uint64_t ) <S2SV_ModStart> 8 : ( uint64_t ) <S2SV_ModStart> * s ; if ( alloc_size != ( size_t ) alloc_size <S2SV_ModEnd> ) goto <S2SV_ModStart> img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 <S2SV_ModEnd> ; img <S2SV_ModStart> ] = stride_in_bytes <S2SV_ModEnd> ; img <S2SV_ModStart> ] = stride_in_bytes <S2SV_ModEnd> >> xcs
<S2SV_ModStart> img_data_owner ) vpx_free <S2SV_ModEnd> ( img
<S2SV_ModStart> else { const int bytes_per_sample = ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> + x * bytes_per_sample <S2SV_ModStart> + x * bytes_per_sample + <S2SV_ModEnd> y * <S2SV_ModStart> ] = data <S2SV_ModEnd> + ( <S2SV_ModStart> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y <S2SV_ModStart> ] = data <S2SV_ModEnd> + ( <S2SV_ModStart> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y <S2SV_ModStart> ] = data <S2SV_ModEnd> + ( <S2SV_ModStart> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y <S2SV_ModStart> ] = data <S2SV_ModEnd> + ( <S2SV_ModStart> x_chroma_shift ) * bytes_per_sample + <S2SV_ModEnd> ( y
<S2SV_ModStart> x ) memset <S2SV_ModEnd> ( x
<S2SV_ModStart> ) ; free <S2SV_ModEnd> ( addr <S2SV_ModStart> ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> NULL ; <S2SV_ModEnd> addr = <S2SV_ModStart> addr = malloc <S2SV_ModEnd> ( size <S2SV_ModStart> ) ; <S2SV_ModEnd> if (
<S2SV_ModStart> NULL ; <S2SV_ModEnd> new_addr = <S2SV_ModStart> new_addr = realloc <S2SV_ModEnd> ( addr <S2SV_ModStart> ) ; <S2SV_ModEnd> if (
<S2SV_ModStart> # if <S2SV_ModEnd> HAVE_MEDIA flags <S2SV_ModStart> if HAVE_NEON || HAVE_NEON_ASM
<S2SV_ModStart> src_pitch ; memcpy <S2SV_ModEnd> ( dest
<S2SV_ModStart> interpolation ) memcpy <S2SV_ModEnd> ( temp_area <S2SV_ModStart> else { memcpy <S2SV_ModEnd> ( temp_area <S2SV_ModStart> ; } memcpy <S2SV_ModEnd> ( temp_area
<S2SV_ModStart> ++ ) memset <S2SV_ModEnd> ( dst <S2SV_ModStart> ++ ) memcpy <S2SV_ModEnd> ( dst <S2SV_ModStart> ++ ) memset <S2SV_ModEnd> ( dst <S2SV_ModStart> ++ ) memcpy <S2SV_ModEnd> ( dst <S2SV_ModStart> ++ ) memset <S2SV_ModEnd> ( dst <S2SV_ModStart> ++ ) memcpy <S2SV_ModEnd> ( dst
<S2SV_ModStart> ; } memset <S2SV_ModEnd> ( ybf
<S2SV_ModStart> ybf -> uv_crop_width = ( width + 1 ) / 2 ; ybf -> uv_crop_height = ( height + 1 ) / 2 ; ybf ->
<S2SV_ModStart> ) { memset <S2SV_ModEnd> ( dst_ptr1 <S2SV_ModStart> ) ; memset <S2SV_ModEnd> ( dst_ptr2 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dst_ptr1 <S2SV_ModStart> ) { memcpy <S2SV_ModEnd> ( dst_ptr2
<S2SV_ModStart> # endif # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { assert ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ; <S2SV_ModStart> ) { memcpy_short_addr <S2SV_ModEnd> ( dst <S2SV_ModStart> ) { memcpy_short_addr <S2SV_ModEnd> ( dst <S2SV_ModStart> ) { memcpy_short_addr <S2SV_ModEnd> ( dst <S2SV_ModStart> ) ; return ; } else { assert ( ! ( dst_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) ) ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } src = src_ybc -> u_buffer ; dst = dst_ybc -> u_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } src = src_ybc -> v_buffer ; dst = dst_ybc -> v_buffer ; for ( row = 0 ; row < src_ybc -> uv_height ; ++ row ) { memcpy ( dst , src , src_ybc -> uv_width ) ; src += src_ybc -> uv_stride ; dst += dst_ybc -> uv_stride ; } vp8_yv12_extend_frame_borders_c ( dst_ybc ) ;
<S2SV_ModStart> ) { const int uv_border = ybf -> border / 2 ; assert ( ybf -> border % 2 == 0 ) ; <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( ybf -> flags & YV12_FLAG_HIGHBITDEPTH ) { extend_plane_high ( ybf -> y_buffer , ybf -> y_stride , ybf -> y_crop_width , ybf -> y_crop_height , ybf -> border , ybf -> border , ybf -> border + ybf -> y_height - ybf -> y_crop_height , ybf -> border + ybf -> y_width - ybf -> y_crop_width ) ; extend_plane_high ( ybf -> u_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; extend_plane_high ( ybf -> v_buffer , ybf -> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width ) ; return ; } # endif <S2SV_ModStart> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> ) ; <S2SV_ModStart> uv_stride , ybf -> uv_crop_width , ybf -> uv_crop_height , uv_border , uv_border , uv_border + ybf -> uv_height - ybf -> uv_crop_height , uv_border + ybf -> uv_width - ybf -> uv_crop_width <S2SV_ModEnd> ) ;
<S2SV_ModStart> y_buffer ; # if CONFIG_VP9_HIGHBITDEPTH if ( src_ybc -> flags & YV12_FLAG_HIGHBITDEPTH ) { const uint16_t * src16 = CONVERT_TO_SHORTPTR ( src ) ; uint16_t * dst16 = CONVERT_TO_SHORTPTR ( dst ) ; <S2SV_ModStart> ) { memcpy ( dst16 , src16 , src_ybc -> y_width * sizeof ( uint16_t ) ) ; src16 += src_ybc -> y_stride ; dst16 += dst_ybc -> y_stride ; } return ; } # endif for ( row = 0 ; row < src_ybc -> y_height ; ++ row ) { memcpy <S2SV_ModEnd> ( dst
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ) ; break ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> * ) calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> = 0 , frame_parallel = 0 <S2SV_ModStart> int ec_enabled = 0 ; int keep_going <S2SV_ModStart> 1 ; int opt_yv12 = 0 ; int opt_i420 = 0 ; <S2SV_ModStart> { 0 , 0 , 0 } ; # if CONFIG_VP9_HIGHBITDEPTH int output_bit_depth = 0 ; # endif <S2SV_ModEnd> # if <S2SV_ModStart> NULL ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * img_shifted = NULL ; # endif <S2SV_ModStart> , got_data , flush_decoder = 0 <S2SV_ModStart> { 0 , NULL <S2SV_ModStart> = { NULL , NULL <S2SV_ModEnd> } ; <S2SV_ModStart> VpxInputContext vpx_input_ctx ; # if CONFIG_WEBM_IO <S2SV_ModEnd> struct WebmInputContext <S2SV_ModStart> WebmInputContext webm_ctx ; memset ( & ( webm_ctx ) , 0 , sizeof ( webm_ctx ) ) <S2SV_ModEnd> ; input <S2SV_ModStart> input . webm_ctx = & webm_ctx ; # endif input . <S2SV_ModStart> & vpx_input_ctx <S2SV_ModEnd> ; exec_name <S2SV_ModStart> 1 ; opt_yv12 = 1 ; # if CONFIG_VP9_HIGHBITDEPTH output_bit_depth = 8 ; # endif <S2SV_ModStart> 0 ; opt_i420 = 1 ; <S2SV_ModStart> , & rawvideo , argi ) ) { use_y4m = 0 ; } else if ( arg_match ( & arg , & <S2SV_ModStart> ) ; # if CONFIG_VP9_DECODER || CONFIG_VP10_DECODER <S2SV_ModStart> , & frameparallelarg , argi ) ) frame_parallel = 1 ; # endif else if ( arg_match ( & arg , & <S2SV_ModStart> ) ; else if ( arg_match ( & arg , & continuearg , argi ) ) keep_going = 1 ; # if CONFIG_VP9_HIGHBITDEPTH else if ( arg_match ( & arg , & outbitdeptharg , argi ) ) { output_bit_depth = arg_parse_uint ( & arg ) ; } # endif <S2SV_ModStart> fn ) { free ( argv ) ; <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>input<S2SV_blank>file<S2SV_blank>\'%s\'" <S2SV_ModEnd> , strcmp <S2SV_ModStart> "stdin" ) <S2SV_ModEnd> ; } <S2SV_ModStart> , "YUV4MPEG2<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>output<S2SV_blank>patterns," "<S2SV_blank>try<S2SV_blank>--i420<S2SV_blank>or<S2SV_blank>--yv12<S2SV_blank>or<S2SV_blank>--rawvideo.\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> 0 ) | ( frame_parallel ? VPX_CODEC_USE_FRAME_THREADING : 0 ) <S2SV_ModStart> interface -> codec_interface ( ) , <S2SV_ModEnd> & cfg <S2SV_ModStart> int corrupted = 0 <S2SV_ModStart> ) ; if ( ! keep_going ) <S2SV_ModStart> ; } else { flush_decoder = 1 ; } } else { flush_decoder = 1 ; <S2SV_ModStart> ) ; if ( flush_decoder ) { if ( vpx_codec_decode ( & decoder , NULL , 0 , NULL , 0 ) ) { warn ( "Failed<S2SV_blank>to<S2SV_blank>flush<S2SV_blank>decoder:<S2SV_blank>%s" , vpx_codec_error ( & decoder ) ) ; } } <S2SV_ModStart> if ( ! frame_parallel && <S2SV_ModStart> ) ; if ( ! keep_going ) <S2SV_ModStart> NULL , img -> fmt <S2SV_ModEnd> , display_width <S2SV_ModStart> 16 ) ; scaled_img -> bit_depth = img -> bit_depth <S2SV_ModStart> ) { # if CONFIG_LIBYUV libyuv_scale <S2SV_ModEnd> ( img <S2SV_ModStart> scaled_img ; # else fprintf ( stderr , "Failed<S2SV_blank><S2SV_blank>to<S2SV_blank>scale<S2SV_blank>output<S2SV_blank>frame:<S2SV_blank>%s.\\n" "Scaling<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>" "To<S2SV_blank>enable<S2SV_blank>scaling,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , vpx_codec_error ( & decoder ) ) ; return EXIT_FAILURE ; # endif } } # if CONFIG_VP9_HIGHBITDEPTH if ( ! output_bit_depth ) { output_bit_depth = img -> bit_depth ; } if ( output_bit_depth != img -> bit_depth ) { const vpx_img_fmt_t shifted_fmt = output_bit_depth == 8 ? img -> fmt ^ ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) : img -> fmt | VPX_IMG_FMT_HIGHBITDEPTH ; if ( img_shifted && img_shifted_realloc_required ( img , img_shifted , shifted_fmt ) ) { vpx_img_free ( img_shifted ) ; img_shifted = NULL ; } if ( ! img_shifted ) { img_shifted = vpx_img_alloc ( NULL , shifted_fmt , img -> d_w , img -> d_h , 16 ) ; img_shifted -> bit_depth = output_bit_depth ; } if ( output_bit_depth > img -> bit_depth ) { vpx_img_upshift ( img_shifted , img , output_bit_depth - img -> bit_depth ) ; } else { vpx_img_downshift ( img_shifted , img , img -> bit_depth - output_bit_depth ) ; } img = img_shifted ; } # endif <S2SV_ModEnd> if ( <S2SV_ModStart> if ( img -> fmt == VPX_IMG_FMT_I440 || img -> fmt == VPX_IMG_FMT_I44016 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>y4m<S2SV_blank>output<S2SV_blank>for<S2SV_blank>440<S2SV_blank>sampling.\\n" ) ; goto fail ; } if ( <S2SV_ModStart> -> fmt , img -> bit_depth <S2SV_ModStart> } } else { if ( frame_out == 1 ) { if ( opt_i420 ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>i420<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; goto fail ; } } if ( opt_yv12 ) { if ( ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) || img -> bit_depth != 8 ) { fprintf ( stderr , "Cannot<S2SV_blank>produce<S2SV_blank>yv12<S2SV_blank>output<S2SV_blank>for<S2SV_blank>bit-stream.\\n" ) ; goto fail ; } } } } <S2SV_ModStart> } } <S2SV_ModEnd> } if <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img_shifted ) vpx_img_free ( img_shifted ) ; # endif
<S2SV_ModStart> fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>output<S2SV_blank>file<S2SV_blank>\'%s\'" <S2SV_ModEnd> , name
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 )
<S2SV_ModStart> usage_exit ( void <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> y ; # if CONFIG_VP9_HIGHBITDEPTH const int bytes_per_sample = ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; # else const int bytes_per_sample = 1 ; # endif <S2SV_ModStart> buf , bytes_per_sample <S2SV_ModEnd> , w
<S2SV_ModStart> -> ebml ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { uint32_t l_w = img1 -> d_w ; <S2SV_ModEnd> uint32_t c_w <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( img1 -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { l_w *= 2 ; c_w *= 2 ; } # endif <S2SV_ModStart> ] , l_w <S2SV_ModEnd> ) ==
<S2SV_ModStart> num ; # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> && ( <S2SV_ModStart> if ( img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( <S2SV_ModStart> img ) { <S2SV_ModStart> NULL , VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , "%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> , cfg <S2SV_ModStart> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , "Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n" "Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n" "To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n" , stream -> index ) ; # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ; static int64_t <S2SV_ModEnd> ivf_header_pos = <S2SV_ModStart> ) { <S2SV_ModEnd> write_webm_block ( <S2SV_ModStart> ) { const int64_t <S2SV_ModEnd> currpos = <S2SV_ModStart> break ; # if CONFIG_FP_MB_STATS case VPX_CODEC_FPMB_STATS_PKT : stats_write ( & stream -> fpmb_stats , pkt -> data . firstpass_mb_stats . buf , pkt -> data . firstpass_mb_stats . sz ) ; stream -> nbytes += pkt -> data . raw . sz ; break ; # endif
<S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> codec -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> decoder -> codec_interface <S2SV_ModEnd> ( )
<S2SV_ModStart> raw ; # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t raw_shift ; int allocated_raw_shift = 0 ; int use_16bit_internal = 0 ; int input_shift = 0 ; # endif <S2SV_ModStart> VpxInputContext input <S2SV_ModEnd> ; struct <S2SV_ModStart> 0 ; memset ( & input , 0 , sizeof ( input ) ) ; <S2SV_ModStart> input . only_i420 <S2SV_ModEnd> = 1 <S2SV_ModStart> input . bit_depth = 0 <S2SV_ModEnd> ; argv <S2SV_ModStart> ) ; switch ( global . color_type ) { case I420 : input . fmt = VPX_IMG_FMT_I420 ; break ; case I422 : input . fmt = VPX_IMG_FMT_I422 ; break ; case I444 : input . fmt = VPX_IMG_FMT_I444 ; break ; case I440 : input . fmt = VPX_IMG_FMT_I440 ; break ; case YV12 : input . fmt = VPX_IMG_FMT_YV12 ; break ; } <S2SV_ModStart> 1 ; int64_t <S2SV_ModEnd> lagged_count = <S2SV_ModStart> height ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ) ; if ( ! input . bit_depth ) { FOREACH_STREAM ( { if ( stream -> config . cfg . g_input_bit_depth ) input . bit_depth = stream -> config . cfg . g_input_bit_depth ; else input . bit_depth = stream -> config . cfg . g_input_bit_depth = ( int ) stream -> config . cfg . g_bit_depth ; } ) ; if ( input . bit_depth > 8 ) input . fmt |= VPX_IMG_FMT_HIGHBITDEPTH ; } else { FOREACH_STREAM ( { stream -> config . cfg . g_input_bit_depth = input . bit_depth ; } ) ; } <S2SV_ModStart> raw , input . fmt , <S2SV_ModEnd> input . <S2SV_ModStart> & global , & input . pixel_aspect_ratio <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global . codec -> name , "vp9" ) == 0 || strcmp ( global . codec -> name , "vp10" ) == 0 ) { FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) { use_16bit_internal = 1 ; } if ( stream -> config . cfg . g_profile == 0 ) { input_shift = 0 ; } else { input_shift = ( int ) stream -> config . cfg . g_bit_depth - stream -> config . cfg . g_input_bit_depth ; } } ) ; } # endif <S2SV_ModStart> ) ; <S2SV_ModEnd> } } <S2SV_ModStart> ) { # if CONFIG_VP9_HIGHBITDEPTH vpx_image_t * frame_to_encode ; if ( input_shift || ( use_16bit_internal && input . bit_depth == 8 ) ) { assert ( use_16bit_internal ) ; if ( ! allocated_raw_shift ) { vpx_img_alloc ( & raw_shift , raw . fmt | VPX_IMG_FMT_HIGHBITDEPTH , input . width , input . height , 32 ) ; allocated_raw_shift = 1 ; } vpx_img_upshift ( & raw_shift , & raw , input_shift ) ; frame_to_encode = & raw_shift ; } else { frame_to_encode = & raw ; } vpx_usec_timer_start ( & timer ) ; if ( use_16bit_internal ) { assert ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ; FOREACH_STREAM ( { if ( stream -> config . use_16bit_internal ) encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ; else assert ( 0 ) ; } ) ; } else { assert ( ( frame_to_encode -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) == 0 ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? frame_to_encode : NULL , frames_in ) ) ; } # else <S2SV_ModStart> ) ; # endif <S2SV_ModStart> length && streams != NULL && <S2SV_ModStart> ) { const int64_t <S2SV_ModEnd> frame_in_lagged = <S2SV_ModStart> else { const int64_t <S2SV_ModEnd> input_pos = <S2SV_ModStart> ) ; const int64_t <S2SV_ModEnd> input_pos_lagged = <S2SV_ModStart> lagged_count ; const <S2SV_ModStart> ) ; if ( ! global . quiet ) fprintf ( stderr , "\\033[K" ) ; <S2SV_ModStart> quiet ) { <S2SV_ModStart> "\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7" PRId64 "B<S2SV_blank>%7" PRId64 "b/f<S2SV_blank>%7" <S2SV_ModEnd> PRId64 "b/s" <S2SV_ModStart> ? ( int64_t <S2SV_ModEnd> ) ( <S2SV_ModStart> ) ) ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> show_psnr ) { if ( global . codec -> fourcc == VP9_FOURCC ) { FOREACH_STREAM ( <S2SV_ModEnd> show_psnr ( <S2SV_ModStart> ( stream , ( 1 << stream -> config . cfg . g_input_bit_depth ) - 1 ) ) ; } else { FOREACH_STREAM ( show_psnr ( stream , 255.0 ) ) ; } } <S2SV_ModEnd> FOREACH_STREAM ( <S2SV_ModStart> ) ; # if CONFIG_FP_MB_STATS FOREACH_STREAM ( stats_close ( & stream -> fpmb_stats , global . passes - 1 ) ) ; # endif <S2SV_ModStart> ; } ) ; # endif # if CONFIG_VP9_HIGHBITDEPTH if ( allocated_raw_shift ) vpx_img_free ( & raw_shift
<S2SV_ModStart> if ( stream == NULL ) { <S2SV_ModEnd> fatal ( <S2SV_ModStart> ) ; } <S2SV_ModStart> codec -> codec_interface <S2SV_ModEnd> ( ) <S2SV_ModStart> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> stream -> ebml . last_pts_ns <S2SV_ModEnd> = - <S2SV_ModStart> - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> input -> pixel_aspect_ratio . numerator = 1 ; input -> pixel_aspect_ratio . denominator = 1 ; input -> <S2SV_ModStart> input -> pixel_aspect_ratio . numerator = input -> y4m . par_n ; input -> pixel_aspect_ratio . denominator = input -> y4m . par_d ; input -> <S2SV_ModStart> input -> fmt = input -> y4m . vpx_fmt ; input -> bit_depth = input -> y4m . bit_depth <S2SV_ModEnd> ; }
<S2SV_ModStart> * global , const struct VpxRational * pixel_aspect_ratio <S2SV_ModStart> -> fourcc , pixel_aspect_ratio
<S2SV_ModStart> arg ; const int num_encoder = get_vpx_encoder_count ( ) ; if ( num_encoder < 1 ) die ( "Error:<S2SV_blank>no<S2SV_blank>valid<S2SV_blank>encoder<S2SV_blank>available\\n" ) ; <S2SV_ModStart> get_vpx_encoder_by_index ( num_encoder - 1 ) ; global -> passes = 0 ; global -> color_type = I420 <S2SV_ModEnd> ; global <S2SV_ModStart> global -> color_type = YV12 ; else if ( arg_match ( & arg , & use_i420 , argi ) ) global -> color_type = I420 ; else if ( arg_match ( & arg , & use_i422 , argi ) ) global -> color_type = I422 ; else if ( arg_match ( & arg , & use_i444 , argi ) ) global -> color_type = I444 ; else if ( arg_match ( & arg , & use_i440 , argi ) ) global -> color_type = I440 <S2SV_ModEnd> ; else <S2SV_ModStart> ; else <S2SV_ModEnd> argj ++ <S2SV_ModStart> if CONFIG_VP9_ENCODER || CONFIG_VP10_ENCODER if ( global -> codec != NULL && global -> codec -> name != NULL )
<S2SV_ModStart> 0 ; # if CONFIG_VP9_HIGHBITDEPTH int test_16bit_internal = 0 ; # endif <S2SV_ModStart> # endif # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , "vp10" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif <S2SV_ModStart> if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; # if CONFIG_FP_MB_STATS } else if ( arg_match ( & arg , & fpmbf_name , argi ) ) { config -> fpmb_stats_fn = arg . val ; # endif } else if ( arg_match ( & arg , & use_webm , argi ) ) { # if CONFIG_WEBM_IO config -> write_webm = 1 ; # else die ( "Error:<S2SV_blank>--webm<S2SV_blank>specified<S2SV_blank>but<S2SV_blank>webm<S2SV_blank>is<S2SV_blank>disabled." ) ; # endif } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & bitdeptharg , argi ) ) { config -> cfg . g_bit_depth = arg_parse_enum_or_int ( & arg ) ; } else if ( arg_match ( & arg , & inbitdeptharg , argi ) ) { config -> cfg . g_input_bit_depth = arg_parse_uint ( & arg ) ; # endif # if CONFIG_WEBM_IO <S2SV_ModStart> ) ; # endif <S2SV_ModStart> , & resize_width , argi ) ) { config -> cfg . rc_scaled_width = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & resize_height , argi ) ) { config -> cfg . rc_scaled_height = arg_parse_uint ( & arg ) ; } else if ( arg_match ( & arg , & <S2SV_ModStart> VPX_KF_DISABLED ; # if CONFIG_VP9_HIGHBITDEPTH } else if ( arg_match ( & arg , & test16bitinternalarg , argi ) ) { if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || strcmp ( global -> codec -> name , "vp10" ) == 0 ) { test_16bit_internal = 1 ; } # endif <S2SV_ModStart> if ( ctrl_args_map != NULL && <S2SV_ModStart> j < ( int ) <S2SV_ModStart> if ( ctrl_args_map != NULL && <S2SV_ModStart> j < ( int ) <S2SV_ModStart> } } # if CONFIG_VP9_HIGHBITDEPTH if ( strcmp ( global -> codec -> name , "vp9" ) == 0 || strcmp ( global -> codec -> name , "vp10" ) == 0 ) { config -> use_16bit_internal = test_16bit_internal | ( config -> cfg . g_profile > 1 ) ; } # endif
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> ; } # if CONFIG_FP_MB_STATS if ( stream -> config . fpmb_stats_fn ) { if ( ! stats_open_file ( & stream -> fpmb_stats , stream -> config . fpmb_stats_fn , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store" ) ; } else { if ( ! stats_open_mem ( & stream -> fpmb_stats , pass ) ) fatal ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>mb<S2SV_blank>statistics<S2SV_blank>store" ) ; } # endif <S2SV_ModStart> pass ) { <S2SV_ModStart> ) ; # if CONFIG_FP_MB_STATS stream -> config . cfg . rc_firstpass_mb_stats_in = stats_get ( & stream -> fpmb_stats ) ; # endif }
<S2SV_ModStart> * stream , double peak <S2SV_ModStart> psnr_samples_total , peak <S2SV_ModEnd> , (
<S2SV_ModStart> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , "Source<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>File<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>Format:<S2SV_blank>%s\\n" , <S2SV_ModEnd> input -> <S2SV_ModStart> filename , file_type_to_string ( <S2SV_ModStart> input -> file_type ) , image_format_to_string ( input -> fmt ) <S2SV_ModEnd> ) ; <S2SV_ModStart> SHOW ( g_bit_depth ) ; SHOW ( g_input_bit_depth ) ; SHOW ( <S2SV_ModStart> ( rc_resize_allowed ) ; SHOW ( rc_scaled_width ) ; SHOW ( rc_scaled_height
<S2SV_ModStart> struct vp9_ref_frame ref_enc , ref_dec ; ref_enc <S2SV_ModEnd> . idx <S2SV_ModStart> 0 ; ref_dec . idx = 0 ; <S2SV_ModStart> , & ref_enc ) ; enc_img = ref_enc <S2SV_ModEnd> . img <S2SV_ModStart> , & ref_dec ) ; dec_img = ref_dec . img ; # if CONFIG_VP9_HIGHBITDEPTH if ( ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) != ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ) { if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & enc_img , enc_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , enc_img . d_w , enc_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & enc_img , & ref_enc . img ) ; } if ( dec_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { vpx_img_alloc ( & dec_img , dec_img . fmt - VPX_IMG_FMT_HIGHBITDEPTH , dec_img . d_w , dec_img . d_h , 16 ) ; vpx_img_truncate_16_to_8 ( & dec_img , & ref_dec . img ) ; } } # endif <S2SV_ModEnd> } ctx_exit_on_error <S2SV_ModStart> ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( enc_img . fmt & VPX_IMG_FMT_HIGHBITDEPTH ) { find_mismatch_high ( & enc_img , & dec_img , y , u , v ) ; } else { <S2SV_ModStart> ) ; } # else find_mismatch ( & enc_img , & dec_img , y , u , v ) ; # endif
<S2SV_ModStart> usage_exit ( void <S2SV_ModStart> int i ; const int num_encoder = get_vpx_encoder_count ( ) <S2SV_ModStart> # endif # if CONFIG_VP10_ENCODER fprintf ( stderr , "\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n" ) ; arg_show_usage ( stderr , vp10_args ) ; # endif <S2SV_ModStart> i < num_encoder <S2SV_ModEnd> ; ++ <S2SV_ModStart> ) ; const char * defstr = ( i == ( num_encoder - 1 ) ) ? "(default)" : "" ; fprintf ( stderr , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n" <S2SV_ModEnd> , encoder <S2SV_ModStart> encoder -> codec_interface ( ) ) , defstr <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } fprintf ( stderr , "\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ; fprintf ( stderr , "Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n" ) ;
<S2SV_ModStart> <S2SV_null> <S2SV_null> static
<S2SV_ModStart> streami ; ( void ) global ; <S2SV_ModStart> cfg . g_input_bit_depth > ( unsigned int ) stream -> config . cfg . g_bit_depth ) { fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>codec<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)<S2SV_blank>less<S2SV_blank>than<S2SV_blank>input<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>(%d)" , stream -> index , ( int ) stream -> config . cfg . g_bit_depth , stream -> config . cfg . g_input_bit_depth ) ; } for ( streami = stream ; streami ; streami = streami -> next ) { if ( ! streami -> config . out_fn ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>Output<S2SV_blank>file<S2SV_blank>is<S2SV_blank>required<S2SV_blank>(specify<S2SV_blank>with<S2SV_blank>-o)" , streami -> index ) ; if ( streami != stream ) { const char * a = stream <S2SV_ModEnd> -> config <S2SV_ModStart> . out_fn ; const char * b = streami -> config . out_fn ; if ( ! strcmp ( a , b ) && strcmp ( a , "/dev/null" ) && strcmp ( a , ":nul" ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> config . stats_fn ; const char * b = streami -> config . stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } # if CONFIG_FP_MB_STATS <S2SV_ModEnd> if ( <S2SV_ModStart> config . fpmb_stats_fn ; const char * b = streami -> config . fpmb_stats_fn ; if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream<S2SV_blank>%d:<S2SV_blank>duplicate<S2SV_blank>mb<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>(from<S2SV_blank>stream<S2SV_blank>%d)" , streami -> index , stream -> index ) ; } # endif <S2SV_ModEnd> } }
<S2SV_ModStart> if ( stats -> file == NULL ) fatal ( "First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!" ) ; if (
<S2SV_ModStart> vpx_img_fmt_t fmt , unsigned int bit_depth <S2SV_ModStart> char * color ; switch ( bit_depth ) { case 8 : <S2SV_ModEnd> color = <S2SV_ModStart> "C420jpeg\\n" ; break ; case 9 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p9<S2SV_blank>XYSCSS=444P9\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p9<S2SV_blank>XYSCSS=422P9\\n" : "C420p9<S2SV_blank>XYSCSS=420P9\\n" ; break ; case 10 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p10<S2SV_blank>XYSCSS=444P10\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p10<S2SV_blank>XYSCSS=422P10\\n" : "C420p10<S2SV_blank>XYSCSS=420P10\\n" ; break ; case 12 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p12<S2SV_blank>XYSCSS=444P12\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p12<S2SV_blank>XYSCSS=422P12\\n" : "C420p12<S2SV_blank>XYSCSS=420P12\\n" ; break ; case 14 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p14<S2SV_blank>XYSCSS=444P14\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p14<S2SV_blank>XYSCSS=422P14\\n" : "C420p14<S2SV_blank>XYSCSS=420P14\\n" ; break ; case 16 : color = fmt == VPX_IMG_FMT_I44416 ? "C444p16<S2SV_blank>XYSCSS=444P16\\n" : fmt == VPX_IMG_FMT_I42216 ? "C422p16<S2SV_blank>XYSCSS=422P16\\n" : "C420p16<S2SV_blank>XYSCSS=420P16\\n" ; break ; default : color = NULL ; assert ( 0 ) ; }
<S2SV_ModStart> int c_sz ; ( void ) _aux
<S2SV_ModStart> ) { ( void ) _y4m ; ( void ) _dst ; ( void ) _aux ;
<S2SV_ModStart> int c_sz ; int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 <S2SV_ModStart> _y4m -> bps <S2SV_ModEnd> ; pic_sz <S2SV_ModStart> -> pic_h * bytes_per_sample <S2SV_ModStart> dst_c_dec_h ; c_w *= bytes_per_sample ; <S2SV_ModStart> stride [ VPX_PLANE_Y <S2SV_ModEnd> ] = <S2SV_ModStart> stride [ VPX_PLANE_ALPHA ] = <S2SV_ModEnd> _y4m -> <S2SV_ModStart> -> pic_w * bytes_per_sample <S2SV_ModStart> stride [ VPX_PLANE_U <S2SV_ModEnd> ] = <S2SV_ModStart> stride [ VPX_PLANE_V <S2SV_ModEnd> ] = <S2SV_ModStart> planes [ VPX_PLANE_Y <S2SV_ModEnd> ] = <S2SV_ModStart> planes [ VPX_PLANE_U <S2SV_ModEnd> ] = <S2SV_ModStart> planes [ VPX_PLANE_V <S2SV_ModEnd> ] = <S2SV_ModStart> planes [ VPX_PLANE_ALPHA <S2SV_ModEnd> ] =
<S2SV_ModStart> 80 ] = { 0 } <S2SV_ModStart> _y4m -> bps <S2SV_ModEnd> = 12 <S2SV_ModStart> 12 ; _y4m -> bit_depth = 8 ; <S2SV_ModStart> chroma_type , "420p10" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 10 ; _y4m -> bps = 15 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "420p12" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> dst_c_dec_h = 2 ; _y4m -> src_c_dec_v = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; _y4m -> bit_depth = 12 ; _y4m -> bps = 18 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>420p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , <S2SV_ModStart> _y4m -> bps <S2SV_ModEnd> = 16 <S2SV_ModStart> = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , "422p10" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 20 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "422p12" ) == 0 ) { _y4m -> src_c_dec_h = 2 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ; _y4m -> bps = 24 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>422p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 <S2SV_ModStart> _y4m -> bps <S2SV_ModEnd> = 24 <S2SV_ModStart> chroma_type , "444p10" <S2SV_ModEnd> ) == <S2SV_ModStart> 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 30 ; _y4m -> bit_depth = 10 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; <S2SV_ModStart> ) { <S2SV_ModEnd> fprintf ( <S2SV_ModStart> stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p10<S2SV_blank>to<S2SV_blank>420jpeg\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } } else if ( strcmp ( _y4m -> chroma_type , "444p12" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ; _y4m -> bps = 36 ; _y4m -> bit_depth = 12 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; if ( only_420 ) { fprintf ( stderr , "Unsupported<S2SV_blank>conversion<S2SV_blank>from<S2SV_blank>444p12<S2SV_blank>to<S2SV_blank>420jpeg\\n" ) ; return - 1 ; } } else if ( strcmp ( _y4m -> chroma_type , "444alpha" ) == 0 ) { _y4m -> src_c_dec_h = 1 ; _y4m -> src_c_dec_v = 1 ; if ( only_420 ) { _y4m -> dst_c_dec_h = 2 ; _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 3 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> convert = y4m_convert_444_420jpeg ; } else { _y4m -> vpx_fmt = VPX_IMG_FMT_444A ; _y4m -> bps = 32 ; _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ; _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ; _y4m -> dst_buf_read_sz = 4 * _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_null ; } } else if ( strcmp ( _y4m -> chroma_type , "mono" ) == 0 ) { _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ; _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ; _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ; _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ; _y4m -> convert = y4m_convert_mono_420jpeg ; } else { fprintf ( stderr , "Unknown<S2SV_blank>chroma<S2SV_blank>sampling<S2SV_blank>type:<S2SV_blank>%s\\n" , _y4m -> chroma_type ) ; return - 1 ; } <S2SV_ModStart> ) ; if ( _y4m -> bit_depth == 8 ) <S2SV_ModStart> ) ; else _y4m -> dst_buf <S2SV_ModEnd> = ( <S2SV_ModStart> malloc ( 2 * _y4m -> dst_buf_sz ) ; if ( <S2SV_ModStart> -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz
<S2SV_ModStart> 1 ) { <S2SV_ModStart> 1 ; } if ( pbi -> decoding_thread_count > pbi -> common . mb_rows - 1 ) { pbi -> decoding_thread_count = pbi -> common . mb_rows - 1 ; }
<S2SV_ModStart> if CONFIG_MULTITHREAD <S2SV_ModEnd> vp8_decoder_remove_threads (
<S2SV_ModStart> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { <S2SV_ModStart> allocated_decoding_thread_count ; ++ i <S2SV_ModEnd> ) { <S2SV_ModStart> NULL ; vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ;
<S2SV_ModStart> i ; <S2SV_ModEnd> vpx_free ( <S2SV_ModStart> mt_yabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> mt_uabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> mt_vabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> mt_yleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> mt_uleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> mt_vleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free <S2SV_ModStart> } } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;
<S2SV_ModStart> , x_f <S2SV_ModEnd> ; WORD32 <S2SV_ModStart> ++ ; y0 [ h2 ] = ixheaacd_add32_sat ( x_0 , x_2 ) ; y0 [ h2 + 1 ] = ixheaacd_add32_sat ( x_1 , x_3 ) ; y1 [ h2 ] = ixheaacd_add32_sat ( x_4 , x_6 ) ; y1 [ h2 + 1 ] = ixheaacd_add32_sat ( x_5 , x_7 ) ; y2 [ h2 ] = ixheaacd_sub32_sat ( x_0 , x_2 ) ; y2 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_1 , x_3 ) ; y3 [ h2 ] = ixheaacd_sub32_sat ( x_4 , x_6 ) ; y3 [ h2 + 1 ] = ixheaacd_sub32_sat ( x_5 , x_7 ) ; x_8 = * x2 ++ ; x_9 = * x2 ++ ; x_a = * x2 ++ ; x_b = * x2 ++ ; x_c = * x2 ++ ; x_d = * x2 ++ ; x_e = * x2 ++ ; x_f = * x2 ++ ; y0 [ h2 + 2 ] = ixheaacd_add32_sat ( x_8 , x_a ) ; y0 [ h2 + 3 ] = ixheaacd_add32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y1 <S2SV_ModStart> [ h2 + 2 ] = ixheaacd_add32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y1 <S2SV_ModStart> h2 + 3 ] = ixheaacd_add32_sat ( x_d , x_f ) ; y2 [ h2 + 2 ] = ixheaacd_sub32_sat ( x_8 , x_a ) ; y2 [ h2 + 3 ] = ixheaacd_sub32_sat ( x_9 , x_b ) <S2SV_ModEnd> ; y3 <S2SV_ModStart> [ h2 + 2 ] = ixheaacd_sub32_sat ( x_c , x_e ) <S2SV_ModEnd> ; y3 <S2SV_ModStart> h2 + 3 ] = ixheaacd_sub32_sat ( x_d , x_f ) <S2SV_ModEnd> ; }
<S2SV_ModStart> fft_jmp ; WORD64 <S2SV_ModEnd> xt0_0 , <S2SV_ModStart> yt2_0 ; WORD64 <S2SV_ModEnd> xh0_0 , <S2SV_ModStart> xh0_0 = ( WORD64 ) <S2SV_ModStart> x_0 + ( WORD64 ) <S2SV_ModStart> xl0_0 = ( WORD64 ) <S2SV_ModStart> x_0 - ( WORD64 ) <S2SV_ModStart> xh20_0 = ( WORD64 ) <S2SV_ModStart> x_h2_0 + ( WORD64 ) <S2SV_ModStart> xl20_0 = ( WORD64 ) <S2SV_ModStart> x_h2_0 - ( WORD64 ) <S2SV_ModStart> ] = ( WORD32 ) ixheaacd_add64_sat ( xh0_0 , xh20_0 ) <S2SV_ModEnd> ; xt0_0 <S2SV_ModStart> xt0_0 = ( WORD64 ) <S2SV_ModStart> xh0_0 - ( WORD64 ) <S2SV_ModStart> xh1_0 = ( WORD64 ) <S2SV_ModStart> x_1 + ( WORD64 ) <S2SV_ModStart> xl1_0 = ( WORD64 ) <S2SV_ModStart> x_1 - ( WORD64 ) <S2SV_ModStart> xh21_0 = ( WORD64 ) <S2SV_ModStart> x_h2_1 + ( WORD64 ) <S2SV_ModStart> xl21_0 = ( WORD64 ) <S2SV_ModStart> x_h2_1 - ( WORD64 ) <S2SV_ModStart> ] = ( WORD32 ) ixheaacd_add64_sat ( xh1_0 , xh21_0 ) <S2SV_ModEnd> ; yt0_0 <S2SV_ModStart> yt0_0 = ( WORD64 ) <S2SV_ModStart> xh1_0 - ( WORD64 ) <S2SV_ModStart> xt1_0 = ( WORD64 ) <S2SV_ModStart> xl0_0 + ( WORD64 ) <S2SV_ModStart> xt2_0 = ( WORD64 ) <S2SV_ModStart> xl0_0 - ( WORD64 ) <S2SV_ModStart> yt2_0 = ( WORD64 ) <S2SV_ModStart> xl1_0 + ( WORD64 ) <S2SV_ModStart> yt1_0 = ( WORD64 ) <S2SV_ModStart> xl1_0 - ( WORD64 )
<S2SV_ModStart> timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i1 <S2SV_ModStart> treal = ixheaacd_sub32_sat ( i2 , r2 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; filter_states [ j ] = treal ; treal = ixheaacd_sub32_sat ( i1 , r1 ) ; treal = ( ixheaacd_shl32_sat ( treal , shift ) ) ; * filter_states ++ = treal ; timag = ixheaacd_add32_sat <S2SV_ModEnd> ( i2
<S2SV_ModStart> if ( ptr_hbe_txposer -> <S2SV_ModStart> ( * ( ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_cmplx_anal_fft ) )
<S2SV_ModStart> if ( ptr_hbe_txposer -> <S2SV_ModStart> ( * ( ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft ) )
<S2SV_ModStart> ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_analy_cos_sin_table_kl_16 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_analy_cos_sin_table_kl_24 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft_p3 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_analy_cos_sin_table_kl_32 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_analy_cos_sin_table_kl_8 ; ptr_hbe_txposer -> <S2SV_ModStart> ixheaacd_real_synth_fft_p2 ; ptr_hbe_txposer -> <S2SV_ModStart> break ; <S2SV_ModEnd> } } <S2SV_ModStart> ; } }
<S2SV_ModStart> else { if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ;
<S2SV_ModStart> port & USHRT_MAX <S2SV_ModEnd> ; *
<S2SV_ModStart> ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ( "b/26366256" ) ; android_errorWriteLog ( 0x534e4554 , "26366256"
<S2SV_ModStart> ) ; android_errorWriteLog ( 0x534e4554 , "26366256" ) ;
<S2SV_ModStart> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> numSamples ; if ( numSamples <= 0 ) { ALOGE ( "b/26366256" ) ; return ; }
<S2SV_ModStart> ; } if ( pWTIntFrame -> numSamples < 0 ) { ALOGE ( "b/26366256" ) ; pWTIntFrame -> numSamples = 0 ; }
<S2SV_ModStart> pStackPtr >= ( CDL_STACK_SIZE - 1 ) ) { ALOGE ( "b/34031018,<S2SV_blank>stackPtr(%d)" , * pStackPtr ) ; android_errorWriteLog ( 0x534e4554 , "34031018" ) ; <S2SV_ModEnd> return EAS_ERROR_FILE_FORMAT <S2SV_ModStart> EAS_ERROR_FILE_FORMAT ; }
<S2SV_ModStart> ; } if ( dls . pDLS ) { <S2SV_ModStart> 1 ; }
<S2SV_ModStart> if ( dataSize < 0 ||
<S2SV_ModStart> samples_per_partition ; int idx = ( int ) partword [ j ] [ i ] ; if ( idx < info -> partitions && <S2SV_ModEnd> info -> <S2SV_ModStart> stagemasks [ idx <S2SV_ModEnd> ] &
<S2SV_ModStart> -> dim && i < n
<S2SV_ModStart> -> dim && i < n <S2SV_ModStart> -> dim && i < n
<S2SV_ModStart> errout ; int limit = ( info -> type == 2 ? vi -> channels : 1 ) * ci -> blocksizes [ 1 ] / 2 ; if ( info -> begin > info -> end || info -> end > limit ) { goto errout ; }
<S2SV_ModStart> zone ; size_t tilemap_size ; <S2SV_ModStart> height ; tilemap_size = <S2SV_ModEnd> x_size * <S2SV_ModStart> map_tile ) ; if ( x_size == 0 || tilemap_size / x_size / sizeof ( struct map_tile ) != y_size || ! ( tilemap = malloc ( tilemap_size
<S2SV_ModStart> ) { size_t original_length = memory_length ; <S2SV_ModStart> d_memory , original_length <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( q < p ) { DPRINTF ( ( "Wrapped<S2SV_blank>around<S2SV_blank>%p<S2SV_blank><<S2SV_blank>%p\\n" , q , p ) ) ; goto out ; } if ( q
<S2SV_ModStart> tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; <S2SV_ModStart> ) <= ss <S2SV_ModEnd> * sst <S2SV_ModStart> ) , ss <S2SV_ModEnd> * sst <S2SV_ModStart> sst_len , ss <S2SV_ModEnd> , sst
<S2SV_ModStart> cdf_secid_t ) ( <S2SV_ModStart> size ) / sizeof ( maxsector ) ) <S2SV_ModStart> ( sid >= maxsector ) { DPRINTF ( ( "Sector<S2SV_blank>%d<S2SV_blank>>=<S2SV_blank>%d\\n" <S2SV_ModEnd> , sid
<S2SV_ModStart> . len = 20 + level <S2SV_ModEnd> ) *
<S2SV_ModStart> ( pos + len <S2SV_ModStart> , pos + len
<S2SV_ModStart> , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { <S2SV_ModStart> ms ) && root_storage <S2SV_ModStart> cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime
<S2SV_ModStart> , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { <S2SV_ModStart> ; } if ( root_storage ) { <S2SV_ModStart> cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2desc <S2SV_ModStart> 2 ; } <S2SV_ModStart> count , root_storage <S2SV_ModEnd> ) ;
<S2SV_ModStart> , root_storage <S2SV_ModEnd> ) )
<S2SV_ModStart> { size_t tail = <S2SV_ModEnd> ( i <S2SV_ModStart> + 1 ; if ( cdf_check_stream_offset ( sst , h , p , tail * sizeof ( uint32_t ) , __LINE__ ) == - 1 ) goto out ; size_t ofs = CDF_GETUINT32 ( p , tail
<S2SV_ModStart> { size_t <S2SV_ModEnd> maxcount ; <S2SV_ModStart> si_count = CDF_TOLE4 <S2SV_ModEnd> ( si <S2SV_ModStart> NULL ; if ( cdf_read_property_info ( sst , h , <S2SV_ModEnd> CDF_TOLE4 ( <S2SV_ModStart> CDF_TOLE4 ( <S2SV_ModEnd> sd -> <S2SV_ModStart> 1 ) <S2SV_ModEnd> return - <S2SV_ModStart> 1 ; <S2SV_ModEnd> return 0
<S2SV_ModStart> FILE_ELF_PHNUM_MAX ; ms -> elf_notes_max = FILE_ELF_NOTES_MAX ;
<S2SV_ModStart> 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ;
<S2SV_ModStart> 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : ms -> elf_notes_max = * ( const size_t * ) val ; return 0 ;
<S2SV_ModStart> ) ; if ( nelements == 0 ) { DPRINTF ( ( "CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n" ) ) ; goto out ; } <S2SV_ModStart> < nelements && i < sh . sh_properties ; <S2SV_ModEnd> j ++
<S2SV_ModStart> ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer <S2SV_ModStart> buffer -> data , buffer -> <S2SV_ModStart> ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data <S2SV_ModStart> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , <S2SV_ModStart> strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + <S2SV_ModEnd> strlen ( <S2SV_ModStart> strlen ( AUTH_LINE_SENTINEL <S2SV_ModEnd> ) - <S2SV_ModStart> ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = <S2SV_ModEnd> 0 ; <S2SV_ModStart> 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE
<S2SV_ModStart> client -> auth_buffer = g_byte_array_new ( ) <S2SV_ModEnd> ; client
<S2SV_ModStart> ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( "Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n" ) ; side_closed ( side ) ; break ; }
<S2SV_ModStart> ) { } else if ( warn_script_unsaved && fv -> script_unsaved && AskScriptChanged ( ) == 2 ) { return false ;
<S2SV_ModStart> type == et_controlevent && event -> u . control . subtype == et_textchanged ) { sd -> fv -> script_unsaved = ! GTextFieldIsEmpty ( GWidgetGetControl ( sd -> gw , CID_Script ) ) ; } else if ( event -> type == et_controlevent && event -> u . control . subtype == et_save ) { sd -> fv -> script_unsaved = false ; } else if ( event -> type ==
<S2SV_ModStart> ) ; GTextFieldSaved ( gt ) ;
<S2SV_ModStart> > LEVEL_3_MAX_HEADER_LEN || header_len < RAW_DATA_LEN ( header )
<S2SV_ModStart> result ; if ( nbytes > LEVEL_3_MAX_HEADER_LEN ) { return NULL ; }
<S2SV_ModStart> u32 size , u32 num <S2SV_ModStart> ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModStart> += size * num <S2SV_ModStart> ( size * num
<S2SV_ModStart> u32 size , u32 num <S2SV_ModStart> ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModStart> ( size * num
<S2SV_ModStart> u8 ) , <S2SV_ModEnd> strmLen )
<S2SV_ModStart> decContainer_t ) , 1
<S2SV_ModStart> u32 size , u32 num <S2SV_ModStart> ) { if ( size > UINT32_MAX / num ) { ALOGE ( "can\'t<S2SV_blank>allocate<S2SV_blank>%u<S2SV_blank>*<S2SV_blank>%u<S2SV_blank>bytes" , size , num ) ; android_errorWriteLog ( 0x534e4554 , "27855419" ) ; return NULL ; } <S2SV_ModStart> ( size * num
<S2SV_ModStart> u32 size , u32 num <S2SV_ModStart> ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModStart> ( size * num
<S2SV_ModStart> ( size , 1
<S2SV_ModStart> ) ; if ( picSizeInMbs > ( UINT32_MAX - 32 - 15 ) / 384 ) { ALOGE ( "b/28533562" ) ; android_errorWriteLog ( 0x534e4554 , "28533562" ) ; return ( MEMORY_ALLOCATION_ERROR ) ; }
<S2SV_ModStart> ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> picHeightInMbs ; }
<S2SV_ModStart> int32_t sessionId __unused <S2SV_ModStart> int32_t ioId __unused
<S2SV_ModStart> NULL || replySize == NULL || <S2SV_ModStart> || pReplyData == NULL || replySize <S2SV_ModStart> || pReplyData == NULL || replySize <S2SV_ModStart> NULL || replySize == NULL || <S2SV_ModStart> NULL || replySize == NULL || <S2SV_ModStart> ( pReplyData == NULL || replySize
<S2SV_ModStart> * pDownmixer __unused <S2SV_ModStart> bool init __unused
<S2SV_ModStart> pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , "63662938" ) ; return - EINVAL ; }
<S2SV_ModStart> if ( multiuser_get_app_id ( uid ) <S2SV_ModEnd> >= AID_APP
<S2SV_ModStart> "add" ; if ( uid >= AID_APP ) { return 0 ; }
<S2SV_ModStart> ) ; if ( ! strcmp ( key , "path" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , "disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> ) { size_t len = strlen ( s ) + 1 ; <S2SV_ModStart> pool_alloc ( len <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( r <S2SV_ModStart> , s , len
<S2SV_ModStart> ) ; memcpy <S2SV_ModEnd> ( m <S2SV_ModStart> , name , nlen + 1
<S2SV_ModStart> ) ; if ( ! strcmp ( key , "url" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , "disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s" , value ) ;
<S2SV_ModStart> obj , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void
<S2SV_ModStart> obj , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void <S2SV_ModStart> ) { <S2SV_ModEnd> add_preferred_base_object ( <S2SV_ModStart> OBJECT_ADDED ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> obj , <S2SV_ModEnd> const char
<S2SV_ModStart> obj , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void <S2SV_ModStart> obj , name <S2SV_ModEnd> , cb_data <S2SV_ModStart> obj , name <S2SV_ModEnd> ) ;
<S2SV_ModStart> object ; size_t pathlen ; <S2SV_ModStart> SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> , path -> buf <S2SV_ModEnd> , cb_data <S2SV_ModStart> ) ; strbuf_setlen ( path , pathlen ) ;
<S2SV_ModStart> SEEN ; strbuf_addstr ( base , name ) ; <S2SV_ModStart> , base -> buf <S2SV_ModEnd> , cb_data <S2SV_ModStart> , cb_data <S2SV_ModEnd> ) ;
<S2SV_ModStart> obj , <S2SV_ModEnd> name , <S2SV_ModStart> show_object , & base <S2SV_ModEnd> , path
<S2SV_ModStart> object , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void
<S2SV_ModStart> object , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void <S2SV_ModStart> 0 ) <S2SV_ModEnd> bitmap_pos = <S2SV_ModStart> ) ; <S2SV_ModEnd> bitmap_set (
<S2SV_ModStart> object , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> , void
<S2SV_ModStart> NULL , <S2SV_ModEnd> data )
<S2SV_ModStart> obj , <S2SV_ModEnd> const char
<S2SV_ModStart> obj , <S2SV_ModEnd> const char <S2SV_ModStart> char * name <S2SV_ModEnd> ) { <S2SV_ModStart> ) { const <S2SV_ModEnd> char * <S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> 2 ; if ( q + o >= e ) goto out ;
<S2SV_ModStart> ) { size_t ss = <S2SV_ModEnd> CDF_SEC_SIZE ( <S2SV_ModStart> h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> off_t ) pos , <S2SV_ModEnd> ( (
<S2SV_ModStart> ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( <S2SV_ModStart> h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( "bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> ) + pos <S2SV_ModEnd> , len
<S2SV_ModStart> ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; <S2SV_ModStart> p + ofs <S2SV_ModEnd> - 2 <S2SV_ModStart> ( uint32_t ) <S2SV_ModStart> "u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n" , i , <S2SV_ModEnd> inp [ <S2SV_ModStart> p , offs <S2SV_ModEnd> ) )
<S2SV_ModStart> ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h <S2SV_ModStart> pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst <S2SV_ModStart> pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst
<S2SV_ModStart> ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h
<S2SV_ModStart> ) ; } if ( error == NULL ) <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; <S2SV_ModEnd> } table
<S2SV_ModStart> ) { uint32_t <S2SV_ModEnd> nestsize = <S2SV_ModStart> = ( uint32_t <S2SV_ModEnd> ) ms
<S2SV_ModStart> ) ; if ( mp4 == 0 ) { printf ( "error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>MP4/MOV\\n" , argv [ 1 ] ) ; return - 1 ; } <S2SV_ModStart> ) ; double <S2SV_ModEnd> in = <S2SV_ModStart> ) { double in = 0.0 , out = 0.0 ; <S2SV_ModStart> , GPMF_SAMPLE_RATE_PRECISE , & in , & out ) ; printf ( "%c%c%c%c<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%f<S2SV_blank>Hz<S2SV_blank>(from<S2SV_blank>%f<S2SV_blank>to<S2SV_blank>%f)\\n" <S2SV_ModEnd> , PRINTF_4CC <S2SV_ModStart> , rate , in , out
<S2SV_ModStart> sizeof ( the_url <S2SV_ModEnd> ) -
<S2SV_ModStart> < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) <S2SV_ModStart> ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> } else break ; } else <S2SV_ModStart> ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else <S2SV_ModStart> ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else <S2SV_ModStart> ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else <S2SV_ModStart> } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [
<S2SV_ModStart> allow_add_in_command ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum <S2SV_ModStart> . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> ) ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum <S2SV_ModStart> . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> else { if ( strlen ( <S2SV_ModEnd> sep + <S2SV_ModStart> 1 ) >= sizeof <S2SV_ModEnd> ( cat_enum <S2SV_ModStart> . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( <S2SV_ModEnd> sep + <S2SV_ModStart> 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> 0 ; } <S2SV_ModStart> cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> , '%' <S2SV_ModStart> ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n" , sep ) ) ; return GF_NOT_SUPPORTED ; }
<S2SV_ModStart> ) { strncpy <S2SV_ModEnd> ( the_url <S2SV_ModStart> . to_url , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; fprintf
<S2SV_ModStart> ext ; if ( strlen ( url_arg ) >= sizeof ( the_url ) ) { fprintf ( stderr , "Input<S2SV_blank>url<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long,<S2SV_blank>truncating<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>chars.\\n" , url_arg , ( int ) ( sizeof ( the_url ) - 1 ) ) ; strncpy ( the_url , url_arg , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 ; } else { <S2SV_ModStart> ) ; } <S2SV_ModStart> e ) { strncpy <S2SV_ModEnd> ( the_url <S2SV_ModStart> sess ) , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_cfg ) - 1 ] = 0 ; } <S2SV_ModEnd> gf_dm_sess_del ( <S2SV_ModStart> ) { strncpy <S2SV_ModEnd> ( the_url <S2SV_ModStart> "MP4Client<S2SV_blank>" GPAC_FULL_VERSION , sizeof ( the_url ) - 1 ) ; the_url [ sizeof ( the_url ) - 1 ] = 0 <S2SV_ModEnd> ; gf_term_connect
<S2SV_ModStart> opt_string ; if ( sepIdx >= sizeof ( szSec ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>Section<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> sep ; if ( sepIdx >= sizeof ( szKey ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>key<S2SV_blank>name<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } <S2SV_ModStart> 0 ; if ( strlen ( <S2SV_ModEnd> sep2 + <S2SV_ModStart> 1 ) >= sizeof ( szVal ) ) { fprintf ( stderr , "Badly<S2SV_blank>formatted<S2SV_blank>option<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>value<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long\\n" , opt_string ) ; return ; } strcpy ( szVal , sep2 + 1 )
<S2SV_ModStart> szName [ 1024 <S2SV_ModEnd> ] , <S2SV_ModStart> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> > 1 && strlen ( ext ) <= sizeof ( szExt )
<S2SV_ModStart> ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ;
<S2SV_ModStart> while ( ( i < to_read ) && <S2SV_ModStart> 0 ) <S2SV_ModEnd> ) {
<S2SV_ModStart> ) { GF_Box * dref ; <S2SV_ModStart> "[iso<S2SV_blank>file]<S2SV_blank>Missing<S2SV_blank>dref<S2SV_blank>box<S2SV_blank>in<S2SV_blank>dinf\\n" ) ) ; dref = gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF <S2SV_ModStart> * ) dref ; gf_isom_box_add_for_dump_mode ( s , dref <S2SV_ModEnd> ) ;
<S2SV_ModStart> rounds , dec_tables . T <S2SV_ModEnd> ) ; <S2SV_ModStart> rounds , dec_tables . T <S2SV_ModEnd> ) ;
<S2SV_ModStart> rounds , enc_tables . T <S2SV_ModEnd> ) ; <S2SV_ModStart> rounds , enc_tables . T <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { dec_tables . counter_head ++ ; dec_tables . counter_tail ++ ;
<S2SV_ModStart> ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> * ) & enc_tables <S2SV_ModEnd> , sizeof <S2SV_ModStart> sizeof ( enc_tables <S2SV_ModEnd> ) )
<S2SV_ModStart> <S2SV_null> static inline <S2SV_ModStart> 0 ; len - i >= 8 * 32 <S2SV_ModEnd> ; i <S2SV_ModStart> ; } for ( ; i < len ; i += 32 ) { ( void ) tab [ i ] ; }
<S2SV_ModStart> vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return
<S2SV_ModStart> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> close_connection ( <S2SV_ModStart> ) ; return - 1 ; } return 0 ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) ; if ( <S2SV_ModStart> conn ) != 0 ) return
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> parse_input ( <S2SV_ModStart> ; } return <S2SV_ModStart> conn ) <S2SV_ModEnd> ; } <S2SV_ModStart> ; return 0 <S2SV_ModStart> ) ; return 0 ;
<S2SV_ModStart> ) { if ( cpkt . length != 16 ) { fprintf ( stderr , _ ( "Invalid<S2SV_blank>salt<S2SV_blank>length:<S2SV_blank>%d<S2SV_blank>(instead<S2SV_blank>of<S2SV_blank>16)<S2SV_blank>received<S2SV_blank>from<S2SV_blank>server<S2SV_blank>%s\\n" ) , cpkt . length , ether_ntoa ( ( struct ether_addr * ) dstmac ) ) ; } <S2SV_ModStart> data , 16 <S2SV_ModEnd> ) ;
<S2SV_ModStart> int plen , act_pass_len <S2SV_ModStart> # endif act_pass_len = strnlen ( password , 82 ) ; <S2SV_ModStart> 0 ; memcpy <S2SV_ModEnd> ( md5data <S2SV_ModStart> password , act_pass_len ) <S2SV_ModEnd> ; memcpy <S2SV_ModStart> 1 + act_pass_len <S2SV_ModEnd> , pass_salt <S2SV_ModStart> md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ;
<S2SV_ModStart> == MT_CPTYPE_PASSWORD && cpkt . length == 17 <S2SV_ModStart> _ ( "(%d)<S2SV_blank>Unhandeled<S2SV_blank>control<S2SV_blank>packet<S2SV_blank>type:<S2SV_blank>%d,<S2SV_blank>length:<S2SV_blank>%d" <S2SV_ModEnd> ) , <S2SV_ModStart> . cptype , cpkt . length
<S2SV_ModStart> slavename ; int act_pass_len ; <S2SV_ModStart> # endif act_pass_len = strlen ( user -> password ) ; act_pass_len = act_pass_len <= 82 ? act_pass_len : 82 ; <S2SV_ModStart> 0 ; memcpy <S2SV_ModEnd> ( md5data <S2SV_ModStart> password , act_pass_len <S2SV_ModEnd> ) ; <S2SV_ModStart> 1 + act_pass_len <S2SV_ModEnd> , curconn <S2SV_ModStart> md5data , 1 + act_pass_len + 16 <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( <S2SV_ModEnd> act_size > <S2SV_ModStart> > MT_PACKET_LEN - packet -> size
<S2SV_ModStart> if ( length > MT_PACKET_LEN - <S2SV_ModStart> -> size <S2SV_ModEnd> ) {
<S2SV_ModStart> if ( data_len > MT_PACKET_LEN - 4 - <S2SV_ModStart> -> size <S2SV_ModEnd> ) {
<S2SV_ModStart> uint16_t ) ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize - sizeof ( effect_param_t
<S2SV_ModStart> int ) sizeof ( effect_param_t ) || ( ( effect_param_t * ) pCmdData ) -> psize > * replySize -
<S2SV_ModStart> ( param2 < 0 || param2 <S2SV_ModStart> EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32438598" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> if ( param2 < 0 || <S2SV_ModStart> EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32436341" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; } <S2SV_ModStart> if ( param2 < 0 || <S2SV_ModStart> EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , "32247948" ) ; ALOGW ( "\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d" , param2 ) ; }
<S2SV_ModStart> = - EINVAL <S2SV_ModEnd> ; bool <S2SV_ModStart> 0 ; uint32_t session_id ; uint32_t stream_type ; effect_uuid_t uuid ; <S2SV_ModStart> ) ; if ( recv_contex == NULL ) { return status ; } <S2SV_ModStart> vol_listner_init_lock ) ; session_id = recv_contex -> session_id ; stream_type = recv_contex -> stream_type ; uuid = recv_contex -> desc -> uuid <S2SV_ModStart> , & uuid <S2SV_ModEnd> , sizeof <S2SV_ModStart> session_id == <S2SV_ModEnd> session_id ) <S2SV_ModStart> stream_type == <S2SV_ModEnd> stream_type ) <S2SV_ModStart> list_remove ( node <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ;
<S2SV_ModStart> server_princ , <S2SV_ModEnd> r -> <S2SV_ModStart> -> client_princ ? & r -> client_princ <S2SV_ModStart> -> name : NULL , <S2SV_ModEnd> r -> <S2SV_ModStart> -> client_princ ? & r -> client_princ <S2SV_ModStart> -> realm : NULL
<S2SV_ModStart> krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) <S2SV_ModStart> cp , tgt_realm ,
<S2SV_ModStart> krb5_principal client_principal , const char * tgt_realm <S2SV_ModStart> ) , tgt_realm <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( 3 == <S2SV_ModStart> o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { *
<S2SV_ModStart> if ( 3 == <S2SV_ModStart> o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { *
<S2SV_ModStart> if ( 3 == <S2SV_ModStart> o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * <S2SV_ModStart> ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> if ( 3 == <S2SV_ModStart> o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) <S2SV_ModEnd> { * <S2SV_ModStart> ; } LIBXSMM_ASSERT ( 0 != l_row && 0 != l_column ) ;
<S2SV_ModStart> ] ; <S2SV_ModEnd> j = <S2SV_ModStart> b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> ] ; <S2SV_ModEnd> j = <S2SV_ModStart> b ; if ( j >= 0 && j < elements * size ) { <S2SV_ModStart> ] ; <S2SV_ModEnd> j = <S2SV_ModStart> b ; if ( j >= 0 && j < elements * size ) {
<S2SV_ModStart> ) { <S2SV_ModEnd> uint16_t StructSize <S2SV_ModStart> ; } smb_ofile_flush ( sr , <S2SV_ModEnd> sr -> <S2SV_ModStart> -> fid_ofile <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } smb_ofile_flush <S2SV_ModEnd> ( sr <S2SV_ModStart> ) ; smb_ofile_flush <S2SV_ModEnd> ( sr
<S2SV_ModStart> '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ <S2SV_ModEnd> ; rw_exit
<S2SV_ModStart> dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
<S2SV_ModStart> len ; qboolean isLocalConfig ; <S2SV_ModStart> ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> , seq , size << 3
<S2SV_ModStart> * offset , int maxoffset <S2SV_ModStart> ) { if ( bloc >= maxoffset ) { * ch = 0 ; * offset = maxoffset + 1 ; return ; }
<S2SV_ModStart> * offset , int maxoffset <S2SV_ModStart> , fout , maxoffset
<S2SV_ModStart> * fout , int maxoffset <S2SV_ModStart> , fout , maxoffset <S2SV_ModStart> , fout , maxoffset
<S2SV_ModStart> * fout , int maxoffset <S2SV_ModStart> , fout , maxoffset <S2SV_ModStart> ) { if ( bloc >= maxoffset ) { bloc = maxoffset + 1 ; return ; }
<S2SV_ModStart> nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } <S2SV_ModStart> ) { if ( msg -> readcount + ( bits >> 3 ) > msg -> cursize ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> 7 ; if ( msg -> bit + nbits > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; } <S2SV_ModStart> -> bit , msg -> cursize << 3 <S2SV_ModStart> ) ; if ( msg -> bit > msg -> cursize << 3 ) { msg -> readcount = msg -> cursize + 1 ; return 0 ; }
<S2SV_ModStart> msg -> overflowed ) { <S2SV_ModEnd> return ; <S2SV_ModStart> if ( msg -> cursize + ( bits >> 3 ) > msg -> maxsize ) { msg -> overflowed = qtrue ; return ; } if ( <S2SV_ModStart> 7 ; if ( msg -> bit + nbits > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; } <S2SV_ModStart> -> bit , msg -> maxsize << 3 <S2SV_ModStart> ) ; if ( msg -> bit > msg -> maxsize << 3 ) { msg -> overflowed = qtrue ; return ; }
<S2SV_ModStart> | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> ) ; if ( ! COM_CompareExtension ( filename , ".txt" ) ) { Com_Printf ( "Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".txt\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n" ) ; return ; }
<S2SV_ModStart> ( "Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n" ) ; return ; } if ( ! COM_CompareExtension ( filename , ".cfg" ) ) { Com_Printf ( "Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\".cfg\\"<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"
<S2SV_ModStart> | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> ) ; if ( COM_CompareExtension ( s_alDriver -> string , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , s_alDriver -> string ) ; return qfalse ; }
<S2SV_ModStart> len ; qboolean isLocalConfig ; <S2SV_ModStart> ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> len ; qboolean isLocalConfig ; <S2SV_ModStart> ) ; isLocalConfig = ! strcmp ( filename , "autoexec.cfg" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> ) { if ( isLocalConfig && search -> pack ) continue ;
<S2SV_ModStart> dllhandle ; if ( COM_CompareExtension ( name , ".pk3" ) ) { Com_Printf ( "Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\"%s\\"" , name ) ; return NULL ; }
<S2SV_ModStart> & t ) ; if ( tm == NULL ) return g_strdup ( "???"
<S2SV_ModStart> * list , * newlist <S2SV_ModStart> == nick <S2SV_ModEnd> ) { <S2SV_ModStart> ) { newlist = <S2SV_ModEnd> nick -> <S2SV_ModStart> -> next ; <S2SV_ModEnd> } else <S2SV_ModStart> else { newlist = list ; <S2SV_ModStart> ; } g_hash_table_remove ( channel -> nicks , nick -> nick ) ; if ( newlist != NULL ) { g_hash_table_insert ( channel -> nicks , newlist -> nick , newlist ) ; }
<S2SV_ModStart> signal_remove ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ; signal_remove (
<S2SV_ModStart> ) ; signal_add ( "server<S2SV_blank>disconnected" , ( SIGNAL_FUNC ) sig_server_disconnected ) ;
<S2SV_ModStart> ) ; g_free_not_null ( ircconn -> sasl_username ) ; g_free_not_null ( ircconn -> sasl_password ) ;
<S2SV_ModStart> sasl_username = g_strdup ( <S2SV_ModStart> -> sasl_username ) <S2SV_ModStart> sasl_password = g_strdup ( <S2SV_ModStart> -> sasl_password )
<S2SV_ModStart> sasl_username = g_strdup ( ircnet -> sasl_username ) ; conn -> sasl_password = g_strdup ( ircnet -> sasl_password ) <S2SV_ModEnd> ; }
<S2SV_ModStart> ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( <S2SV_ModStart> ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev (
<S2SV_ModStart> ) { flush_cmd ( ) ;
<S2SV_ModStart> 0 ; <S2SV_ModEnd> if (
<S2SV_ModStart> false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else
<S2SV_ModStart> * ifindex , int * hoplimit <S2SV_ModStart> cbuf [ 2 * <S2SV_ModStart> -> cmsg_level != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> cmsghdr -> <S2SV_ModStart> -> cmsg_type ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> cmsghdr -> <S2SV_ModStart> ; } break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; }
<S2SV_ModStart> , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; err = - errno ; goto close_sock ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVHOPLIMIT , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVHOPLIMIT,."
<S2SV_ModStart> -> ifindex , & msg -> hoplimit <S2SV_ModStart> ndp , "rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d" <S2SV_ModEnd> , str_in6_addr <S2SV_ModStart> -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , "ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> if (
<S2SV_ModStart> json_tokener_success ; if ( ( len < - 1 ) || ( len == - 1 && strlen ( str ) > INT32_MAX ) ) { tok -> err = json_tokener_error_size ; return NULL ; }
<S2SV_ModStart> & ( 1U << ( unsigned int ) <S2SV_ModEnd> i )
<S2SV_ModStart> & ( 1U << ( unsigned int ) <S2SV_ModEnd> i )
<S2SV_ModStart> ) ; goto done ; <S2SV_ModStart> "Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images" ) ; goto done
<S2SV_ModStart> ) ; if ( rctx -> image_width < 1 || rctx -> image_height < 1 ) { iw_set_error ( rctx -> ctx , "Invalid<S2SV_blank>image<S2SV_blank>dimensions" ) ; goto done ; }
<S2SV_ModStart> ) ) { r = ONIGERR_INVALID_GROUP_NAME ; onig_scan_env_set_error_string ( env , r , p - 1 , p + 1 ) ; return r ; } <S2SV_ModEnd> PINC ;
<S2SV_ModStart> . len + 1
<S2SV_ModStart> ) ; if ( len < j + msg -> len + 1 ) { LM_ERR ( "not<S2SV_blank>enough<S2SV_blank>space<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>sip<S2SV_blank>message\\n" ) ; return - 1 ; }
<S2SV_ModStart> ) { char * p = end = <S2SV_ModEnd> * value <S2SV_ModStart> + 1 ; while ( * p ) { if ( * p == '\\\\' ) { p ++ ; * end = * p ; } else { * end = * p ; if ( * p == <S2SV_ModEnd> \'"\' ) <S2SV_ModStart> \'"\' ) break ; } p ++ ; end ++ ; } if ( * end != \'"\' <S2SV_ModEnd> ) { <S2SV_ModStart> ; end = ++ p <S2SV_ModEnd> ; }
<S2SV_ModStart> ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> <S2SV_ModStart> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> -> bit_val , file
<S2SV_ModStart> valsz , "<S2SV_blank>\\\\\\"\'$`<>" <S2SV_ModEnd> ) ; <S2SV_ModStart> valsz , "\\"\\\\" ) ; fputs ( "\\"" <S2SV_ModEnd> , stdout
<S2SV_ModStart> tmpname , const <S2SV_ModStart> * dir , const char * prefix <S2SV_ModStart> localtmp ; const <S2SV_ModStart> rc ; <S2SV_ModEnd> tmpenv = <S2SV_ModStart> = dir ? dir : <S2SV_ModEnd> getenv ( <S2SV_ModStart> if ( ! <S2SV_ModStart> tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModStart> tmpenv , prefix <S2SV_ModEnd> ) ;
<S2SV_ModStart> -> pw , ".chfn"
<S2SV_ModStart> ( pw , ".chsh"
<S2SV_ModStart> * pwd , const char * prefix <S2SV_ModStart> NULL ; <S2SV_ModEnd> pw_init ( <S2SV_ModStart> tmpname , "/etc" , prefix <S2SV_ModEnd> ) )
<S2SV_ModStart> NULL ; <S2SV_ModEnd> if ( <S2SV_ModStart> tmpname , "/etc" , ".vipw" <S2SV_ModEnd> ) )
<S2SV_ModStart> ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) ; int num = snprintf <S2SV_ModEnd> ( outfilename <S2SV_ModStart> outfilename , sizeof ( outfilename ) , <S2SV_ModStart> ) ; if ( num >= sizeof ( outfilename ) ) { fprintf ( stderr , "maximum<S2SV_blank>length<S2SV_blank>of<S2SV_blank>output<S2SV_blank>prefix<S2SV_blank>exceeded\\n" ) ; return 1 ; }
<S2SV_ModStart> not_found ; if ( e - p > HOST_NAME_MAX - 1 ) goto not_found ;
<S2SV_ModStart> == p ) goto not_found ; if ( e - p > HOST_NAME_MAX - 1
<S2SV_ModStart> ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION <S2SV_ModEnd> ; }
<S2SV_ModStart> == gcode && wordlist [ key ] . index >= 0
<S2SV_ModStart> } } if ( * state != CCS_START )
<S2SV_ModStart> , group <S2SV_ModEnd> ; Node <S2SV_ModStart> * tp ; unsigned int parse_depth ; group = 0 <S2SV_ModStart> goto end_of_token ; parse_depth = env -> parse_depth <S2SV_ModStart> ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID ; parse_depth ++ ; if ( parse_depth > ParseDepthLimit ) return ONIGERR_PARSE_DEPTH_LIMIT_OVER ;
<S2SV_ModStart> ) ; <S2SV_ModEnd> DATA_ENSURE ( <S2SV_ModStart> ; s <S2SV_ModEnd> ++ ;
<S2SV_ModStart> dmin ; if ( q >= end ) return 0 ;
<S2SV_ModStart> ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
<S2SV_ModStart> ) { if ( p - str < reg -> dmax ) { * low = ( UChar * ) str ; if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , str , * low ) ; } else { <S2SV_ModStart> ) ; }
<S2SV_ModStart> then_len , else_len , <S2SV_ModStart> + SIZE_OP_ATOMIC_END + <S2SV_ModEnd> SIZE_OP_JUMP ; <S2SV_ModStart> ) { <S2SV_ModEnd> else_len = <S2SV_ModStart> reg ) ; if ( else_len < 0 ) return else_len ; } else else_len = 0 <S2SV_ModStart> addr = SIZE_OP_ATOMIC_END + <S2SV_ModStart> r = add_op ( reg , OP_ATOMIC_END ) ; if ( r != 0 ) return r ; if ( IS_NOT_NULL ( Else ) ) { r =
<S2SV_ModStart> ; } len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END ; <S2SV_ModStart> ) { <S2SV_ModEnd> tlen =
<S2SV_ModStart> < 0 || num >= 256
<S2SV_ModStart> < 0 || num >= 256
<S2SV_ModStart> ) { int temp_size = 500 ; char * temp = malloc ( temp_size ) <S2SV_ModEnd> ; int <S2SV_ModStart> ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; }
<S2SV_ModStart> 0x1F ; if ( ld -> buffer_size < words * 4 ) ld -> bytes_left = 0 ; else
<S2SV_ModStart> ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;
<S2SV_ModStart> 0 ; last_name = 0 ;
<S2SV_ModStart> isspace ( ( unsigned char )
<S2SV_ModStart> * q <S2SV_ModEnd> ; Clp_Parser <S2SV_ModStart> printf ( "Copyright<S2SV_blank>(C)<S2SV_blank>1992-2010<S2SV_blank>I.<S2SV_blank>Lee<S2SV_blank>Hetherington,<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> ) { set_lenIV ( line <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ) ) { set_cs_start ( line ) <S2SV_ModEnd> ; } <S2SV_ModStart> isdigit ( ( unsigned char ) <S2SV_ModStart> isdigit ( ( unsigned char ) <S2SV_ModStart> isspace ( ( unsigned char )
<S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> isxdigit ( ( unsigned char ) <S2SV_ModStart> isxdigit ( ( unsigned char ) <S2SV_ModStart> isxdigit ( ( unsigned char ) <S2SV_ModStart> isxdigit ( ( unsigned char )
<S2SV_ModStart> isspace ( ( unsigned char )
<S2SV_ModStart> printf ( "Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> isupper ( ( unsigned char ) <S2SV_ModStart> isdigit ( ( unsigned char ) <S2SV_ModStart> islower ( ( unsigned char )
<S2SV_ModStart> isspace ( ( unsigned char ) <S2SV_ModStart> isspace ( ( unsigned char )
<S2SV_ModStart> { return skip ( c , body_size + 2 <S2SV_ModEnd> , MSG_JOB_TOO_BIG
<S2SV_ModStart> * key_data = NULL ; if ( n_key_data < <S2SV_ModEnd> 0 ) <S2SV_ModStart> if ( key_data <S2SV_ModEnd> == NULL <S2SV_ModStart> 0 ; ret [ i ] != NULL <S2SV_ModEnd> ; i <S2SV_ModStart> ++ ) <S2SV_ModEnd> free (
<S2SV_ModStart> if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = <S2SV_ModStart> bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if (
<S2SV_ModStart> ) ; arg = ( arg != NULL ) ? arg : "" ;
<S2SV_ModStart> ( retval || pname_data . length == 0 || pname_data . data [ pname_data . length - 1 ] != '\\0'
<S2SV_ModStart> null_server ; krb5_data d ; <S2SV_ModStart> ) ; d = make_data ( ( char * ) sendauth_version , strlen ( sendauth_version ) + 1 ) ; if ( ! data_eq <S2SV_ModEnd> ( inbuf <S2SV_ModStart> ( inbuf , d <S2SV_ModEnd> ) ) <S2SV_ModStart> ( appl_version != NULL && ! problem ) { d = make_data ( appl_version , strlen ( appl_version ) + 1 ) ; if ( ! data_eq <S2SV_ModEnd> ( inbuf <S2SV_ModStart> ( inbuf , d ) <S2SV_ModEnd> ) {
<S2SV_ModStart> ( retval == 0 && server_ptr == NULL ) retval = KRB5_KDB_NOENTRY ; if ( retval
<S2SV_ModStart> ] == NULL || * realms [ 0 ] ==
<S2SV_ModStart> ( REMAIN == 0 || REMAIN
<S2SV_ModStart> ) ; <S2SV_ModEnd> ret_freegc ( <S2SV_ModStart> -> checksum <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } <S2SV_ModEnd> gr -> <S2SV_ModStart> value = "xxxx" ; <S2SV_ModEnd> gr -> <S2SV_ModStart> gr_ctx . <S2SV_ModEnd> length = <S2SV_ModStart> length = 4 <S2SV_ModEnd> ; gr
<S2SV_ModStart> ) ; princ -> pw_expiration = 0 ; clear ( princ -> attributes , KRB5_KDB_REQUIRES_PWCHANGE ) ;
<S2SV_ModStart> if ( ! code <S2SV_ModEnd> || code <S2SV_ModStart> == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
<S2SV_ModStart> ) ; success = data_eq_string ( * realm , <S2SV_ModEnd> handle -> <S2SV_ModStart> . realm ) && data_eq_string ( * c1 , "kadmin" ) && ! data_eq_string ( * c2 , "history" ) ; <S2SV_ModEnd> fail_princ :
<S2SV_ModStart> if ( ctx -> terminated ||
<S2SV_ModStart> if ( ctx -> terminated ||
<S2SV_ModStart> GSS_C_NO_BUFFER_SET ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; }
<S2SV_ModStart> kgctx . established = 1 ; kgctx .
<S2SV_ModStart> ; } if ( <S2SV_ModEnd> comp1 -> <S2SV_ModStart> -> data != NULL ) memcpy ( comp1_str <S2SV_ModStart> , comp1 -> data , comp1 -> length ) ; if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 <S2SV_ModStart> if ( <S2SV_ModEnd> ! temp_buf <S2SV_ModStart> ; } if ( comp2 -> data != NULL ) memcpy <S2SV_ModEnd> ( temp_buf <S2SV_ModStart> -> length <S2SV_ModEnd> ) ;
<S2SV_ModStart> kdc_active_realm , client . princ <S2SV_ModEnd> , request
<S2SV_ModStart> ) ; * objp = NULL ;
<S2SV_ModStart> ; } * tl_data_head = NULL ;
<S2SV_ModStart> ) ; <S2SV_ModEnd> XDR_DESTROY (
<S2SV_ModStart> ( REMAIN == 0 || REMAIN
<S2SV_ModStart> , last_pwd , n_new_keys <S2SV_ModStart> ) { n_new_keys = count_new_keys ( kdb -> n_key_data , kdb -> key_data ) ; <S2SV_ModStart> context , n_new_keys <S2SV_ModEnd> , kdb
<S2SV_ModStart> if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> ) && entry -> policy == NULL <S2SV_ModEnd> ) return <S2SV_ModStart> mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & <S2SV_ModStart> return KADM5_BAD_MASK <S2SV_ModEnd> ; ret
<S2SV_ModStart> if ( entry == NULL ) return EINVAL ; if ( <S2SV_ModStart> ) && entry -> policy == NULL <S2SV_ModEnd> ) return <S2SV_ModStart> if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) <S2SV_ModEnd> ) return <S2SV_ModStart> ) return KADM5_BAD_MASK <S2SV_ModEnd> ; if
<S2SV_ModStart> = 0 ; if ( sprinc == NULL ) return NULL
<S2SV_ModStart> if ( password == NULL ||
<S2SV_ModStart> ; goto bailout <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto bailout <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto bailout <S2SV_ModEnd> ; } <S2SV_ModStart> ; goto bailout <S2SV_ModEnd> ; }
<S2SV_ModStart> ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; <S2SV_ModEnd> goto cleanup <S2SV_ModStart> ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ;
<S2SV_ModStart> ( rep != NULL && rep <S2SV_ModStart> data = ( char * )
<S2SV_ModStart> 1 ; if ( i < n_key_data - 1 ) <S2SV_ModStart> [ i + 1
<S2SV_ModStart> } } if ( ! <S2SV_ModEnd> xdr_opaque ( <S2SV_ModStart> ) ) return FALSE ; if ( ( * objp ) [ size - 1 ] != '\\0' ) return FALSE ; if ( memchr ( * objp , '\\0' , size - 1 ) != NULL ) return FALSE ; return TRUE
<S2SV_ModStart> KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
<S2SV_ModStart> ; char <S2SV_ModEnd> * strval <S2SV_ModStart> ; krb5_boolean <S2SV_ModEnd> establish_links = <S2SV_ModStart> ) { if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } st = validate_xargs ( context , ldap_server_handle , & xargs , standalone_principal_dn , subtreelist , <S2SV_ModEnd> ntrees ) <S2SV_ModStart> st ) <S2SV_ModEnd> goto cleanup
<S2SV_ModStart> KRB5_PREAUTH_FAILED ; if ( retval == 0 ) rs . enc_tkt_reply -> flags |= TKT_FLG_PRE_AUTH ;
<S2SV_ModStart> config ; <S2SV_ModEnd> armor_key = <S2SV_ModStart> = respond ; rs -> enc_tkt_reply = enc_tkt_reply
<S2SV_ModStart> arg , EINVAL <S2SV_ModEnd> , NULL <S2SV_ModStart> arg , EINVAL <S2SV_ModEnd> , NULL
<S2SV_ModStart> ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> token_wrapper_len + 22 <S2SV_ModEnd> ) {
<S2SV_ModStart> retval ) r = k5memdup0 <S2SV_ModEnd> ( realm <S2SV_ModStart> ( realm , rlen , & retval ) ; <S2SV_ModEnd> while (
<S2SV_ModStart> size_t i <S2SV_ModEnd> ; gss_delete_sec_context
<S2SV_ModStart> NULL ) return retval <S2SV_ModEnd> ; status <S2SV_ModStart> 0 ; <S2SV_ModEnd> X509_NAME_free (
<S2SV_ModStart> j ; * md_out = NULL ; md = calloc ( 1 , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> sizeof ( <S2SV_ModEnd> * md <S2SV_ModStart> cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_subject_name <S2SV_ModStart> ) , & <S2SV_ModEnd> md -> <S2SV_ModStart> -> subject_dn ) ; if ( ret ) goto cleanup ; ret = rfc2253_name <S2SV_ModEnd> ( X509_get_issuer_name <S2SV_ModStart> ) , & <S2SV_ModEnd> md -> <S2SV_ModStart> -> issuer_dn ) ; if ( ret ) goto cleanup ; <S2SV_ModEnd> ret =
<S2SV_ModStart> != 0 && state -> status == NULL ) state -> status = "UNKNOWN_REASON" <S2SV_ModEnd> ; au_state
<S2SV_ModStart> cleanup : if ( status == NULL ) status = "UNKNOWN_REASON" <S2SV_ModEnd> ; if
<S2SV_ModStart> code ) { * status = "DECODE_PA_FOR_USER" ; return code ; } <S2SV_ModEnd> code =
<S2SV_ModStart> ) { * status = "INVALID_S4U2PROXY_OPTIONS" ; <S2SV_ModStart> ) { * status = "EVIDENCE_TICKET_MISMATCH" ;
<S2SV_ModStart> code ) { * status = "DECODE_PA_S4U_X509_USER" ; return code ; } <S2SV_ModEnd> code =
<S2SV_ModStart> ) { int len <S2SV_ModEnd> ; char <S2SV_ModStart> ( ! ( hdr -> filename = <S2SV_ModStart> fn ) ) <S2SV_ModStart> MSPACK_ERR_NOMEMORY ; <S2SV_ModEnd> if ( <S2SV_ModStart> if ( ( len = <S2SV_ModStart> 9 ) ) < 2 <S2SV_ModEnd> ) return <S2SV_ModStart> i < len <S2SV_ModEnd> ; i <S2SV_ModStart> i ++ ) if ( ! ( * <S2SV_ModEnd> fn ++ <S2SV_ModStart> fn ++ <S2SV_ModEnd> = buf <S2SV_ModStart> break ; if ( i == 9 && buf [ 8 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + <S2SV_ModStart> + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) <S2SV_ModStart> return MSPACK_ERR_SEEK ; fn -- <S2SV_ModStart> if ( ( len = <S2SV_ModStart> 4 ) ) < 2 <S2SV_ModEnd> ) return <S2SV_ModStart> i < len <S2SV_ModEnd> ; i <S2SV_ModStart> i ++ ) if ( ! ( * <S2SV_ModEnd> fn ++ <S2SV_ModStart> fn ++ <S2SV_ModEnd> = buf <S2SV_ModStart> break ; if ( i == 4 && buf [ 3 ] != '\\0' ) return MSPACK_ERR_DATAFORMAT ; if ( sys -> seek ( fh , ( off_t ) ( <S2SV_ModEnd> i + <S2SV_ModStart> + 1 - len ) , MSPACK_SYS_SEEK_CUR <S2SV_ModEnd> ) ) <S2SV_ModStart> return MSPACK_ERR_SEEK ; fn --
<S2SV_ModStart> 1 ; if ( bits_left == 0 ) <S2SV_ModStart> 16 ) <S2SV_ModEnd> ; bits_left
<S2SV_ModStart> if ( name_len == 40 && <S2SV_ModStart> memcmp ( name , content_name , 40 <S2SV_ModEnd> ) == <S2SV_ModStart> ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && <S2SV_ModEnd> memcmp ( <S2SV_ModStart> memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == <S2SV_ModStart> sec1 . control <S2SV_ModEnd> = fi <S2SV_ModStart> if ( name_len == 41 && <S2SV_ModStart> memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == <S2SV_ModStart> sec1 . spaninfo <S2SV_ModEnd> = fi <S2SV_ModStart> if ( name_len == 105 && <S2SV_ModStart> memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == <S2SV_ModStart> sec1 . <S2SV_ModEnd> rtable = <S2SV_ModStart> fi ; <S2SV_ModEnd> } fi
<S2SV_ModStart> -> index_root >= <S2SV_ModEnd> chm -> <S2SV_ModStart> chunk_end ; if ( name_len == 0 ) goto chunk_end ;
<S2SV_ModStart> ( chunk_num >= <S2SV_ModEnd> chm ->
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_ModEnd> char * <S2SV_ModStart> create_output_name ( <S2SV_ModEnd> char * <S2SV_ModStart> * fname ) { <S2SV_ModEnd> char * <S2SV_ModStart> char * out , <S2SV_ModEnd> * p <S2SV_ModStart> * p <S2SV_ModEnd> ; if <S2SV_ModStart> if ( ( out = malloc ( <S2SV_ModEnd> strlen ( <S2SV_ModStart> strlen ( fname ) + 1 <S2SV_ModEnd> ) ) <S2SV_ModStart> ) { <S2SV_ModEnd> while ( <S2SV_ModStart> fname == '/' || * fname == '\\\\' <S2SV_ModEnd> ) fname <S2SV_ModStart> ++ ; strcpy ( out , ( * fname ) ? fname : "x" ) ; for ( <S2SV_ModStart> p = out ; * p ; p ++ ) <S2SV_ModEnd> { if <S2SV_ModStart> if ( p [ 0 ] == '.' && p [ 1 ] == '.' <S2SV_ModEnd> && ( <S2SV_ModStart> && ( p [ 2 ] == '/' || p [ 2 ] == '\\\\' <S2SV_ModEnd> ) ) <S2SV_ModStart> ) { p [ 0 ] = p [ 1 ] = 'x' <S2SV_ModEnd> ; } <S2SV_ModStart> } } <S2SV_ModEnd> } return <S2SV_ModStart> } return out <S2SV_ModEnd> ; }
<S2SV_ModStart> create_output_name ( <S2SV_ModEnd> f [ <S2SV_ModStart> -> filename <S2SV_ModEnd> ) ;
<S2SV_ModStart> chunk_end ; <S2SV_ModEnd> name = <S2SV_ModStart> length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue
<S2SV_ModStart> if ( rar -> dictionary_size == 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>zero<S2SV_blank>dictionary<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } if (
<S2SV_ModStart> _a ; const size_t max_write = INT_MAX ; <S2SV_ModStart> "archive_write_data" ) ; if ( s > max_write ) s = max_write
<S2SV_ModStart> r ; size_t <S2SV_ModEnd> ffmax , <S2SV_ModStart> cnt , ( int ) <S2SV_ModStart> ( ( <S2SV_ModEnd> l = <S2SV_ModStart> if ( <S2SV_ModEnd> np -> <S2SV_ModStart> ( parent_len > 240 || <S2SV_ModEnd> np -> <S2SV_ModStart> > 240 || parent_len + np -> mb_len > 240 <S2SV_ModStart> if ( <S2SV_ModEnd> l == <S2SV_ModStart> if ( <S2SV_ModEnd> l == <S2SV_ModStart> if ( <S2SV_ModEnd> l ==
<S2SV_ModStart> LOGICAL_BLOCK_SIZE * ( int64_t ) <S2SV_ModStart> LOGICAL_BLOCK_SIZE * ( int64_t )
<S2SV_ModStart> [ filename_size <S2SV_ModEnd> ] =
<S2SV_ModStart> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
<S2SV_ModStart> '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Path<S2SV_blank>is<S2SV_blank>absolute" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for (
<S2SV_ModStart> ) ; assert ( ( ae = archive_entry_new ( ) ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; assert ( 0 == archive_write_header ( a , ae ) ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; assert ( 0 == unlink ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ) ; assert ( archive_entry_clear ( ae ) != NULL ) ; archive_entry_copy_pathname ( ae , "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ; archive_entry_set_mode ( ae , S_IFREG | 0777 ) ; archive_write_disk_set_options ( a , ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) ; failure ( "Extracting<S2SV_blank>an<S2SV_blank>absolute<S2SV_blank>path<S2SV_blank>should<S2SV_blank>fail<S2SV_blank>here." ) ; assertEqualInt ( ARCHIVE_FAILED , archive_write_header ( a , ae ) ) ; archive_entry_free ( ae ) ; assert ( 0 == archive_write_finish_entry ( a ) ) ; assertFileNotExists ( "/tmp/libarchive_test-test_write_disk_secure-absolute_path.tmp" ) ;
<S2SV_ModStart> , best_bid , n <S2SV_ModStart> for ( n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> ) { <S2SV_ModStart> } } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding" ) ; return ( ARCHIVE_FATAL ) ;
<S2SV_ModStart> kEmptyStream : if ( h -> emptyStreamBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ; } if ( h -> emptyFileBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> ; } if ( h -> antiBools != NULL ) return ( - 1 ) ; <S2SV_ModStart> * 4 ) return ( - 1 ) ; if ( zip -> entry_names != NULL <S2SV_ModStart> p ; if ( h -> attrBools != NULL ) return ( - 1 ) ;
<S2SV_ModStart> if ( lha -> compsize < 0 ) goto invalid ; if (
<S2SV_ModStart> ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , "Too<S2SV_blank>many<S2SV_blank>arguments" ) ; return ARCHIVE_WARN ; } <S2SV_ModStart> ) ; <S2SV_ModEnd> } if
<S2SV_ModStart> # if HAVE_LZMA_H <S2SV_ModEnd> && HAVE_LIBLZMA
<S2SV_ModStart> 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;
<S2SV_ModStart> ) - 128 <S2SV_ModEnd> ) )
<S2SV_ModStart> ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
<S2SV_ModStart> * b + len , * avail - len <S2SV_ModEnd> , nl
<S2SV_ModStart> ) { if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , "Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte" ) ; return ( ARCHIVE_FATAL ) ; }
<S2SV_ModStart> if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , "Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n" ) ; return AVERROR_INVALIDDATA ; } if (
<S2SV_ModStart> if ( <S2SV_ModEnd> temp_buffer & <S2SV_ModStart> temp_buffer & 0xfffffe00 ) continue ; if ( temp_buffer < 2 <S2SV_ModEnd> ) continue <S2SV_ModStart> ( temp_buffer >= 0x100 && temp_buffer <S2SV_ModStart> if ( temp_buffer >= 0x120 &&
<S2SV_ModStart> uint16_t auxsize ; int ret <S2SV_ModStart> ] ; if ( ( ret = <S2SV_ModStart> vsize ) ) < 0 ) return ret <S2SV_ModStart> } } if ( ( ret = <S2SV_ModStart> asize ) ) < 0 ) return ret
<S2SV_ModStart> ) { size_t <S2SV_ModEnd> len ; <S2SV_ModStart> len = <S2SV_ModEnd> ( cp <S2SV_ModStart> len > <S2SV_ModEnd> sizeof (
<S2SV_ModStart> label_len ; <S2SV_ModEnd> GET8 ( <S2SV_ModStart> 1 ; if ( j + label_len > length ) return - 1 ;
<S2SV_ModStart> ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; <S2SV_ModEnd> need_to_append_dot = <S2SV_ModStart> 1 ; <S2SV_ModEnd> for (
<S2SV_ModStart> int i <S2SV_ModEnd> = 0 <S2SV_ModStart> ] & ! TGA_RLE_FLAG <S2SV_ModEnd> ) + <S2SV_ModStart> if ( ( bitmap_caret <S2SV_ModEnd> + ( <S2SV_ModStart> ) ) >= image_block_size <S2SV_ModEnd> ) { <S2SV_ModStart> ) { memcpy ( tga -> bitmap + bitmap_caret , decompression_buffer + buffer_caret , pixel_block_size ) ; bitmap_caret += pixel_block_size ; <S2SV_ModEnd> } buffer_caret <S2SV_ModStart> if ( ( bitmap_caret <S2SV_ModEnd> + ( <S2SV_ModStart> ) ) >= image_block_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } memcpy ( tga -> bitmap + bitmap_caret , decompression_buffer + buffer_caret , encoded_pixels * pixel_block_size ) ; bitmap_caret += ( encoded_pixels * pixel_block_size ) ; buffer_caret += ( encoded_pixels * pixel_block_size ) ; <S2SV_ModEnd> } }
<S2SV_ModStart> == TGA_BPP_32 && <S2SV_ModEnd> tga ->
<S2SV_ModStart> # endif if ( ! ( <S2SV_ModEnd> ( tga <S2SV_ModStart> -> bits == TGA_BPP_24 && tga -> alphabits == 0 ) || ( tga -> bits == TGA_BPP_32 && tga -> alphabits == 8 ) ) ) { gd_error_ex ( GD_WARNING , "gd-tga:<S2SV_blank>%u<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>with<S2SV_blank>%u<S2SV_blank>alpha<S2SV_blank>bits<S2SV_blank>not<S2SV_blank>supported\\n" , <S2SV_ModEnd> tga -> <S2SV_ModStart> -> bits , tga -> alphabits <S2SV_ModStart> - 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> if ( color < 0 || ( ! gdImageTrueColor ( im ) && color >= gdImageColorsTotal ( im ) ) <S2SV_ModEnd> ) { <S2SV_ModStart> ; } match = 1 ; for ( y = 0 ; match && y < height ; y ++ ) { for ( x = 0 ; match && x < width ; x ++ ) { match = ( gdColorMatch ( im , color , gdImageGetPixel ( im , x , y ) , threshold ) ) > 0 ; } } if ( y == height - 1 ) { return NULL ; }
<S2SV_ModStart> ++ ; if ( encoded_pixels != 0 ) { if ( ! ( ( buffer_caret + ( encoded_pixels * pixel_block_size ) ) < image_block_size ) ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } <S2SV_ModStart> } } } <S2SV_ModStart> ++ ; if ( encoded_pixels != 0 ) { if ( ! ( ( buffer_caret + ( encoded_pixels * pixel_block_size ) ) < image_block_size ) ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } <S2SV_ModStart> } } }
<S2SV_ModStart> ) { gdImageDestroy <S2SV_ModEnd> ( tmp_im
<S2SV_ModStart> dp ; if ( dp -> pos < 0 || dp -> pos >= dp -> realSize ) { return 0 ; } <S2SV_ModStart> ; } if ( dp -> pos + rlen > dp -> realSize ) { rlen = dp -> realSize - dp -> pos ; }
<S2SV_ModStart> buf [ 1024 <S2SV_ModEnd> ] ;
<S2SV_ModStart> } } gdCtxPuts ( out , "#define<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_width<S2SV_blank>" ) ; <S2SV_ModStart> out , "%d\\n" <S2SV_ModEnd> , gdImageSX <S2SV_ModStart> ) ; gdCtxPuts ( out , "#define<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_height<S2SV_blank>" ) ; <S2SV_ModStart> out , "%d\\n" <S2SV_ModEnd> , gdImageSY <S2SV_ModStart> ) ; gdCtxPuts ( out , "static<S2SV_blank>unsigned<S2SV_blank>char<S2SV_blank>" ) ; gdCtxPuts ( out , name ) ; gdCtxPuts ( out , "_bits[]<S2SV_blank>=<S2SV_blank>{\\n<S2SV_blank><S2SV_blank>" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { gdCtxPuts <S2SV_ModEnd> ( out <S2SV_ModStart> ) { gdCtxPuts <S2SV_ModEnd> ( out <S2SV_ModStart> } } gdCtxPuts <S2SV_ModEnd> ( out
<S2SV_ModStart> int iSrc <S2SV_ModEnd> ; if <S2SV_ModStart> } } <S2SV_ModEnd> res -> <S2SV_ModStart> ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
<S2SV_ModStart> ( remain <= <S2SV_ModEnd> 0 )
<S2SV_ModStart> ) { _gdImageGifCtx <S2SV_ModEnd> ( im <S2SV_ModStart> im , out <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> NULL ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im <S2SV_ModStart> out ) ) { <S2SV_ModEnd> rv = <S2SV_ModStart> ) ; } else { rv = NULL ; }
<S2SV_ModStart> ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image <S2SV_ModStart> image , fg <S2SV_ModEnd> , out <S2SV_ModStart> , out <S2SV_ModEnd> ) ;
<S2SV_ModStart> NULL ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im <S2SV_ModStart> out ) ) { <S2SV_ModEnd> rv = <S2SV_ModStart> ) ; } else { rv = NULL ; }
<S2SV_ModStart> if ( buffer_caret + pixel_block_size > rle_size ) { gdFree ( decompression_buffer ) ; gdFree ( conversion_buffer ) ; return - 1 ; } if (
<S2SV_ModStart> ) { check_file ( "heap_overflow_1.tga" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; check_file ( "heap_overflow_2.tga" <S2SV_ModEnd> ) ;
<S2SV_ModStart> res ; size_t weights_size ; if ( overflow2 ( windows_size , sizeof ( double ) ) ) { return NULL ; } else { weights_size = windows_size * sizeof ( double ) ; } res = ( LineContribType * ) gdMalloc ( sizeof ( LineContribType ) ) ; if ( ! res ) { return NULL ; } res -> WindowSize = windows_size ; res -> LineLength = line_length ; if ( overflow2 ( line_length , sizeof ( ContributionType ) ) ) { gdFree ( res ) ; return NULL ; } res -> ContribRow = ( ContributionType * ) gdMalloc ( line_length * sizeof ( ContributionType ) ) ; if ( res -> ContribRow == NULL ) { gdFree ( res ) ; return NULL ; } for ( u <S2SV_ModEnd> = 0 <S2SV_ModStart> 0 ; <S2SV_ModEnd> u < <S2SV_ModStart> ++ ) <S2SV_ModEnd> { res <S2SV_ModStart> gdMalloc ( weights_size ) ; if ( <S2SV_ModEnd> res -> <S2SV_ModStart> i ; <S2SV_ModEnd> for ( <S2SV_ModStart> ; i < <S2SV_ModEnd> u ;
<S2SV_ModStart> < 0 || color < 0 <S2SV_ModStart> return ; } if ( ! im -> trueColor ) { if ( ( color > ( im -> colorsTotal - 1 ) ) || ( border > ( im -> colorsTotal - 1 ) ) ) { return ; }
<S2SV_ModStart> > image_block_size || buffer_caret + pixel_block_size > rle_size <S2SV_ModStart> > image_block_size || buffer_caret + ( encoded_pixels * pixel_block_size ) > rle_size
<S2SV_ModStart> GIT_PKT_NG ; if ( len < 3 ) goto out_err ; <S2SV_ModStart> 3 ; len -= 3 ; <S2SV_ModStart> ptr = memchr <S2SV_ModEnd> ( line <S2SV_ModStart> , '<S2SV_blank>' , len <S2SV_ModStart> '\\0' ; if ( len < 1 ) goto out_err ; <S2SV_ModStart> 1 ; len -= 1 ; <S2SV_ModStart> ptr = memchr <S2SV_ModEnd> ( line <S2SV_ModStart> , '\\n' , len
<S2SV_ModStart> ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; }
<S2SV_ModStart> line_end ; <S2SV_ModEnd> error =
<S2SV_ModStart> = 0 <S2SV_ModEnd> ; switch
<S2SV_ModStart> off |= ( ( unsigned ) <S2SV_ModStart> << 24UL )
<S2SV_ModStart> GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
<S2SV_ModStart> ) { giterr_set_str ( GITERR_NET , "Invalid<S2SV_blank>empty<S2SV_blank>packet" ) ; return GIT_ERROR <S2SV_ModEnd> ; }
<S2SV_ModStart> line_end ; <S2SV_ModEnd> error =
<S2SV_ModStart> = 0 <S2SV_ModEnd> ; switch
<S2SV_ModStart> 0 ; # define ADD_DELTA ( o , shift ) { if ( delta < delta_end ) ( o ) |= ( ( unsigned ) <S2SV_ModEnd> * delta <S2SV_ModStart> ++ << shift ) ; else goto fail ; } if ( cmd & 0x01 ) ADD_DELTA ( off , 0UL ) ; if ( cmd & 0x02 ) ADD_DELTA ( off , 8UL ) <S2SV_ModEnd> ; if <S2SV_ModStart> 0x04 ) ADD_DELTA ( off , 16UL ) <S2SV_ModEnd> ; if <S2SV_ModStart> 0x08 ) ADD_DELTA ( off , <S2SV_ModEnd> 24UL ) <S2SV_ModStart> 0x10 ) ADD_DELTA ( len , 0UL ) <S2SV_ModEnd> ; if <S2SV_ModStart> 0x20 ) ADD_DELTA ( len , 8UL ) <S2SV_ModEnd> ; if <S2SV_ModStart> 0x40 ) ADD_DELTA ( len , 16UL ) <S2SV_ModEnd> ; if <S2SV_ModStart> 0x10000 ; # undef ADD_DELTA
<S2SV_ModStart> int is_valid = ( error == GIT_OK ) <S2SV_ModStart> ( ) <S2SV_ModEnd> ; error
<S2SV_ModStart> int is_valid = ( error == GIT_OK ) <S2SV_ModStart> ( ) <S2SV_ModEnd> ; error
<S2SV_ModStart> = 0 , end <S2SV_ModStart> if ( GIT_ADD_SIZET_OVERFLOW ( & end , off , len ) || <S2SV_ModStart> base_len < end <S2SV_ModEnd> || res_sz
<S2SV_ModStart> htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ;
<S2SV_ModStart> htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ;
<S2SV_ModStart> + size < * object || * object + size <S2SV_ModStart> if ( * object + size < * object || <S2SV_ModStart> * 2 < * object || * object + size * 2 <S2SV_ModStart> + size < * object || * object + size <S2SV_ModStart> + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( "%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n" <S2SV_ModEnd> , __func__
<S2SV_ModStart> 0 ; int wv , w1 , w2 , w3 , w4 ; int tmpval [ 4 ] ; int tmpcnt <S2SV_ModEnd> = 0 <S2SV_ModStart> do { while ( ptr < buf + len && ( * ptr == '<S2SV_blank>' || * ptr == '\\t' || * ptr == '\\n' || * ptr == '\\r' ) ) { ptr ++ ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } if ( ( wv = base64_table [ ( int ) ( unsigned char ) * ptr ++ ] ) == - 1 ) { continue ; } tmpval [ tmpcnt ++ ] = wv ; if ( tmpcnt == 4 ) { tmpcnt = 0 ; w1 = tmpval [ 0 ] ; w2 = tmpval [ 1 ] ; w3 = tmpval [ 2 ] ; w4 = tmpval [ 3 ] ; if ( w2 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w1 << 2 ) + ( w2 >> 4 ) ) & 0xFF ) ; } if ( w3 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w2 << 4 ) + ( w3 >> 2 ) ) & 0xFF ) ; } if ( w4 >= 0 ) { outbuf [ p ++ ] = ( unsigned char ) ( ( ( w3 << 6 ) + w4 ) & 0xFF ) ; } <S2SV_ModEnd> } }
<S2SV_ModStart> ) ; if ( filestats . st_size < 8 ) { printf ( "ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n" ) ; return - 1 ; }
<S2SV_ModStart> ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( "%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%" PRIu64 "<S2SV_blank>bytes\\n" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
<S2SV_ModStart> htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ;
<S2SV_ModStart> htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ;
<S2SV_ModStart> 2 ; ( ( <S2SV_ModStart> 1 ] ) && ( kk < input -> length ) )
<S2SV_ModStart> ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
<S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ke ; <S2SV_ModEnd> char fromname <S2SV_ModStart> ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { <S2SV_ModStart> libreswan_log ( "Received<S2SV_blank>Notify(%d):<S2SV_blank>%s" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModStart> ; return STF_FAIL +
<S2SV_ModStart> 16 ] , reallen <S2SV_ModStart> ( ( err = der_length_sequence ( siginfo , 2 , & reallen ) ) != CRYPT_OK ) { XFREE ( out ) ; goto bail_2 ; } if ( ( reallen == outlen ) && (
<S2SV_ModStart> if ( options -> flags & ( UV_PROCESS_SETUID | UV_PROCESS_SETGID ) ) { SAVE_ERRNO ( setgroups ( 0 , NULL ) ) ; } if (
<S2SV_ModStart> buf = g_malloc0 <S2SV_ModEnd> ( size
<S2SV_ModStart> buf = g_try_malloc0 <S2SV_ModEnd> ( size
<S2SV_ModStart> - 1 ) ; virCheckReadOnlyGoto ( dom -> conn -> flags , error
<S2SV_ModStart> if ( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>user<S2SV_blank>SID<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } if ( <S2SV_ModStart> ) { if ( strings_size > ( ( record_data_size - 4 ) - strings_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>strings<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> ) { if ( data_size > ( ( record_data_size - 4 ) - data_offset ) ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_RUNTIME , LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS , "%s:<S2SV_blank>data<S2SV_blank>size<S2SV_blank>value<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds." , function ) ; goto on_error ; } <S2SV_ModStart> record_data [ record_data_offset <S2SV_ModEnd> ] )
<S2SV_ModStart> ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
<S2SV_ModStart> ) { const int qslen = blen - qs ; <S2SV_ModStart> qs , ( size_t ) qslen ) ; qs = j <S2SV_ModEnd> ; j <S2SV_ModStart> j += qslen <S2SV_ModEnd> ; }
<S2SV_ModStart> CONST_STR_LEN ( "%2f?" ) , CONST_STR_LEN ( "/?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( "/%2f?" ) , CONST_STR_LEN ( "//?" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN (
<S2SV_ModStart> false ; if ( url_len >= sizeof ( url_address ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Truncating<S2SV_blank>overflowed<S2SV_blank>address<S2SV_blank>\'%.*s\'" , __func__ , url_len , url_begin ) ; url_len = sizeof ( url_address ) - 1 ; }
<S2SV_ModStart> if ( n2size < 1 ) <S2SV_ModEnd> { applog
<S2SV_ModStart> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor <S2SV_ModStart> && ( intptr_t <S2SV_ModEnd> ) value <S2SV_ModStart> SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> msg , "\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , descriptor <S2SV_ModStart> && ( intptr_t <S2SV_ModEnd> ) value <S2SV_ModStart> SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )
<S2SV_ModStart> ) ; <S2SV_ModEnd> return 0
<S2SV_ModStart> { return NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> { return NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> { return NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> { return NULL <S2SV_ModEnd> ; }
<S2SV_ModStart> szFileName , pszFileName , <S2SV_ModStart> - 5 <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> = - <S2SV_ModStart> , ret <S2SV_ModEnd> ; bool <S2SV_ModStart> ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , <S2SV_ModStart> ; return fret <S2SV_ModEnd> ; } <S2SV_ModStart> ) { usernic_error ( <S2SV_ModEnd> "Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'." , <S2SV_ModStart> ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>" "user<S2SV_blank>IDs:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> setns ( <S2SV_ModStart> fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( <S2SV_ModStart> ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>" "the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> if ( <S2SV_ModStart> VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> ( ! ifindex ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name <S2SV_ModEnd> ( oldname <S2SV_ModStart> ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( "Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n" , ret , <S2SV_ModEnd> oldname , <S2SV_ModStart> newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> IFNAMSIZ ] ; char <S2SV_ModEnd> * namep <S2SV_ModStart> ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } <S2SV_ModStart> ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>" "user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>" "ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> setns ( <S2SV_ModStart> ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( "Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>" "of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) <S2SV_ModEnd> close ( <S2SV_ModStart> close ( fd ) ; close ( <S2SV_ModStart> ; return fret <S2SV_ModEnd> ; }
<S2SV_ModStart> r = safe_mount <S2SV_ModEnd> ( "cgroup_root" <S2SV_ModStart> , "size=10240k,mode=755" , root
<S2SV_ModStart> if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : <S2SV_ModEnd> NULL )
<S2SV_ModStart> ret = safe_mount ( path , destpath , "none" , MS_BIND , NULL , conf -> rootfs . mount <S2SV_ModEnd> ) ;
<S2SV_ModStart> "%r/proc/sys/net" , "%r/proc/tty" <S2SV_ModEnd> , NULL <S2SV_ModStart> LXC_AUTO_PROC_MIXED , "%r/proc/tty" <S2SV_ModEnd> , "%r/proc/sys/net" <S2SV_ModStart> r = safe_mount ( source , destination , default_mounts [ i ] . fstype , mflags , default_mounts [ i ] . options , conf -> rootfs . path ? conf -> rootfs . mount : NULL <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( safe_mount <S2SV_ModEnd> ( "none" <S2SV_ModStart> , "size=100000,mode=755" , rootfs -> path ? rootfs -> mount : NULL
<S2SV_ModStart> int optional , const char * rootfs <S2SV_ModStart> if ( safe_mount <S2SV_ModEnd> ( fsname <S2SV_ModStart> , data , rootfs <S2SV_ModStart> data ) < 0
<S2SV_ModStart> , path , rootfs -> mount
<S2SV_ModStart> * path , const char * rootfs <S2SV_ModStart> , optional , rootfs
<S2SV_ModStart> , path , rootfs
<S2SV_ModStart> -> mnt_dir , NULL
<S2SV_ModStart> if ( safe_mount ( console -> name , path , "none" , MS_BIND , 0 , rootfs -> mount <S2SV_ModEnd> ) )
<S2SV_ModStart> if ( safe_mount ( console -> name , lxcpath , "none" , MS_BIND , 0 , rootfs -> mount ) ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , <S2SV_ModEnd> console -> <S2SV_ModStart> , lxcpath ) ; return - 1 ; } ret = snprintf ( lxcpath , sizeof ( lxcpath ) , "%s/console" , ttydir ) ; if ( ret >= sizeof ( lxcpath ) ) { ERROR ( "lxc/console<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long" ) ; return - 1 ; } ret = symlink ( lxcpath , path ) ; if ( ret ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>for<S2SV_blank>console" ) ; return - 1 ; } INFO ( "console<S2SV_blank>has<S2SV_blank>been<S2SV_blank>setup<S2SV_blank>on<S2SV_blank>%s" , lxcpath ) ; return 0 <S2SV_ModEnd> ; }
<S2SV_ModStart> ipc_socket ; int procfd = payload -> procfd ; <S2SV_ModStart> LXC_ATTACH_LSM ) && init_ctx -> lsm_label <S2SV_ModStart> on_exec ; <S2SV_ModEnd> on_exec = <S2SV_ModStart> 0 ; if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> init_ctx -> <S2SV_ModStart> -> lsm_label ) <S2SV_ModEnd> < 0 <S2SV_ModStart> } } close ( procfd ) ;
<S2SV_ModStart> ] ; int procfd ; <S2SV_ModStart> ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> = exec_payload , . procfd = procfd
<S2SV_ModStart> strlen ( "/lxc/lock/" <S2SV_ModEnd> ) + <S2SV_ModStart> len , "%s/lxc/lock/%s" <S2SV_ModEnd> , rundir <S2SV_ModStart> ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , "%s/lxc/lock/%s/.%s" , rundir , p , <S2SV_ModEnd> n ) <S2SV_ModStart> n ) ; free ( rundir <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> return NULL
<S2SV_ModStart> = RUNTIME_PATH "/lxc/lock/var/lib/lxc/" <S2SV_ModEnd> ; ret
<S2SV_ModStart> ipc_socket ; <S2SV_ModEnd> lxc_attach_options_t * <S2SV_ModStart> fd ; int lsm_labelfd ; <S2SV_ModStart> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>" "that<S2SV_blank>it<S2SV_blank>is<S2SV_blank>done<S2SV_blank>pre-initializing<S2SV_blank>(2):<S2SV_blank>%s" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; <S2SV_ModStart> "PR_SET_NO_NEW_PRIVS<S2SV_blank>is<S2SV_blank>set.<S2SV_blank>Process<S2SV_blank>cannot<S2SV_blank>use<S2SV_blank>execve()<S2SV_blank>" "gainable<S2SV_blank>privileges." ) ; } status = 3 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>set<S2SV_blank>up<S2SV_blank>LSM<S2SV_blank>labels<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 <S2SV_ModStart> on_exec ; ret = lxc_abstract_unix_recv_fd ( ipc_socket , & lsm_labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>parent<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_ModStart> lsm_set_label_at ( lsm_labelfd <S2SV_ModEnd> , on_exec <S2SV_ModStart> ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label." ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; close ( lsm_labelfd ) ; rexit ( - 1 ) ; } close ( lsm_labelfd ) ; <S2SV_ModEnd> } if <S2SV_ModStart> ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_ModEnd> lxc_proc_put_context_info ( <S2SV_ModStart> ; } <S2SV_ModEnd> rexit (
<S2SV_ModStart> <S2SV_null> <S2SV_null> static <S2SV_ModStart> ( int lsm_labelfd <S2SV_ModEnd> , int <S2SV_ModStart> lsm_label ) { int fret <S2SV_ModEnd> = - <S2SV_ModStart> - 1 <S2SV_ModEnd> ; const <S2SV_ModStart> 0 ) return 0 <S2SV_ModEnd> ; if <S2SV_ModStart> 0 ) return 0 <S2SV_ModEnd> ; if <S2SV_ModStart> 0 ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; <S2SV_ModEnd> goto out <S2SV_ModStart> ) ; <S2SV_ModEnd> goto out <S2SV_ModStart> write ( lsm_labelfd <S2SV_ModEnd> , command <S2SV_ModStart> SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s." , command ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , command ) ; } else if ( strcmp ( name , "SELinux" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> ) ; goto out ; } INFO ( "Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s." , lsm_label ) ; } else <S2SV_ModEnd> { ERROR <S2SV_ModStart> ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : <S2SV_ModStart> if ( lsm_labelfd <S2SV_ModEnd> != - <S2SV_ModStart> close ( lsm_labelfd <S2SV_ModEnd> ) ; <S2SV_ModStart> ; return fret <S2SV_ModEnd> ; }
<S2SV_ModStart> ] ; <S2SV_ModEnd> signed long <S2SV_ModStart> ) { int procfd = - 1 ; <S2SV_ModStart> ; } procfd = open ( "/proc" , O_DIRECTORY | O_RDONLY | O_CLOEXEC ) ; if ( procfd < 0 ) { SYSERROR ( "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>/proc." <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status <S2SV_ModEnd> , sizeof <S2SV_ModStart> sizeof ( status ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> ERROR ( <S2SV_ModStart> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } <S2SV_ModStart> ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>" "from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" <S2SV_ModEnd> ) ; <S2SV_ModStart> ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>" "initialization<S2SV_blank>(2):<S2SV_blank>%s." , strerror ( errno ) <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } expected = 3 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>for<S2SV_blank>the<S2SV_blank>child<S2SV_blank>to<S2SV_blank>tell<S2SV_blank>us<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(3):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) && init_ctx -> lsm_label ) { int on_exec , labelfd ; on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; labelfd = lsm_openat ( procfd , attached_pid , on_exec ) ; if ( labelfd < 0 ) goto cleanup_error ; ret = lxc_abstract_unix_send_fd ( ipc_sockets [ 0 ] , labelfd , NULL , 0 ) ; if ( ret <= 0 ) { ERROR ( "Error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>send<S2SV_blank>child<S2SV_blank>LSM<S2SV_blank>fd<S2SV_blank>(4):<S2SV_blank>%s." , strerror ( errno ) ) ; goto cleanup_error ; } } <S2SV_ModStart> cleanup_error : if ( procfd >= 0 ) close ( procfd ) ; <S2SV_ModStart> CLONE_NEWCGROUP ; <S2SV_ModEnd> ret = <S2SV_ModStart> exec_payload , <S2SV_ModEnd> } ;
<S2SV_ModStart> pid , fc -> uid ,
<S2SV_ModStart> tpid , uid_t tuid , <S2SV_ModStart> if ( ! may_move_pid ( tpid , tuid , <S2SV_ModEnd> cred . <S2SV_ModStart> pid ) ) { fail = true ; break ; } if ( fprintf ( pids_file , "%d" , ( int ) cred . pid )
<S2SV_ModStart> ) { <S2SV_ModEnd> bool answer <S2SV_ModStart> char * c2 = get_pid_cgroup ( pid , contrl <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> char * <S2SV_ModStart> char * linecmp <S2SV_ModEnd> ; if <S2SV_ModStart> c2 ) return false <S2SV_ModEnd> ; prune_init_slice <S2SV_ModStart> nextcg ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> true ; <S2SV_ModEnd> out : <S2SV_ModStart> out : <S2SV_ModEnd> free ( <S2SV_ModStart> free ( c2 <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> * controller , * next = NULL <S2SV_ModStart> ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next <S2SV_ModEnd> ) ) <S2SV_ModStart> ) { if ( fpath && strcmp ( next , fpath ) == 0 ) ret = - EEXIST ; else ret = - ENOENT <S2SV_ModEnd> ; goto <S2SV_ModStart> ( ! fc_may_access ( fc , controller , path1 , NULL , O_RDWR ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> ) ; free ( next ) ;
<S2SV_ModStart> ( ! caller_may_see_dir ( fc -> pid , controller , path1 ) ) { ret = - ENOENT ; goto out ; } if ( !
<S2SV_ModStart> ( cgroup ) { if ( ! caller_may_see_dir ( fc -> pid , controller , cgroup ) ) return - ENOENT ; if ( <S2SV_ModEnd> ! fc_may_access <S2SV_ModStart> ) ) <S2SV_ModEnd> return -
<S2SV_ModStart> * controller , * next = NULL <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> cgroup , & next ) ) { if ( ! fpath || strcmp ( next , fpath ) == 0 ) ret = - EBUSY ; else ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY <S2SV_ModEnd> ) ) <S2SV_ModStart> ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { ret = - EACCES ; goto out ; } if ( ! <S2SV_ModStart> ) ; free ( next ) ;
<S2SV_ModStart> == IS_ARRAY && Z_TYPE_PP ( ptr ) == IS_ARRAY
<S2SV_ModStart> ) { goto softfail <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto softfail <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; softfail : state -> offset = 0 ;
<S2SV_ModStart> * len + 8
<S2SV_ModStart> * to = g . inf <S2SV_ModStart> , * sufx = "" ; size_t pre = 0 <S2SV_ModEnd> ; if <S2SV_ModStart> . decode ) { if ( <S2SV_ModEnd> ( g <S2SV_ModStart> ) { pre = justname ( g . inf ) - g . inf ; <S2SV_ModStart> to = justname ( <S2SV_ModStart> . hname ) <S2SV_ModStart> strlen ( to ) ; } else if ( <S2SV_ModEnd> strcmp ( <S2SV_ModStart> ".tgz" ) == 0 ) sufx = <S2SV_ModEnd> ".tar" ; <S2SV_ModStart> ".tar" ; } else sufx = g . sufx ; <S2SV_ModStart> MALLOC ( pre + <S2SV_ModStart> len + <S2SV_ModEnd> strlen ( <S2SV_ModStart> strlen ( <S2SV_ModEnd> sufx ) <S2SV_ModStart> sufx ) <S2SV_ModEnd> + 1 <S2SV_ModStart> outf , g . inf , pre ) ; memcpy <S2SV_ModEnd> ( g <S2SV_ModStart> outf + pre , to , len ) ; strcpy ( g . outf + pre + len , <S2SV_ModEnd> sufx )
<S2SV_ModStart> MS_FALSE ; if ( strchr ( timestring , '\\'' ) || strchr ( timestring , '\\\\' ) ) { msSetError ( MS_MISCERR , "Invalid<S2SV_blank>time<S2SV_blank>filter." , "msPostGISLayerSetTimeFilter()" ) ; return MS_FALSE ; }
<S2SV_ModStart> bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ;
<S2SV_ModStart> u ; if <S2SV_ModEnd> ( n <S2SV_ModStart> ( n < 0 || n >= <S2SV_ModEnd> 32 ) <S2SV_ModStart> 32 ) { return - 1 ; } <S2SV_ModEnd> v =
<S2SV_ModStart> m ; if <S2SV_ModEnd> ( n <S2SV_ModStart> ( n < 0 || n >= <S2SV_ModEnd> 32 ) <S2SV_ModStart> 32 ) { return EOF ; } <S2SV_ModEnd> assert (
<S2SV_ModStart> i , JAS_CAST <S2SV_ModStart> ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( <S2SV_ModStart> ] ) ) <S2SV_ModStart> i , JAS_CAST <S2SV_ModStart> ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( <S2SV_ModStart> ) ) )
<S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl <S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl <S2SV_ModStart> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl <S2SV_ModStart> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl
<S2SV_ModStart> ( roishift < 0 ) { jas_eprintf ( "warning:<S2SV_blank>forcing<S2SV_blank>negative<S2SV_blank>ROI<S2SV_blank>shift<S2SV_blank>to<S2SV_blank>zero<S2SV_blank>" "(bitstream<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>corrupt)\\n" ) ; roishift = 0 ; } if ( roishift <S2SV_ModStart> = ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << numbps
<S2SV_ModStart> > 0 && jas_seq2d_size ( a )
<S2SV_ModStart> depth ; if ( numcolors > <S2SV_ModEnd> RAS_CMAP_MAXSIZ ) <S2SV_ModStart> RAS_CMAP_MAXSIZ ) { return - 1 ; } <S2SV_ModEnd> actualnumcolors =
<S2SV_ModStart> 0 ; assert ( <S2SV_ModEnd> jas_image_numcmpts ( <S2SV_ModStart> image ) <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( ! ( <S2SV_ModEnd> data [ <S2SV_ModStart> ) ) ) ) { goto error ; } <S2SV_ModEnd> } pad <S2SV_ModStart> ) { goto error ; } z = ( z << 8 ) | c ; nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { goto error ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { goto error ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < 3 ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> i ; assert ( numcmpts <= 3 ) ; for ( i = 0 ; i < 3 ; ++ i ) { data [ i ] = 0 ; } <S2SV_ModStart> ) { if ( ! ( <S2SV_ModStart> ) ) ) ) { goto error ; } <S2SV_ModEnd> } rowsize <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error ; } nz -= 8 ; z &= RAS_ONES ( nz ) ; } } if ( nz > 0 ) { c = ( z >> ( 8 - nz ) ) & RAS_ONES ( nz ) ; if ( jas_stream_putc ( out , c ) == EOF ) { goto error ; } } if ( pad % 2 ) { if ( jas_stream_putc ( out , 0 ) == EOF ) { goto error ; } } } for ( i = 0 ; i < numcmpts ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; data [ i ] = 0 ; } return 0 ; error : for ( i = 0 ; i < numcmpts ; ++ i ) { if ( data [ i ] ) { jas_matrix_destroy ( data [ i ] ) ; } } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> * buf <S2SV_ModEnd> ; assert <S2SV_ModStart> ) ) && bufsize

<S2SV_ModStart> ; int hstartrow <S2SV_ModEnd> ; if <S2SV_ModStart> ) { hstartrow <S2SV_ModEnd> = ( <S2SV_ModStart> numrows - hstartrow <S2SV_ModEnd> ; n <S2SV_ModStart> a [ hstartrow <S2SV_ModEnd> * stride
<S2SV_ModStart> ; int hstartrow <S2SV_ModEnd> ; if <S2SV_ModStart> buf = jas_alloc3 <S2SV_ModEnd> ( bufsize <S2SV_ModStart> bufsize , JPC_QMFB_COLGRPSIZE , <S2SV_ModStart> ) { hstartrow <S2SV_ModEnd> = ( <S2SV_ModStart> numrows - hstartrow <S2SV_ModEnd> ; n <S2SV_ModStart> a [ hstartrow <S2SV_ModEnd> * stride
<S2SV_ModStart> buf = jas_alloc3 <S2SV_ModEnd> ( bufsize <S2SV_ModStart> ( bufsize , numcols
<S2SV_ModStart> if ( numrows < 0 || numcols < 0 ) { return 0 ; } if (
<S2SV_ModStart> n ; image = 0 ; info = 0 ; <S2SV_ModStart> ) ; goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto error <S2SV_ModEnd> ; } <S2SV_ModStart> , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>" "mincolors<S2SV_blank>%ld\\n" , JAS_CAST ( long <S2SV_ModEnd> , info <S2SV_ModStart> -> len ) , JAS_CAST ( long <S2SV_ModStart> -> width ) , JAS_CAST ( long <S2SV_ModStart> -> height ) , JAS_CAST ( long <S2SV_ModStart> -> numplanes ) , JAS_CAST ( long , <S2SV_ModEnd> info -> <S2SV_ModStart> -> depth ) , JAS_CAST ( long <S2SV_ModStart> -> enctype ) , JAS_CAST ( long <S2SV_ModStart> -> siz ) , JAS_CAST ( long <S2SV_ModStart> -> hres ) , JAS_CAST ( long <S2SV_ModStart> -> vres ) , JAS_CAST ( long , <S2SV_ModEnd> info -> <S2SV_ModStart> -> numcolors ) , JAS_CAST ( long <S2SV_ModStart> ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; goto error ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error ; } <S2SV_ModStart> ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ? jas_stream_memopen2 <S2SV_ModEnd> ( 0
<S2SV_ModStart> m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble" ) ; }
<S2SV_ModStart> ) { char * new_buf ; size_t new_bufsize <S2SV_ModEnd> ; JAS_DBGLOG <S2SV_ModStart> if ( bufsize < 0 <S2SV_ModEnd> ) { <S2SV_ModStart> ) { jas_deprecated ( "negative<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>for<S2SV_blank>jas_stream_memopen" ) <S2SV_ModEnd> ; } <S2SV_ModStart> ; } if ( buf && bufsize <= 0 ) { jas_eprintf ( "Invalid<S2SV_blank>use<S2SV_blank>of<S2SV_blank>jas_stream_memopen<S2SV_blank>detected.\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; jas_deprecated ( "A<S2SV_blank>user-provided<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>" "jas_stream_memopen<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>growable.\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) { new_bufsize = 0 ; new_buf = 0 <S2SV_ModEnd> ; } <S2SV_ModStart> else { new_bufsize <S2SV_ModEnd> = bufsize <S2SV_ModStart> bufsize ; new_buf = buf <S2SV_ModEnd> ; } <S2SV_ModStart> ; } return jas_stream_memopen2 ( new_buf , new_bufsize ) <S2SV_ModEnd> ; }
<S2SV_ModStart> m ; if ( n < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_pad" ) ; }
<S2SV_ModStart> bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read" ) ; }
<S2SV_ModStart> bufptr ; if ( cnt < 0 ) { jas_deprecated ( "negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write" ) ; }
<S2SV_ModStart> ) { ssize_t <S2SV_ModEnd> n ;
<S2SV_ModStart> m , size_t <S2SV_ModEnd> bufsize ) <S2SV_ModStart> buf ; <S2SV_ModEnd> JAS_DBGLOG ( <S2SV_ModStart> , ( "mem_resize(%p,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , m <S2SV_ModStart> ) ; if ( ! bufsize ) { jas_eprintf ( "mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n" "This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n" ) ; }
<S2SV_ModStart> obj ; size_t <S2SV_ModEnd> newpos ;
<S2SV_ModStart> ) { size_t <S2SV_ModEnd> n ; <S2SV_ModStart> obj ; size_t newbufsize ; size_t <S2SV_ModEnd> newpos ; <S2SV_ModStart> ) { if ( ! jas_safe_size_mul ( newbufsize , 2 , & newbufsize ) ) { <S2SV_ModEnd> JAS_DBGLOG ( <S2SV_ModStart> , ( "new<S2SV_blank>buffer<S2SV_blank>size<S2SV_blank>would<S2SV_blank>cause<S2SV_blank>overflow\\n" ) ) ; <S2SV_ModEnd> return - <S2SV_ModStart> } } JAS_DBGLOG ( 100 , ( "mem_write<S2SV_blank>resizing<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%zu\\n" , m -> bufsize_ , newbufsize ) ) ; assert ( newbufsize > 0 ) ; if ( mem_resize ( m , newbufsize ) ) { return - 1 ; } }
<S2SV_ModStart> * fmtname ; int debug <S2SV_ModStart> 0 ; debug = 0 ; <S2SV_ModStart> ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case <S2SV_ModStart> } } jas_setdbglevel ( debug ) ; <S2SV_ModStart> ) { jas_stream_close ( instream ) ;
<S2SV_ModStart> ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; <S2SV_ModStart> ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%d;<S2SV_blank>width<S2SV_blank>%d;<S2SV_blank>height<S2SV_blank>%d;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%d;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>hres<S2SV_blank>%d;<S2SV_blank>vres<S2SV_blank>%d;<S2SV_blank>numcolors<S2SV_blank>%d;<S2SV_blank>" "mincolors<S2SV_blank>%d\\n" , info -> len , info -> width , info -> height , info -> numplanes , info -> depth , info -> enctype , info -> siz , info -> hres , info -> vres , info -> numcolors , info -> mincolors ) ) ;
<S2SV_ModStart> |= ( JAS_CAST ( uint_fast32_t , c ) <S2SV_ModEnd> << 24
<S2SV_ModStart> , ( "jas_malloc(%zu)\\n" <S2SV_ModEnd> , size
<S2SV_ModStart> , ( "jas_realloc(%x,<S2SV_blank>%zu)\\n" <S2SV_ModEnd> , ptr
<S2SV_ModStart> i ; size_t size ; matrix = 0 ; <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> datasize_ = 0 ; if ( ! jas_safe_size_mul ( numrows , numcols , & size ) ) { goto error ; } matrix -> datasize_ = size <S2SV_ModEnd> ; if <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto error <S2SV_ModEnd> ; } <S2SV_ModStart> matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ;
<S2SV_ModStart> pirlvls ; if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy
<S2SV_ModStart> ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( <S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << ( <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy

<S2SV_ModStart> ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } <S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl <S2SV_ModStart> * ( JAS_CAST ( uint_fast32_t , 1 ) << <S2SV_ModEnd> ( pirlvl <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpx <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy <S2SV_ModStart> % ( JAS_CAST ( uint_fast32_t , 1 ) <S2SV_ModEnd> << rpy

<S2SV_ModStart> if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( "all<S2SV_blank>tiles<S2SV_blank>are<S2SV_blank>outside<S2SV_blank>the<S2SV_blank>image<S2SV_blank>area\\n" ) ; return - 1 ; } if (

<S2SV_ModStart> = boxinfo <S2SV_ModEnd> ; box <S2SV_ModStart> ) { <S2SV_ModEnd> jas_eprintf ( <S2SV_ModStart> tmpstream ) ; box -> ops = & boxinfo -> ops
<S2SV_ModStart> max_mem ; size_t max_samples ; char optstr [ 32 ] ; <S2SV_ModStart> ] ; max_samples = 64 * JAS_MEBI ; <S2SV_ModStart> ; case OPT_MAXSAMPLES : max_samples = strtoull ( jas_optarg , 0 , 10 ) ; break ; case <S2SV_ModStart> ; } snprintf ( optstr , sizeof ( optstr ) , "max_samples=%-zu" , max_samples ) ; <S2SV_ModStart> fmtid , optstr <S2SV_ModEnd> ) ) <S2SV_ModStart> ! ( fmtname = jas_image_fmttostr ( fmtid ) ) ) { jas_eprintf ( "format<S2SV_blank>name<S2SV_blank>lookup<S2SV_blank>failed\\n" ) ; return EXIT_FAILURE ; } if ( ! ( <S2SV_ModStart> ; } printf ( "%s<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%ld\\n" , fmtname <S2SV_ModEnd> , numcmpts <S2SV_ModStart> depth , JAS_CAST <S2SV_ModStart> ( long , <S2SV_ModEnd> jas_image_rawsize ( <S2SV_ModStart> ( image )
<S2SV_ModStart> j ; jas_uchar <S2SV_ModEnd> * dp
<S2SV_ModStart> ) { jas_ulonglong <S2SV_ModEnd> tmp ; <S2SV_ModStart> JAS_CAST ( jas_longlong <S2SV_ModEnd> , ( <S2SV_ModStart> JAS_CAST ( jas_longlong <S2SV_ModEnd> , tmp
<S2SV_ModStart> ) { jas_ulonglong <S2SV_ModEnd> tmp ;
<S2SV_ModStart> ) { jas_ulonglong <S2SV_ModEnd> tmp ;
<S2SV_ModStart> ) { jas_ulonglong <S2SV_ModEnd> tmp ;
<S2SV_ModStart> n , jas_ulonglong <S2SV_ModEnd> * val <S2SV_ModStart> c ; jas_ulonglong <S2SV_ModEnd> v ;
<S2SV_ModStart> jas_iccprof_createfrombuf ( jas_uchar <S2SV_ModEnd> * buf
<S2SV_ModStart> n , jas_longlong <S2SV_ModEnd> val ) <S2SV_ModStart> ) { jas_ulonglong <S2SV_ModEnd> tmp ;
<S2SV_ModStart> n , jas_ulonglong <S2SV_ModEnd> val )
<S2SV_ModStart> ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }
<S2SV_ModStart> cmpt ; size_t size ; <S2SV_ModStart> ) ; if ( ! jas_safe_size_mul ( <S2SV_ModEnd> dec -> <S2SV_ModStart> -> numhtiles , <S2SV_ModEnd> dec -> <S2SV_ModStart> -> numvtiles , & size <S2SV_ModEnd> ) ) <S2SV_ModStart> ; } dec -> numtiles = size ; JAS_DBGLOG ( 10 , ( "numtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numhtiles<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numvtiles<S2SV_blank>=<S2SV_blank>%d;\\n" , dec -> numtiles , dec -> numhtiles , dec -> numvtiles ) ) ; if ( ! ( dec -> tiles = jas_alloc2 ( dec -> numtiles , sizeof ( jpc_dec_tile_t ) ) ) ) { return - 1 ; }
<S2SV_ModStart> ( "RCT<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>three<S2SV_blank>components\\n" ) ; return - 1 ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" <S2SV_ModStart> ; } if ( ! jas_image_cmpt_domains_same ( dec -> image ) ) { jas_eprintf ( "RCT<S2SV_blank>requires<S2SV_blank>all<S2SV_blank>components<S2SV_blank>have<S2SV_blank>the<S2SV_blank>same<S2SV_blank>domain\\n" ) ; return - 1 ; }
<S2SV_ModStart> } } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } jas_tvparser_destroy ( tvp ) ;
<S2SV_ModStart> = len ; JAS_DBGLOG ( 10 , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%d\\n" , \'"\' , boxinfo -> name , \'"\' , box -> type , box -> len ) ) <S2SV_ModStart> ) { box -> ops = & jp2_boxinfo_unk . ops ;
<S2SV_ModStart> jas_eprintf ( "got<S2SV_blank>box<S2SV_blank>type<S2SV_blank>%s\\n" <S2SV_ModEnd> , box
<S2SV_ModStart> box = jp2_box_create0 ( <S2SV_ModEnd> ) ) <S2SV_ModStart> ; } <S2SV_ModEnd> box ->
<S2SV_ModStart> box = jp2_box_create0 ( ) ) ) { goto error ; } <S2SV_ModEnd> if ( <S2SV_ModStart> , ( "preliminary<S2SV_blank>processing<S2SV_blank>of<S2SV_blank>JP2<S2SV_blank>box:<S2SV_blank>" "type=%c%s%c<S2SV_blank>(0x%08x);<S2SV_blank>length=%" PRIuFAST32 "\\n" <S2SV_ModEnd> , \'"\' <S2SV_ModStart> ) { JAS_DBGLOG ( 10 , ( "big<S2SV_blank>length\\n" ) ) ;
<S2SV_ModStart> ) { jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ;
<S2SV_ModStart> int i ; bpcc -> bpcs = 0
<S2SV_ModStart> int channo ; cdef -> ents = 0
<S2SV_ModStart> int i ; cmap -> ents = 0
<S2SV_ModStart> 0 ; pclr -> bpc = 0 ;
<S2SV_ModStart> prcwidthexpn + <S2SV_ModEnd> picomp -> <S2SV_ModStart> prcheightexpn + <S2SV_ModEnd> picomp ->
<S2SV_ModStart> tmp ; siz -> comps = 0 ; <S2SV_ModStart> ) { goto error ; } if ( ! siz -> width || ! siz -> height ) { jas_eprintf ( "reference<S2SV_blank>grid<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> tilewidth || ! siz -> tileheight ) { jas_eprintf ( "tile<S2SV_blank>cannot<S2SV_blank>have<S2SV_blank>zero<S2SV_blank>area\\n" ) ; goto error ; } if ( ! siz -> numcomps || siz -> numcomps > 16384 ) { jas_eprintf ( "number<S2SV_blank>of<S2SV_blank>components<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> xoff >= siz -> width ) { jas_eprintf ( "XOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> yoff >= siz -> height ) { jas_eprintf ( "YOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tilexoff > siz -> xoff || siz -> tilexoff + siz -> tilewidth <= siz -> xoff ) { jas_eprintf ( "XTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( siz -> tileyoff > siz -> yoff || siz -> tileyoff + siz -> tileheight <= siz -> yoff ) { jas_eprintf ( "YTOsiz<S2SV_blank>not<S2SV_blank>in<S2SV_blank>permissible<S2SV_blank>range\\n" ) ; goto error ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { goto error ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { goto error ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; goto error ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; goto error ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { goto error ; } return 0 ; error : if ( siz -> comps ) { jas_free ( siz -> comps ) ; } <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> 0 ; size_t pathlen = 0 ; <S2SV_ModStart> AF_UNIX : pathlen = sizeof ( <S2SV_ModEnd> ( ( <S2SV_ModStart> -> sun_path ) ; if ( MAXPATHLEN <= pathlen ) { pathlen = MAXPATHLEN <S2SV_ModEnd> - 1 <S2SV_ModStart> - 1 ; } strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen <S2SV_ModEnd> ] =
<S2SV_ModStart> el ) { if ( c -> rbytes > 1024 ) { char * ptr = c -> rcurr ; while ( * ptr == '<S2SV_blank>' ) { ++ ptr ; } if ( strcmp ( ptr , "get<S2SV_blank>" ) && strcmp ( ptr , "gets<S2SV_blank>" ) ) { conn_set_state ( c , conn_closing ) ; return 1 ; } } return 0 ; } <S2SV_ModEnd> cont =
<S2SV_ModStart> res ; int num_allocs = 0 ; <S2SV_ModStart> ) { if ( num_allocs == 4 ) { return gotdata ; } ++ num_allocs ;
<S2SV_ModStart> it = limited_get <S2SV_ModEnd> ( key <S2SV_ModStart> , c <S2SV_ModEnd> ) ;
<S2SV_ModStart> ntokens >= 4 <S2SV_ModEnd> && settings <S2SV_ModStart> ntokens >= 4 <S2SV_ModEnd> && settings
<S2SV_ModStart> if ( ptr - c -> rcurr > 100 || ( strncmp ( ptr <S2SV_ModEnd> , "get<S2SV_blank>" <S2SV_ModStart> , "get<S2SV_blank>" , 4 <S2SV_ModStart> ) && strncmp <S2SV_ModEnd> ( ptr <S2SV_ModStart> , "gets<S2SV_blank>" , 5 )
<S2SV_ModStart> if ( <S2SV_ModEnd> udp_specified &&
<S2SV_ModStart> udpport = 0 <S2SV_ModEnd> ; settings
<S2SV_ModStart> ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;
<S2SV_ModStart> while ( ( i < ( int ) header_buf_used ) && ( <S2SV_ModStart> == '\\n' )
<S2SV_ModStart> ) d ; if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1
<S2SV_ModStart> parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser
<S2SV_ModStart> parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) <S2SV_ModEnd> ; parser
<S2SV_ModStart> if ( <S2SV_ModEnd> l > <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModStart> + n - p ) <S2SV_ModStart> if ( <S2SV_ModEnd> l > <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModStart> + n - p ) <S2SV_ModStart> if ( <S2SV_ModEnd> l > <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModStart> + n - p ) <S2SV_ModStart> if ( <S2SV_ModEnd> l > <S2SV_ModStart> l > ( unsigned ) ( <S2SV_ModStart> + n - p )
<S2SV_ModStart> , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> ) ; if ( n == 0 ) { <S2SV_ModStart> ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( "Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;
<S2SV_ModStart> ) ; * pp = p -> next ;
<S2SV_ModStart> ; } if ( desc == NULL ) desc = "" ;
<S2SV_ModStart> 8 ; <S2SV_ModEnd> break ; <S2SV_ModStart> 8 ; <S2SV_ModEnd> break ; <S2SV_ModStart> 4 ; <S2SV_ModEnd> break ; <S2SV_ModStart> break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> 8 ; <S2SV_ModEnd> break ; <S2SV_ModStart> 8 ; <S2SV_ModEnd> break ; <S2SV_ModStart> 4 ; <S2SV_ModEnd> break ; <S2SV_ModStart> break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
<S2SV_ModStart> ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>ERROR<S2SV_blank>***<S2SV_blank>Image<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>global<S2SV_blank>GIF<S2SV_blank>canvas<S2SV_blank>!\\n" ) ; # endif return - 1 ; } if ( ( i -> posX + i -> width ) > i -> parent -> width ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>X<S2SV_blank>position\\n" ) ; # endif i -> posX = i -> parent -> width - i -> width ; } if ( ( i -> posY + i -> height ) > i -> parent -> height ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , "***<S2SV_blank>WARNING<S2SV_blank>***<S2SV_blank>Adjusting<S2SV_blank>Y<S2SV_blank>position\\n" ) ; # endif i -> posY = i -> parent -> height - i -> height ; }
<S2SV_ModStart> act_code ; if ( npix > 0 ) <S2SV_ModStart> casspecial ; if ( npix >= ( <S2SV_ModEnd> stack_top - <S2SV_ModStart> stackp ) ) { WritePixels ( i , & context , stackp , stack_top - stackp ) ; } else if ( npix > 0 ) { WritePixels ( i , & context , stackp , npix ) ; } <S2SV_ModEnd> npix -=
<S2SV_ModStart> , size ; if ( get_securelevel ( ) > 0 ) return - EPERM
<S2SV_ModStart> else { # ifdef UPNP_ENABLE_POST_WRITE <S2SV_ModStart> HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif
<S2SV_ModStart> 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
<S2SV_ModStart> ) ; if ( c16 -> Curves [ i ] == NULL ) { for ( j = 0 ; j < i ; j ++ ) { _cmsFree ( ContextID , c16 -> Curves [ j ] ) ; } _cmsFree ( ContextID , c16 -> Curves ) ; _cmsFree ( ContextID , c16 ) ; return NULL ; }
<S2SV_ModStart> ) ; Lut = NULL ; <S2SV_ModStart> Error : if ( Lut != NULL )
<S2SV_ModStart> - o - 4
<S2SV_ModStart> ) ; VALIDATE_TEST ( "test59.bson" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , "corrupt<S2SV_blank>BSON" ) ;
<S2SV_ModStart> sr -> uri_processed <S2SV_ModEnd> ) <
<S2SV_ModStart> sr -> fd_is_fdt = MK_FALSE ; sr ->
<S2SV_ModStart> ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> ) ; } else { close ( sr -> fd_file ) ; }
<S2SV_ModStart> hash ; sr -> fd_is_fdt = MK_TRUE ;
<S2SV_ModStart> size_t e ; mrb_value nil <S2SV_ModStart> ) { <S2SV_ModEnd> mrb_gc_mark ( <S2SV_ModStart> } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
<S2SV_ModStart> c ; enum mrb_fiber_state status ; <S2SV_ModStart> c ) ; status = c -> status <S2SV_ModStart> resume && <S2SV_ModEnd> status == <S2SV_ModStart> if ( <S2SV_ModEnd> status == <S2SV_ModStart> MRB_FIBER_RUNNING || <S2SV_ModEnd> status == <S2SV_ModStart> if ( <S2SV_ModEnd> status == <S2SV_ModStart> ; } old_c <S2SV_ModEnd> -> status <S2SV_ModStart> ) ; fiber_switch_context ( mrb , c ) ; if ( <S2SV_ModEnd> status == <S2SV_ModStart> e ; mrb_stack_extend ( mrb , len + 2 ) ; <S2SV_ModEnd> b = <S2SV_ModStart> ; } <S2SV_ModEnd> if (
<S2SV_ModStart> ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; <S2SV_ModStart> ( mrb <S2SV_ModEnd> ) ;
<S2SV_ModStart> s && ( <S2SV_ModStart> != \'\\"\' ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 ) ) <S2SV_ModStart> * s ) && ( ptmp != ( tmp + sizeof ( tmp ) - 1 )
<S2SV_ModStart> s + 2 <S2SV_ModEnd> ) ;
<S2SV_ModStart> = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , "Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n" )
<S2SV_ModStart> LONG_STRING ] = "" <S2SV_ModStart> line , "%1023s<S2SV_blank>" <S2SV_ModEnd> ANUM "<S2SV_blank>" <S2SV_ModStart> "<S2SV_blank>" ANUM "<S2SV_blank>%c<S2SV_blank>%8191[^\\n]" <S2SV_ModEnd> , group <S2SV_ModStart> 4 ) { mutt_debug ( 4 , "Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n" , line ) ; <S2SV_ModStart> 0 ; }
<S2SV_ModStart> ) { if ( dlen < 2 ) break ; <S2SV_ModStart> -= 2 <S2SV_ModEnd> ; *
<S2SV_ModStart> + 2 , sizeof ( obuf )
<S2SV_ModStart> + 2 , sizeof ( buf2 ) <S2SV_ModStart> + 2 , sizeof ( buf2 )
<S2SV_ModStart> * in , size_t olen <S2SV_ModStart> 4 ; if ( len == olen ) return len ; <S2SV_ModStart> ) { if ( len == olen ) return len ; <S2SV_ModStart> ) { if ( len == olen ) return len ;
<S2SV_ModStart> ) { const int olen = <S2SV_ModEnd> 3 * <S2SV_ModStart> + 1 ; char * out = mutt_mem_malloc ( olen <S2SV_ModStart> , it , olen
<S2SV_ModStart> , encoded , sizeof ( buffer )
<S2SV_ModStart> , out1 , sizeof ( out2 ) <S2SV_ModStart> , out1 , sizeof ( out2 )
<S2SV_ModStart> ) ; if ( strlen ( line ) == 0 ) return - 1 ;
<S2SV_ModStart> mx ; size_t len = 0 ; <S2SV_ModStart> ) ; len = <S2SV_ModStart> ) , "%smailboxes<S2SV_blank>" <S2SV_ModEnd> , subscribe <S2SV_ModStart> : "un" ) ; imap_quote_string ( mbox + len , sizeof ( mbox ) - len <S2SV_ModStart> , path , true
<S2SV_ModStart> bcache , cache_id ( id ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) <S2SV_ModEnd> ) ==
<S2SV_ModStart> bcache , cache_id ( <S2SV_ModStart> -> data ) <S2SV_ModStart> bcache , cache_id ( <S2SV_ModStart> -> data ) <S2SV_ModStart> bcache , cache_id ( <S2SV_ModStart> -> data )
<S2SV_ModStart> bcache , cache_id ( <S2SV_ModStart> -> data )
<S2SV_ModStart> ) ) ; if ( fc . messages == NULL ) return - 1
<S2SV_ModStart> dlen -= 3 <S2SV_ModEnd> ; for
<S2SV_ModStart> . user , false <S2SV_ModStart> . pass , false
<S2SV_ModStart> . name , true
<S2SV_ModStart> . str , false <S2SV_ModStart> , delim , false <S2SV_ModStart> . str , false <S2SV_ModStart> . str , false <S2SV_ModStart> . str , false
<S2SV_ModStart> , buf , false
<S2SV_ModStart> * src , bool quote_backtick <S2SV_ModStart> ) { <S2SV_ModEnd> const char <S2SV_ModStart> const char * quote = "`\\"\\\\" ; if ( ! quote_backtick ) quote ++ <S2SV_ModEnd> ; char
<S2SV_ModStart> if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.zshrc" <S2SV_ModStart> if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.cshrc" <S2SV_ModStart> if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> ) { copy_file_as_user <S2SV_ModEnd> ( "/etc/skel/.bashrc"
<S2SV_ModStart> ) ; <S2SV_ModEnd> char * <S2SV_ModStart> ] = "/bin/sh" <S2SV_ModEnd> ; arg
<S2SV_ModStart> ) { struct utsname u ; int rv = uname ( & u ) ; if ( rv != 0 ) errExit ( "uname" ) ; int major ; int minor ; if ( 2 != sscanf ( u . release , "%d.%d" , & major , & minor ) ) { fprintf ( stderr , "Error:<S2SV_blank>cannot<S2SV_blank>extract<S2SV_blank>Linux<S2SV_blank>kernel<S2SV_blank>version:<S2SV_blank>%s\\n" , u . version ) ; exit ( 1 ) ; } if ( major < 4 || ( major == 4 && minor < 8 ) ) { fprintf ( stderr , "Error:<S2SV_blank>--allow-debuggers<S2SV_blank>is<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>Linux<S2SV_blank>kernels<S2SV_blank>prior<S2SV_blank>to<S2SV_blank>4.8.<S2SV_blank>" "A<S2SV_blank>bug<S2SV_blank>in<S2SV_blank>ptrace<S2SV_blank>call<S2SV_blank>allows<S2SV_blank>a<S2SV_blank>full<S2SV_blank>bypass<S2SV_blank>of<S2SV_blank>the<S2SV_blank>seccomp<S2SV_blank>filter.<S2SV_blank>" "Your<S2SV_blank>current<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>is<S2SV_blank>%d.%d.\\n" , major , minor ) ; exit ( 1 ) ; }
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> src , <S2SV_ModEnd> dest , <S2SV_ModStart> ( ) <S2SV_ModEnd> , S_IRUSR <S2SV_ModStart> S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> src , <S2SV_ModEnd> dest , <S2SV_ModStart> ( ) <S2SV_ModEnd> , S_IRUSR <S2SV_ModStart> S_IWUSR ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( <S2SV_ModStart> ) { copy_file_as_user ( "/etc/skel/.zshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.zshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else if ( arg_csh ) { if ( asprintf ( & fname , "%s/.cshrc" , homedir ) == - 1 ) errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; <S2SV_ModStart> is_link ( fname <S2SV_ModEnd> ) ) <S2SV_ModStart> stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( stat ( "/etc/skel/.cshrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.cshrc" , fname , u , g , 0644 ) ; fs_logger ( "clone<S2SV_blank>/etc/skel/.cshrc" ) ; } else { touch_file_as_user ( fname , u , g , 0644 ) ; fs_logger2 ( "touch" , fname ) ; } free ( fname ) ; } else { if ( asprintf ( & fname , "%s/.bashrc" , homedir <S2SV_ModEnd> ) == <S2SV_ModStart> errExit ( "asprintf" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( is_link ( fname ) ) { fprintf ( stderr , "Error:<S2SV_blank>invalid<S2SV_blank>%s<S2SV_blank>file\\n" , fname ) ; exit ( 1 ) ; } if ( stat ( "/etc/skel/.bashrc" , & s ) == 0 ) { copy_file_as_user ( "/etc/skel/.bashrc" , fname , u , g , 0644 <S2SV_ModEnd> ) ; <S2SV_ModStart> fs_logger ( "clone<S2SV_blank>/etc/skel/.bashrc" ) ; <S2SV_ModEnd> } free <S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) { char * rp = realpath ( src , NULL ) ; if ( ! rp ) { <S2SV_ModStart> stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>access<S2SV_blank>%s\\n" , src <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } if ( strncmp ( rp , cfg . homedir , strlen ( cfg . homedir ) ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { <S2SV_ModEnd> fprintf ( <S2SV_ModStart> stderr , "Error:<S2SV_blank>.asoundrc<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file<S2SV_blank>outside<S2SV_blank>home<S2SV_blank>directory\\n" ) ; exit ( 1 ) ; } free ( rp ) ; } copy_file_as_user ( src , dest , getuid ( ) , getgid ( ) , 0644 ) ; <S2SV_ModEnd> fs_logger2 ( <S2SV_ModStart> , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> stderr , "Warning:<S2SV_blank>invalid<S2SV_blank>.Xauthority<S2SV_blank>file\\n" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; return 0 <S2SV_ModEnd> ; } <S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> src , <S2SV_ModEnd> dest , <S2SV_ModStart> ( ) , 0600 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; fs_logger2 ( "clone" , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> ) ; <S2SV_ModEnd> fs_logger2 ( <S2SV_ModStart> , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> ) ; <S2SV_ModEnd> fs_logger2 ( <S2SV_ModStart> , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { <S2SV_ModEnd> copy_file ( <S2SV_ModStart> 0644 ) ; <S2SV_ModEnd> fs_logger ( <S2SV_ModStart> ; } <S2SV_ModEnd> else { <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> } free <S2SV_ModStart> ) { <S2SV_ModEnd> copy_file ( <S2SV_ModStart> 0644 ) ; <S2SV_ModEnd> fs_logger ( <S2SV_ModStart> ; } <S2SV_ModEnd> else { <S2SV_ModStart> else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> } free <S2SV_ModStart> ) { <S2SV_ModEnd> copy_file ( <S2SV_ModStart> 0644 ) ; <S2SV_ModEnd> fs_logger ( <S2SV_ModStart> ; } <S2SV_ModEnd> free (
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> ) ; <S2SV_ModEnd> fs_logger2 ( <S2SV_ModStart> , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } copy_file_as_user <S2SV_ModEnd> ( src <S2SV_ModStart> ) ; <S2SV_ModEnd> fs_logger2 ( <S2SV_ModStart> , dest <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; unlink ( RUN_LIB_FILE ) ;
<S2SV_ModStart> ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;
<S2SV_ModStart> ) ; <S2SV_ModEnd> save_cpu ( <S2SV_ModStart> ; } fs_rdonly ( RUN_SECCOMP_DIR ) ; <S2SV_ModStart> # endif set_caps ( ) ;
<S2SV_ModStart> ) { char t <S2SV_ModEnd> = from_hex <S2SV_ModStart> 2 ] ) ; * d ++ = ( char ) ( ( isprint ( t ) ) ? t : '<S2SV_blank>'
<S2SV_ModStart> } } fix_google_param ( google_out ) ; fix_google_param ( google_sig ) ; fix_google_param ( google_reqId ) ; fix_google_param ( google_version ) ; fix_google_param ( responseHandler ) ; fix_google_param ( outFileName ) ;
<S2SV_ModStart> ) { <S2SV_ModEnd> return -
<S2SV_ModStart> dimensions ; unsigned int actual_size = rtype == 2 ? n * 2 : n ; unsigned int limit_r_begin = ( r -> begin < actual_size ? r -> begin : actual_size ) ; unsigned int limit_r_end = ( r -> end < actual_size ? r -> end : actual_size ) ; <S2SV_ModStart> n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int
<S2SV_ModStart> i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; <S2SV_ModStart> n_read = limit_r_end - limit_r_begin <S2SV_ModEnd> ; int
<S2SV_ModStart> [ y & 255 <S2SV_ModStart> [ y & 255
<S2SV_ModStart> ] ; <S2SV_ModEnd> return NULL
<S2SV_ModStart> r ; if <S2SV_ModEnd> ( pow <S2SV_ModStart> dim ) <= <S2SV_ModEnd> entries ) <S2SV_ModStart> entries ) return - 1 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) > <S2SV_ModEnd> entries ) <S2SV_ModStart> entries ) return - 1
<S2SV_ModStart> if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } <S2SV_ModStart> -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )
<S2SV_ModStart> n ) ; if ( w == NULL ) return 0
<S2SV_ModStart> , fname <S2SV_ModEnd> ) ;
<S2SV_ModStart> fd , const char * cmd , const char * args_extra <S2SV_ModEnd> ) { <S2SV_ModStart> fl ; int argc ; char * argv [ RUNCMD_ARGS_MAX + 1 ] ; int r <S2SV_ModEnd> ; term_remove <S2SV_ModStart> ) ; argc = 0 ; r = split_quoted <S2SV_ModEnd> ( cmd <S2SV_ModStart> cmd , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>command\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } r = split_quoted ( args_extra , & argc , argv , RUNCMD_ARGS_MAX ) ; if ( r < 0 ) { fd_printf ( STDERR_FILENO , "Cannot<S2SV_blank>parse<S2SV_blank>extra<S2SV_blank>args\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } if ( argc < 1 ) { fd_printf ( STDERR_FILENO , "No<S2SV_blank>command<S2SV_blank>given\\n" ) ; exit ( RUNCMD_EXEC_FAIL ) ; } argv [ argc ] = NULL ; fd_printf ( STDERR_FILENO , "$<S2SV_blank>%s<S2SV_blank>%s\\n" , cmd , args_extra ) ; establish_child_signal_handlers ( ) ; sigprocmask ( SIG_SETMASK , & sigm_old , NULL ) ; execvp ( argv [ 0 ] , argv ) ; <S2SV_ModEnd> fd_printf ( <S2SV_ModStart> STDERR_FILENO , "exec:<S2SV_blank>%s\\n" , strerror ( errno ) <S2SV_ModEnd> ) ; <S2SV_ModStart> exit ( RUNCMD_EXEC_FAIL <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "stats<S2SV_blank>%s<S2SV_blank>unrecognized" , filegen_string ) ; continue ; } <S2SV_ModStart> ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , "filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized" , filegen_file ) ; continue ; }
<S2SV_ModStart> ) ; <S2SV_ModEnd> filegen_register ( <S2SV_ModStart> ) ; <S2SV_ModEnd> filegen_register ( <S2SV_ModStart> ) ; <S2SV_ModEnd> step_callback =
<S2SV_ModStart> char prefix <S2SV_ModEnd> ; char <S2SV_ModStart> * type ; switch ( <S2SV_ModEnd> ( yyvsp <S2SV_ModStart> String ) [ 0 ] ) { case '+' : case '-' : case '=' : prefix = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) [ 0 ] ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) <S2SV_ModStart> 1 ; break ; default : prefix = '=' ; type = ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ; } ( yyval . Attr_val ) = create_attr_sval ( prefix , estrdup ( type ) ) ; YYFREE ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ; } break ; case 216 : # line 1022 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( ( yyvsp [ ( 3 ) - ( 3 ) ] . Integer ) , NULL , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 217 : # line 1027 "ntp_parser.y" { enqueue ( cfgt . nic_rules , create_nic_rule_node ( 0 , ( yyvsp [ ( 3 ) - ( 3 ) ] . String ) , ( yyvsp [ ( 2 ) - ( 3 ) ] . Integer ) ) ) ; } break ; case 227 : # line 1058 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_ival ( ( yyvsp [ ( 2 ) - ( 2 ) ] . Integer ) ) ) ; } break ; case 228 : # line 1059 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_ival ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ) ; } break ; case 229 : # line 1064 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Attr_val ) ) ; } break ; case 230 : # line 1066 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 ) ] . Attr_val ) ) ; } break ; case 231 : # line 1071 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_ival ( 'i' , ( yyvsp [ ( 1 ) - ( 1 ) ] . Integer ) ) ; } break ; case 233 : # line 1077 "ntp_parser.y" { ( yyval . Attr_val ) = create_attr_shorts ( '-' , ( yyvsp [ ( 2 ) - ( 5 ) ] . Integer ) , ( yyvsp [ ( 4 ) - ( 5 ) ] . Integer ) ) ; } break ; case 234 : # line 1081 "ntp_parser.y" { ( yyval . Queue ) = enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] . Queue ) , create_pval ( ( yyvsp [ ( 2 ) - ( 2 <S2SV_ModEnd> ) ] <S2SV_ModStart> ) ) ) ; } break ; case 235 : # line 1082 "ntp_parser.y" { ( yyval . Queue ) = enqueue_in_new_queue ( create_pval ( ( yyvsp [ ( 1 ) - ( 1 ) ] . String ) ) ) ; } break ; case 236 : # line 1086 "ntp_parser.y" { ( yyval . Queue ) = <S2SV_ModEnd> enqueue ( <S2SV_ModStart> enqueue ( ( yyvsp [ ( 1 ) - ( 2 ) ] <S2SV_ModEnd> . Queue <S2SV_ModStart> Queue ) , ( yyvsp [ ( 2 ) - ( 2 ) ] . Address_node ) ) ; } break ; case 237 : # line 1087 "ntp_parser.y" { ( yyval <S2SV_ModEnd> . Queue <S2SV_ModStart> Queue ) <S2SV_ModEnd> = enqueue_in_new_queue <S2SV_ModStart> enqueue_in_new_queue ( ( yyvsp [ ( 1 ) - ( 1 <S2SV_ModEnd> ) ] <S2SV_ModStart> ; case <S2SV_ModEnd> 238 : <S2SV_ModStart> # line 1092 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1100 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1101 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1105 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1116 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1130 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1134 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1135 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1139 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1140 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1144 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1145 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1150 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1154 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1158 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1162 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1163 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1168 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1172 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1173 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1178 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1180 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1182 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1184 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 1186 <S2SV_ModEnd> "ntp_parser.y" { <S2SV_ModStart> # line 3836 <S2SV_ModEnd> "ntp_parser.c" default
<S2SV_ModStart> ; struct range_data * r = & clt -> clt_ranges <S2SV_ModEnd> ; struct <S2SV_ModStart> ; struct range * range <S2SV_ModEnd> ; size_t <S2SV_ModStart> size_t content_length = 0 <S2SV_ModStart> , ret <S2SV_ModEnd> ; char <S2SV_ModStart> ( ( nranges = parse_ranges ( clt , <S2SV_ModEnd> range_str , <S2SV_ModStart> -> st_size ) ) < 1 <S2SV_ModEnd> ) { <S2SV_ModStart> ) ; r -> range_media = media ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) { range = & r -> range [ 0 ] ; <S2SV_ModStart> abort ; range = & r -> range [ 0 ] ; content_length += <S2SV_ModEnd> range -> <S2SV_ModStart> 1 ; <S2SV_ModEnd> } else <S2SV_ModStart> else { arc4random_buf ( & clt -> clt_boundary , sizeof ( clt -> clt_boundary ) ) ; for ( i = 0 ; i < nranges ; i ++ <S2SV_ModEnd> ) { <S2SV_ModStart> ) { range = & r -> range [ i ] ; if ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu\\r\\n" "Content-Type:<S2SV_blank>%s/%s\\r\\n" "Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n" , clt -> clt_boundary , media -> media_type , media -> media_subtype , range -> start , range -> end , st -> st_size ) ) < 0 <S2SV_ModEnd> ) goto <S2SV_ModStart> content_length += ret + <S2SV_ModEnd> range -> <S2SV_ModStart> 1 ; <S2SV_ModEnd> } if <S2SV_ModStart> ( ( ret = snprintf ( NULL , 0 , "\\r\\n--%llu--\\r\\n" , clt -> clt_boundary ) ) < 0 <S2SV_ModEnd> ) goto <S2SV_ModStart> content_length += ret <S2SV_ModEnd> ; ( <S2SV_ModStart> ) , "byteranges;<S2SV_blank>boundary=%llu" , clt -> clt_boundary <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } r -> range_toread = TOREAD_HTTP_RANGE <S2SV_ModEnd> ; ret <S2SV_ModStart> 0 : close ( fd ) ; <S2SV_ModStart> ; } clt -> clt_fd = fd ; if ( clt -> clt_srvbev != NULL ) bufferevent_free ( clt -> clt_srvbev ) ; clt -> clt_srvbev_throttled = 0 ; clt -> clt_srvbev = bufferevent_new ( clt -> clt_fd , server_read_httprange , server_write , server_file_error , clt ) ; if ( clt -> clt_srvbev == NULL ) { errstr = "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer<S2SV_blank>event" ; <S2SV_ModEnd> goto fail <S2SV_ModStart> fail ; } bufferevent_setwatermark ( clt -> clt_srvbev , EV_READ , 0 , clt -> clt_sndbufsiz ) ; bufferevent_settimeout ( clt -> clt_srvbev , srv_conf -> timeout . tv_sec , srv_conf -> timeout . tv_sec ) ; bufferevent_enable ( clt -> clt_srvbev , EV_READ ) ; bufferevent_disable ( clt -> clt_bev , EV_READ ) ; done : server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable <S2SV_ModEnd> ( clt <S2SV_ModStart> ) ; <S2SV_ModEnd> bufferevent_free ( <S2SV_ModStart> abort : <S2SV_ModEnd> if (
<S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) { <S2SV_ModEnd> struct monitor <S2SV_ModStart> ) ; <S2SV_ModEnd> return mon
<S2SV_ModStart> 0 ; <S2SV_ModEnd> if ( <S2SV_ModStart> if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } if (
<S2SV_ModStart> * b = NULL <S2SV_ModStart> * pkalg = NULL <S2SV_ModStart> * pkblob = NULL <S2SV_ModStart> * sig = NULL <S2SV_ModStart> if ( <S2SV_ModEnd> ( r <S2SV_ModStart> ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done <S2SV_ModStart> ) ; <S2SV_ModEnd> auth2_record_key ( <S2SV_ModStart> ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( "%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user" , __func__ ) ; goto done ; } <S2SV_ModStart> ) ; free ( sig ) ;
<S2SV_ModStart> av , "cDdksE:a:P:t:" <S2SV_ModEnd> ) ) <S2SV_ModStart> k_flag ++ ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( "-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> pledge ( "stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec" <S2SV_ModEnd> , NULL
<S2SV_ModStart> , "usage:<S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>[-Dd]<S2SV_blank>[-a<S2SV_blank>bind_address]<S2SV_blank>[-E<S2SV_blank>fingerprint_hash]\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>[-P<S2SV_blank>pkcs11_whitelist]<S2SV_blank>[-t<S2SV_blank>life]<S2SV_blank>[command<S2SV_blank>[arg<S2SV_blank>...]]\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ssh-agent<S2SV_blank>[-c<S2SV_blank>|<S2SV_blank>-s]<S2SV_blank>-k\\n" )
<S2SV_ModStart> O_ACCMODE ) != O_RDONLY <S2SV_ModEnd> || ( <S2SV_ModStart> flags & ( O_CREAT | O_TRUNC ) ) != 0 <S2SV_ModEnd> ) )
<S2SV_ModStart> int r , dontmax = 0 <S2SV_ModStart> SSH_ERR_INVALID_FORMAT ; if ( ( st . st_mode & S_IFREG ) == 0 || st . st_size <= 0 ) { st . st_size = 64 * 1024 ; dontmax = 1 ; } if ( ( r = sshbuf_allocate ( blob , st . st_size ) ) != 0 || ( dontmax && ( r = sshbuf_set_max_size ( blob , st . st_size ) ) != 0 ) ) return r ;
<S2SV_ModStart> . disable_forwarding || ! use_privsep
<S2SV_ModStart> . disable_forwarding && use_privsep
<S2SV_ModStart> ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
<S2SV_ModStart> if ( * cp == '\\0' || <S2SV_ModEnd> strchr ( <S2SV_ModStart> != NULL || <S2SV_ModEnd> strcmp ( <S2SV_ModStart> cp , "." ) == 0 || strcmp ( cp , <S2SV_ModStart> == 0 <S2SV_ModEnd> ) {
<S2SV_ModStart> SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ;
<S2SV_ModStart> # endif if ( strlen ( password ) > MAX_PASSWORD_LEN ) return 0 ;
<S2SV_ModStart> default : return OFPERR_OFPGMFC_BAD_TYPE <S2SV_ModEnd> ; } <S2SV_ModStart> default : return OFPERR_OFPGMFC_BAD_COMMAND <S2SV_ModEnd> ; }
<S2SV_ModStart> ; } else { <S2SV_ModStart> ; } }
<S2SV_ModStart> dwUIChoice = WTD_UI_NONE <S2SV_ModEnd> ; trust_data <S2SV_ModStart> ) ; switch ( r ) { case ERROR_SUCCESS : break ; case TRUST_E_NOSIGNATURE : uprintf ( "PKI:<S2SV_blank>File<S2SV_blank>does<S2SV_blank>not<S2SV_blank>appear<S2SV_blank>to<S2SV_blank>be<S2SV_blank>signed:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_284 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; default : uprintf ( "PKI:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>validate<S2SV_blank>signature:<S2SV_blank>%s" , WinPKIErrorString ( ) ) ; MessageBoxExU ( hDlg , lmprintf ( MSG_240 ) , lmprintf ( MSG_283 ) , MB_OK | MB_ICONERROR | MB_IS_RTL , selected_langid ) ; break ; }
<S2SV_ModStart> ( ( ( <S2SV_ModStart> 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> return "None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted." ; case CERT_E_UNTRUSTEDROOT : return "The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted." ; case TRUST_E_NOSIGNATURE : return "Not<S2SV_blank>digitally<S2SV_blank>signed." ; case TRUST_E_EXPLICIT_DISTRUST : return "One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."
<S2SV_ModStart> ) { PyUnicodeObject <S2SV_ModEnd> * logical <S2SV_ModStart> = FRIBIDI_TYPE_RTL <S2SV_ModEnd> ; int <S2SV_ModStart> "base_direction" , <S2SV_ModEnd> "clean" , <S2SV_ModStart> kw , "U|iii" <S2SV_ModEnd> , kwargs <S2SV_ModStart> , & <S2SV_ModEnd> clean , <S2SV_ModStart> ) ) { <S2SV_ModStart> NULL ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> ) ; } return unicode_log2vis <S2SV_ModEnd> ( logical <S2SV_ModStart> ) ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> if ( ! client -> auth_user ) { disconnect_client ( client , true , "client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet" ) ; return false ; } if (
<S2SV_ModStart> client -> <S2SV_ModEnd> pool =
<S2SV_ModStart> ( ! user ) { slog_error ( client , "Password<S2SV_blank>packet<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>packet?" ) ; return false ; } if ( !
<S2SV_ModStart> if ( <S2SV_ModEnd> size_left <
<S2SV_ModStart> id ; if ( size_left < 4 ) { LogError ( "Process_ipfix<S2SV_blank>[%u]<S2SV_blank>Template<S2SV_blank>withdraw<S2SV_blank>size<S2SV_blank>error<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>line<S2SV_blank>%u" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; }
<S2SV_ModStart> ) { _gdImageGifCtx <S2SV_ModEnd> ( im <S2SV_ModStart> im , out <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) ; if ( ! _gdImageGifCtx <S2SV_ModEnd> ( im <S2SV_ModStart> out ) ) { <S2SV_ModEnd> rv = <S2SV_ModStart> ) ; } else { rv = NULL ; }
<S2SV_ModStart> ) { _gdImageWBMPCtx <S2SV_ModEnd> ( image <S2SV_ModStart> image , fg <S2SV_ModEnd> , out <S2SV_ModStart> , out <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; if ( ! _gdImageWBMPCtx <S2SV_ModEnd> ( im <S2SV_ModStart> out ) ) { <S2SV_ModEnd> rv = <S2SV_ModStart> ) ; } else { rv = NULL ; }
<S2SV_ModStart> context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; } <S2SV_ModStart> context ; if ( sig_len < sizeof ( digest <S2SV_ModEnd> ) ) <S2SV_ModStart> ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , "broken<S2SV_blank>signature" ) ; } return FAILURE ; }
<S2SV_ModStart> . uncompressed_filesize || read <= 8
<S2SV_ModStart> ) ; if ( new_len > INT_MAX ) { efree ( replaced ) ; RETURN_FALSE ; }
<S2SV_ModStart> char * start , * <S2SV_ModStart> ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> memchr ( start <S2SV_ModEnd> , '&' <S2SV_ModStart> end - start <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> ! eof && vars -> str . c != vars -> ptr
<S2SV_ModStart> elements ; if ( * p >= max - 2 ) { zend_error ( E_WARNING , "Bad<S2SV_blank>unserialize<S2SV_blank>data" ) ; return - 1 ; } <S2SV_ModStart> ; return - 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> # line 501 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { <S2SV_ModStart> # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 <S2SV_ModStart> # line 869 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 612 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 <S2SV_ModStart> # line 717 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> # line 795 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 <S2SV_ModStart> # line 704 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> "ext/standard/var_unserializer.re" { long elements ; <S2SV_ModStart> ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> UNSERIALIZE_PASSTHRU , elements <S2SV_ModEnd> ) ; <S2SV_ModStart> # line 833 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 <S2SV_ModStart> # line 683 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 875 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 <S2SV_ModStart> # line 648 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 931 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 <S2SV_ModStart> # line 615 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 985 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 <S2SV_ModStart> # line 605 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1083 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 <S2SV_ModStart> # line 590 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1157 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 <S2SV_ModStart> # line 563 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1211 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 <S2SV_ModStart> # line 556 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1226 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 <S2SV_ModStart> # line 549 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1236 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 <S2SV_ModStart> # line 526 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1282 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 <S2SV_ModStart> # line 505 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1326 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } <S2SV_ModStart> # line 877 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return
<S2SV_ModStart> ; } if ( input <= 0.0 || output <= 0.0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Gamma<S2SV_blank>values<S2SV_blank>should<S2SV_blank>be<S2SV_blank>positive" ) ; RETURN_FALSE ; }
<S2SV_ModStart> ( yych <= '/' ) goto yy18 ; if ( yych >= ';' <S2SV_ModEnd> ) goto <S2SV_ModStart> # line 805 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 <S2SV_ModStart> # line 837 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 <S2SV_ModStart> # line 882 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 <S2SV_ModStart> # line 937 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 <S2SV_ModStart> # line 990 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 <S2SV_ModStart> # line 1087 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 <S2SV_ModStart> # line 1162 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 <S2SV_ModStart> # line 1215 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 <S2SV_ModStart> # line 1229 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 <S2SV_ModStart> # line 1238 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 <S2SV_ModStart> # line 1286 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 <S2SV_ModStart> # line 1335 <S2SV_ModEnd> "ext/standard/var_unserializer.c" }
<S2SV_ModStart> 1 ; apr_brigade_cleanup ( brigade ) ;
<S2SV_ModStart> ; } if ( len >= FPM_LOG_BUFFER ) { zlog ( ZLOG_NOTICE , "the<S2SV_blank>log<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>full<S2SV_blank>(%d).<S2SV_blank>The<S2SV_blank>access<S2SV_blank>log<S2SV_blank>request<S2SV_blank>has<S2SV_blank>been<S2SV_blank>truncated." , FPM_LOG_BUFFER ) ; len = FPM_LOG_BUFFER ; break ; }
<S2SV_ModStart> ) { <S2SV_ModEnd> zend_throw_exception (
<S2SV_ModStart> 1 ; const zend_uchar * const packet_end = ( zend_uchar * ) row_buffer -> ptr + data_size ; <S2SV_ModStart> p ; const <S2SV_ModStart> ) ; if ( len != MYSQLND_NULL_LENGTH && ( ( p + len ) > packet_end ) ) { php_error_docref ( NULL , E_WARNING , "Malformed<S2SV_blank>server<S2SV_blank>packet.<S2SV_blank>Field<S2SV_blank>length<S2SV_blank>pointing<S2SV_blank>" MYSQLND_SZ_T_SPEC "<S2SV_blank>bytes<S2SV_blank>after<S2SV_blank>end<S2SV_blank>of<S2SV_blank>packet" , ( p + len ) - packet_end - 1 ) ; DBG_RETURN ( FAIL ) ; }
<S2SV_ModStart> ) { if ( Z_TYPE_PP <S2SV_ModEnd> ( var2 <S2SV_ModStart> var2 ) != IS_DOUBLE ) { zval dval ; dval = * * var ; zval_copy_ctor ( & dval ) <S2SV_ModStart> convert_to_double ( & dval ) ; matrix [ i ] [ j ] = ( float ) Z_DVAL ( dval ) ; } else { matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( <S2SV_ModEnd> var2 ) <S2SV_ModStart> ) ; } } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix" ) ; RETURN_FALSE ; } } } } res = gdImageConvolution ( im_src , matrix , <S2SV_ModEnd> ( float <S2SV_ModStart> float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE <S2SV_ModEnd> ; } <S2SV_ModStart> else { <S2SV_ModEnd> RETURN_FALSE ; <S2SV_ModStart> } } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; <S2SV_ModStart> height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> ) ; }
<S2SV_ModStart> IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; <S2SV_ModStart> ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> ; } } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> ; } } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> ; } } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; <S2SV_ModStart> x = Z_DVAL ( dval ) ; } else { x = <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( tmp ) != IS_DOUBLE ) { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; <S2SV_ModStart> y = Z_DVAL ( dval ) ; } else { y = <S2SV_ModStart> ) ; }
<S2SV_ModStart> IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; <S2SV_ModStart> ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; <S2SV_ModStart> IS_STRING : { zval dval ; dval = * * tmp ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; <S2SV_ModStart> ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ;
<S2SV_ModStart> ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> x = Z_LVAL ( lval ) ; } else { points [ i ] . x = <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> convert_to_long ( & lval <S2SV_ModEnd> ) ; <S2SV_ModStart> y = Z_LVAL ( lval ) ; } else { points [ i ] . y = <S2SV_ModStart> } } }
<S2SV_ModStart> socket_mode = 0660 <S2SV_ModEnd> ; if
<S2SV_ModStart> buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0
<S2SV_ModStart> buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0
<S2SV_ModStart> = spl_array_get_debug_info ; spl_handler_ArrayObject . get_gc = spl_array_get_gc
<S2SV_ModStart> if ( tmp_line_len >= 1 && <S2SV_ModStart> if ( tmp_line_len >= 1 && <S2SV_ModStart> } } \\\n} <S2SV_ModEnd> if (
<S2SV_ModStart> pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
<S2SV_ModStart> ( pcount ) ; ZVAL_UNDEF ( & entry ) ; ZVAL_UNDEF ( & inf <S2SV_ModStart> if ( <S2SV_ModEnd> * p <S2SV_ModStart> } } if ( Z_TYPE ( entry ) != IS_OBJECT ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept <S2SV_ModEnd> ; }
<S2SV_ModStart> -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
<S2SV_ModStart> ) ; <S2SV_ModEnd> return 0
<S2SV_ModStart> ) ; zend_object_store_ctor_failed ( * rval TSRMLS_CC ) ;
<S2SV_ModStart> # line 496 <S2SV_ModEnd> "ext/standard/var_unserializer.c" { <S2SV_ModStart> # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy4 <S2SV_ModStart> # line 855 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 607 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy16 <S2SV_ModStart> # line 708 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 785 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy25 <S2SV_ModStart> # line 699 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 819 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy32 <S2SV_ModStart> # line 678 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 861 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy39 <S2SV_ModStart> # line 643 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 917 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy46 <S2SV_ModStart> # line 610 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 971 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy53 <S2SV_ModStart> # line 600 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1069 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy65 <S2SV_ModStart> # line 585 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1143 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy76 <S2SV_ModStart> # line 558 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1197 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy83 <S2SV_ModStart> # line 551 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1212 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy87 <S2SV_ModStart> # line 544 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1222 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy89 <S2SV_ModStart> # line 521 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1268 <S2SV_ModEnd> "ext/standard/var_unserializer.c" yy95 <S2SV_ModStart> # line 500 <S2SV_ModEnd> "ext/standard/var_unserializer.re" { <S2SV_ModStart> # line 1312 <S2SV_ModEnd> "ext/standard/var_unserializer.c" } <S2SV_ModStart> # line 863 <S2SV_ModEnd> "ext/standard/var_unserializer.re" return
<S2SV_ModStart> ; } INTL_CHECK_LOCALE_LEN ( slocale_len ) ;
<S2SV_ModStart> ; } if ( length > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> ) ; if ( cidx == NULL ) { goto fail1 ; }
<S2SV_ModStart> int iSrc <S2SV_ModEnd> ; if <S2SV_ModStart> } } <S2SV_ModEnd> res -> <S2SV_ModStart> ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] .
<S2SV_ModStart> ( q < p || q
<S2SV_ModStart> < 0 || color < 0
<S2SV_ModStart> var_hash ; int skip = 0 ; <S2SV_ModStart> * tmp ; skip = 0 <S2SV_ModStart> ) { skip = 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) { if ( ! skip ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ; } if ( ! skip ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> var_hash ; int skip = 0 ; <S2SV_ModStart> = p ; skip = 0 <S2SV_ModStart> ) { skip = 1 <S2SV_ModEnd> ; } <S2SV_ModStart> ) { if ( ! skip ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ; } if ( ! skip ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> U_ZERO_ERROR ; buflen ++ ;
<S2SV_ModStart> char * start , * <S2SV_ModStart> ; } start = var -> ptr + var -> already_scanned ; <S2SV_ModStart> memchr ( start <S2SV_ModEnd> , '&' <S2SV_ModStart> end - start <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { var -> already_scanned = var -> end - var -> ptr ; <S2SV_ModStart> ) ; var -> already_scanned = 0 ;
<S2SV_ModStart> ; } if ( len > INT_MAX ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>no<S2SV_blank>more<S2SV_blank>than<S2SV_blank>%d" , INT_MAX ) ; RETURN_FALSE ; }
<S2SV_ModStart> exception_ce , "%s" ,
<S2SV_ModStart> = NULL ; zval * retval <S2SV_ModStart> } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> php_var_unserialize_ex ( retval <S2SV_ModEnd> , & <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( zend_hash_find <S2SV_ModEnd> ( ht
<S2SV_ModStart> ifdef HAVE_IPV6 <S2SV_ModEnd> if ( <S2SV_ModStart> ) { char * <S2SV_ModStart> 2 ) , * e = NULL <S2SV_ModStart> portno = strtol <S2SV_ModEnd> ( p <S2SV_ModStart> + 2 , & e , 10 ) ; if ( e && * e ) { if ( get_err ) { * err = strpprintf ( 0 , "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>address<S2SV_blank>\\"%s\\"" , str ) ; } return NULL ; } <S2SV_ModEnd> return estrndup <S2SV_ModStart> ) { char * e = NULL ; <S2SV_ModStart> portno = strtol ( colon + 1 , & e , 10 ) ; if ( ! e || ! * e ) { return <S2SV_ModEnd> estrndup ( <S2SV_ModStart> ; } } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> int old_bin_num <S2SV_ModEnd> = ZEND_MM_SRUN_BIN_NUM <S2SV_ModStart> ] ; if ( size <= ZEND_MM_MAX_SMALL_SIZE ) { int <S2SV_ModStart> ptr ; }
<S2SV_ModStart> ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
<S2SV_ModStart> TSRMLS_CC ) || ( Z_TYPE_P ( intern -> array ) != IS_ARRAY && Z_TYPE_P ( intern -> array ) != IS_OBJECT ) ) { zval_ptr_dtor ( & intern -> array ) ; <S2SV_ModEnd> goto outexcept
<S2SV_ModStart> ! offset || ! ht
<S2SV_ModStart> zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void oidc_scrub_headers
<S2SV_ModStart> ; } oidc_scrub_headers ( r ) ;
<S2SV_ModStart> pool , "The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR )
<S2SV_ModStart> res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long <S2SV_ModStart> ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table <S2SV_ModStart> xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> <S2SV_ModStart> id_table ) ) ) ) { ERROR ( "read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> + ( ( long long )
<S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
<S2SV_ModStart> 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
<S2SV_ModStart> ; } Assert ( ncolumns <= MaxTupleAttributeNumber ) ;
<S2SV_ModStart> ; } if ( pcount < 0 || pcount > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , pcount , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ; } if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ;
<S2SV_ModStart> ) ; if ( state . num > QUERYTYPEMAXITEMS ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>query<S2SV_blank>items<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , state . num , ( int ) QUERYTYPEMAXITEMS ) ) ) ;
<S2SV_ModStart> ) { check_stack_depth ( ) ;
<S2SV_ModStart> num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) )
<S2SV_ModStart> ; } if ( num + 1 > MaxAllocSize / sizeof ( nodeitem ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "number<S2SV_blank>of<S2SV_blank>levels<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)" , num + 1 , ( int ) ( MaxAllocSize / sizeof ( nodeitem ) ) ) ) ) ;
<S2SV_ModStart> ) { check_stack_depth ( ) ;
<S2SV_ModStart> 0 ; check_stack_depth ( ) ;
<S2SV_ModStart> ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "ltxtquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> int size ; int base_size <S2SV_ModStart> ; } base_size = sizeof ( path -> <S2SV_ModEnd> p [ <S2SV_ModStart> ] ) * npts ; size = offsetof ( PATH , <S2SV_ModEnd> p [ <S2SV_ModStart> ] ) + base_size ; if ( base_size / npts != sizeof ( path -> p [ 0 ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; path
<S2SV_ModStart> ; int base_size ; int <S2SV_ModStart> ) ; base_size = sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_ModStart> ) + base_size ; if ( base_size / npts != <S2SV_ModStart> ] ) || size <= base_size ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "too<S2SV_blank>many<S2SV_blank>points<S2SV_blank>requested" ) ) ) <S2SV_ModEnd> ; poly
<S2SV_ModStart> ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) ) ) ;
<S2SV_ModStart> & nnode ) ; if ( TSQUERY_TOO_BIG ( nnode , sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( "tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large" ) )
<S2SV_ModStart> MAXDATELEN + MAXDATEFIELDS <S2SV_ModEnd> ] ; <S2SV_ModStart> str ) > MAXDATELEN <S2SV_ModEnd> ) {
<S2SV_ModStart> fstr [ 7 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0'
<S2SV_ModStart> fstr [ 7 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] ; int i ; cp ++ ; for ( i = 0 ; i < 6 ; i ++ ) fstr [ i ] = * cp != '\\0' ? * cp ++ : '0' ; fstr [ i ] <S2SV_ModEnd> = '\\0'
<S2SV_ModStart> = lp ; if ( nf >= MAXDATEFIELDS ) return - 1 <S2SV_ModStart> ++ ; <S2SV_ModEnd> } *
<S2SV_ModStart> str ) > MAXDATELEN ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || ( DecodeInterval ( field , ftype , nf , & dtype , tm , & fsec ) != 0 && DecodeISO8601Interval ( str , & dtype , tm , & fsec ) != 0 ) ) { errno = PGTYPES_INTVL_BAD_INTERVAL ; return NULL ; } result = ( interval * ) pgtypes_alloc ( <S2SV_ModEnd> sizeof ( <S2SV_ModStart> sizeof ( interval ) ) ; if ( ! result ) return NULL ; if ( dtype != DTK_DELTA <S2SV_ModEnd> ) { <S2SV_ModStart> PGTYPES_INTVL_BAD_INTERVAL ; free ( result ) ; return NULL ; } if ( tm2interval ( tm , fsec , result ) != 0 <S2SV_ModEnd> ) { <S2SV_ModStart> PGTYPES_INTVL_BAD_INTERVAL ; <S2SV_ModEnd> free ( <S2SV_ModStart> ; } <S2SV_ModEnd> errno =
<S2SV_ModStart> str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : <S2SV_ModEnd> if ( <S2SV_ModStart> if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != <S2SV_ModStart> != 0 <S2SV_ModEnd> ) {
<S2SV_ModStart> # line 62 <S2SV_ModEnd> "dt_test2.pgc" date <S2SV_ModStart> # line 63 <S2SV_ModEnd> "dt_test2.pgc" timestamp <S2SV_ModStart> # line 64 <S2SV_ModEnd> "dt_test2.pgc" char <S2SV_ModStart> # line 65 <S2SV_ModEnd> "dt_test2.pgc" interval <S2SV_ModStart> # line 66 <S2SV_ModEnd> "dt_test2.pgc" date <S2SV_ModStart> # line 67 <S2SV_ModEnd> "dt_test2.pgc" int
<S2SV_ModStart> ] ; <S2SV_ModEnd> size_t pathlen <S2SV_ModStart> ; } <S2SV_ModEnd> res = <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( <S2SV_ModStart> PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno =
<S2SV_ModStart> ] ; <S2SV_ModEnd> size_t pathlen <S2SV_ModStart> ; } <S2SV_ModEnd> res = <S2SV_ModStart> res = is_symlink_path ( p , path , pathlen <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { if ( errno == EPERM ) { <S2SV_ModEnd> pr_log_pri ( <S2SV_ModStart> PR_LOG_WARNING , "error:<S2SV_blank>DefaultRoot<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symlink<S2SV_blank>" "(denied<S2SV_blank>by<S2SV_blank>AllowChrootSymlinks<S2SV_blank>config)" , path ) ; } <S2SV_ModEnd> errno =
<S2SV_ModStart> if ( setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if (
<S2SV_ModStart> old_umask ; const <S2SV_ModEnd> char * <S2SV_ModStart> base_path = "/tmp" ; <S2SV_ModEnd> __debug__ (
<S2SV_ModStart> next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
<S2SV_ModStart> p = cmd [ 0 ] ? <S2SV_ModStart> 1 ) : NULL
<S2SV_ModStart> 'l' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> ) ; } <S2SV_ModStart> 'i' : { RBinObject * obj = r_bin_cur_object ( core -> bin ) ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> < 1 || shdr -> sh_size > SIZE_MAX
<S2SV_ModStart> 0 ; ( i + 3 ) <S2SV_ModEnd> < sec <S2SV_ModStart> 0 ; ( i + 7 ) <S2SV_ModEnd> < sec
<S2SV_ModStart> 0 ; i >= 0 && <S2SV_ModStart> ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; }
<S2SV_ModStart> + 8 + 8 <S2SV_ModStart> ; } const <S2SV_ModStart> ) ) ; const int <S2SV_ModEnd> max_val =
<S2SV_ModStart> ; } if ( p4 <= 0 ) { return ; }
<S2SV_ModStart> RAnalOp next_op = { 0 }
<S2SV_ModStart> name ) { <S2SV_ModStart> continue ; }
<S2SV_ModStart> obuf_len < 1 <S2SV_ModEnd> ) { <S2SV_ModStart> break ; # if 0 <S2SV_ModStart> break ; # endif <S2SV_ModStart> ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ) ; if ( value -> encoding . block . data ) { <S2SV_ModStart> ) ; }

<S2SV_ModStart> ; } int len = to - from ; <S2SV_ModStart> calloc ( len <S2SV_ModEnd> , 1 <S2SV_ModStart> buf , len <S2SV_ModEnd> ) ; <S2SV_ModStart> > 5 + rc <S2SV_ModStart> is_wide32 = ( <S2SV_ModStart> < to ) && ( <S2SV_ModEnd> ! w <S2SV_ModStart> 4 ] )
<S2SV_ModStart> i ; <S2SV_ModEnd> struct minidump_directory <S2SV_ModStart> struct minidump_directory entry <S2SV_ModEnd> ; sdb_num_set <S2SV_ModStart> ) ; ut64 rvadir = obj -> hdr -> stream_directory_rva ; <S2SV_ModStart> ) { ut32 delta = <S2SV_ModEnd> i * <S2SV_ModStart> minidump_directory ) ; int r = r_buf_read_at ( obj -> b , rvadir + delta , ( ut8 * ) & entry , sizeof ( struct minidump_directory <S2SV_ModStart> ) ; if ( r ) { <S2SV_ModStart> obj , & <S2SV_ModStart> ) ; }
<S2SV_ModStart> j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_ModStart> vstart += vdaux <S2SV_ModEnd> ; if
<S2SV_ModStart> ) { if ( dbg_data_len < 20 ) { eprintf ( "Truncated<S2SV_blank>NB10<S2SV_blank>entry,<S2SV_blank>not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>parse\\n" ) ; return 0 ; } <S2SV_ModStart> SCV_NB10_HEADER nb10_hdr = { { 0 } } <S2SV_ModStart> ) ; res -> file_name [ 0 ] = 0 ; if ( nb10_hdr . file_name ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> 16 ; <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ) { <S2SV_ModEnd> return NULL <S2SV_ModStart> ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; <S2SV_ModStart> image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> ( bin <S2SV_ModStart> -> b , <S2SV_ModEnd> bin -> <S2SV_ModStart> . startaddr , ( ut8 * ) image_infos , sz <S2SV_ModStart> dyld_vmbase = r_buf_read64le <S2SV_ModEnd> ( bin <S2SV_ModStart> -> b , <S2SV_ModEnd> bin -> <S2SV_ModStart> liboff ; int pfo = <S2SV_ModEnd> image_infos [ <S2SV_ModStart> . pathFileOffset ; if ( pfo < 0 || pfo <S2SV_ModStart> eprintf ( "corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n" , pfo <S2SV_ModEnd> ) ; <S2SV_ModStart> libname = r_buf_read_string <S2SV_ModEnd> ( bin <S2SV_ModStart> -> b , pfo , 64 <S2SV_ModEnd> ) ;
<S2SV_ModStart> * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> ( ! bin <S2SV_ModEnd> ) { <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> if ( ! bin -> b ||
<S2SV_ModStart> 0xbf ) { <S2SV_ModStart> 1 ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> err ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> err ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> beach ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> beach ; } <S2SV_ModStart> txt ) + 10 <S2SV_ModStart> ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> txt + optxtlen <S2SV_ModEnd> , R_ASM_BUFSIZE <S2SV_ModStart> , R_ASM_BUFSIZE - optxtlen
<S2SV_ModStart> && ( end - <S2SV_ModStart> ) defs > i <S2SV_ModEnd> ) ; <S2SV_ModStart> < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux <S2SV_ModStart> end || end - vstart < <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) ) <S2SV_ModEnd> ) { <S2SV_ModStart> end || end - vstart < <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) ) <S2SV_ModEnd> ) {
<S2SV_ModStart> '<S2SV_blank>' ) { input ++ ; } <S2SV_ModEnd> ptr = <S2SV_ModStart> ) ) { <S2SV_ModStart> ; } } <S2SV_ModStart> ) ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( <S2SV_ModStart> data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header <S2SV_ModStart> , "invalid<S2SV_blank>extent" ) ; free ( buf <S2SV_ModStart> ) ) { free ( buf ) ; <S2SV_ModStart> 0 ; } <S2SV_ModStart> ) ; free ( buf ) ; <S2SV_ModStart> ) ; free ( buf ) ; <S2SV_ModStart> ; } free ( buf ) ; <S2SV_ModStart> indir ) { <S2SV_ModStart> grub_errno ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> grub_errno ; } <S2SV_ModStart> indir ) { <S2SV_ModStart> grub_errno ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> grub_errno ; } <S2SV_ModStart> ) ) { <S2SV_ModStart> grub_errno ; }
<S2SV_ModStart> ) ) { return 0 ; } <S2SV_ModEnd> ext_block =
<S2SV_ModStart> ) { char * fpath = grub_malloc ( <S2SV_ModEnd> grub_strlen ( <S2SV_ModStart> + 1 ) ; <S2SV_ModEnd> char * <S2SV_ModStart> char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , <S2SV_ModEnd> grub_strlen ( <S2SV_ModStart> ) ; <S2SV_ModEnd> while ( <S2SV_ModStart> = currnode ; free ( fpath ) <S2SV_ModStart> ) ; free ( fpath ) ; <S2SV_ModStart> grub_errno ) { free ( fpath ) ; <S2SV_ModStart> grub_errno ; } <S2SV_ModStart> ) ; free ( fpath ) ; <S2SV_ModStart> , c ) ; free ( fpath <S2SV_ModStart> ) ; free ( fpath ) ; <S2SV_ModStart> type ; free ( fpath ) ; <S2SV_ModStart> ; } free ( fpath ) ;
<S2SV_ModStart> device ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> if ( ! disk <S2SV_ModEnd> ) { <S2SV_ModStart> ) { eprintf ( "oops.<S2SV_blank>no<S2SV_blank>disk\\n" ) ; return 1 ; } <S2SV_ModStart> = 512 <S2SV_ModEnd> ; RIOBind <S2SV_ModStart> bio ) { <S2SV_ModStart> bio ; } if ( <S2SV_ModEnd> iob -> <S2SV_ModStart> blocksize ) <S2SV_ModEnd> == - <S2SV_ModStart> 1 ) { <S2SV_ModStart> ; } <S2SV_ModEnd> return 0
<S2SV_ModStart> ) ; if ( ! tbuf ) { return NULL ; }
<S2SV_ModStart> sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) )

<S2SV_ModStart> ! data || len < 2 ) { <S2SV_ModEnd> return 0 <S2SV_ModStart> 0 ; }
<S2SV_ModStart> } } return - 1 ;
<S2SV_ModStart> ) { char * filename = grub_malloc ( <S2SV_ModEnd> dirent . <S2SV_ModStart> + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node <S2SV_ModStart> GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = <S2SV_ModStart> fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> <S2SV_ModStart> grub_errno ) { free ( filename ) ; <S2SV_ModEnd> grub_free ( <S2SV_ModStart> ) ) { free ( filename ) ; <S2SV_ModStart> return 1 ; } free ( filename )
<S2SV_ModStart> INDIRECT_BLOCKS ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> pos ; if ( len < 1 || len == 0xffffffff ) { return - 1 ; }
<S2SV_ModStart> . objects || ! object -> list . objects [ 0 ] || ! object -> list . objects [ 1 ] || <S2SV_ModEnd> object ->
<S2SV_ModStart> ) { if ( reg_index < 2 ) { <S2SV_ModStart> temp ; } <S2SV_ModStart> temp ; if ( reg_index < 2 ) { <S2SV_ModStart> X86R_UNDEFINED ; }
<S2SV_ModStart> RAnalOp next_op = { 0 }
<S2SV_ModStart> esil ) { <S2SV_ModStart> return ; }
<S2SV_ModStart> ) ; int minsz = R_MIN ( len , size ) ; minsz = R_MAX ( minsz , 0 ) ; <S2SV_ModStart> j < minsz <S2SV_ModEnd> ; j <S2SV_ModStart> ) { ut8 ch = ( ( j + idx - 1 ) > minsz ) ? 0xff : <S2SV_ModEnd> buf [ <S2SV_ModStart> idx ] ; r_cons_printf ( "%02x" , ch <S2SV_ModStart> UT64_MAX ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> UT64_MAX ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> 1 ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> ( argReg > <S2SV_ModEnd> regsz ) <S2SV_ModStart> ) { return ;
<S2SV_ModStart> opcode_desc ; if ( len < 2 ) { return NULL ; }
<S2SV_ModStart> if ( len > 1 ) { if ( <S2SV_ModStart> 127 ) { <S2SV_ModStart> size ; } else { <S2SV_ModEnd> op -> <S2SV_ModStart> size ; } } else { op -> jump = addr ; }
<S2SV_ModStart> string ; if ( name > 1024 ) { <S2SV_ModStart> ; } else { eprintf ( "Invalid<S2SV_blank>string<S2SV_blank>pointer<S2SV_blank>at<S2SV_blank>%p\\n" , name ) ; } }
<S2SV_ModStart> ) ; char * txt = op -> txt ; int txtLen = strlen ( op -> txt ) ; int txtLeft = R_ASM_BUFSIZE - txtLen ; txt += txtLen ; <S2SV_ModStart> count && txtLen <S2SV_ModEnd> + 10 <S2SV_ModStart> ) { <S2SV_ModEnd> snprintf ( <S2SV_ModStart> snprintf ( txt , txtLeft <S2SV_ModEnd> , "%d<S2SV_blank>" <S2SV_ModStart> ) ; txtLen = strlen ( txt ) ; txt += txtLen ; txtLeft -= txtLen ; <S2SV_ModStart> snprintf ( txt , txtLeft - 1 <S2SV_ModEnd> , "%d"
<S2SV_ModStart> buf ) { if ( pos + real_offset + len >= size ) { grub_errno = GRUB_ERR_BAD_FS ; return grub_errno ; } <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) ; st32 vnaux = entry -> vn_aux ; if ( vnaux < 1 ) { goto beach ; } <S2SV_ModStart> vstart += vnaux <S2SV_ModEnd> ; for
<S2SV_ModStart> ) { if ( len < 4 ) { return ; }
<S2SV_ModStart> dyld_info = calloc ( 1 , <S2SV_ModEnd> sizeof ( <S2SV_ModStart> if ( bin -> dyld_info ) { if ( <S2SV_ModStart> ) ; R_FREE <S2SV_ModEnd> ( bin <S2SV_ModStart> } } }
<S2SV_ModStart> 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) {
<S2SV_ModStart> { i ++ <S2SV_ModEnd> ; }
<S2SV_ModStart> NULL ; ut32 len = sec -> payload_len ; <S2SV_ModStart> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data <S2SV_ModEnd> ; ut32 <S2SV_ModStart> < len && len < buflen <S2SV_ModStart> ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto beach ; } if ( i + 4 >= buflen ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> payload_data ; int buflen = bin -> buf -> length - ( ut32 ) sec -> payload_data ; <S2SV_ModStart> < len && len < buflen <S2SV_ModStart> ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ) { goto beach <S2SV_ModEnd> ; } <S2SV_ModStart> ret ; beach : free ( ptr ) ; return ret ;
<S2SV_ModStart> NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> -> length - <S2SV_ModEnd> ( ut32
<S2SV_ModStart> token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false
<S2SV_ModStart> . types_size <S2SV_ModEnd> ) {
<S2SV_ModStart> 0 ] % 6 <S2SV_ModStart> 0x8b ; data [ l ++ ] = ( ( ( ut32 ) op -> operands [ 0 ] . reg ) << 3 ) | 0x5 ; data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; return l ; } if ( a -> bits == 64 ) { if ( op -> operands [ 0 ] . type & OT_QWORD ) { if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { if ( op -> operands [ 1 ] . regs [ 0 ] != - 1 ) { data [ l ++ ] = 0x67 ; } data [ l ++ ] = 0x48 ; } } else if ( op -> operands [ 1 ] . type & OT_DWORD ) { data [ l ++ ] = 0x44 ; } else if ( ! ( op -> operands [ 1 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x67 ; } if ( op -> operands [ 1 ] . type & OT_QWORD && op -> operands [ 0 ] . type & OT_QWORD ) { data [ l ++ ] = 0x48 ; } } if ( op -> operands [ 0 ] . type & OT_WORD ) { data [ l ++ ] = 0x66 ; data [ l ++ ] = op -> operands [ 1 ] . type & OT_BYTE ? 0x8a : 0x8b ; } else { data [ l ++ ] = ( op -> operands [ 1 ] . type & OT_BYTE || op -> operands [ 0 ] . type & OT_BYTE ) ? 0x8a : 0x8b ; } if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_UNDEFINED ) { if ( a -> bits == 64 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 0x4 ; data [ l ++ ] = 0x25 ; } else { <S2SV_ModStart> 0x5 ; } <S2SV_ModStart> 24 ; } else { if ( op -> operands [ 1 ] . scale [ 0 ] > 1 ) { data [ l ++ ] = op -> operands [ 0 ] . reg << 3 | 4 ; if ( op -> operands [ 1 ] . scale [ 0 ] >= 2 ) { base = 5 ; } if ( base ) { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 6 | op -> operands [ 1 ] . regs [ 0 ] << 3 | base ; } else { data [ l ++ ] = getsib ( op -> operands [ 1 ] . scale [ 0 ] ) << 3 | op -> operands [ 1 ] . regs [ 0 ] ; } if ( offset || base ) { data [ l ++ ] = offset ; data [ l ++ ] = offset >> 8 ; data [ l ++ ] = offset >> 16 ; data [ l ++ ] = offset >> 24 ; } <S2SV_ModStart> if ( op -> operands [ 1 ] . regs [ 1 <S2SV_ModEnd> ] != <S2SV_ModStart> ] != X86R_UNDEFINED <S2SV_ModEnd> ) { <S2SV_ModStart> ] = op -> operands [ 1 ] . regs [ 1 ] << 3 | op -> operands [ 1 ] . regs [ 0 ] ; return l ; } if ( offset || op -> operands [ 1 ] . regs [ 0 ] == X86R_EBP ) { mod = 0x2 ; if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x4 ; } } if ( a -> bits == 64 && offset && op -> operands [ 0 ] . type & OT_QWORD ) { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP ) { data [ l ++ ] = 0x5 <S2SV_ModEnd> ; } <S2SV_ModStart> else { if ( op -> operands [ 1 ] . offset > 127 ) { data [ l ++ ] = 0x80 | <S2SV_ModEnd> op -> <S2SV_ModStart> 3 | op -> operands [ 1 ] . regs [ 0 ] <S2SV_ModEnd> ; } <S2SV_ModStart> else { data [ l ++ ] = 0x40 | op -> operands [ 1 ] . regs [ 0 ] ; } } if ( op -> operands [ 1 ] . offset > 127 ) { mod = 0x1 ; } } else { if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_EIP && ( op -> operands [ 0 ] . type & OT_DWORD ) ) { data [ l ++ ] = 0x0d ; } else if ( op -> operands [ 1 ] . regs [ 0 ] == X86R_RIP && ( op -> operands [ 0 ] . type & OT_QWORD ) ) { data [ l ++ ] = 0x05 ; } else { data [ l ++ ] = mod << 5 | <S2SV_ModEnd> op -> <S2SV_ModStart> 3 | <S2SV_ModEnd> op ->
<S2SV_ModStart> ) ; snprintf <S2SV_ModEnd> ( op <S2SV_ModStart> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> ) ; snprintf <S2SV_ModEnd> ( op <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i" <S2SV_ModStart> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#x" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%#04hx" <S2SV_ModStart> undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" <S2SV_ModStart> 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" <S2SV_ModStart> 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" <S2SV_ModStart> ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" <S2SV_ModStart> ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]" <S2SV_ModStart> 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" <S2SV_ModStart> 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" <S2SV_ModStart> ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>[%04x]" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>class+%i" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>field+%i" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>%s" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>thing+%i" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>string+%i" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>v%i,<S2SV_blank>0x%" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i" <S2SV_ModStart> 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i}" <S2SV_ModStart> 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" <S2SV_ModStart> default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "<S2SV_blank>{}" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>class+%i" <S2SV_ModStart> ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" <S2SV_ModStart> else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ",<S2SV_blank>method+%i"
<S2SV_ModStart> has_va ; <S2SV_ModEnd> char * <S2SV_ModStart> arch = strdup ( info -> arch ) ; char * cpu = info -> cpu ? strdup ( info -> cpu ) : NULL <S2SV_ModEnd> ; ut16 <S2SV_ModStart> if ( <S2SV_ModEnd> cpu && <S2SV_ModStart> && * <S2SV_ModEnd> cpu ) <S2SV_ModStart> "anal.cpu" , <S2SV_ModEnd> cpu ) <S2SV_ModStart> , binfile ) ; free ( cpu ) ; free ( arch
<S2SV_ModStart> i ; size_t vstart_off = i ; <S2SV_ModStart> 1 || shdr -> sh_size - vstart_off < vdaux <S2SV_ModEnd> ) { <S2SV_ModStart> } vstart += vdaux ; vstart_off <S2SV_ModStart> vda_next ; vstart_off += aux . vda_next ;
<S2SV_ModStart> : case \'"\' : case '\\\\' : case
<S2SV_ModStart> ) { char ch = * arg ; <S2SV_ModStart> switch ( ch <S2SV_ModEnd> ) { <S2SV_ModStart> : case '=' : case <S2SV_ModStart> ++ = ch <S2SV_ModEnd> ; break
<S2SV_ModStart> r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s.%s\\"\\n" <S2SV_ModEnd> , module <S2SV_ModStart> r_cons_printf ( "\\"k<S2SV_blank>bin/pe/%s/%d=%s\\"\\n" <S2SV_ModEnd> , module
<S2SV_ModStart> ; } char op0 = 0 ; <S2SV_ModStart> ) { op0 = * q ; <S2SV_ModStart> = p <S2SV_ModEnd> ; } <S2SV_ModStart> p = op0 <S2SV_ModEnd> ; cmd
<S2SV_ModStart> ) ) ; gchar * dot_filename ; gchar * png_filename ; gchar * command_line <S2SV_ModStart> ) ; dot_filename = g_strdup_printf ( "/tmp/rs-filter-graph.%u" , g_random_int ( ) ) ; png_filename = g_strdup_printf ( "%s.%u.png" , dot_filename , g_random_int ( ) ) ; <S2SV_ModStart> g_file_set_contents ( dot_filename <S2SV_ModEnd> , str <S2SV_ModStart> ) ; command_line = g_strdup_printf ( "dot<S2SV_blank>-Tpng<S2SV_blank>>%s<S2SV_blank><%s" , png_filename , dot_filename ) ; <S2SV_ModStart> system ( command_line <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ; g_free ( command_line ) ; command_line = g_strdup_printf ( "gnome-open<S2SV_blank>%s" , png_filename ) ; <S2SV_ModStart> system ( command_line <S2SV_ModEnd> ) ) <S2SV_ModStart> ( "Calling<S2SV_blank>gnome-open<S2SV_blank>failed." ) ; g_free ( command_line ) ; g_free ( dot_filename ) ; g_free ( png_filename
<S2SV_ModStart> tagval , uint32 <S2SV_ModEnd> * length
<S2SV_ModStart> while ( indexw < width && <S2SV_ModStart> while ( indexw < width && <S2SV_ModStart> while ( indexw < width && <S2SV_ModStart> while ( indexw < width &&
<S2SV_ModStart> data ; struct stream packet = * s ; <S2SV_ModStart> if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cliprdr_process(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>packet<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } if (
<S2SV_ModStart> tagval ; struct stream packet ; <S2SV_ModStart> ) ; packet = * s ; <S2SV_ModStart> False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>version<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } <S2SV_ModStart> False ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "cssp_read_tsrequest(),<S2SV_blank>consume<S2SV_blank>of<S2SV_blank>token<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; } s_realloc ( token , length ) ; s_reset ( token ) <S2SV_ModEnd> ; out_uint8p
<S2SV_ModStart> buf ; struct stream packet = * s ; if ( ! s_check ( s ) ) { rdp_protocol_error ( "lspci_process(),<S2SV_blank>stream<S2SV_blank>is<S2SV_blank>in<S2SV_blank>unstable<S2SV_blank>state" , & packet ) ; }
<S2SV_ModStart> ) { uint32 length ; struct stream packet = * s <S2SV_ModEnd> ; ber_parse_header <S2SV_ModStart> ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),<S2SV_blank>consume<S2SV_blank>domain<S2SV_blank>params<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> result ; uint32 <S2SV_ModEnd> length ; <S2SV_ModStart> STREAM s ; struct stream packet <S2SV_ModStart> False ; packet = * s ; <S2SV_ModStart> ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_recv_connect_response(),<S2SV_blank>consume<S2SV_blank>connect<S2SV_blank>id<S2SV_blank>from<S2SV_blank>stream<S2SV_blank>would<S2SV_blank>overrun" , & packet ) ; }
<S2SV_ModStart> next_order ; struct stream packet = * s ; <S2SV_ModStart> ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( "process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream" , & packet ) ; }
<S2SV_ModStart> ( "exFAT<S2SV_blank>file<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found" ) ; return - EIO ; } if ( ef -> sb -> sector_bits < 9 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>small<S2SV_blank>sector<S2SV_blank>size:<S2SV_blank>2^%hhd" , ef -> sb -> sector_bits ) ; free ( ef -> sb ) ; return - EIO ; } if ( ( int ) ef -> sb -> sector_bits + ( int ) ef -> sb -> spc_bits > 25 ) { exfat_close ( ef -> dev ) ; exfat_error ( "too<S2SV_blank>big<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>2^(%hhd+%hhd)" , ef -> sb -> sector_bits , ef -> sb -> spc_bits ) ; free ( ef -> sb <S2SV_ModStart> if ( <S2SV_ModEnd> le64_to_cpu (
<S2SV_ModStart> ( spath ) ) return - 1 ; if ( strstr ( name , ".." ) || strchr ( name , '/'
<S2SV_ModStart> 0 ) # ifdef SUPER_SECURE memcpy ( own_dir , "/dev/null/" , 2 ) ; # else <S2SV_ModStart> ) ; # endif
<S2SV_ModStart> key ; <S2SV_ModEnd> } * <S2SV_ModStart> ) ; <S2SV_ModEnd> for (
<S2SV_ModStart> key ; <S2SV_ModEnd> } * <S2SV_ModStart> ) ; <S2SV_ModEnd> for (
<S2SV_ModStart> key ; <S2SV_ModEnd> } *
<S2SV_ModStart> key ; <S2SV_ModEnd> } *
<S2SV_ModStart> rpmpsm psm , int exclusive <S2SV_ModStart> dest , exclusive ? "wx.ufdio" : "a.ufdio" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; if ( ! exclusive && wfd != NULL && ! linkSane ( wfd , dest ) ) { rc = RPMERR_OPEN_FAILED ; goto exit ; }
<S2SV_ModStart> psm , 1 , <S2SV_ModStart> psm , 1 , <S2SV_ModStart> psm , 0 ,
<S2SV_ModStart> psm , 0 ,
<S2SV_ModStart> st_mode ) ) { struct stat dsb ; if ( stat ( fn , & dsb ) == 0 && S_ISDIR ( dsb . st_mode ) ) { uid_t fuid ; if ( sb . st_uid == 0 || ( rpmugUid ( rpmfilesFUser ( fi , ix ) , & fuid ) == 0 && sb . st_uid == fuid ) ) { sb = dsb ; } } <S2SV_ModEnd> } if
<S2SV_ModStart> rpmfi fi , const struct stat * fsb <S2SV_ModStart> ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> return 0
<S2SV_ModStart> , fi , & sb
<S2SV_ModStart> sock , "%s" , <S2SV_ModStart> sock , "%s" ,
<S2SV_ModStart> socket , "%s" , <S2SV_ModStart> socket , "%s" ,
<S2SV_ModStart> ) ; id_key_set = rb_intern_const ( "key_set" ) ;
<S2SV_ModStart> ; } if ( p_key ) rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> * name <S2SV_ModEnd> ; name <S2SV_ModStart> NULL , NULL <S2SV_ModEnd> , NULL
<S2SV_ModStart> ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;
<S2SV_ModStart> ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , "key<S2SV_blank>not<S2SV_blank>set" ) ;
<S2SV_ModStart> ) { if ( opt_disable_client_reconnect ) { applog ( LOG_WARNING , "Stratum<S2SV_blank>client.reconnect<S2SV_blank>received<S2SV_blank>but<S2SV_blank>is<S2SV_blank>disabled,<S2SV_blank>not<S2SV_blank>reconnecting." ) ; return false ; } <S2SV_ModEnd> char * <S2SV_ModStart> ] ; char * sockaddr_url , * stratum_port , * tmp ; url = ( char * ) json_string_value ( json_array_get ( val <S2SV_ModEnd> , 0 <S2SV_ModStart> , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; port <S2SV_ModEnd> = ( <S2SV_ModStart> val , <S2SV_ModEnd> 1 ) <S2SV_ModStart> stratum_port ; snprintf ( address , sizeof ( address ) <S2SV_ModEnd> , "%s:%s"
<S2SV_ModStart> ) ) { applog ( LOG_WARNING , "%s:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>header<S2SV_blank>to<S2SV_blank>header_bin,<S2SV_blank>got<S2SV_blank>%s" , __func__ , header ) ; pool_failed ( pool ) ; return false ; } <S2SV_ModEnd> cb1 =
<S2SV_ModStart> if ( n2size < 1 ) <S2SV_ModEnd> { applog
<S2SV_ModStart> , struct manager_ctx * manager , struct <S2SV_ModStart> -> password ) ; if ( server -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , server -> method ) ; else if ( manager -> method ) fprintf ( f , ",\\n\\"method\\":\\"%s\\"" , manager -> method <S2SV_ModStart> server -> <S2SV_ModEnd> plugin )
<S2SV_ModStart> ] ; int i ; int port ; port = atoi ( server -> port ) <S2SV_ModEnd> ; build_config <S2SV_ModStart> working_dir , manager , server ) <S2SV_ModEnd> ; memset <S2SV_ModStart> BUF_SIZE , "%s<S2SV_blank>--manager-address<S2SV_blank>%s<S2SV_blank>-f<S2SV_blank>%s/.shadowsocks_%d.pid<S2SV_blank>-c<S2SV_blank>%s/.shadowsocks_%d.conf" <S2SV_ModEnd> , executable <S2SV_ModStart> executable , <S2SV_ModEnd> manager -> <S2SV_ModStart> working_dir , <S2SV_ModEnd> port , <S2SV_ModStart> working_dir , <S2SV_ModEnd> port )
<S2SV_ModStart> scopeCount ) ; if ( Stream_GetRemainingLength ( s ) / sizeof ( LICENSE_BLOB ) < scopeCount ) return FALSE
<S2SV_ModStart> retval ; int <S2SV_ModEnd> keylen ; <S2SV_ModStart> retval ; int <S2SV_ModEnd> keylen ;
<S2SV_ModStart> if ( keylen >= nodesize - rec_off <S2SV_ModEnd> ) { <S2SV_ModStart> keylen , ( nodesize - rec_off ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> -> tokenpos >= ( <S2SV_ModEnd> p -> <S2SV_ModStart> -> tokenlen - 1 )
<S2SV_ModStart> ) { <S2SV_ModEnd> int o_name_len <S2SV_ModStart> * buf , * buf2 <S2SV_ModEnd> , * <S2SV_ModStart> l ; <S2SV_ModEnd> buf = <S2SV_ModStart> ) ; <S2SV_ModEnd> name_len = <S2SV_ModStart> decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( <S2SV_ModStart> } } buf2 = estrndup <S2SV_ModEnd> ( value <S2SV_ModStart> ( value , value_len ) ; <S2SV_ModEnd> value_len = <S2SV_ModStart> skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return *
<S2SV_ModStart> { char * buf , * buf2 <S2SV_ModEnd> , * <S2SV_ModStart> l ; <S2SV_ModEnd> buf = <S2SV_ModStart> ) ; <S2SV_ModEnd> name_len = <S2SV_ModStart> encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup <S2SV_ModStart> } } buf2 = estrndup <S2SV_ModEnd> ( value <S2SV_ModStart> ( value , value_len ) ; <S2SV_ModEnd> value_len = <S2SV_ModStart> ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url
<S2SV_ModStart> ; int nb_bits = req [ offset + 5 ] ; int <S2SV_ModStart> < nb || nb_bits * 8 < nb <S2SV_ModStart> + 4 ] ; int nb_bytes = req [ offset + 5 <S2SV_ModStart> || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8
<S2SV_ModStart> ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> ) { <S2SV_ModEnd> goto peekout <S2SV_ModStart> ) { if ( buf ) <S2SV_ModStart> memcpy_fromio ( buf <S2SV_ModEnd> , bus <S2SV_ModStart> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) <S2SV_ModEnd> memcpy_fromio ( <S2SV_ModStart> memcpy_fromio ( buf <S2SV_ModEnd> , bus <S2SV_ModStart> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( <S2SV_ModStart> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) <S2SV_ModStart> ; } <S2SV_ModEnd> saa7164_writel (
<S2SV_ModStart> enable ( bool start_restricted <S2SV_ModEnd> ) { <S2SV_ModStart> LOG_INFO ( LOG_TAG , "%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d" <S2SV_ModEnd> , __func__ <S2SV_ModStart> , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> ; if
<S2SV_ModStart> ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ;
<S2SV_ModStart> ) ; if ( ! is_restricted_mode ( ) ) btif_config_remove_restricted ( config ) ;
<S2SV_ModStart> ) ; if ( is_restricted_mode ( ) ) { BTIF_TRACE_WARNING ( "%s:<S2SV_blank>\'%s\'<S2SV_blank>pairing<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed<S2SV_blank>if<S2SV_blank>unrestricted" , __func__ , bdstr ) ; btif_config_set_int ( bdstr , "Restricted" , 1 ) ; }
<S2SV_ModStart> enable ( false
<S2SV_ModStart> enable ( false
<S2SV_ModStart> enable ( false
<S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false <S2SV_ModStart> enable ( false
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL ) <S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 250000 ) <S2SV_ModStart> ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 250000 )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 250000 )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( us_delay )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( us_delay )
<S2SV_ModStart> read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 500 ) <S2SV_ModStart> sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL )
<S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> O_CLOEXEC ) ) <S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> O_CLOEXEC ) )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 50 )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( ev )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> * ev )
<S2SV_ModStart> r = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> addr_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , O_RDONLY ) <S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , FACTORY_BT_BDADDR_STORAGE_LEN )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 100000 )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 200000 )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 200000 )
<S2SV_ModStart> result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> int ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_DONTWAIT ) )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL ) )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_WAITALL ) )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , O_RDWR ) <S2SV_ModStart> err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ) ) <S2SV_ModStart> flags = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> fcntl ( <S2SV_ModStart> O_NONBLOCK ) )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( tETH_HDR )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> . congest_packet ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> IFF_UP ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> & ifr )
<S2SV_ModStart> err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & ifr ) <S2SV_ModStart> err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & ifr ) <S2SV_ModStart> err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ifr ) )
<S2SV_ModStart> ) { TEMP_FAILURE_RETRY ( <S2SV_ModStart> , UI_DEV_DESTROY )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ) )
<S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , O_RDWR ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( dev ) <S2SV_ModStart> ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> EV_KEY ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( <S2SV_ModStart> EV_REL ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModEnd> ioctl ( <S2SV_ModStart> , EV_SYN ) <S2SV_ModStart> ++ ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> mapped_id ) ) ; if ( TEMP_FAILURE_RETRY <S2SV_ModEnd> ( ioctl <S2SV_ModStart> , NULL )
<S2SV_ModStart> || ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & size ) <S2SV_ModStart> count = TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_DONTWAIT ) ) <S2SV_ModStart> drop_it || TEMP_FAILURE_RETRY ( <S2SV_ModStart> size ) )
<S2SV_ModStart> sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT )
<S2SV_ModStart> received = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , size )
<S2SV_ModStart> || ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> size ) ) <S2SV_ModStart> ) ) { <S2SV_ModEnd> BTA_JvRfcommWrite ( <S2SV_ModStart> ) ; } <S2SV_ModStart> need_close || TEMP_FAILURE_RETRY ( <S2SV_ModStart> & size )
<S2SV_ModStart> sent = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT )
<S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & clen )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> } return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL )
<S2SV_ModStart> opts = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , F_GETFL ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , opts )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> - 1 )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_NOSIGNAL )
<S2SV_ModStart> err = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & delay )
<S2SV_ModStart> INVALID_FD ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> , length )
<S2SV_ModStart> logfile_fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | S_IROTH ) <S2SV_ModStart> ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 16 )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> client_socket = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL ) <S2SV_ModStart> client_socket ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , length )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , length )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( 10000 )
<S2SV_ModStart> ) ; int dir_fd = - 1 ; FILE * fp = NULL ; static const <S2SV_ModStart> char * temp_file_ext = ".new" ; const int filename_len = strlen ( filename ) ; const int temp_filename_len = filename_len + strlen ( temp_file_ext ) + 1 ; char * <S2SV_ModStart> osi_calloc ( temp_filename_len ) ; snprintf ( temp_filename , temp_filename_len , "%s%s" , filename , temp_file_ext ) ; char * temp_dirname = osi_strdup ( filename ) ; const char * directoryname = dirname ( temp_dirname <S2SV_ModEnd> ) ; <S2SV_ModStart> ( ! directoryname ) { LOG_ERROR ( "%s<S2SV_blank>error<S2SV_blank>extracting<S2SV_blank>directory<S2SV_blank>from<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , filename , strerror ( errno ) ) ; goto error ; } dir_fd = TEMP_FAILURE_RETRY ( open ( directoryname , O_RDONLY ) ) ; if ( dir_fd < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> fp = <S2SV_ModStart> ) ; if ( <S2SV_ModStart> name ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> for ( <S2SV_ModStart> ) ; if ( <S2SV_ModStart> value ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } <S2SV_ModEnd> } if <S2SV_ModStart> ) ) { if ( <S2SV_ModStart> fp ) == EOF ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>to<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } } } if ( fsync ( fileno ( fp ) ) < 0 ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; } if ( <S2SV_ModEnd> fclose ( <S2SV_ModStart> fp ) == EOF ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>file<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } fp = NULL <S2SV_ModStart> ; } if ( fsync ( dir_fd ) < 0 ) { LOG_WARN ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>fsync<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; } if ( close ( dir_fd ) < 0 ) { LOG_ERROR ( "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>close<S2SV_blank>dir<S2SV_blank>\'%s\':<S2SV_blank>%s" , __func__ , directoryname , strerror ( errno ) ) ; goto error ; } <S2SV_ModStart> ( temp_filename ) ; osi_free ( temp_dirname <S2SV_ModStart> error : <S2SV_ModEnd> unlink ( <S2SV_ModStart> ) ; if ( fp ) fclose ( fp ) ; if ( dir_fd != - 1 ) close ( dir_fd ) ; <S2SV_ModStart> ( temp_filename ) ; osi_free ( temp_dirname
<S2SV_ModStart> 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> timeout ) )
<S2SV_ModStart> bytes_read = TEMP_FAILURE_RETRY ( <S2SV_ModStart> -> buffer_size )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> - 1 )
<S2SV_ModStart> flags = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , F_GETFL ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_NONBLOCK ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , flags )
<S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , NULL )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> & size )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_DONTWAIT ) )
<S2SV_ModStart> ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_DONTWAIT ) )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) ) ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) <S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> . read_poll_tmo_ms ) <S2SV_ModStart> n = TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , msglen )
<S2SV_ModStart> if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) <S2SV_ModStart> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> & len )
<S2SV_ModStart> 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> MSG_WAITALL ) )
<S2SV_ModStart> ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 1 ) <S2SV_ModStart> ; } TEMP_FAILURE_RETRY ( <S2SV_ModStart> UIPC_FLUSH_BUFFER_SIZE ) )
<S2SV_ModStart> result = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL ) )
<S2SV_ModStart> ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> 0 ) )
<S2SV_ModStart> ) { UINT16 buflen = <S2SV_ModEnd> ( UINT16 <S2SV_ModStart> ) ) ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , "28672558" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen
<S2SV_ModStart> == NULL || pin_len > PIN_CODE_LEN
<S2SV_ModStart> ) ; btif_config_write ( <S2SV_ModEnd> ) ;
<S2SV_ModStart> CONFIG_SETTLE_PERIOD_MS , timer_config_save_cb <S2SV_ModEnd> , NULL
<S2SV_ModStart> ; } btif_config_devcache_cleanup ( ) ;
<S2SV_ModStart> namelen - 1 <S2SV_ModEnd> ) ;
<S2SV_ModStart> file [ 1024 <S2SV_ModEnd> ] ; <S2SV_ModStart> maps , "%*x-%*x<S2SV_blank>%*s<S2SV_blank>%zx<S2SV_blank>%5s<S2SV_blank>%ld<S2SV_blank>%1023s\\n" <S2SV_ModEnd> , &
<S2SV_ModStart> ) { if ( numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts ) { return NULL ; } size_t mallocSize = <S2SV_ModEnd> sizeof ( <S2SV_ModStart> ) + ( <S2SV_ModStart> numInts ) ) ; native_handle_t * h = malloc ( mallocSize
<S2SV_ModStart> size_t data_size ; if ( validate_and_calculate_camera_metadata_entry_data_size ( & data_size , <S2SV_ModEnd> entry . <S2SV_ModStart> count ) != OK ) { ALOGE ( "%s:<S2SV_blank>Entry<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>invalid.<S2SV_blank>type:<S2SV_blank>%u<S2SV_blank>count:<S2SV_blank>%u" , __FUNCTION__ , entry . type , entry . count ) ; return ERROR ; } <S2SV_ModEnd> if (
<S2SV_ModStart> == NULL ) return ERROR ; if ( src -> entry_count + dst -> entry_count < src -> entry_count ) return ERROR ; if ( src -> data_count + dst -> data_count < src -> data_count
<S2SV_ModStart> ; } if ( metadata -> data_count > metadata -> data_capacity ) { ALOGE ( "%s:<S2SV_blank>Data<S2SV_blank>count<S2SV_blank>(%" PRIu32 ")<S2SV_blank>should<S2SV_blank>be<S2SV_blank><=<S2SV_blank>data<S2SV_blank>capacity<S2SV_blank>" "(%" PRIu32 ")" , __FUNCTION__ , metadata -> data_count , metadata -> data_capacity ) ; android_errorWriteLog ( SN_EVENT_LOG_ID , "30591838" ) ; return ERROR ; }
<S2SV_ModStart> # endif # ifdef HAVE_MKDTEMP if ( no_rc_dir && tmp_dir != rc_dir ) if ( rmdir ( tmp_dir ) != 0 ) { fprintf ( stderr , "Can\'t<S2SV_blank>remove<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>(%s)!\\n" , tmp_dir ) ; exit ( 1 ) ; } # endif
<S2SV_ModStart> "/tmp" ; # ifdef HAVE_MKDTEMP tmp_dir = mkdtemp ( Strnew_m_charp ( tmp_dir , "/w3m-XXXXXX" , NULL ) -> ptr ) ; if ( tmp_dir == NULL ) tmp_dir = rc_dir ; # endif
<S2SV_ModStart> if ( h_env -> envc == 0 || ( h_env -> envc_real < h_env -> nenv && envs [ h_env -> envc ] . env != HTML_DL && envs [ h_env -> envc ] . env != HTML_DL_COMPACT ) ) { PUSH_ENV ( HTML_DL ) ; } if (
<S2SV_ModStart> , nattr ; tagname [ 0 ] = '\\0'
<S2SV_ModStart> if ( l == NULL ) break ; if (
<S2SV_ModStart> ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; <S2SV_ModStart> INDENT_INCR ; if ( offset < 0 ) offset = 0 ;
<S2SV_ModStart> x -> area_size <S2SV_ModEnd> * 6 <S2SV_ModStart> x -> area_size <S2SV_ModEnd> ) newlen
<S2SV_ModStart> ; } else { matvar -> name [ tmp - 1 ] = '\\0' ; }
<S2SV_ModStart> if ( is_url ( source ) ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>refers<S2SV_blank>to<S2SV_blank>a<S2SV_blank>remote<S2SV_blank>device" ) ; goto error ; } if (
<S2SV_ModStart> # endif char * crypt_password ; <S2SV_ModStart> # endif crypt_password = crypt ( password , user_password ) ; if ( crypt_password == NULL ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; return - 1 ; } <S2SV_ModStart> user_password , crypt_password <S2SV_ModEnd> ) !=
<S2SV_ModStart> ifdef _WIN32 DWORD error ; <S2SV_ModStart> Token ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; <S2SV_ModStart> ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; error = GetLastError ( ) ; if ( error != ERROR_LOGON_FAILURE ) { <S2SV_ModStart> pcap_fmt_errmsg_for_win32_err ( errmsgbuf , PCAP_ERRBUF_SIZE , error , "LogonUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; } return - 1 ; } if ( ImpersonateLoggedOnUser ( Token ) == 0 ) { pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; pcap_fmt_errmsg_for_win32_err ( errmsgbuf <S2SV_ModEnd> , PCAP_ERRBUF_SIZE <S2SV_ModStart> ) , "ImpersonateLoggedOnUser()<S2SV_blank>failed" ) ; rpcapd_log ( LOGPRIO_ERROR , "%s" , errmsgbuf ) ; CloseHandle <S2SV_ModEnd> ( Token <S2SV_ModStart> Token ) ; return - 1 ; } <S2SV_ModEnd> CloseHandle ( <S2SV_ModStart> ; return <S2SV_ModEnd> 0 ; <S2SV_ModStart> # else int error ; <S2SV_ModStart> PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; <S2SV_ModStart> PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; <S2SV_ModStart> # endif errno = 0 ; <S2SV_ModStart> ) { error = errno ; pcap_snprintf ( errbuf , PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" ) ; if ( error == 0 ) { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed" ) ; } else { rpcapd_log ( LOGPRIO_ERROR , "crypt()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) ) ; } <S2SV_ModEnd> return - <S2SV_ModStart> PCAP_ERRBUF_SIZE , "Authentication<S2SV_blank>failed" <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { error = errno ; <S2SV_ModStart> PCAP_ERRBUF_SIZE , error <S2SV_ModEnd> , "setuid" <S2SV_ModStart> ) ; rpcapd_log ( LOGPRIO_ERROR , "setuid()<S2SV_blank>failed:<S2SV_blank>%s" , strerror ( error ) ) ;
<S2SV_ModStart> findalldevs_if ; uint32 replylen ; <S2SV_ModStart> ; } replylen = 0 ; <S2SV_ModStart> description ) replylen <S2SV_ModEnd> += strlen <S2SV_ModStart> name ) replylen <S2SV_ModEnd> += strlen <S2SV_ModStart> ) ; replylen <S2SV_ModEnd> += sizeof <S2SV_ModStart> # endif replylen <S2SV_ModEnd> += ( <S2SV_ModStart> nif , replylen <S2SV_ModEnd> ) ;
<S2SV_ModStart> block_trailer ) || ( total_length > BT_SHB_INSANE_MAX ) <S2SV_ModStart> PCAP_ERRBUF_SIZE , "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%lu_<S2SV_blank><<S2SV_blank>%lu<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof <S2SV_ModStart> block_trailer ) , total_length , BT_SHB_INSANE_MAX <S2SV_ModEnd> ) ;
<S2SV_ModStart> PCAP_ERRBUF_SIZE , "truncated<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file;<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>read<S2SV_blank>%" <S2SV_ModEnd> PRIsize "<S2SV_blank>bytes,<S2SV_blank>only<S2SV_blank>got<S2SV_blank>%"
<S2SV_ModStart> "Section<S2SV_blank>Header<S2SV_blank>Block<S2SV_blank>in<S2SV_blank>pcapng<S2SV_blank>dump<S2SV_blank>file<S2SV_blank>has<S2SV_blank>invalid<S2SV_blank>length<S2SV_blank>%" PRIsize "<S2SV_blank><<S2SV_blank>_%u_<S2SV_blank><<S2SV_blank>%u<S2SV_blank>(BT_SHB_INSANE_MAX)" <S2SV_ModEnd> , sizeof
<S2SV_ModStart> len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" <S2SV_ModEnd> , len
<S2SV_ModStart> ndo , "%s" , tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ) { ND_TCHECK_16BITS ( obj_tptr + offset ) ; <S2SV_ModStart> INT_SWITCHING_TYPE_SUBOBJ : ND_TCHECK_8BITS ( obj_tptr + offset + 2 ) ; <S2SV_ModStart> ) ) ) ; ND_TCHECK_8BITS ( obj_tptr + offset + 3 <S2SV_ModStart> ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_ModStart> WAVELENGTH_SUBOBJ : ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ;
<S2SV_ModStart> 0 ; if ( is_ipv6 ) { <S2SV_ModStart> ( struct olsr_msg6 ) ) ; <S2SV_ModEnd> msgptr . <S2SV_ModStart> else { ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; <S2SV_ModStart> u_int name_entries ; u_int addr_size ; int name_entries_valid ; u_int i ; if ( msg_tlen < 4 ) goto trunc ; ND_TCHECK2 ( * msg_data , 4 ) ; name_entries <S2SV_ModStart> ) ; <S2SV_ModEnd> addr_size = <S2SV_ModStart> 4 ; if ( is_ipv6 ) addr_size = 16 ; <S2SV_ModEnd> name_entries_valid = <S2SV_ModStart> = 0 <S2SV_ModEnd> ; if <S2SV_ModStart> = 1 <S2SV_ModEnd> ; ND_PRINT
<S2SV_ModStart> , * <S2SV_ModEnd> t , <S2SV_ModStart> , c ; const u_char * s <S2SV_ModStart> = ( u_char <S2SV_ModEnd> * ) <S2SV_ModStart> s = <S2SV_ModEnd> p , <S2SV_ModStart> > 0 && ND_TTEST ( * s ) <S2SV_ModStart> ( i <= 1 || ! ND_TTEST ( * s ) ) break ; <S2SV_ModEnd> i -- <S2SV_ModStart> ^ 0x20 <S2SV_ModEnd> ; }
<S2SV_ModStart> DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>?)" ) ) ; break ; }
<S2SV_ModStart> len < 10 <S2SV_ModEnd> ) ND_PRINT
<S2SV_ModStart> ( * TPA <S2SV_ModEnd> ( ap <S2SV_ModStart> ndo , "who-has<S2SV_blank>" ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ARPOP_REPLY : spaddr_print_ip ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>%s" <S2SV_ModEnd> , linkaddr_string <S2SV_ModStart> ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string <S2SV_ModStart> ) ) ) ) ; tpaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ndo , "%s<S2SV_blank>at<S2SV_blank>" <S2SV_ModEnd> , linkaddr_string <S2SV_ModStart> ) ) ) ) ; spaddr_print_ip ( ndo , ap , pro <S2SV_ModEnd> ) ;
<S2SV_ModStart> ndo , "who-has<S2SV_blank>" ) ) ; atmarp_tpaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ndo , "<S2SV_blank>tell<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ARPOP_REPLY : atmarp_spaddr_print ( ndo , ap , pro ) ; ND_PRINT ( ( ndo , "<S2SV_blank>is-at<S2SV_blank>" <S2SV_ModEnd> ) ) <S2SV_ModStart> ndo , "at<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ; <S2SV_ModStart> ndo , "for<S2SV_blank>" ) ) ; atmarp_spaddr_print ( ndo , ap , pro <S2SV_ModEnd> ) ;
<S2SV_ModStart> if ( tlen == BGP_VPN_RD_LEN + 4 + sizeof ( struct in_addr ) && <S2SV_ModStart> if ( tlen == BGP_VPN_RD_LEN + 3 + sizeof ( struct in6_addr ) &&
<S2SV_ModStart> er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ <S2SV_ModStart> ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>c<S2SV_blank>%04x" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ;
<S2SV_ModStart> dp [ 4 <S2SV_ModEnd> ] ) <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "<S2SV_blank><%s>" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 3 ] <S2SV_ModEnd> ) )
<S2SV_ModStart> ) ; ND_TCHECK <S2SV_ModEnd> ( dp <S2SV_ModStart> 0 ] <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) { ND_TCHECK_16BITS ( & dp -> icmp_cksum ) ;
<S2SV_ModStart> 3 ) goto trunc ; <S2SV_ModEnd> if ( <S2SV_ModStart> 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , "Tag[%u]<S2SV_blank>" , * data ) ) ; else ND_PRINT ( ( ndo , "Tag[Unused]<S2SV_blank>" ) ) ; data ++ ; length -- <S2SV_ModEnd> ; } <S2SV_ModStart> ; } <S2SV_ModEnd> break ; <S2SV_ModStart> EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> 0 ; i < length && * data <S2SV_ModEnd> ; i
<S2SV_ModStart> - 1 <S2SV_ModEnd> ) ;
<S2SV_ModStart> - 1 <S2SV_ModEnd> ) ; <S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> - 1 <S2SV_ModEnd> ) ;
<S2SV_ModStart> + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> - p <S2SV_ModEnd> , NULL
<S2SV_ModStart> , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> - bp <S2SV_ModEnd> , NULL
<S2SV_ModStart> u_int length <S2SV_ModEnd> ) { <S2SV_ModStart> if ( ! ND_TTEST ( * p ) <S2SV_ModEnd> ) { <S2SV_ModStart> "\\n\\t" , length <S2SV_ModEnd> ) ; <S2SV_ModStart> "\\n\\t" , length <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( length <S2SV_ModEnd> > 1 <S2SV_ModStart> "\\n\\t" , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> optlen == 6 <S2SV_ModEnd> ) ND_PRINT <S2SV_ModStart> ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6]" <S2SV_ModEnd> ) ) <S2SV_ModStart> 42 : switch ( optlen ) { case 6 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; break ; case 8 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)" , EXTRACT_16BITS ( option + 6 ) ) ) ; break ; case 10 : ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>(elapsed<S2SV_blank>time<S2SV_blank>%u)" , EXTRACT_32BITS ( option + 6 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>6<S2SV_blank>or<S2SV_blank>8<S2SV_blank>or<S2SV_blank>10]" ) ) ; break ; } break ; case 43 : if ( optlen == 6 ) ND_PRINT ( ( ndo , "<S2SV_blank>%u" , EXTRACT_32BITS ( option + 2 ) ) ) ; else <S2SV_ModStart> "<S2SV_blank>%u" , EXTRACT_16BITS <S2SV_ModEnd> ( option <S2SV_ModStart> ndo , "<S2SV_blank>[optlen<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>or<S2SV_blank>6]" <S2SV_ModEnd> ) )
<S2SV_ModStart> ++ ; if ( depth == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else
<S2SV_ModStart> ; } if ( ! ND_TTEST2 ( * bp , 2 ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>[|OPT]" ) ) ; return ; }
<S2SV_ModStart> ) { if ( total_subobj_len < 4 ) goto invalid ; <S2SV_ModStart> ( subobj_len < 4 || subobj_len > total_subobj_len <S2SV_ModEnd> ) goto
<S2SV_ModStart> ) ; ND_TCHECK ( bp -> bp_flags ) ;
<S2SV_ModStart> -> icmp_length && ND_TTEST2 ( ext_dp -> icmp_ext_version_res , plen - ICMP_EXTD_MINLEN ) <S2SV_ModStart> ICMP_EXTD_MINLEN ; if ( ND_TTEST2 ( ext_dp -> icmp_ext_version_res , hlen ) ) { <S2SV_ModStart> ) ; }
<S2SV_ModStart> IPOPT_TS : if ( ip_printts <S2SV_ModEnd> ( ndo <S2SV_ModStart> ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; case
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> ip_printts ( <S2SV_ModStart> ; return ( 0 ) <S2SV_ModStart> ) ; ND_TCHECK ( cp [ 2 ] ) ; <S2SV_ModStart> ) ; ND_TCHECK ( cp [ 3 ] ) ; <S2SV_ModStart> = "<S2SV_blank>^<S2SV_blank>" ; ND_TCHECK2 ( cp [ len ] , hoplen ) <S2SV_ModStart> ) ; return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> ND_TCHECK ( * dp <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( * tptr <S2SV_ModEnd> ) ; <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , "[|esis]" ) ) <S2SV_ModEnd> ; }
<S2SV_ModStart> tval ; u_int <S2SV_ModEnd> i ; <S2SV_ModStart> ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>RES:<S2SV_blank>%u,<S2SV_blank>Sel:<S2SV_blank>%u,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%u" <S2SV_ModEnd> , tval <S2SV_ModStart> 0x07 ) , <S2SV_ModEnd> EXTRACT_16BITS (
<S2SV_ModStart> ) { if ( i + 4 > length ) return - 1 ; <S2SV_ModStart> ) ) ; if ( i + 4 + optlen > length ) return - 1
<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( cp ) ;
<S2SV_ModStart> ; int <S2SV_ModEnd> elt ; <S2SV_ModStart> elt ; u_int offset , max_offset ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; max_offset = ( u_int ) ( cp - bp ) ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < <S2SV_ModEnd> ndo -> <S2SV_ModStart> -> ndo_snapend ) { if ( ( i & INDIR_MASK <S2SV_ModEnd> ) == <S2SV_ModStart> ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; offset = ( ( ( i << 8 ) | * cp <S2SV_ModEnd> ) & <S2SV_ModStart> ) & 0x3fff ) ; if ( offset >= max_offset ) { ND_PRINT ( ( ndo , "<BAD<S2SV_blank>PTR>" ) ) ; return ( NULL ) ; } max_offset = offset ; cp = bp + offset ; if ( ( l = labellen ( ndo , cp ) <S2SV_ModEnd> ) == <S2SV_ModStart> ) == ( u_int ) - 1 ) return ( NULL ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ) ; <S2SV_ModEnd> i = <S2SV_ModStart> ++ ; <S2SV_ModEnd> continue ; <S2SV_ModStart> l ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ++ ; <S2SV_ModEnd> if (
<S2SV_ModStart> ) { ND_TCHECK2 ( * tptr , alen ) ;
<S2SV_ModStart> vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; <S2SV_ModStart> vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> ) ; if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
<S2SV_ModStart> bp ; ep = ndo -> ndo_snapend ; ND_TCHECK ( dp -> ip6r_segleft ) ; <S2SV_ModStart> -> ip6r_len <S2SV_ModEnd> ; ND_PRINT
<S2SV_ModStart> obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> ) ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
<S2SV_ModStart> ) ) { ND_TCHECK_16BITS ( & bp [ 6 ] ) ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> if ( <S2SV_ModEnd> ND_TTEST2 (
<S2SV_ModStart> 0 && <S2SV_ModEnd> ND_TTEST ( <S2SV_ModStart> ie && <S2SV_ModEnd> ND_TTEST (
<S2SV_ModStart> ) ; ND_TCHECK_16BITS ( p + l2info -> cookie_len ) ;
<S2SV_ModStart> ) { if ( caplen < hdrlen + 1 ) { ND_PRINT ( ( ndo , "%s" , tstr ) ) ; return hdrlen ; }
<S2SV_ModStart> 12 && ( <S2SV_ModStart> & TH_SYN )
<S2SV_ModStart> if ( opt_len < 4 ) return 0 ; if ( <S2SV_ModEnd> flags & <S2SV_ModStart> 4 ; opt_len -= 4 ; <S2SV_ModStart> ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> 8 ; opt_len -= 8 ; <S2SV_ModStart> else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> 4 ; opt_len -= 4 ; <S2SV_ModStart> ) { if ( opt_len < 8 ) return 0 ; <S2SV_ModStart> 8 ; opt_len -= 8 ; <S2SV_ModStart> else { if ( opt_len < 4 ) return 0 ; <S2SV_ModStart> 4 ; opt_len -= 4 ; } if ( opt_len < 4 ) return 0 ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> 4 ; opt_len -= 4 ; if ( opt_len < 2 ) return 0 ; <S2SV_ModStart> 2 ; opt_len -= 2 ; if ( opt_len >= 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>csum<S2SV_blank>0x%x" , EXTRACT_16BITS ( opt ) ) ) ; opt_len -= 2 ; } } if ( opt_len != 0 ) return 0 ; return 1 <S2SV_ModEnd> ; }
<S2SV_ModStart> 12 && ( <S2SV_ModStart> TH_SYN ) ) <S2SV_ModStart> 24 && ( <S2SV_ModStart> & TH_ACK )
<S2SV_ModStart> ) ) ) ; ND_TCHECK ( tptr [ 1 ]
<S2SV_ModStart> ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> i <= sysid_len <S2SV_ModEnd> ; i
<S2SV_ModStart> ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ) { <S2SV_ModEnd> bw .
<S2SV_ModStart> * tptr , const u_int length ) { u_int network_addr_type ; u_int <S2SV_ModEnd> hexdump = <S2SV_ModStart> FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Network<S2SV_blank>Address<S2SV_blank>Type<S2SV_blank>(invalid,<S2SV_blank>no<S2SV_blank>data" ) ) ; return hexdump ; } <S2SV_ModStart> AFNUM_INET : if ( length != 1 + 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv4<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> AFNUM_INET6 : if ( length != 1 + 16 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>IPv6<S2SV_blank>address<S2SV_blank>length<S2SV_blank>%u)" , length - 1 ) ) ; hexdump = TRUE ; break ; }
<S2SV_ModStart> ) ; goto next_tlv <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto next_tlv <S2SV_ModEnd> ; } <S2SV_ModStart> ) ; goto next_tlv <S2SV_ModEnd> ; } <S2SV_ModStart> CFM_CHASSIS_ID_MAC_ADDRESS : if ( chassis_id_length != ETHER_ADDR_LEN ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>MAC<S2SV_blank>address<S2SV_blank>length)" ) ) ; hexdump = TRUE ; break ; } <S2SV_ModStart> , tptr + 1 , chassis_id_length <S2SV_ModStart> ) { break <S2SV_ModEnd> ; } <S2SV_ModStart> -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> ) ; goto next_tlv <S2SV_ModEnd> ; } <S2SV_ModStart> -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Domain:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> ndo , "<S2SV_blank>(Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>is<S2SV_blank>missing)" ) ) ; hexdump = TRUE ; break <S2SV_ModEnd> ; } <S2SV_ModStart> -- ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address<S2SV_blank>Length<S2SV_blank>%u" , mgmt_addr_length ) ) ; <S2SV_ModStart> -= mgmt_addr_length ; hex_print ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>Management<S2SV_blank>Address:<S2SV_blank>" , tptr , mgmt_addr_length ) <S2SV_ModStart> ) ; next_tlv :
<S2SV_ModStart> 0 ; <S2SV_ModEnd> memcpy ( <S2SV_ModStart> 0 ; <S2SV_ModEnd> memcpy ( <S2SV_ModStart> 0 ; <S2SV_ModEnd> memcpy ( <S2SV_ModStart> + offset <S2SV_ModEnd> , tim
<S2SV_ModStart> ) { if ( len < ( u_int ) advance ) goto trunc ; <S2SV_ModStart> ) ; if ( advance < 0 ) return ; <S2SV_ModStart> IPPROTO_ROUTING : ND_TCHECK ( * cp ) ; <S2SV_ModStart> ) ; if ( advance < 0 ) return ; <S2SV_ModStart> cp ) ; if ( advance < 0 ) return <S2SV_ModStart> ) ; if ( advance < 0 ) return ;
<S2SV_ModStart> return ( - 1 <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; ND_TCHECK <S2SV_ModEnd> ( dp <S2SV_ModStart> 1 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ] & 0xc0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" <S2SV_ModEnd> ) ) <S2SV_ModStart> ] & 0x80 ) ND_PRINT ( ( ndo , "M" ) ) ; if ( dp -> icmp6_data16 [ 1 ] &
<S2SV_ModStart> 1 ; ND_TCHECK2 ( * s , 1 ) ;
<S2SV_ModStart> PIMV2_HELLO_OPTION_HOLDTIME : if ( olen != 2 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>2<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ; } <S2SV_ModStart> PIMV2_HELLO_OPTION_GENID : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ; } <S2SV_ModStart> PIMV2_HELLO_OPTION_REFRESH_CAP : if ( olen != 4 ) { ND_PRINT ( ( ndo , "ERROR:<S2SV_blank>Option<S2SV_blank>Length<S2SV_blank>!=<S2SV_blank>4<S2SV_blank>Bytes<S2SV_blank>(%u)" , olen ) ) ; } else { <S2SV_ModStart> ) ; }
<S2SV_ModStart> ; } ND_TCHECK_32BITS <S2SV_ModEnd> ( p <S2SV_ModStart> + 2 <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ;
<S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 )
<S2SV_ModStart> ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) <S2SV_ModStart> ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) <S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) <S2SV_ModStart> ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) <S2SV_ModStart> ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 )
<S2SV_ModStart> register struct bsnamemem <S2SV_ModEnd> * tp <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> ) return <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> ) ; <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> = strdup <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> == NULL <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> ) ;
<S2SV_ModStart> register struct bsnamemem <S2SV_ModEnd> * tp <S2SV_ModStart> tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> == NULL <S2SV_ModStart> tp -> bs_name <S2SV_ModEnd> ) ;
<S2SV_ModStart> inline struct bsnamemem <S2SV_ModEnd> * lookup_bytestring <S2SV_ModStart> { struct bsnamemem <S2SV_ModEnd> * tp <S2SV_ModStart> tp -> bs_nxt ) if ( nlen == tp -> bs_nbytes <S2SV_ModEnd> && tp <S2SV_ModStart> tp -> bs_addr0 == i <S2SV_ModEnd> && tp <S2SV_ModStart> tp -> bs_addr1 == j && tp -> bs_addr2 <S2SV_ModEnd> == k <S2SV_ModStart> tp -> bs_bytes <S2SV_ModEnd> ) , <S2SV_ModStart> tp -> bs_nxt ; tp -> bs_addr0 = i ; tp -> bs_addr1 = j ; tp -> bs_addr2 = k ; tp -> bs_bytes <S2SV_ModEnd> = ( <S2SV_ModStart> tp -> bs_bytes <S2SV_ModEnd> == NULL <S2SV_ModStart> tp -> bs_bytes , bs , nlen ) ; tp -> bs_nbytes = nlen ; tp -> bs_nxt <S2SV_ModEnd> = ( <S2SV_ModStart> ( struct bsnamemem <S2SV_ModEnd> * ) <S2SV_ModStart> tp -> bs_nxt <S2SV_ModEnd> == NULL
<S2SV_ModStart> ) ; if ( length < 2 ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; } if ( ! ND_TTEST_16BITS ( p ) ) { ND_PRINT ( ( ndo , "[|mlppp]" ) ) ; return ; }
<S2SV_ModStart> ) { <S2SV_ModEnd> char temp <S2SV_ModStart> ] ; u_int stringlen ; stringlen = len ; if ( stringlen > NFSX_V3FHMAX ) stringlen = NFSX_V3FHMAX ; <S2SV_ModStart> sfsname , stringlen <S2SV_ModEnd> ) ; <S2SV_ModStart> temp [ stringlen <S2SV_ModEnd> ] =
<S2SV_ModStart> ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
<S2SV_ModStart> ) ; if ( plenbytes < 0 ) return plenbytes ;
<S2SV_ModStart> <S2SV_null> static u_int <S2SV_ModEnd> rpki_rtr_pdu_print ( <S2SV_ModStart> tptr , const u_int len , const u_char recurse , const <S2SV_ModStart> msg ; ND_TCHECK_8BITS ( tptr ) ; if ( * tptr != 0 ) { ND_PRINT ( ( ndo , "%sRPKI-RTRv%u<S2SV_blank>(unknown)" , indent_string ( 8 ) , * tptr ) ) ; return len ; } if ( len < sizeof ( rpki_rtr_pdu ) ) { ND_PRINT ( ( ndo , "(%u<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>few<S2SV_blank>to<S2SV_blank>decode)" , len ) ) ; goto invalid ; } ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; <S2SV_ModStart> ) ; <S2SV_ModEnd> hexdump = <S2SV_ModStart> ) ) ; if ( pdu_len < sizeof ( rpki_rtr_pdu ) || pdu_len > len ) goto invalid <S2SV_ModStart> RPKI_RTR_END_OF_DATA_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> RPKI_RTR_CACHE_RESET_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> RPKI_RTR_CACHE_RESPONSE_PDU : if ( pdu_len != sizeof ( rpki_rtr_pdu ) ) goto invalid ; <S2SV_ModStart> pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 12 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> pdu ; if ( pdu_len != sizeof ( rpki_rtr_pdu ) + 24 ) goto invalid ; ND_TCHECK2 ( * tptr , pdu_len ) ; <S2SV_ModStart> error_code ; tlen = sizeof ( rpki_rtr_pdu ) ; if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) ; <S2SV_ModStart> ) ; tlen += 4 <S2SV_ModEnd> ; error_code <S2SV_ModStart> ) ; <S2SV_ModEnd> if ( <S2SV_ModStart> ( encapsulated_pdu_length ) { if ( pdu_len < tlen + encapsulated_pdu_length ) goto invalid ; if ( ! recurse ) { ND_TCHECK2 ( * tptr , tlen + encapsulated_pdu_length ) ; } else <S2SV_ModEnd> { ND_PRINT <S2SV_ModStart> ) ; <S2SV_ModEnd> rpki_rtr_pdu_print ( <S2SV_ModStart> , tptr + tlen , encapsulated_pdu_length , 0 <S2SV_ModStart> 2 ) ; } tlen <S2SV_ModEnd> += encapsulated_pdu_length <S2SV_ModStart> encapsulated_pdu_length ; } if ( pdu_len < tlen + 4 ) goto invalid ; ND_TCHECK2 ( * tptr , tlen + 4 ) <S2SV_ModEnd> ; text_length <S2SV_ModStart> text_length = <S2SV_ModEnd> EXTRACT_32BITS ( <S2SV_ModStart> ( tptr + tlen ) ; tlen <S2SV_ModEnd> += 4 <S2SV_ModStart> 4 ; if ( text_length ) { if ( pdu_len < tlen + text_length ) goto invalid ; ND_PRINT ( ( ndo , "%sError<S2SV_blank>text:<S2SV_blank>" , indent_string ( indent + 2 ) ) ) ; if ( fn_printn ( ndo , tptr + tlen , text_length , ndo -> ndo_snapend ) ) goto trunc ; } } break ; default : <S2SV_ModEnd> ND_TCHECK2 ( <S2SV_ModStart> tptr , pdu_len ) ; <S2SV_ModEnd> hexdump = <S2SV_ModStart> } return pdu_len ; invalid : ND_PRINT ( ( ndo , "%s" , istr ) ) ; ND_TCHECK2 ( * tptr , len ) ; return len <S2SV_ModEnd> ; trunc <S2SV_ModStart> trunc : ND_PRINT ( ( ndo , "\\n\\t%s" , tstr ) ) ; return len <S2SV_ModEnd> ; }
<S2SV_ModStart> ) { <S2SV_ModEnd> if ( <S2SV_ModStart> while ( len <S2SV_ModEnd> ) { <S2SV_ModStart> ) { u_int <S2SV_ModEnd> pdu_len = <S2SV_ModStart> pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( <S2SV_ModStart> ndo , pptr , len , 1 <S2SV_ModEnd> , 8 <S2SV_ModStart> 8 ) ; len <S2SV_ModEnd> -= pdu_len <S2SV_ModStart> pdu_len ; pptr <S2SV_ModEnd> += pdu_len <S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> -> ndo_snapend ; ND_TCHECK_16BITS ( & ip -> ip_len )
<S2SV_ModStart> ( p <S2SV_ModEnd> ) )
<S2SV_ModStart> BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;
<S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo , <S2SV_ModStart> l_strnstart ( ndo ,
<S2SV_ModStart> l_strnstart ( netdissect_options * ndo , <S2SV_ModStart> ) { if ( ! ND_TTEST2 ( * str2 , tl1 ) ) { return 0 ; }
<S2SV_ModStart> + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options
<S2SV_ModStart> ; } ND_TCHECK ( * p ) ;
<S2SV_ModStart> ) { const struct ikev2_id * idp ; <S2SV_ModStart> typedata ; idp = ( const struct ikev2_id * ) ext ; <S2SV_ModStart> ( * idp <S2SV_ModEnd> ) ;
<S2SV_ModStart> len ; ND_TCHECK2 ( * ext , sizeof ( a ) <S2SV_ModEnd> ) ;
<S2SV_ModStart> ( * k <S2SV_ModEnd> ) ;
<S2SV_ModStart> ) ; # define MAILSLOT_BROWSE_STR "\\\\MAILSLOT\\\\BROWSE" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( MAILSLOT_BROWSE_STR ) + 1 ) ; <S2SV_ModStart> ) , MAILSLOT_BROWSE_STR <S2SV_ModEnd> ) == <S2SV_ModStart> ; } # undef MAILSLOT_BROWSE_STR # define PIPE_LANMAN_STR "\\\\PIPE\\\\LANMAN" ND_TCHECK2 ( * ( data1 + 2 ) , strlen ( PIPE_LANMAN_STR ) + 1 ) ; <S2SV_ModStart> ) , PIPE_LANMAN_STR <S2SV_ModEnd> ) == <S2SV_ModStart> ; } # undef PIPE_LANMAN_STR
<S2SV_ModStart> tptr , 2 <S2SV_ModEnd> ) )
<S2SV_ModStart> EAP_FRAME_TYPE_PACKET : ND_TCHECK_8BITS ( tptr ) ; <S2SV_ModStart> ( tptr ) ; ND_TCHECK_16BITS ( tptr + 2 <S2SV_ModStart> ) { ND_TCHECK_8BITS ( tptr + 4 ) ; <S2SV_ModStart> "unknown" , subtype ) , subtype <S2SV_ModEnd> ) ) <S2SV_ModStart> ) { ND_TCHECK_8BITS ( tptr + count ) ; <S2SV_ModStart> EAP_TYPE_TTLS : case EAP_TYPE_TLS : ND_TCHECK_8BITS ( tptr + 5 ) ; if ( subtype == EAP_TYPE_TTLS ) <S2SV_ModStart> ) ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> EAP_TYPE_FAST : ND_TCHECK_8BITS ( tptr + 5 ) ; <S2SV_ModStart> ) { ND_TCHECK_32BITS ( tptr + 6 ) ; <S2SV_ModStart> EAP_TYPE_SIM : ND_TCHECK_8BITS ( tptr + 5 ) ;
<S2SV_ModStart> p + offset + 3 , <S2SV_ModEnd> tim . <S2SV_ModStart> 3 ) ; offset += <S2SV_ModEnd> tim . <S2SV_ModStart> - 3 ; length -= <S2SV_ModEnd> tim . <S2SV_ModStart> 3 ; <S2SV_ModEnd> if (
<S2SV_ModStart> * ret ; size_t len <S2SV_ModStart> NULL ; len = <S2SV_ModEnd> strlen ( <S2SV_ModStart> ptr ) ; if ( len > 0 && ptr [ len <S2SV_ModStart> ptr [ len <S2SV_ModEnd> - 1
<S2SV_ModStart> caplen ; u_int <S2SV_ModEnd> hdrlen ; <S2SV_ModStart> seq ; <S2SV_ModEnd> uint16_t panid <S2SV_ModStart> 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; <S2SV_ModStart> switch ( FC_DEST_ADDRESSING_MODE <S2SV_ModStart> ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return hdrlen <S2SV_ModEnd> ; case <S2SV_ModStart> ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = <S2SV_ModStart> 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 <S2SV_ModStart> ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = <S2SV_ModStart> 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> , p + 2 <S2SV_ModStart> 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> switch ( FC_SRC_ADDRESSING_MODE <S2SV_ModStart> ( fc ) <S2SV_ModEnd> ) { <S2SV_ModStart> { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if <S2SV_ModStart> fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = <S2SV_ModStart> 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if <S2SV_ModStart> fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = <S2SV_ModStart> 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , "[|802.15.4]" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; return hdrlen <S2SV_ModEnd> ; }
<S2SV_ModStart> buf [ 1024 + 1 <S2SV_ModEnd> ] ; <S2SV_ModStart> ] ; char * bufp = buf ; size_t space_left = sizeof ( buf ) , string_size <S2SV_ModEnd> ; register <S2SV_ModStart> ) { if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp , sepstr , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size ; if ( space_left <= 1 ) return ( buf ) ; string_size = strlcpy ( bufp <S2SV_ModEnd> , lp <S2SV_ModStart> -> s , space_left ) ; if ( string_size >= space_left ) return ( buf ) ; bufp += string_size ; space_left -= string_size <S2SV_ModEnd> ; sepstr <S2SV_ModStart> if ( bufp == buf <S2SV_ModEnd> ) (
<S2SV_ModStart> ) { return <S2SV_ModEnd> chdlc_print ( <S2SV_ModStart> p , h -> len <S2SV_ModEnd> ) ;
<S2SV_ModStart> proto ; const u_char * bp = p ; if ( length < CHDLC_HDRLEN ) goto trunc ; ND_TCHECK2 ( * p , CHDLC_HDRLEN ) ; <S2SV_ModStart> if ( length < 2 ) goto trunc ; ND_TCHECK_16BITS ( p ) ; if ( <S2SV_ModStart> ) ; trunc : ND_PRINT ( ( ndo , "[|chdlc]" ) ) ; return ndo -> ndo_snapend - bp ;
<S2SV_ModStart> tlen < 1U +
<S2SV_ModStart> , p <S2SV_ModEnd> ) )
<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( bp ) ;
<S2SV_ModStart> MFR_CTRL_IE_MAGIC_NUM : if ( ie_len != 4 ) { ND_PRINT ( ( ndo , "(invalid<S2SV_blank>length)" ) ) ; break ; }
<S2SV_ModStart> ndo , "%s" , tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> TLV_TCHECK ( 12 <S2SV_ModEnd> ) ; <S2SV_ModStart> ndo , "%s" , tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> tptr ; if ( len < VTP_VLAN_INFO_FIXED_PART_LEN ) goto trunc ; <S2SV_ModStart> ) ; len -= VTP_VLAN_INFO_FIXED_PART_LEN ; tptr += VTP_VLAN_INFO_FIXED_PART_LEN ; if ( len < 4 * ( ( <S2SV_ModEnd> vtp_vlan -> <S2SV_ModStart> -> name_len + 3 ) / 4 ) ) goto trunc ; ND_TCHECK2 ( * tptr , <S2SV_ModEnd> vtp_vlan -> <S2SV_ModStart> -> name_len ) ; fn_printzp ( ndo , tptr , <S2SV_ModEnd> vtp_vlan -> <S2SV_ModStart> -> name_len , NULL ) ; len -= 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += 4 * ( ( vtp_vlan -> name_len <S2SV_ModStart> ) { if ( len < 2 ) goto trunc ; ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> if ( len < tlv_len * 2 + 2 <S2SV_ModEnd> ) { <S2SV_ModStart> ) { ND_PRINT ( ( ndo , "<S2SV_blank>(TLV<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>packet)" ) ) ; <S2SV_ModStart> ) ; if ( tlv_len != 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(invalid<S2SV_blank>TLV<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>1)" , tlv_len ) ) ; return ; } else { <S2SV_ModStart> ; } }
<S2SV_ModStart> u_int len , const unsigned attr_set_level <S2SV_ModStart> if ( attr_set_level == 10 ) ND_PRINT ( ( ndo , "(too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>levels,<S2SV_blank>not<S2SV_blank>recursing)" ) ) ; else if ( <S2SV_ModStart> , alen , attr_set_level + 1
<S2SV_ModStart> , alen , 0
<S2SV_ModStart> ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < <S2SV_ModEnd> ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc <S2SV_ModStart> ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ; <S2SV_ModStart> ) { if ( stlv_len < <S2SV_ModEnd> ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ) goto trunc <S2SV_ModStart> = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN ; stlv_len = stlv_len <S2SV_ModStart> ISIS_SUBTLV_SPBM_SI : if ( stlv_len < <S2SV_ModEnd> 8 ) <S2SV_ModStart> 8 ) goto trunc <S2SV_ModStart> ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> : { if ( stlv_len < <S2SV_ModEnd> ISIS_SUBTLV_SPB_MCID_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModStart> tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> ; break <S2SV_ModStart> : { if ( stlv_len < <S2SV_ModEnd> ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> : { <S2SV_ModEnd> while ( <S2SV_ModStart> while ( stlv_len <S2SV_ModEnd> >= ISIS_SUBTLV_SPB_BVID_MIN_LEN <S2SV_ModStart> ) { <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> ; } tptr += stlv_len ; len -= stlv_len ;
<S2SV_ModStart> ; } if ( ! ND_TTEST ( rp -> rm_call . cb_proc ) ) return ( 0 ) ; <S2SV_ModStart> . cb_proc ) ; if ( ! ND_TTEST ( rp -> rm_call . cb_vers ) ) return ( 0
<S2SV_ModStart> header_len ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;
<S2SV_ModStart> ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ;
<S2SV_ModStart> plen ; char asbuf [ sizeof ( astostr ) ] ; <S2SV_ModStart> 1 ; ND_TCHECK_32BITS ( pptr + 1 ) ; as_printf ( ndo , asbuf , sizeof ( asbuf ) , EXTRACT_32BITS ( pptr + 1 ) ) ; <S2SV_ModStart> pptr [ 5 <S2SV_ModEnd> ] , <S2SV_ModStart> pptr [ 5 <S2SV_ModEnd> ] , <S2SV_ModStart> "origin<S2SV_blank>AS:<S2SV_blank>%s,<S2SV_blank>route<S2SV_blank>target<S2SV_blank>%s" , asbuf <S2SV_ModEnd> , bgp_vpn_rd_print
<S2SV_ModStart> RSVP_CTYPE_1 : ND_TCHECK_32BITS ( obj_tptr ) ;
<S2SV_ModStart> if ( snpal == 6 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , etheraddr_string ( ndo , snpa ) ) ) ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>SNPA<S2SV_blank>(length:<S2SV_blank>%u):<S2SV_blank>%s" , snpal , linkaddr_string ( ndo , snpa , LINKADDR_OTHER , snpal ) ) ) ; if ( netal != <S2SV_ModEnd> 0 ) <S2SV_ModStart> ndo , "\\n\\t<S2SV_blank><S2SV_blank>NET<S2SV_blank>(length:<S2SV_blank>%u)<S2SV_blank>%s" , netal , <S2SV_ModEnd> isonsap_string (
<S2SV_ModStart> serviceId == EXTRACT_16BITS <S2SV_ModEnd> ( &
<S2SV_ModStart> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( &
<S2SV_ModStart> uint32_t phase _U_ <S2SV_ModStart> int depth _U_ <S2SV_ModStart> ) { <S2SV_ModEnd> switch ( <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>attrs=(" ) <S2SV_ModStart> ; } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , "<S2SV_blank>status=(" ) ) ; <S2SV_ModStart> ) ; ND_PRINT ( ( ndo , ")" ) ) <S2SV_ModEnd> ; break <S2SV_ModStart> default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>data=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; }
<S2SV_ModStart> ndo , "<S2SV_blank>n<S2SV_blank>len=%u" <S2SV_ModEnd> , ntohs <S2SV_ModStart> if ( ntohs ( e . len ) > 4 ) { if ( <S2SV_ModEnd> ndo -> <S2SV_ModStart> -> ndo_vflag > 2 <S2SV_ModEnd> ) { <S2SV_ModStart> if ( <S2SV_ModEnd> ndo -> <S2SV_ModStart> -> ndo_vflag > 1 <S2SV_ModEnd> ) { <S2SV_ModStart> ) ( <S2SV_ModEnd> ext + <S2SV_ModStart> ; } }
<S2SV_ModStart> ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" <S2SV_ModEnd> , len <S2SV_ModStart> if ( len > 4 ) { if ( <S2SV_ModEnd> ndo -> <S2SV_ModStart> -> ndo_vflag > 1 <S2SV_ModEnd> ) { <S2SV_ModStart> -> ndo_vflag <S2SV_ModEnd> ) { <S2SV_ModStart> ; } }
<S2SV_ModStart> u_char showspi <S2SV_ModEnd> , showsomedata <S2SV_ModStart> 1 ; <S2SV_ModEnd> showsomedata = <S2SV_ModStart> = 1 <S2SV_ModEnd> ; break <S2SV_ModStart> if ( cp < ep ) { if ( <S2SV_ModEnd> ndo -> <S2SV_ModStart> -> ndo_vflag > 3 <S2SV_ModEnd> || ( <S2SV_ModStart> ) ) <S2SV_ModEnd> { ND_PRINT <S2SV_ModStart> ( showsomedata <S2SV_ModEnd> ) { <S2SV_ModStart> trunc ; }
<S2SV_ModStart> ) { if ( i + 2 > length ) return - 1 ; <S2SV_ModStart> ) ) ; if ( i + 2 + optlen > length ) return - 1
<S2SV_ModStart> VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) { ND_TCHECK_8BITS ( tptr ) ;
<S2SV_ModStart> ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
<S2SV_ModStart> * ah ; ND_TCHECK ( * ep ) <S2SV_ModStart> trunc ; if ( ep -> length < 4 ) { ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>length<S2SV_blank>%u" , ep -> length ) ) ; break ; }
<S2SV_ModStart> prep ) || ! ND_TTEST ( * prep ) ) <S2SV_ModEnd> return ( <S2SV_ModStart> ) ; <S2SV_ModEnd> n =
<S2SV_ModStart> return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> return ; ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , "%s" , tstr ) )
<S2SV_ModStart> flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; <S2SV_ModStart> = len <S2SV_ModEnd> ; ND_PRINT
<S2SV_ModStart> * len , int * truncated <S2SV_ModStart> s ; <S2SV_ModEnd> s = <S2SV_ModStart> pptr ; for ( ; ; ) { if <S2SV_ModEnd> ( * <S2SV_ModStart> ( * len == 0 ) { return NULL ; } if ( ! ND_TTEST ( <S2SV_ModEnd> * * <S2SV_ModStart> pptr ) ) { * truncated = 1 ; return NULL ; } if ( * * pptr == '\\0' ) { break ; } <S2SV_ModEnd> ( * <S2SV_ModStart> -- ; <S2SV_ModEnd> return s
<S2SV_ModStart> 0 ; int truncated = 0 ; <S2SV_ModStart> & parselen , & truncated ) ; if ( truncated ) goto trunc <S2SV_ModEnd> ; if <S2SV_ModStart> lose ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ) ; return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|zephyr]<S2SV_blank>(%d)" , length ) ) ; return ;
<S2SV_ModStart> , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> += BGP_VPN_RD_LEN + 4
<S2SV_ModStart> ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , icmp6_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , mldv2_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> optlen ; ND_TCHECK ( opt -> rpl_dio_len ) ; <S2SV_ModStart> ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> ndo , "%s" , rpl_tstr <S2SV_ModEnd> ) )
<S2SV_ModStart> int hexdump , ret <S2SV_ModStart> ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( <S2SV_ModStart> 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( <S2SV_ModStart> 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( <S2SV_ModStart> 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
<S2SV_ModStart> ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; <S2SV_ModStart> ) ; trunc : return - 1 ;
<S2SV_ModStart> ) ; <S2SV_ModEnd> } else <S2SV_ModStart> ) ; } <S2SV_ModStart> return ; <S2SV_ModEnd> } sport <S2SV_ModStart> ) ; ND_TCHECK_16BITS ( bp ) ;
<S2SV_ModStart> saw_digit ) { bp ++ ; <S2SV_ModStart> invalid ; } <S2SV_ModStart> '\\r' ) { bp ++ ; <S2SV_ModStart> invalid ; } <S2SV_ModStart> '\\n' ) { bp ++ ; <S2SV_ModStart> invalid ; } <S2SV_ModStart> trunc : * endp = bp ; <S2SV_ModStart> invalid : * endp = bp ;
<S2SV_ModStart> ) { ND_TCHECK_32BITS ( & bp [ <S2SV_ModEnd> hlen + <S2SV_ModStart> hlen + 4 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { ND_TCHECK_32BITS ( & bp [ <S2SV_ModEnd> hlen + <S2SV_ModStart> hlen + 4 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { ND_TCHECK_32BITS ( & bp [ <S2SV_ModEnd> hlen + <S2SV_ModStart> hlen + 4 ] <S2SV_ModEnd> ) ; <S2SV_ModStart> IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; <S2SV_ModStart> 0xf0 ) { <S2SV_ModStart> ) ; } <S2SV_ModStart> 1 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; ND_TCHECK <S2SV_ModEnd> ( mh <S2SV_ModStart> 1 ] ) ; if ( mh -> ip6m_data8 [ 1 ] <S2SV_ModStart> IP6M_MINLEN ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; <S2SV_ModStart> 2 ; ND_TCHECK_16BITS ( & bp [ hlen ] <S2SV_ModEnd> ) ; <S2SV_ModStart> ND_TCHECK2 ( bp [ hlen ] , <S2SV_ModEnd> 16 )
<S2SV_ModStart> ; } if ( len < sizeof ( struct eigrp_common_header ) ) { ND_PRINT ( ( ndo , "EIGRP<S2SV_blank>%s,<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( eigrp_opcode_values , "unknown<S2SV_blank>(%u)" , eigrp_com_header -> opcode ) , len , ( u_int ) sizeof ( struct eigrp_common_header ) ) ) ; return ; } <S2SV_ModStart> ) ; if ( eigrp_tlv_len < sizeof ( struct eigrp_tlv_header ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) sizeof ( struct eigrp_tlv_header ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_general_parm ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_sw_version ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_int ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_ip_ext ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_cable_setup ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_int ) ) ) ) ; break ; } <S2SV_ModStart> tlv_tptr ; if ( tlv_tlen < sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( u_int ) ( sizeof ( struct eigrp_tlv_header ) + sizeof ( * tlv_ptr . eigrp_tlv_at_ext ) ) ) ) ; break ; }
<S2SV_ModStart> lshp -> ls_length <S2SV_ModEnd> ) ;
<S2SV_ModStart> u_char * ep2 <S2SV_ModEnd> ) { <S2SV_ModStart> t ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ) ; } if ( ep2 <S2SV_ModEnd> < p <S2SV_ModStart> ; return ep2 <S2SV_ModEnd> + 1 <S2SV_ModStart> ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> ] ; if ( ! <S2SV_ModStart> 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } <S2SV_ModEnd> } else <S2SV_ModStart> "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( <S2SV_ModStart> ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> totlen ; trunc : return NULL ;
<S2SV_ModStart> u_char * ep2 <S2SV_ModEnd> , const <S2SV_ModStart> v ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> ; else { ND_TCHECK_16BITS ( & p [ 2 ] ) ; <S2SV_ModStart> ) ; } if ( ep2 <S2SV_ModEnd> < p <S2SV_ModStart> ; return ep2 <S2SV_ModEnd> + 1 <S2SV_ModStart> ; } ND_TCHECK_16BITS ( & p [ 0 ] ) ; <S2SV_ModStart> "value=" ) ) ; ND_TCHECK_16BITS ( & p [ 2 ] <S2SV_ModStart> ; else { if ( ! <S2SV_ModStart> 2 ) ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; } } <S2SV_ModEnd> } else <S2SV_ModStart> "len=%d<S2SV_blank>value=" , totlen - 4 ) ) ; if ( ! <S2SV_ModEnd> rawprint ( <S2SV_ModStart> ] , totlen - 4 ) ) { <S2SV_ModEnd> ND_PRINT ( <S2SV_ModStart> ) ; goto trunc ; } } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_ModStart> totlen ; trunc : return NULL ;
<S2SV_ModStart> cp , ep2 <S2SV_ModEnd> , map <S2SV_ModStart> ) ; if ( cp == NULL ) { ND_PRINT ( ( ndo , ")" ) ) ; goto trunc ; }
<S2SV_ModStart> nmap ) <S2SV_ModEnd> cp = <S2SV_ModStart> cp , ep2 , map , nmap ) ; else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> ep2 ) <S2SV_ModEnd> ND_PRINT (
<S2SV_ModStart> cp , ep2 , map , nmap ) ; } else cp = ikev1_attr_print ( ndo , cp , ep2 ) ; if ( cp == NULL ) goto trunc ; } if <S2SV_ModStart> ep2 ) <S2SV_ModEnd> ND_PRINT (
<S2SV_ModStart> BGP_CAPCODE_MP : ND_TCHECK_8BITS ( opt + i + 5 ) ;
<S2SV_ModStart> LLDP_PRIVATE_8023_SUBTYPE_MTU : if ( tlv_len < 6 ) { return hexdump ; }
<S2SV_ModStart> ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; <S2SV_ModStart> RIP6_REQUEST : length_left <S2SV_ModEnd> = length <S2SV_ModStart> = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModStart> == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> <S2SV_ModStart> ; } } <S2SV_ModStart> ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:" , j , length <S2SV_ModEnd> ) ) <S2SV_ModStart> ndo , "<S2SV_blank>ripng-req<S2SV_blank>%u:" , j ) <S2SV_ModEnd> ) ; <S2SV_ModStart> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof <S2SV_ModStart> ) ; length_left <S2SV_ModEnd> -= sizeof <S2SV_ModStart> ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> RIP6_RESPONSE : length_left <S2SV_ModEnd> = length <S2SV_ModStart> = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModStart> ) != length_left ) ND_PRINT ( ( ndo , "<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:" , j , length <S2SV_ModEnd> ) ) <S2SV_ModStart> ) ; <S2SV_ModEnd> for ( <S2SV_ModStart> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof <S2SV_ModStart> ) ; length_left <S2SV_ModEnd> -= sizeof <S2SV_ModStart> ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break <S2SV_ModStart> ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ; return ; trunc : ND_PRINT ( ( ndo , "[|ripng]" ) ) ; return ;
<S2SV_ModStart> IPOPT_LSRR : if ( <S2SV_ModStart> option_len ) == - 1 ) goto trunc
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> ip_printroute ( <S2SV_ModStart> ; return ( 0 ) <S2SV_ModStart> length ) ) ; ND_TCHECK ( cp [ 2 ] <S2SV_ModStart> ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; <S2SV_ModStart> ; } return ( 0 ) ; trunc : return ( - 1 ) ;
<S2SV_ModStart> 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> + 4 ; ND_TCHECK ( cp [ 0 ] )
<S2SV_ModStart> ) { ND_TCHECK ( bp [ 0 ] ) ; <S2SV_ModStart> ; } ND_TCHECK ( bp [ 3 ] ) ;
<S2SV_ModStart> length ; tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart> ) ; <S2SV_ModEnd> type = <S2SV_ModStart> ) ; tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> ) ) ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart> , length <S2SV_ModEnd> ) ; <S2SV_ModStart> BGP_AIGP_TLV : if ( length < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT <S2SV_ModStart> ( tptr <S2SV_ModEnd> ) ) <S2SV_ModStart> , tptr <S2SV_ModEnd> , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" <S2SV_ModStart> , length <S2SV_ModEnd> ) ;
<S2SV_ModStart> * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> tcp_socket = <S2SV_ModStart> desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> g_options . <S2SV_ModStart> . only_desired_port ) break ; <S2SV_ModEnd> desired_port ++ <S2SV_ModStart> 49152 ; NOTE ( "Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> == NULL <S2SV_ModStart> uint16_t real_port ; if ( tcp_socket ) real_port <S2SV_ModStart> ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> ) ; NOTE ( "Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable" , real_port , tcp_socket ? "" : "not<S2SV_blank>" , tcp6_socket ? "" : "not<S2SV_blank>" ) ; <S2SV_ModStart> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> ) ; <S2SV_ModStart> ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;
<S2SV_ModStart> ERR ( "IPv4:<S2SV_blank>callocing<S2SV_blank>this<S2SV_blank>failed" <S2SV_ModEnd> ) ; <S2SV_ModStart> socket ( AF_INET <S2SV_ModEnd> , SOCK_STREAM <S2SV_ModStart> ERR ( "IPv4<S2SV_blank>socket<S2SV_blank>open<S2SV_blank>failed" ) ; goto error ; } struct sockaddr_in <S2SV_ModEnd> addr ; <S2SV_ModStart> addr . sin_family = AF_INET ; addr . sin_port <S2SV_ModEnd> = htons <S2SV_ModStart> addr . sin_addr . s_addr = htonl ( 0x7F000001 ) <S2SV_ModEnd> ; if <S2SV_ModStart> ERR ( "IPv4<S2SV_blank>bind<S2SV_blank>on<S2SV_blank>port<S2SV_blank>failed.<S2SV_blank>" <S2SV_ModEnd> "Requested<S2SV_blank>port<S2SV_blank>may<S2SV_blank>be<S2SV_blank>taken<S2SV_blank>or<S2SV_blank>require<S2SV_blank>root<S2SV_blank>permissions." ) <S2SV_ModStart> ERR ( "IPv4<S2SV_blank>listen<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>socket" <S2SV_ModEnd> ) ;
<S2SV_ModStart> == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int addrs_in_same_network_family
<S2SV_ModStart> * or_circ = NULL ; origin_circuit_t * origin_circ = NULL ; crypt_path_t * layer_hint <S2SV_ModStart> ) ) { <S2SV_ModStart> ) ; } else { tor_assert ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED ) ; origin_circ = TO_ORIGIN_CIRCUIT ( circ ) ; layer_hint = origin_circ -> cpath -> prev ; } <S2SV_ModStart> end_reason , layer_hint <S2SV_ModEnd> ) ; <S2SV_ModStart> END_STREAM_REASON_NOTDIRECTORY , layer_hint <S2SV_ModEnd> ) ; <S2SV_ModStart> END_STREAM_REASON_INTERNAL , layer_hint <S2SV_ModEnd> ) ; <S2SV_ModStart> END_STREAM_REASON_EXITPOLICY , layer_hint <S2SV_ModEnd> ) ; <S2SV_ModStart> ) { tor_assert ( origin_circ <S2SV_ModEnd> ) ; <S2SV_ModStart> END_STREAM_REASON_DONE , layer_hint <S2SV_ModEnd> ) ;
<S2SV_ModStart> [ MAX_PKT_SIZE + 1 <S2SV_ModStart> buf ) - 1 <S2SV_ModStart> ) { <S2SV_ModEnd> if (
<S2SV_ModStart> ; } <S2SV_ModEnd> } <S2SV_null>
<S2SV_ModStart> ny ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i <S2SV_ModEnd> ; upb <S2SV_ModStart> = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( <S2SV_ModEnd> int ) <S2SV_ModStart> int ) * max ) ; d1 = g <S2SV_ModEnd> = ( <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> ) ; d2 = b <S2SV_ModEnd> = ( <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; loopmaxh = maxh - offy ; if ( offy > 0U ) { size_t j ; for ( j = 0 ; j < maxw ; ++ j ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } } <S2SV_ModStart> < ( loopmaxh <S2SV_ModEnd> & ~ <S2SV_ModStart> ~ ( size_t <S2SV_ModEnd> ) 1U <S2SV_ModStart> ) { size_t j ; <S2SV_ModStart> maxw ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; } <S2SV_ModStart> < ( loopmaxw <S2SV_ModEnd> & ~ <S2SV_ModStart> ~ ( size_t <S2SV_ModEnd> ) 1U <S2SV_ModStart> j < loopmaxw <S2SV_ModEnd> ) { <S2SV_ModStart> i < loopmaxh <S2SV_ModEnd> ) { <S2SV_ModStart> ) { size_t j ; <S2SV_ModStart> ~ ( size_t <S2SV_ModEnd> ) 1U <S2SV_ModStart> d2 ; <S2SV_ModEnd> img -> <S2SV_ModStart> w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> <S2SV_ModStart> h = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . dx = img -> comps [ 0 ] . dx ; <S2SV_ModEnd> img -> <S2SV_ModStart> ] . dy = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . <S2SV_ModEnd> dy = <S2SV_ModStart> img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return <S2SV_ModStart> fails : <S2SV_ModEnd> free ( <S2SV_ModStart> ) ; <S2SV_ModEnd> free ( <S2SV_ModStart> ) ; <S2SV_ModEnd> free (
<S2SV_ModStart> cr ; size_t <S2SV_ModEnd> maxw , <S2SV_ModStart> , max , offx , loopmaxw <S2SV_ModStart> upb ; size_t i <S2SV_ModEnd> ; upb <S2SV_ModStart> = ( size_t <S2SV_ModEnd> ) img <S2SV_ModStart> = ( size_t <S2SV_ModEnd> ) img <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; <S2SV_ModStart> ) { size_t j ; if ( offx > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } <S2SV_ModStart> < ( loopmaxw <S2SV_ModEnd> & ~ <S2SV_ModStart> ~ ( size_t <S2SV_ModEnd> ) 1U <S2SV_ModStart> j < loopmaxw <S2SV_ModEnd> ) { <S2SV_ModStart> d2 ; <S2SV_ModEnd> img -> <S2SV_ModStart> w = img -> comps [ 2 ] . w = img -> comps [ 0 ] . w ; <S2SV_ModEnd> img -> <S2SV_ModStart> h = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . h = img -> comps [ 0 ] . h ; img -> comps [ 1 ] . dx = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = <S2SV_ModEnd> img -> <S2SV_ModStart> ] . <S2SV_ModEnd> dy = <S2SV_ModStart> img -> color_space = OPJ_CLRSPC_SRGB <S2SV_ModEnd> ; return <S2SV_ModStart> fails : <S2SV_ModEnd> free ( <S2SV_ModStart> ) ; <S2SV_ModEnd> free ( <S2SV_ModStart> ) ; <S2SV_ModEnd> free (
<S2SV_ModStart> cr ; size_t <S2SV_ModEnd> maxw , <S2SV_ModStart> = ( size_t <S2SV_ModEnd> ) img <S2SV_ModStart> = ( size_t <S2SV_ModEnd> ) img <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> ) * <S2SV_ModEnd> max ) <S2SV_ModStart> d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free (
<S2SV_ModStart> for ( <S2SV_ModEnd> pad = <S2SV_ModStart> pad = (
<S2SV_ModStart> if ( ( <S2SV_ModStart> 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , "%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n" , __FILE__ , __LINE__ ) ; <S2SV_ModStart> return ; }
<S2SV_ModStart> cmap_len = get_tga_ushort <S2SV_ModEnd> ( & <S2SV_ModStart> x_origin = get_tga_ushort <S2SV_ModEnd> ( & <S2SV_ModStart> y_origin = get_tga_ushort <S2SV_ModEnd> ( & <S2SV_ModStart> image_w = get_tga_ushort <S2SV_ModEnd> ( & <S2SV_ModStart> image_h = get_tga_ushort <S2SV_ModEnd> ( &
<S2SV_ModStart> ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
<S2SV_ModStart> 0x01 ; if ( parameters -> numresolution == 1 ) { parameters -> res_spec = 1 ; parameters -> prcw_init [ 0 ] = 128 ; parameters -> prch_init [ 0 ] = 128 ; } else { <S2SV_ModStart> 256 ; }
<S2SV_ModStart> p_tx0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp <S2SV_ModStart> -> tdx , <S2SV_ModEnd> p_image -> <S2SV_ModStart> p_tx1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp <S2SV_ModStart> -> tdx , <S2SV_ModEnd> p_image -> <S2SV_ModStart> p_ty0 = ( OPJ_INT32 ) opj_uint_max <S2SV_ModEnd> ( p_cp <S2SV_ModStart> -> tdy , <S2SV_ModEnd> p_image -> <S2SV_ModStart> p_ty1 = ( OPJ_INT32 ) opj_uint_min <S2SV_ModEnd> ( p_cp <S2SV_ModStart> -> tdy , <S2SV_ModEnd> p_image ->
<S2SV_ModStart> , y , written <S2SV_ModStart> y = written = <S2SV_ModStart> = c1 ; written ++ <S2SV_ModStart> c1 ; written ++ ; <S2SV_ModStart> } } if ( written != width * height ) { fprintf ( stderr , "warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ) ; <S2SV_ModEnd> l_mco_size = <S2SV_ModStart> ; } l_current_data = p_j2k -> m_specific_param . m_encoder . m_header_tile_data ;
<S2SV_ModStart> header -> biBitCount == 0 ) { fprintf ( stderr , "Error,<S2SV_blank>invalid<S2SV_blank>biBitCount<S2SV_blank>%d\\n" , 0 ) ; return OPJ_FALSE ; } if ( header ->
<S2SV_ModStart> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { l_current_pi -> include = <S2SV_ModStart> ) ; }
<S2SV_ModStart> ) ; if ( p_total_data_size < 4 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOD<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> ) ; <S2SV_ModEnd> if (
<S2SV_ModStart> ) { if ( length < 6 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 6 ) ; } return OPJ_FALSE ; } <S2SV_ModStart> ) { if ( length < 2 ) { if ( p_t2_mode == FINAL_PASS ) { opj_event_msg ( p_manager , EVT_ERROR , "opj_t2_encode_packet():<S2SV_blank>only<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>in<S2SV_blank>" "output<S2SV_blank>buffer.<S2SV_blank>%u<S2SV_blank>needed.\\n" , length , 2 ) ; } return OPJ_FALSE ; }
<S2SV_ModStart> if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
<S2SV_ModStart> } } if ( Info_h . biWidth == 0 || Info_h . biHeight == 0 ) { fclose ( IN ) ; return NULL ; } if ( Info_h . biBitCount > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> ) { if ( 8 > ( ( ( OPJ_UINT32 ) - 1 ) - 31 ) / Info_h . biWidth ) { fclose ( IN ) ; return NULL ; } <S2SV_ModStart> ; } if ( stride > ( ( OPJ_UINT32 ) - 1 ) / sizeof ( OPJ_UINT8 ) / Info_h . biHeight ) { fclose ( IN ) ; return NULL ; }
<S2SV_ModStart> p_data , p_total_data_size , <S2SV_ModStart> p_data , p_total_data_size ,
<S2SV_ModStart> p_data , p_total_data_size ,
<S2SV_ModStart> , OPJ_UINT32 p_total_data_size , OPJ_UINT32 <S2SV_ModStart> ) ; if ( p_total_data_size < 12 ) { opj_event_msg ( p_manager , EVT_ERROR , "Not<S2SV_blank>enough<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>output<S2SV_blank>buffer<S2SV_blank>to<S2SV_blank>write<S2SV_blank>SOT<S2SV_blank>marker\\n" ) ; return OPJ_FALSE ; }
<S2SV_ModStart> lbase [ 512 <S2SV_ModEnd> ] ; <S2SV_ModStart> strbase [ 512 <S2SV_ModEnd> ] ; <S2SV_ModStart> ltest [ 512 <S2SV_ModEnd> ] ; <S2SV_ModStart> strtest [ 512 <S2SV_ModEnd> ] ; <S2SV_ModStart> lbase , "%511[^\\r\\n]" <S2SV_ModEnd> , strbase <S2SV_ModStart> ltest , "%511[^\\r\\n]" <S2SV_ModEnd> , strtest <S2SV_ModStart> nbase != 511 <S2SV_ModEnd> && ntest <S2SV_ModStart> ntest != 511 <S2SV_ModEnd> ) ;
<S2SV_ModStart> f , "PG%31[<S2SV_blank>\\t]%c%c%31[<S2SV_blank>\\t+-]%d%31[<S2SV_blank>\\t]%d%31[<S2SV_blank>\\t]%d" <S2SV_ModEnd> , temp
<S2SV_ModStart> ( ( size_t ) ( <S2SV_ModStart> numlayers + 1U <S2SV_ModEnd> ) *
<S2SV_ModStart> AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . <S2SV_ModStart> . sun_path <S2SV_ModEnd> , path <S2SV_ModStart> sun_len = sizeof <S2SV_ModEnd> ( struct <S2SV_ModStart> struct sockaddr_un ) ; <S2SV_ModEnd> if (
<S2SV_ModStart> AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . <S2SV_ModStart> . sun_path <S2SV_ModEnd> , address <S2SV_ModStart> sun_len = sizeof <S2SV_ModEnd> ( struct <S2SV_ModStart> struct sockaddr_un ) ; <S2SV_ModEnd> client ->
<S2SV_ModStart> ) { if ( dir_len > PATH_MAX ) { uwsgi_log ( "invalid<S2SV_blank>path<S2SV_blank>size:<S2SV_blank>%d<S2SV_blank>(max<S2SV_blank>%d)\\n" , dir_len , PATH_MAX ) ; return NULL ; } char * src = uwsgi_concat2n ( <S2SV_ModEnd> dir , <S2SV_ModStart> , dir_len , "" , 0 ) <S2SV_ModEnd> ; char <S2SV_ModStart> ) ; free ( src ) ; <S2SV_ModStart> ; } free ( src ) ;
<S2SV_ModStart> if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , "*" , "AUTHENTICATE" , "Invalid<S2SV_blank>parameter" ) ; return 0 ; } if (
<S2SV_ModStart> ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> ) { if ( s == 0 ) return ( ( void * ) NULL ) ;
<S2SV_ModStart> ) { return <S2SV_ModStart> ) ; <S2SV_ModEnd> } else
<S2SV_ModStart> ) ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> rowsize ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorDecodeTile" , "%s" , "occ0%rowsize<S2SV_blank>!=<S2SV_blank>0" ) ; return 0 ; } <S2SV_ModEnd> assert ( <S2SV_ModStart> ) { if ( ! <S2SV_ModStart> rowsize ) ) return 0
<S2SV_ModStart> ) ; if ( ! <S2SV_ModStart> cc ) ) return 0
<S2SV_ModStart> ) ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "PredictorEncodeTile" , "%s" , "(cc0%rowsize)!=0" ) ; return 0 ; } <S2SV_ModEnd> while (
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> fpAcc ( <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( cc <S2SV_ModStart> stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpAcc" , "%s" , "cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) return 0 <S2SV_ModStart> ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> fpDiff ( <S2SV_ModStart> ) ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ) return 0 <S2SV_ModStart> -- ) return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horAcc16 ( <S2SV_ModStart> 2 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc16" , "%s" , "cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horAcc32 ( <S2SV_ModStart> 4 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc32" , "%s" , "cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horAcc8 ( <S2SV_ModStart> cp0 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horAcc8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> } } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horDiff16 ( <S2SV_ModStart> 2 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%(2*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( <S2SV_ModStart> 4 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> ) ) != <S2SV_ModEnd> 0 ) <S2SV_ModStart> 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff32" , "%s" , "(cc%(4*stride))!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> ; } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> horDiff8 ( <S2SV_ModStart> cp0 ; if <S2SV_ModEnd> ( ( <S2SV_ModStart> stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "horDiff8" , "%s" , "(cc%stride)!=0" ) ; return 0 ; } <S2SV_ModEnd> if ( <S2SV_ModStart> } } return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc16 ( <S2SV_ModStart> ) ; return
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> swabHorAcc32 ( <S2SV_ModStart> ) ; return
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff16 ( <S2SV_ModStart> 2 ; if ( ! <S2SV_ModStart> cc ) ) return 0 <S2SV_ModStart> ) ; return 1 ;
<S2SV_ModStart> <S2SV_null> static int <S2SV_ModEnd> swabHorDiff32 ( <S2SV_ModStart> 4 ; if ( ! <S2SV_ModStart> cc ) ) return 0 <S2SV_ModStart> ) ; return 1 ;
<S2SV_ModStart> stripsperplane = TIFFhowmany_32_maxuint_compat <S2SV_ModEnd> ( td <S2SV_ModStart> -> td_imagelength , <S2SV_ModEnd> rowsperstrip )
<S2SV_ModStart> , samplesperpixel = 1 <S2SV_ModStart> , input_photometric = PHOTOMETRIC_MINISBLACK
<S2SV_ModStart> 0 ; uint32 <S2SV_ModEnd> strip ,
<S2SV_ModStart> i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 <S2SV_ModStart> bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ;
<S2SV_ModStart> < ns && row < imagelength
<S2SV_ModStart> < imagewidth && colb < imagew
<S2SV_ModStart> < imagewidth && colb < imagew
<S2SV_ModStart> s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpContig2SeparateByRow" ) ; return 0 ; }
<S2SV_ModStart> s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , "Error,<S2SV_blank>can<S2SV_blank>only<S2SV_blank>handle<S2SV_blank>BitsPerSample=8<S2SV_blank>in<S2SV_blank>%s" , "cpSeparate2ContigByRow" ) ; return 0 ; }
<S2SV_ModStart> void ) TIFFGetFieldDefaulted <S2SV_ModEnd> ( in
<S2SV_ModStart> uint16 bitspersample = 1
<S2SV_ModStart> ) ; _TIFFfree ( working_copy ) ;
<S2SV_ModStart> * tmp <S2SV_ModEnd> ; if <S2SV_ModStart> ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> * tmp <S2SV_ModEnd> ; if <S2SV_ModStart> ; } tmp = ( uint8 * ) _TIFFmalloc ( cc ) ;
<S2SV_ModStart> outskew , int64 <S2SV_ModEnd> inskew )
<S2SV_ModStart> ) ; int64 <S2SV_ModEnd> iskew = <S2SV_ModStart> iskew = ( int64 ) <S2SV_ModStart> imagew - ( int64 ) <S2SV_ModStart> ( colb > iskew <S2SV_ModEnd> ) {
<S2SV_ModStart> ) ) { tif -> tif_rawcc = 0 ; tif -> tif_rawcp = tif -> tif_rawdata ; <S2SV_ModStart> ) ; }
<S2SV_ModStart> * buffer , tsize_t buffersize <S2SV_ModStart> 0xd8 : if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> ) { if ( * bufferoffset + datalen + 2 + 6 > buffersize ) return ( 0 ) ; <S2SV_ModStart> + 2 ) ; if ( * bufferoffset + 9 >= buffersize ) return ( 0 <S2SV_ModStart> 1 ; if ( * bufferoffset + 11 + 3 * ( ncomp - 1 ) >= buffersize ) return ( 0 ) ; <S2SV_ModStart> 0xdb : if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> ) { if ( * bufferoffset + datalen + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> else { if ( * bufferoffset + 2 > buffersize ) return ( 0 ) ; <S2SV_ModStart> 1 ; if ( * bufferoffset + * striplength - i > buffersize ) return ( 0 ) ;
<S2SV_ModStart> buffer , t2p -> tiff_datasize ,
<S2SV_ModStart> 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = <S2SV_ModStart> read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModStart> ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "loadImage" , "Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer" ) ; return ( - 1 ) ; }
<S2SV_ModStart> 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( "reverseSamplesBytes" , "bytes_per_pixel<S2SV_blank>too<S2SV_blank>large" ) ; return ( 1 ) ; }
<S2SV_ModStart> bufp += stripsize <S2SV_ModEnd> ; }
<S2SV_ModStart> strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 <S2SV_ModStart> return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 <S2SV_ModStart> 0 ) <S2SV_ModEnd> return ; <S2SV_ModStart> return ; <S2SV_ModEnd> newcounts = <S2SV_ModStart> tif , nstrips <S2SV_ModEnd> , sizeof <S2SV_ModStart> tif , nstrips <S2SV_ModEnd> , sizeof <S2SV_ModStart> strip < nstrips <S2SV_ModEnd> ; strip <S2SV_ModStart> ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset <S2SV_ModStart> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField
<S2SV_ModStart> uint32 nstrips <S2SV_ModEnd> ; nstrips
<S2SV_ModStart> } } if ( tile_buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( "readContigTilesIntoBuffer" , "Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size." ) ; exit ( - 1 ) ; } <S2SV_ModStart> ( tile_buffsize + 3 <S2SV_ModStart> ) return 0 ; tilebuf [ tile_buffsize ] = 0 ; tilebuf [ tile_buffsize + 1 ] = 0 ; tilebuf [ tile_buffsize + 2 ] =
<S2SV_ModStart> ( count > <S2SV_ModEnd> 4 )
<S2SV_ModStart> ) { if ( code >= clear ) { fprintf ( stderr , "bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n" , code , clear ) ; return 0 ; }
<S2SV_ModStart> retval = htc_request_check_hdrs <S2SV_ModEnd> ( sp <S2SV_ModStart> sp , hp <S2SV_ModEnd> ) ; <S2SV_ModStart> ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null>
<S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> r )
<S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p )
<S2SV_ModStart> vct_iscrlf ( & <S2SV_ModStart> vct_iscrlf ( &
<S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p ) <S2SV_ModStart> vct_iscrlf ( <S2SV_ModEnd> p )
<S2SV_ModStart> break ; if ( l > ll ) l = ll ;
<S2SV_ModStart> offset ; size_t devicePathLen = 0 <S2SV_ModEnd> ; if <S2SV_ModStart> break ; if ( ! NT_SUCCESS ( RtlUnalignedStringCchLengthW ( request -> DevicePath , TC_MAX_PATH , & devicePathLen ) ) || ( devicePathLen < 28 ) || ( devicePathLen > 30 ) || ( memcmp ( request -> DevicePath , L"\\\\Device\\\\Harddisk" , 16 * sizeof ( WCHAR ) ) ) || ( memcmp ( & request -> DevicePath [ devicePathLen - 11 ] , L"\\\\Partition0" , 11 * sizeof ( WCHAR ) ) ) ) { Irp -> IoStatus . Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; break ; } <S2SV_ModStart> ) { byte * readBuffer = TCalloc ( TC_MAX_VOLUME_SECTOR_SIZE ) ; if ( ! readBuffer ) { Irp -> IoStatus . Status = STATUS_INSUFFICIENT_RESOURCES ; Irp -> IoStatus . Information = 0 ; } else { <S2SV_ModStart> readBuffer , TC_MAX_VOLUME_SECTOR_SIZE <S2SV_ModEnd> , & <S2SV_ModStart> ntStatus ) ) { if ( IoStatus . Information >= TC_SECTOR_SIZE_BIOS <S2SV_ModStart> Status = STATUS_INVALID_PARAMETER ; Irp -> IoStatus . Information = 0 ; } } else { Irp -> IoStatus . Status = <S2SV_ModStart> = 0 ; } TCfree ( readBuffer )
<S2SV_ModStart> + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> ) { assert ( v -> len != 0 ) ;
<S2SV_ModStart> MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
<S2SV_ModStart> ++ ) { if ( a -> type == szMAPI_BINARY ) <S2SV_ModStart> ; } }
<S2SV_ModStart> a -> type == szMAPI_BINARY && a -> <S2SV_ModStart> if ( a -> type == szMAPI_BINARY &&
<S2SV_ModStart> ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> , ( res <S2SV_ModEnd> ) )
<S2SV_ModStart> ( size_t num , size_t <S2SV_ModStart> ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> "checked_xmalloc" , res <S2SV_ModEnd> ) ; <S2SV_ModStart> xmalloc ( num ,
<S2SV_ModStart> ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> void * ptr ; <S2SV_ModStart> malloc ( res <S2SV_ModEnd> ) ; <S2SV_ModStart> , ( res <S2SV_ModEnd> ) )
<S2SV_ModStart> ( size_t num , size_t <S2SV_ModStart> ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> malloc ( res <S2SV_ModEnd> ) ;
<S2SV_ModStart> } else if ( pool -> free_total < NW_BUF_POOL_MAX_SIZE ) <S2SV_ModStart> } } else { free ( buf ) ; }
<S2SV_ModStart> } else if ( cache -> free_total < NW_CACHE_MAX_SIZE ) <S2SV_ModStart> } } else { free ( obj ) ; }
<S2SV_ModStart> uint32_t pkg_size ; if ( pkg -> body_size > RPC_PKG_MAX_BODY_SIZE ) { return - 1 ; } pkg_size <S2SV_ModStart> ) ; if ( send_buf == <S2SV_ModEnd> NULL ) <S2SV_ModStart> NULL ) { return - 1 ; } <S2SV_ModEnd> } memcpy
<S2SV_ModStart> == NULL || strlen ( connection ) > UT_WS_SVR_MAX_HEADER_SIZE
<S2SV_ModStart> length > 1 <S2SV_ModEnd> ) {
<S2SV_ModStart> , * mask3 , * mask4 , * mask5 , * mask6 , * mask7 <S2SV_ModEnd> ; const <S2SV_ModStart> NULL ; mask3 = NULL ; mask4 = NULL ; mask5 = NULL ; mask6 = NULL ; mask7 <S2SV_ModEnd> = NULL <S2SV_ModStart> NULL ; length = strlen <S2SV_ModEnd> ( mask <S2SV_ModStart> ( mask <S2SV_ModEnd> ) + <S2SV_ModStart> 1 ; mask2 <S2SV_ModEnd> = malloc <S2SV_ModStart> ( ! mask2 <S2SV_ModEnd> ) goto <S2SV_ModStart> ) ; mask2 <S2SV_ModEnd> [ 0 <S2SV_ModStart> '\\0' ; if ( <S2SV_ModStart> strftime ( mask2 <S2SV_ModEnd> , length <S2SV_ModStart> 1 , mask <S2SV_ModEnd> , date_tmp <S2SV_ModStart> date_tmp ) == 0 ) mask2 [ 0 ] = '\\0' ; mask3 = weechat_string_replace ( mask2 , dir_separator , "\\01" ) ; if ( ! mask3 ) goto end ; mask4 = weechat_buffer_string_replace_local_var ( buffer , mask3 ) ; if ( ! mask4 ) goto end ; mask5 = weechat_string_replace ( mask4 , dir_separator , weechat_config_string ( logger_config_file_replacement_char ) ) ; if ( ! mask5 ) goto end ; # ifdef __CYGWIN__ mask6 = weechat_string_replace ( mask5 , "\\\\" , weechat_config_string ( logger_config_file_replacement_char ) ) ; # else mask6 = strdup ( mask5 ) ; # endif if ( ! mask6 ) goto end ; mask7 = weechat_string_replace ( mask6 , "\\01" , dir_separator ) ; if ( ! mask7 ) goto end <S2SV_ModStart> weechat_string_tolower ( mask7 <S2SV_ModEnd> ) ; <S2SV_ModStart> mask , mask7 <S2SV_ModEnd> ) ; <S2SV_ModStart> if ( mask3 <S2SV_ModEnd> ) free <S2SV_ModStart> free ( mask3 ) ; if ( mask4 <S2SV_ModEnd> ) free <S2SV_ModStart> free ( mask4 ) ; if ( mask5 <S2SV_ModEnd> ) free <S2SV_ModStart> free ( mask5 ) ; if ( mask6 <S2SV_ModEnd> ) free <S2SV_ModStart> free ( mask6 <S2SV_ModEnd> ) ; <S2SV_ModStart> ; return mask7 <S2SV_ModEnd> ; }
<S2SV_ModStart> ; } ( * psig ) = s + <S2SV_ModEnd> padlen + <S2SV_ModStart> 3 ; { const u_char * p ; size_t cnt_ffs = 0 ; for ( p = s + 2 ; p < s + padlen + 2 ; p ++ ) if ( * p == 0xFF ) cnt_ffs ++ ; if ( cnt_ffs != padlen ) return "4" "invalid<S2SV_blank>Padding<S2SV_blank>String" ; } <S2SV_ModEnd> return NULL
<S2SV_ModStart> , expr -> unary . child
<S2SV_ModStart> ; return ( * field_rtrn != NULL ) <S2SV_ModEnd> ; case
<S2SV_ModStart> if ( ! str ) return false ; if (
<S2SV_ModStart> s ) && ! eof ( s )
<S2SV_ModStart> ) { if ( file -> file_type == FILE_TYPE_GEOMETRY ) { log_vrb ( ctx , 1 , "Geometry<S2SV_blank>sections<S2SV_blank>are<S2SV_blank>not<S2SV_blank>supported;<S2SV_blank>ignoring\\n" ) ; } else { <S2SV_ModStart> ) ; }
<S2SV_ModStart> pred_rtrn ) || ! expr -> action . args
<S2SV_ModStart> false ; <S2SV_ModEnd> i = <S2SV_ModStart> } } }
<S2SV_ModStart> ; return ( * elem_rtrn != NULL && * field_rtrn != NULL ) <S2SV_ModEnd> ; case <S2SV_ModStart> entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; if ( * field_rtrn == NULL ) return false ;
<S2SV_ModStart> * ) <S2SV_ModEnd> append )
<S2SV_ModStart> if ( ! page_name_is_good ( page <S2SV_ModEnd> ) )
<S2SV_ModStart> page && page_name_is_good ( page ) && <S2SV_ModStart> ) { if ( page_name_is_good ( page ) ) { <S2SV_ModStart> return ; } <S2SV_ModStart> page && page_name_is_good ( page ) && <S2SV_ModStart> ( page && page_name_is_good ( page )
<S2SV_ModStart> > BUFSIZE - <S2SV_ModEnd> sizeof (
<S2SV_ModStart> ) { <S2SV_ModEnd> DEBUG ( <S2SV_ModStart> ; } handle_modern_connection ( servers , sock ) ; } for ( i = 0 ; i < servers -> len ; i ++ ) { int net ; SERVER * serve ; serve = & ( g_array_index ( servers , SERVER , i ) ) ; if ( serve -> socket < 0 ) { continue ; } if ( FD_ISSET ( serve -> socket , & rset ) ) { <S2SV_ModEnd> if ( <S2SV_ModStart> accept ( serve -> socket <S2SV_ModEnd> , ( <S2SV_ModStart> ; } handle_connection ( servers , <S2SV_ModEnd> net , <S2SV_ModStart> net , serve , NULL <S2SV_ModEnd> ) ;
<S2SV_ModStart> pp ; unsigned <S2SV_ModEnd> contentlen = <S2SV_ModStart> ++ ; sscanf ( sb , "%u" , & contentlen ) ; if ( contentlen > LINESIZE * 1024 ) contentlen = 0 <S2SV_ModEnd> ; } <S2SV_ModStart> pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"<S2SV_blank>enctype=\\"application/x-www-form-urlencoded\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" <S2SV_ModEnd> ) ; <S2SV_ModStart> : { unsigned <S2SV_ModEnd> l = <S2SV_ModStart> writable || ! contentlen || <S2SV_ModStart> while ( l < contentlen && <S2SV_ModStart> buf , ( contentlen - l ) > <S2SV_ModStart> - 1 ? LINESIZE - 1 : contentlen - l <S2SV_ModStart> ) ; if ( ! l ) { if ( i < 9 || <S2SV_ModEnd> strncasecmp ( <S2SV_ModStart> ) { buf [ i ] = 0 ; <S2SV_ModStart> += i <S2SV_ModEnd> ; }
<S2SV_ModStart> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%d);\\n" <S2SV_ModEnd> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" <S2SV_ModStart> ) ; int poll_interval = s_poll_interval ? strtol ( s_poll_interval , NULL , 10 ) : 0 ; <S2SV_ModStart> if ( ( poll_interval <= 0 ) || ( poll_interval > 3600 * 24 ) ) poll_interval = 3000 <S2SV_ModEnd> ; const <S2SV_ModStart> op_iframe_id , poll_interval <S2SV_ModEnd> , redirect_uri
